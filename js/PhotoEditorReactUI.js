(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("photoeditorsdk"), require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["photoeditorsdk", "react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["PhotoEditorReactUI"] = factory(require("photoeditorsdk"), require("react"), require("react-dom"));
	else
		root["PhotoEditorReactUI"] = factory(root["PhotoEditorSDK"], root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_60__, __WEBPACK_EXTERNAL_MODULE_263__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 264);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

"use strict";
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageFormat = exports.ColorMatrix = exports.now = exports.Log = exports.cancelAnimationFrame = exports.requestAnimationFrame = exports.SDK = exports.EXIF = exports.ReactDOM = exports.UniformType = exports.OptionType = exports.RenderType = exports.Base64 = exports.Color = exports.SharedState = exports.Constants = exports.EventEmitter = exports.SDKUtils = exports.Vector2 = exports.ReactBEM = exports.BaseComponent = exports.Classnames = exports.BEM = exports.React = exports.Utils = exports.Promise = undefined;

var _photoeditorsdk = __webpack_require__(29);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

var _react = __webpack_require__(60);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(263);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _classnames = __webpack_require__(88);

var _classnames2 = _interopRequireDefault(_classnames);

var _bem = __webpack_require__(67);

var _bem2 = _interopRequireDefault(_bem);

var _reactBem = __webpack_require__(71);

var _reactBem2 = _interopRequireDefault(_reactBem);

var _baseComponent = __webpack_require__(98);

var _baseComponent2 = _interopRequireDefault(_baseComponent);

var _utils = __webpack_require__(201);

var _utils2 = _interopRequireDefault(_utils);

var _constants = __webpack_require__(175);

var _constants2 = _interopRequireDefault(_constants);

var _sharedState = __webpack_require__(200);

var _sharedState2 = _interopRequireDefault(_sharedState);

var _animationFrame = __webpack_require__(203);

var _log = __webpack_require__(74);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Base64 = _photoeditorsdk2.default.Base64;
var Color = _photoeditorsdk2.default.Color;
var ColorMatrix = _photoeditorsdk2.default.Math.ColorMatrix;
var EventEmitter = _photoeditorsdk2.default.EventEmitter;
var EXIF = _photoeditorsdk2.default.EXIF;
var OptionType = _photoeditorsdk2.default.OptionType;
var Promise = _photoeditorsdk2.default.Promise;
var SDKUtils = _photoeditorsdk2.default.Utils;
var RenderType = _photoeditorsdk2.default.RenderType;
var ImageFormat = _photoeditorsdk2.default.ImageFormat;
var SDK = _photoeditorsdk2.default;
var UniformType = _photoeditorsdk2.default.UniformType;
var Vector2 = _photoeditorsdk2.default.Math.Vector2;

var now = typeof window !== 'undefined' && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : __webpack_require__(89);

exports.Promise = Promise;
exports.Utils = _utils2.default;
exports.React = _react2.default;
exports.BEM = _bem2.default;
exports.Classnames = _classnames2.default;
exports.BaseComponent = _baseComponent2.default;
exports.ReactBEM = _reactBem2.default;
exports.Vector2 = Vector2;
exports.SDKUtils = SDKUtils;
exports.EventEmitter = EventEmitter;
exports.Constants = _constants2.default;
exports.SharedState = _sharedState2.default;
exports.Color = Color;
exports.Base64 = Base64;
exports.RenderType = RenderType;
exports.OptionType = OptionType;
exports.UniformType = UniformType;
exports.ReactDOM = _reactDom2.default;
exports.EXIF = EXIF;
exports.SDK = SDK;
exports.requestAnimationFrame = _animationFrame.requestAnimationFrame;
exports.cancelAnimationFrame = _animationFrame.cancelAnimationFrame;
exports.Log = _log2.default;
exports.now = now;
exports.ColorMatrix = ColorMatrix;
exports.ImageFormat = ImageFormat;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(209);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(208);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(33);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _typeof2 = __webpack_require__(33);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _defineProperty = __webpack_require__(75);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SCROLLBAR_WIDTH = 12;

var ScrollbarComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ScrollbarComponent, _BaseComponent);

  function ScrollbarComponent() {
    (0, _classCallCheck3.default)(this, ScrollbarComponent);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call(this));

    if (!_this.constructor.NATIVE_SCROLLBAR_WIDTH) {
      _this.constructor.NATIVE_SCROLLBAR_WIDTH = _globals.Utils.getScrollbarWidth();
    }

    _this._needsStyleFixes = true;
    _this._isDragging = false;
    _this._bindAll('_onButtonDragStart', '_onButtonDrag', '_onButtonDragStop', '_onBarDragStart', '_onBarDrag', '_onBarDragStop', '_onListScroll');
    _this.state = {
      buttonSize: 0,
      buttonPosition: 0,
      buttonVisible: false
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after the component has been mounted
   */


  ScrollbarComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);
    this.update();
  };

  ScrollbarComponent.prototype.fixStyles = function fixStyles() {
    if (!_globals.Utils.isMobile()) {
      this._updateListSize();
    }
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user scrolls the list
   * @private
   */


  ScrollbarComponent.prototype._onListScroll = function _onListScroll() {
    if (this._isDragging) return;

    var direction = this._getDirection();

    var listScrollSize = void 0,
        listScrollPosition = void 0,
        backgroundScrollSize = void 0;
    if (direction === ScrollbarComponent.HORIZONTAL) {
      listScrollSize = this._list.scrollWidth - this._list.offsetWidth;
      listScrollPosition = this._list.scrollLeft;
      backgroundScrollSize = this._node.offsetWidth - this.state.buttonSize;
    } else if (direction === ScrollbarComponent.VERTICAL) {
      listScrollSize = this._list.scrollHeight - this._list.offsetHeight;
      listScrollPosition = this._list.scrollTop;
      backgroundScrollSize = this._node.offsetHeight - this.state.buttonSize;
    }

    var progress = listScrollPosition / listScrollSize;
    this.setState({
      buttonPosition: backgroundScrollSize * progress
    });
  };

  /**
   * Gets called when the user presses a mouse button on the bar
   * @private
   */


  ScrollbarComponent.prototype._onButtonDragStart = function _onButtonDragStart(e) {
    this._isDragging = true;
    this._initialButtonPosition = this.state.buttonPosition || 0;
  };

  /**
   * Gets called while the user drags the button
   * @param {Vector2} diff
   * @private
   */


  ScrollbarComponent.prototype._onButtonDrag = function _onButtonDrag(diff) {
    var direction = this._getDirection();

    var buttonPosition = void 0;
    if (direction === ScrollbarComponent.HORIZONTAL) {
      buttonPosition = this._initialButtonPosition + diff.x;
    } else if (direction === ScrollbarComponent.VERTICAL) {
      buttonPosition = this._initialButtonPosition + diff.y;
    }
    this._setButtonPosition(buttonPosition);
  };

  /**
   * Gets called when the user releases the button
   * @private
   */


  ScrollbarComponent.prototype._onButtonDragStop = function _onButtonDragStop() {
    this._isDragging = false;
  };

  /**
   * Gets called when the user starts dragging the bar
   * @param  {Event} e
   * @private
   */


  ScrollbarComponent.prototype._onBarDragStart = function _onBarDragStart(e) {
    var mousePosition = _globals.Utils.getEventPosition(e);
    this._initialPosition = mousePosition.clone();
    var boundingRect = this._node.getBoundingClientRect();
    var elementOffset = new _globals.Vector2(boundingRect.left, boundingRect.top);

    var relativePosition = mousePosition.clone().subtract(elementOffset);

    var direction = this._getDirection();
    if (direction === ScrollbarComponent.HORIZONTAL) {
      this._setButtonPosition(relativePosition.x - this.state.buttonSize / 2);
    } else if (direction === ScrollbarComponent.VERTICAL) {
      this._setButtonPosition(relativePosition.y - this.state.buttonSize / 2);
    }

    document.addEventListener('mousemove', this._onBarDrag);
    document.addEventListener('touchmove', this._onBarDrag);
    document.addEventListener('mouseup', this._onBarDragStop);
    document.addEventListener('touchend', this._onBarDragStop);
  };

  /**
   * Gets called while the user drags the bar
   * @param  {Event} e
   * @private
   */


  ScrollbarComponent.prototype._onBarDrag = function _onBarDrag(e) {
    var mousePosition = _globals.Utils.getEventPosition(e);

    var boundingRect = this._node.getBoundingClientRect();
    var elementOffset = new _globals.Vector2(boundingRect.left, boundingRect.top);

    var relativePosition = mousePosition.clone().subtract(elementOffset);
    var direction = this._getDirection();
    if (direction === ScrollbarComponent.HORIZONTAL) {
      this._setButtonPosition(relativePosition.x - this.state.buttonSize / 2);
    } else if (direction === ScrollbarComponent.VERTICAL) {
      this._setButtonPosition(relativePosition.y - this.state.buttonSize / 2);
    }
  };

  /**
   * Gets called when the user releases the bar
   * @private
   */


  ScrollbarComponent.prototype._onBarDragStop = function _onBarDragStop() {
    document.removeEventListener('mousemove', this._onBarDrag);
    document.removeEventListener('touchmove', this._onBarDrag);
    document.removeEventListener('mouseup', this._onBarDragStop);
    document.removeEventListener('touchend', this._onBarDragStop);
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Sets the button position to the given value
   * @param {Number} buttonPosition
   * @private
   */


  ScrollbarComponent.prototype._setButtonPosition = function _setButtonPosition(buttonPosition) {
    var direction = this._getDirection();

    var scrollableButtonSize = void 0,
        scrollableListSize = void 0;
    if (direction === ScrollbarComponent.HORIZONTAL) {
      scrollableButtonSize = this._node.offsetWidth - this.state.buttonSize;
      scrollableListSize = this._list.scrollWidth - this._list.offsetWidth;
    } else if (direction === ScrollbarComponent.VERTICAL) {
      scrollableButtonSize = this._node.offsetHeight - this.state.buttonSize;
      scrollableListSize = this._list.scrollHeight - this._list.offsetHeight;
    }

    // Clamp button position
    buttonPosition = Math.max(0, buttonPosition);
    buttonPosition = Math.min(buttonPosition, scrollableButtonSize);

    // Set button position
    this.setState({ buttonPosition: buttonPosition });

    // Update list scroll position
    var progress = buttonPosition / scrollableButtonSize;
    var scrollPosition = scrollableListSize * progress;

    if (direction === ScrollbarComponent.HORIZONTAL) {
      this._list.scrollLeft = scrollPosition;
    } else if (direction === ScrollbarComponent.VERTICAL) {
      this._list.scrollTop = scrollPosition;
    }
  };

  /**
   * Updates the button position and size
   * @param {Function} cb
   * @private
   */


  ScrollbarComponent.prototype._updateButtonSize = function _updateButtonSize(cb) {
    var buttonSize = 0;
    var buttonVisible = false;
    var parentSize = void 0,
        parentScrollSize = void 0;

    var direction = this._getDirection();
    if (direction === ScrollbarComponent.HORIZONTAL) {
      parentSize = this._list.clientWidth;
      parentScrollSize = this._list.scrollWidth;
    } else if (direction === ScrollbarComponent.VERTICAL) {
      parentSize = this._list.offsetHeight;
      parentScrollSize = this._list.scrollHeight;
    }

    buttonSize = parentSize / parentScrollSize * parentSize;
    buttonVisible = parentScrollSize > parentSize;

    this.setState({ buttonSize: buttonSize, buttonVisible: buttonVisible }, cb);
  };

  /**
   * Updates the list size
   * @private
   */


  ScrollbarComponent.prototype._updateListSize = function _updateListSize() {
    if (!this._list) return;

    var direction = this._getDirection();
    if (direction === ScrollbarComponent.HORIZONTAL) {
      this._list.style.height = '';
      var fullDimensions = this._getFullListDimensions();
      this._listSize = fullDimensions.y;
      this._listContentSize = this._list.offsetHeight;
    } else if (direction === ScrollbarComponent.VERTICAL) {
      this._list.style.width = '';
      var _fullDimensions = this._getFullListDimensions();
      this._listSize = _fullDimensions.x;
      this._listContentSize = this._list.offsetWidth;
    }
  };

  /**
   * In order to get the absolute width and height of the list, including the scrollbar,
   * we need to make use of `getBoundingClientRect`
   * @return {PhotoEditorSDK.Math.Vector2}
   * @private
   */


  ScrollbarComponent.prototype._getFullListDimensions = function _getFullListDimensions() {
    var rect = this._list.getBoundingClientRect();
    return new _globals.Vector2(rect.width, rect.height);
  };

  // -------------------------------------------------------------------------- PUBLIC API

  /**
   * Updates the dimensions and stuff
   */


  ScrollbarComponent.prototype.update = function update() {
    var _this2 = this;

    if (_globals.Utils.isMobile()) {
      return;
    }

    var _refs = this.refs,
        root = _refs.root,
        list = _refs.list;

    this._node = root;
    this._list = list;

    var direction = this._getDirection();
    this._updateButtonSize(function () {
      if (!_this2._listSize) {
        _this2._updateListSize();
      }

      var newListSize = _this2._listSize;
      if (_this2.state.buttonVisible) {
        newListSize += _this2.constructor.NATIVE_SCROLLBAR_WIDTH;
      }

      if (direction === ScrollbarComponent.HORIZONTAL) {
        _this2._list.style.height = newListSize + 'px';
        _this2._node.style.top = _this2._listContentSize - SCROLLBAR_WIDTH + 'px';
        _this2._node.style.width = _this2._list.offsetWidth + 'px';
      } else if (direction === ScrollbarComponent.VERTICAL) {
        _this2._list.style.width = newListSize + 'px';
        _this2._node.style.left = _this2._listContentSize - SCROLLBAR_WIDTH + 'px';
        _this2._node.style.height = _this2._list.offsetHeight + 'px';
      }
    });

    this._list.addEventListener('scroll', this._onListScroll);
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Returns this scrollbar's direction
   * @return {String}
   * @private
   */


  ScrollbarComponent.prototype._getDirection = function _getDirection() {
    return this.props.direction || 'horizontal';
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the button's style object
   * @return {Object}
   * @private
   */


  ScrollbarComponent.prototype._getButtonStyle = function _getButtonStyle() {
    var direction = this._getDirection();
    if (direction === 'horizontal') {
      return {
        left: this.state.buttonPosition,
        width: this.state.buttonSize
      };
    } else {
      return {
        top: this.state.buttonPosition,
        height: this.state.buttonSize
      };
    }
  };

  // -------------------------------------------------------------------------- GETTERS

  ScrollbarComponent.prototype.getList = function getList() {
    return this.refs.list;
  };

  ScrollbarComponent.prototype.getRoot = function getRoot() {
    return this.refs.root;
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  ScrollbarComponent.prototype.renderWithBEM = function renderWithBEM() {
    if (_globals.Utils.isMobile()) {
      return this.props.children;
    }

    var buttonStyle = this._getButtonStyle();
    var scrollbarStyle = {
      display: this.state.buttonVisible ? 'block' : 'none'
    };

    var child = _globals.React.cloneElement(this.props.children, {
      ref: 'list'
    });

    return _globals.ReactBEM.createElement(
      'div',
      null,
      child,
      _globals.ReactBEM.createElement(
        'div',
        {
          bem: '$b:scrollbar m:' + (this.props.direction || 'horizontal') + ' m:' + (this.state.buttonVisible ? 'visible' : 'invisible'),
          ref: 'root',
          style: scrollbarStyle,
          onMouseDown: this._onBarDragStart,
          onTouchStart: this._onBarDragStart },
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onButtonDragStart,
            onDrag: this._onButtonDrag,
            onStop: this._onButtonDragStop },
          _globals.ReactBEM.createElement('div', {
            bem: 'e:bar',
            style: buttonStyle,
            onMouseDown: this._onButtonDown })
        )
      )
    );
  };

  return ScrollbarComponent;
}(_globals.BaseComponent);

exports.default = ScrollbarComponent;


ScrollbarComponent.HORIZONTAL = 'horizontal';
ScrollbarComponent.VERTICAL = 'vertical';

ScrollbarComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass2 = __webpack_require__(76);

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Modal = function (_EventEmitter) {
  (0, _inherits3.default)(Modal, _EventEmitter);

  function Modal(type, title, text) {
    var overlay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    (0, _classCallCheck3.default)(this, Modal);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this.type = type;
    _this.title = title;
    _this.text = text;
    _this.overlay = overlay;
    _this.data = null;
    return _this;
  }

  /**
   * Sets the data to the given one
   * @param {Object} data
   */


  Modal.prototype.setData = function setData(data) {
    this.data = data;
    this.emit('update');
  };

  /**
   * Closes this modal
   */


  Modal.prototype.close = function close() {
    this.emit('close');
  };

  return Modal;
}(_globals.EventEmitter); /*
                           * This file is part of PhotoEditorSDK.
                           *
                           * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                           * All rights reserved.
                           *
                           * Redistribution and use in source and binary forms, without
                           * modification, are permitted provided that the following license agreement
                           * is approved and a legal/financial contract was signed by the user.
                           * The license agreement can be found under following link:
                           *
                           * https://www.photoeditorsdk.com/LICENSE.txt
                           */

var ModalManager = function (_EventEmitter2) {
  (0, _inherits3.default)(ModalManager, _EventEmitter2);

  function ModalManager() {
    (0, _classCallCheck3.default)(this, ModalManager);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _EventEmitter2.call(this));

    _this2._modals = [];
    return _this2;
  }

  /**
   * Creates a loading modal
   * @param  {String} text
   * @return {Modal}
   */


  ModalManager.prototype.displayLoading = function displayLoading(text) {
    var modal = new Modal('loading', null, text);
    this.addModal(modal);
    return modal;
  };

  /**
   * Creates a progress modal
   * @param  {String} text
   * @return {Modal}
   */


  ModalManager.prototype.displayProgress = function displayProgress(text) {
    var progress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var modal = new Modal('progress', null, text);
    modal.setData({ progress: progress });
    this.addModal(modal);
    return modal;
  };

  /**
   * Creats a warning modal
   * @param  {String} title
   * @param  {String} text
   * @return {Modal}
   */


  ModalManager.prototype.displayWarning = function displayWarning(title, text) {
    var modal = new Modal('warning', title, text);
    this.addModal(modal);
    return modal;
  };

  /**
   * Creates an error modal
   * @param  {String} title
   * @param  {String} text
   * @param  {Boolean} overlay = true
   * @return {Modal}
   */


  ModalManager.prototype.displayError = function displayError(title, text) {
    var overlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var modal = new Modal('error', title, text, overlay);
    this.addModal(modal);
    return modal;
  };

  /**
   * Adds the given modal to the list of modals
   * @param {Modal} modal
   */


  ModalManager.prototype.addModal = function addModal(modal) {
    var _this3 = this;

    this._modals.push(modal);
    modal.on('close', function () {
      _this3.removeModal(modal);
    });
    modal.on('update', function () {
      _this3.emit('update');
    });
    this.emit('update');
  };

  /**
   * Removes the given modal from the list of modals
   * @param  {Modal} modal
   */


  ModalManager.prototype.removeModal = function removeModal(modal) {
    var index = this._modals.indexOf(modal);
    this._modals.splice(index, 1);
    this.emit('update');
  };

  /**
   * Returns the modals
   * @return {Array.<Modal>}
   */


  ModalManager.prototype.getModals = function getModals() {
    return this._modals;
  };

  /**
   * Returns the one and only instance of this class
   * @return {ModalManager}
   */


  (0, _createClass3.default)(ModalManager, null, [{
    key: 'instance',
    get: function get() {
      if (!this._instance) {
        this._instance = new ModalManager();
      }
      return this._instance;
    }
  }]);
  return ModalManager;
}(_globals.EventEmitter);

exports.default = ModalManager;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _backButtonComponent = __webpack_require__(97);

var _backButtonComponent2 = _interopRequireDefault(_backButtonComponent);

var _doneButtonComponent = __webpack_require__(149);

var _doneButtonComponent2 = _interopRequireDefault(_doneButtonComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ControlsComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ControlsComponent, _BaseComponent);

  function ControlsComponent() {
    (0, _classCallCheck3.default)(this, ControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._hasBackButton = true;
    _this._hasDoneButton = false;
    _this._backButtonClicked = false;

    _this._bindAll('_onBackClick', '_onDoneClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the back button
   * @param {Event} e
   * @private
   */


  ControlsComponent.prototype._onBackClick = function _onBackClick(e) {
    this._backButtonClicked = true;
    this.props.onSwitchControls('back');
  };

  /**
   * Gets called when the user clicks the done button
   * @param {Event} e
   * @private
   */


  ControlsComponent.prototype._onDoneClick = function _onDoneClick(e) {
    this._onBackClick();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the controls of this component
   * @return {ReactBEM.Element}
   */


  ControlsComponent.prototype.renderControls = function renderControls() {
    return null;
  };

  /**
   * Renders the overlay controls of this component
   * @return {ReactBEM.Element}
   */


  ControlsComponent.prototype.renderOverlayControls = function renderOverlayControls() {
    return null;
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  ControlsComponent.prototype.renderWithBEM = function renderWithBEM() {
    var forcedControl = this.props.options && this.props.options.forcedControl;
    var backButton = this._hasBackButton && !forcedControl ? _globals.ReactBEM.createElement(_backButtonComponent2.default, { onClick: this._onBackClick }) : null;

    var doneButton = this._hasDoneButton || forcedControl ? _globals.ReactBEM.createElement(_doneButtonComponent2.default, { onClick: this._onDoneClick }) : null;

    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:controls', ref: 'root' },
      this.renderOverlayControls(),
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:table' },
        backButton,
        this.renderControls(),
        doneButton
      )
    );
  };

  return ControlsComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = ControlsComponent;


ControlsComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The base class for all controls
 * @class
 * @memberof PhotoEditorSDK.UI.ReactUI
 */
var Control = function () {
  function Control() {
    (0, _classCallCheck3.default)(this, Control);
  }

  /**
   * Returns the initial shared state for this control
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @param  {Object} additionalState = {}
   * @return {Object}
   * @override
   */
  Control.prototype.getInitialSharedState = function getInitialSharedState() {
    return {};
  };

  /**
   * Checks if this control is available to the user
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {Boolean}
   * @override
   */


  Control.prototype.isAvailable = function isAvailable(editor) {
    return false;
  };

  /**
   * Returns the assets that should be preloaded for this control
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {String[]}
   */


  Control.getPreloadAssets = function getPreloadAssets() {
    return [];
  };

  return Control;
}();

/**
 * This control's top bar component. Used for the upper part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.TopBarControlsComponent}
 */


Control.topBarControlsComponent = null;

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 */
Control.controlsComponent = null;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 */
Control.canvasControlsComponent = null;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
Control.identifier = null;

/**
 * This control's icon path
 * @type {String}
 */
Control.iconPath = null;

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 */
Control.languageKey = null;

/**
 * The default options for this control
 * @type {Object}
 */
Control.defaultOptions = {};

exports.default = Control;

/***/ },
/* 9 */
/***/ function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

var store      = __webpack_require__(53)('wks')
  , uid        = __webpack_require__(35)
  , Symbol     = __webpack_require__(13).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DraggableComponent = function (_BaseComponent) {
  (0, _inherits3.default)(DraggableComponent, _BaseComponent);

  function DraggableComponent() {
    (0, _classCallCheck3.default)(this, DraggableComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onDragStart', '_onDragMove', '_onDragEnd');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user stars dragging the child
   * @param {Event} e
   * @private
   */


  DraggableComponent.prototype._onDragStart = function _onDragStart(e) {
    if (this.props.disabled) return;

    e.preventDefault();
    e.stopPropagation();

    this._initialMousePosition = _globals.Utils.getEventPosition(e);

    document.addEventListener('mousemove', this._onDragMove);
    document.addEventListener('touchmove', this._onDragMove);
    document.addEventListener('mouseup', this._onDragEnd);
    document.addEventListener('touchend', this._onDragEnd);

    var element = this.refs.element;

    var boundingRect = element.getBoundingClientRect();
    var elementOffset = new _globals.Vector2(boundingRect.left, boundingRect.top);

    var relativePosition = this._initialMousePosition.clone().subtract(elementOffset);
    this.props.onStart && this.props.onStart(relativePosition, e);
  };

  /**
   * Gets called while the user drags the child
   * @param {Event} e
   * @private
   */


  DraggableComponent.prototype._onDragMove = function _onDragMove(e) {
    e.preventDefault();
    e.stopPropagation();

    var mousePosition = _globals.Utils.getEventPosition(e);
    if (!mousePosition) return;
    var mouseDiff = mousePosition.clone().subtract(this._initialMousePosition);

    this.props.onDrag && this.props.onDrag(mouseDiff, e);
  };

  /**
   * Gets called when the user stops dragging the child
   * @param {Event} e
   * @private
   */


  DraggableComponent.prototype._onDragEnd = function _onDragEnd(e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();

    this._onDragMove(e);

    document.removeEventListener('mousemove', this._onDragMove);
    document.removeEventListener('touchmove', this._onDragMove);
    document.removeEventListener('mouseup', this._onDragEnd);
    document.removeEventListener('touchend', this._onDragEnd);

    this.props.onStop && this.props.onStop(e);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {React.Element}
   */


  DraggableComponent.prototype.render = function render() {
    if (!this.props.children || this.props.children instanceof Array) {
      throw new Error('DraggableComponent expects exactly one child.');
    }

    return _globals.React.cloneElement(this.props.children, {
      onMouseDown: this._onDragStart,
      onTouchStart: this._onDragStart,
      ref: 'element'
    });
  };

  return DraggableComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


exports.default = DraggableComponent;


DraggableComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _sliderComponent = __webpack_require__(30);

var _sliderComponent2 = _interopRequireDefault(_sliderComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SliderOverlayComponent = function (_BaseComponent) {
  (0, _inherits3.default)(SliderOverlayComponent, _BaseComponent);

  function SliderOverlayComponent() {
    (0, _classCallCheck3.default)(this, SliderOverlayComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onSliderValueChange');

    _this.state = { value: _this.props.value };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component receives new props
   * @param  {Object} props
   */


  SliderOverlayComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
    if (props.value !== this.state.value) {
      this.state.value = props.value;
    }
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the slider value has changed
   * @param  {Number} value
   * @private
   */


  SliderOverlayComponent.prototype._onSliderValueChange = function _onSliderValueChange(value) {
    this.props.onChange && this.props.onChange(value);
    this.setState({ value: value });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the SliderComponent
   * @return {SliderComponent}
   * @private
   */


  SliderOverlayComponent.prototype._renderSlider = function _renderSlider() {
    var props = _globals.SDKUtils.defaults(this.props, {
      style: '',
      middleDot: false,
      minValue: 1,
      maxValue: 100,
      label: 'Label',
      onChange: this._onSliderValueChange,
      value: this.state.value
    });
    return _globals.ReactBEM.createElement(_sliderComponent2.default, props);
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  SliderOverlayComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:controls e:overlay m:slider m:dark' },
      this._renderSlider()
    );
  };

  return SliderOverlayComponent;
}(_globals.BaseComponent);

exports.default = SliderOverlayComponent;


SliderOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 13 */
/***/ function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(15)
  , IE8_DOM_DEFINE = __webpack_require__(79)
  , toPrimitive    = __webpack_require__(56)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(16) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(26);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(25)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

var global    = __webpack_require__(13)
  , core      = __webpack_require__(9)
  , ctx       = __webpack_require__(45)
  , hide      = __webpack_require__(22)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ },
/* 18 */
/***/ function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(80)
  , defined = __webpack_require__(46);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CanvasControlsComponent = function (_BaseComponent) {
  (0, _inherits3.default)(CanvasControlsComponent, _BaseComponent);

  function CanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, CanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onCanvasZoomDone');
    return _this;
  }

  // -------------------------------------------------------------------------- HIT TEST

  /**
   * Checks if any other control reacts to a click at the given position
   * @param  {Vector2} clickPosition
   * @private
   */


  CanvasControlsComponent.prototype._performHitTest = function _performHitTest(clickPosition) {
    var container = this.refs.container;

    var containerRect = container.getBoundingClientRect();
    var containerPosition = new _globals.Vector2(containerRect.left, containerRect.top);

    var positionOnCanvas = clickPosition.subtract(containerPosition);

    var editor = this.context.editor;

    var controls = editor.controls.getAvailable();

    // Check if any of the controls responds to a click
    // at the given position
    for (var identifier in controls) {
      var control = controls[identifier];
      var clickResponse = control.clickAtPosition && control.clickAtPosition(positionOnCanvas, editor);

      if (clickResponse) {
        // Don't re-select an already selected item
        if (clickResponse.selectedSprite === this.getSharedState('selectedSprite')) {
          return true;
        }

        // Responds to click, switch to the controls
        this.props.onSwitchControls(control, clickResponse);
        return true;
      }
    }

    return false;
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called after the canvas has been zoomed in or out
   * @private
   */


  CanvasControlsComponent.prototype._onCanvasZoomDone = function _onCanvasZoomDone() {
    this.forceUpdate();
  };

  /**
   * Binds the events in _events
   * @protected
   */


  CanvasControlsComponent.prototype._bindEvents = function _bindEvents() {
    _BaseComponent.prototype._bindEvents.call(this);
    this.context.mediator.on(_globals.Constants.EVENTS.ZOOM_DONE, this._onCanvasZoomDone);
  };

  /**
   * Unbinds the events in _events
   * @protected
   */


  CanvasControlsComponent.prototype._unbindEvents = function _unbindEvents() {
    _BaseComponent.prototype._unbindEvents.call(this);
    this.context.mediator.off(_globals.Constants.EVENTS.ZOOM_DONE, this._onCanvasZoomDone);
  };

  return CanvasControlsComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = CanvasControlsComponent;


CanvasControlsComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _headerComponent = __webpack_require__(150);

var _headerComponent2 = _interopRequireDefault(_headerComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ScreenComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ScreenComponent, _BaseComponent);

  function ScreenComponent() {
    (0, _classCallCheck3.default)(this, ScreenComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  /**
   * Renders the header (if enabled)
   * @return {ReactBEM.Element}
   * @private
   */
  ScreenComponent.prototype._renderHeader = function _renderHeader() {
    if (!this.context.options.showHeader) {
      return null;
    }
    return _globals.ReactBEM.createElement(_headerComponent2.default, null);
  };

  /**
   * Renders this screen
   * @return {ReactBEM.Element}
   * @private
   */


  ScreenComponent.prototype._renderScreen = function _renderScreen() {
    return _globals.ReactBEM.createElement('div', null);
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  ScreenComponent.prototype.renderWithBEM = function renderWithBEM() {
    var screenBEMSpecifier = 'b:screen';
    if (!this.context.options.showHeader) {
      screenBEMSpecifier += ' m:noHeader';
    }

    return _globals.ReactBEM.createElement(
      'div',
      { bem: screenBEMSpecifier, className: !this.props.visible ? 'is-hidden' : null },
      this._renderHeader(),
      this._renderScreen()
    );
  };

  return ScreenComponent;
}(_globals.BaseComponent);

exports.default = ScreenComponent;


ScreenComponent.propTypes = {
  editor: _globals.React.PropTypes.any
};

ScreenComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(14)
  , createDesc = __webpack_require__(28);
module.exports = __webpack_require__(16) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ },
/* 23 */
/***/ function(module, exports) {

module.exports = {};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _assign = __webpack_require__(207);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ },
/* 25 */
/***/ function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ },
/* 26 */
/***/ function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(84)
  , enumBugKeys = __webpack_require__(47);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ },
/* 28 */
/***/ function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ },
/* 29 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_29__;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(24);

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */
var SliderComponent = function (_BaseComponent) {
  (0, _inherits3.default)(SliderComponent, _BaseComponent);

  function SliderComponent() {
    (0, _classCallCheck3.default)(this, SliderComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onKnobDragStart', '_onKnobDrag', '_onKnobDragStop', '_onBarDragStart', '_onBarDrag', '_onBarDragStop', '_onMiddleDotClick');

    _this.state = {
      value: _this.props.value || 0,
      sliderPosition: 0,
      foregroundLeft: 0,
      foregroundWidth: 0
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after the component has been mounted
   */


  SliderComponent.prototype.componentDidMount = function componentDidMount() {
    // Trigger a re-render to position the knob
    this._setValue(this.state.value, false);
  };

  /**
   * Gets called when this component receives new props
   * @param  {Object} props
   */


  SliderComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
    if (props.value !== this.state.value) {
      this._setValue(props.value, false);
    }
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user presses a mouse button on the middle dot
   * @private
   */


  SliderComponent.prototype._onMiddleDotClick = function _onMiddleDotClick() {
    this._previousValue = this.state.value;
    var newValue = this.props.minValue + (this.props.maxValue - this.props.minValue) / 2;
    this._setValue(newValue, true, true);
  };

  /**
   * Gets called when the user starts dragging the knob
   * @param  {Vector2} position
   * @private
   */


  SliderComponent.prototype._onKnobDragStart = function _onKnobDragStart(position) {
    this._previousValue = this.state.value;
    this._initialSliderPosition = this.state.sliderPosition;
    this._initialPosition = position;
  };

  /**
   * Gets called while the user drags the knob
   * @param  {Vector2} diff
   * @private
   */


  SliderComponent.prototype._onKnobDrag = function _onKnobDrag(diff) {
    var bar = this.refs.bar;

    var barWidth = bar.offsetWidth;

    var newSliderPosition = this._initialSliderPosition + diff.x;
    newSliderPosition = Math.max(0, Math.min(newSliderPosition, barWidth));
    var progress = newSliderPosition / barWidth;
    var newValue = this.props.minValue + (this.props.maxValue - this.props.minValue) * progress;

    this._setValue(newValue);
  };

  /**
   * Gets called when the user stops dragging the knob
   * @private
   */


  SliderComponent.prototype._onKnobDragStop = function _onKnobDragStop() {
    this._setValue(this.state.value, true, true);
  };

  /**
   * Gets called when the user starts dragging the bar
   * @param  {Vector2} position
   * @private
   */


  SliderComponent.prototype._onBarDragStart = function _onBarDragStart(position) {
    this._previousValue = this.state.value;
    this._initialPosition = position.clone();

    var bar = this.refs.bar;

    var barWidth = bar.offsetWidth;
    var progress = position.x / barWidth;
    var newValue = this.props.minValue + (this.props.maxValue - this.props.minValue) * progress;
    this._setValue(newValue);
  };

  /**
   * Gets called while the user drags the bar
   * @param  {Vector2} diff
   * @private
   */


  SliderComponent.prototype._onBarDrag = function _onBarDrag(diff) {
    var position = this._initialPosition.clone().add(diff);

    var bar = this.refs.bar;

    var barWidth = bar.offsetWidth;
    var progress = position.x / barWidth;
    var newValue = this.props.minValue + (this.props.maxValue - this.props.minValue) * progress;
    newValue = Math.max(this.props.minValue, Math.min(this.props.maxValue, newValue));
    this._setValue(newValue);
  };

  /**
   * Gets called when the user stops dragging the bar
   * @private
   */


  SliderComponent.prototype._onBarDragStop = function _onBarDragStop() {
    this._setValue(this.state.value, true, true);
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the style for the knob (position)
   * @return {Object}
   * @private
   */


  SliderComponent.prototype._getKnobStyle = function _getKnobStyle() {
    return { left: this.state.sliderPosition };
  };

  /**
   * Returns the style for the foreground bar
   * @return {Object}
   * @private
   */


  SliderComponent.prototype._getForegroundStyle = function _getForegroundStyle() {
    return {
      left: this.state.foregroundLeft,
      width: this.state.foregroundWidth
    };
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Decides whether or not this slider should have a middle dot on the bar
   * @private
   */


  SliderComponent.prototype._displayMiddleDot = function _displayMiddleDot() {
    return this.props.middleDot !== false;
  };

  /**
   * Sets the value to the given value, updates the slider position
   * @param {Number} value
   * @param {Boolean} emitChange = true
   * @param {Boolean} emitRelease = false
   * @private
   */


  SliderComponent.prototype._setValue = function _setValue(value) {
    var emitChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var emitRelease = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    value = Math.round(value);
    var _props = this.props,
        minValue = _props.minValue,
        maxValue = _props.maxValue;

    var progress = (value - minValue) / (maxValue - minValue);

    // Calculate slider position
    var bar = this.refs.bar;

    var barWidth = bar.offsetWidth;
    var sliderPosition = barWidth * progress;

    // Calculate foreground position and width
    var foregroundWidth = progress * barWidth;
    var foregroundLeft = 0;
    if (this._displayMiddleDot()) {
      foregroundWidth = Math.abs(progress - 0.5) * barWidth;
      foregroundLeft = progress < 0.5 ? barWidth * 0.5 - foregroundWidth : '50%';
    }

    this.setState({ value: value, sliderPosition: sliderPosition, foregroundWidth: foregroundWidth, foregroundLeft: foregroundLeft });

    if (emitChange) {
      this.props.onChange && this.props.onChange(value, this._previousValue, emitRelease);
    }
  };

  /**
   * Builds a display value from the given props
   * @param {Number} value
   * @return {String}
   * @private
   */


  SliderComponent.prototype._buildValue = function _buildValue(value) {
    // Limit decimals to two digits, if present
    if (value % 1 !== 0) {
      value = value.toFixed(2);
    }

    // Add positive value prefix (+) if value is > 0
    if (this.props.positiveValuePrefix && value >= 0) {
      value = '' + this.props.positiveValuePrefix + value;
    }

    // Add unit if present
    if (this.props.valueUnit) {
      value += this.props.valueUnit;
    }

    return value;
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  SliderComponent.prototype.renderWithBEM = function renderWithBEM() {
    var middleDot = null;
    if (this._displayMiddleDot()) {
      middleDot = _globals.ReactBEM.createElement('div', { bem: 'e:middleDot', onClick: this._onMiddleDotClick });
    }

    var foregroundProps = {
      style: this._getForegroundStyle()
    };

    var componentBem = '$b:slider' + (this.props.style ? ' m:' + this.props.style : '');
    return _globals.ReactBEM.createElement(
      'div',
      { bem: componentBem },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:bar', ref: 'bar' },
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onBarDragStart,
            onDrag: this._onBarDrag,
            onStop: this._onBarDragStop },
          _globals.ReactBEM.createElement(
            'div',
            null,
            _globals.ReactBEM.createElement('div', { bem: '$e:background' }),
            _globals.ReactBEM.createElement('div', (0, _extends3.default)({ bem: '$e:foreground' }, foregroundProps)),
            _globals.ReactBEM.createElement(
              _draggableComponent2.default,
              {
                onStart: this._onKnobDragStart,
                onDrag: this._onKnobDrag,
                onStop: this._onKnobDragStop },
              _globals.ReactBEM.createElement('div', { bem: 'e:knob b:knob m:slider', style: this._getKnobStyle() })
            )
          )
        ),
        middleDot
      ),
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:labels' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label m:lowerBoundary' },
          this._buildValue(this.props.minValue)
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label m:value' },
          this.props.label,
          ' ',
          this._buildValue(this.state.value)
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label m:upperBoundary' },
          this._buildValue(this.props.maxValue)
        )
      )
    );
  };

  return SliderComponent;
}(_globals.BaseComponent);

exports.default = SliderComponent;


SliderComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(24);

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _textItemComponent = __webpack_require__(138);

var _textItemComponent2 = _interopRequireDefault(_textItemComponent);

var _stickerItemComponent = __webpack_require__(137);

var _stickerItemComponent2 = _interopRequireDefault(_stickerItemComponent);

var _brushItemComponent = __webpack_require__(136);

var _brushItemComponent2 = _interopRequireDefault(_brushItemComponent);

var _canvasControlsComponent = __webpack_require__(20);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _SDK$Operations$Sprit = _globals.SDK.Operations.SpriteOperation,
    Sticker = _SDK$Operations$Sprit.Sticker,
    Text = _SDK$Operations$Sprit.Text,
    Brush = _SDK$Operations$Sprit.Brush; /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SpritesCanvasControlsComponent = function (_CanvasControlsCompon) {
  (0, _inherits3.default)(SpritesCanvasControlsComponent, _CanvasControlsCompon);

  function SpritesCanvasControlsComponent() {
    var _this$_events;

    (0, _classCallCheck3.default)(this, SpritesCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _CanvasControlsCompon.call.apply(_CanvasControlsCompon, [this].concat(args)));

    _this._bindAll('_onCanvasClick', '_onSpriteDragStart', '_onSpriteDragStop', '_onOperationUpdated', '_onOperationRemoved', '_onSpriteFlip', '_onSpriteTakeToFront', '_onSpriteRemove');

    _this._canvasClickDisabled = false;

    _this._events = (_this$_events = {}, (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated), (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when an operation has been removed
   * @param  {Operation} operation
   * @private
   */


  SpritesCanvasControlsComponent.prototype._onOperationRemoved = function _onOperationRemoved(operation) {
    var selectedSprite = this.getSharedState('selectedSprite');
    if (operation !== this.getSharedState('operation') || !selectedSprite) return;

    // Operation can be removed by the undo button. We need
    // to make sure we re-create the operation for the lifetime
    // of this control
    var editor = this.context.editor;

    var newOperation = editor.operations.getOrCreate('sprite', {
      sprites: [selectedSprite],
      enabled: false
    });
    this.setSharedState({
      operation: newOperation,
      operationExistedBefore: false,
      initialOptions: {}
    });
  };

  /**
   * Gets called when an operation has been updated
   * @param  {Operation} operation
   * @private
   */


  SpritesCanvasControlsComponent.prototype._onOperationUpdated = function _onOperationUpdated(operation) {
    var selectedSprite = this.getSharedState('selectedSprite');
    if (operation !== this.getSharedState('operation') || !selectedSprite) return;

    // If the currently selected sprite is no longer existent,
    // re-add it
    var sprites = operation.getSprites();
    if (sprites.indexOf(selectedSprite) === -1) {
      sprites.push(selectedSprite);
    }

    this.forceUpdate();
  };

  /**
   * Gets called when the selected item is deselected
   * @private
   */


  SpritesCanvasControlsComponent.prototype._onItemBlur = function _onItemBlur() {};

  /**
   * Gets called when the user clicks somewhere on the canvas
   * @param  {Event} e
   * @private
   */


  SpritesCanvasControlsComponent.prototype._onCanvasClick = function _onCanvasClick(e) {
    if (this._canvasClickDisabled) return;

    var hitTest = this._performHitTest(_globals.Utils.getEventPosition(e));
    if (!hitTest) {
      if (this.getSharedState('selectedSprite')) {
        this._onItemBlur();
      }
      this.props.onSwitchControls('home');
    }
  };

  /**
   * Gets called when the user flips the selected sprite
   * @param  {String} direction
   * @private
   */


  SpritesCanvasControlsComponent.prototype._onSpriteFlip = function _onSpriteFlip(direction) {
    var selectedSprite = this.getSharedState('selectedSprite');
    switch (direction) {
      case 'h':
        selectedSprite.setFlipHorizontally(!selectedSprite.getFlipHorizontally());
        break;
      case 'v':
        selectedSprite.setFlipVertically(!selectedSprite.getFlipVertically());
        break;
    }
  };

  /**
   * Gets called when the user takes the selected sprite to front
   * @private
   */


  SpritesCanvasControlsComponent.prototype._onSpriteTakeToFront = function _onSpriteTakeToFront(direction) {
    var operation = this.getSharedState('operation');
    operation.takeSpriteToFront(this.getSharedState('selectedSprite'));
    this.forceSharedUpdate();
  };

  /**
   * Gets called when the user removes the selected sprite
   * @param  {String} direction
   * @private
   */


  SpritesCanvasControlsComponent.prototype._onSpriteRemove = function _onSpriteRemove() {
    var operation = this.getSharedState('operation');
    var selectedSprite = this.getSharedState('selectedSprite');
    operation.removeSprite(selectedSprite);
    selectedSprite.dispose();

    this.setSharedState({
      selectedSprite: null
    });
  };

  // -------------------------------------------------------------------------- DRAGGING

  /**
   * Gets called when a sprite has received a dragging event. Blocks the `_onCanvasClick`
   * handler until `_onSpriteDragStop`
   * @private
   */


  SpritesCanvasControlsComponent.prototype._onSpriteDragStart = function _onSpriteDragStart() {
    this._canvasClickDisabled = true;
  };

  /**
   * Since `_onCanvasClick` is triggered right after the drag end event for knobs is triggered,
   * we need to wait a short amount of time until we re-enabale the canvas click
   * @private
   */


  SpritesCanvasControlsComponent.prototype._onSpriteDragStop = function _onSpriteDragStop() {
    var _this2 = this;

    setTimeout(function () {
      _this2._canvasClickDisabled = false;
    }, 100);
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the container style
   * @return {Object}
   * @private
   */


  SpritesCanvasControlsComponent.prototype._getContainerStyle = function _getContainerStyle() {
    var editor = this.context.editor;

    var canvasDimensions = editor.getCanvasDimensions();
    var outputDimensions = editor.getOutputDimensions();

    var _canvasDimensions$clo = canvasDimensions.clone().divide(2).subtract(outputDimensions.clone().divide(2)),
        x = _canvasDimensions$clo.x,
        y = _canvasDimensions$clo.y;

    return {
      left: x,
      top: y,
      width: outputDimensions.x,
      height: outputDimensions.y
    };
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Returns the properties for the outer container
   * @return {Object}
   * @private
   */


  SpritesCanvasControlsComponent.prototype._getContainerProps = function _getContainerProps() {
    return {};
  };

  /**
   * Returns the properties for the canvas container
   * @return {Object}
   * @private
   */


  SpritesCanvasControlsComponent.prototype._getInnerContainerProps = function _getInnerContainerProps() {
    return {
      style: this._getContainerStyle(),
      onClick: this._onCanvasClick
    };
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the sprite items
   * @return {Array.<SpriteItemComponent>}
   * @private
   */


  SpritesCanvasControlsComponent.prototype._renderSpriteItems = function _renderSpriteItems() {
    var _this3 = this;

    var operation = this.getSharedState('operation');
    var sprites = operation.getSprites();
    var selectedSprite = this.getSharedState('selectedSprite');

    return sprites.map(function (s) {
      var isSelected = s === selectedSprite;
      var ComponentClass = null;
      if (s instanceof Text) {
        ComponentClass = _textItemComponent2.default;
      } else if (s instanceof Sticker) {
        ComponentClass = _stickerItemComponent2.default;
      } else if (s instanceof Brush) {
        ComponentClass = _brushItemComponent2.default;
      }

      return _globals.ReactBEM.createElement(ComponentClass, {
        operation: operation,
        sharedState: _this3.props.sharedState,
        sprite: s,
        selected: isSelected,
        onDragStart: _this3._onSpriteDragStart,
        onDragStop: _this3._onSpriteDragStop,
        onRemove: _this3._onSpriteRemove.bind(_this3, s),
        options: _this3.props.options,
        ref: 'sprite-' + s.getId() });
    });
  };

  /**
   * This renders controls on top of the sprites
   * @return {ReactBEM.Element}
   * @private
   */


  SpritesCanvasControlsComponent.prototype._renderOverlayControls = function _renderOverlayControls() {
    return null;
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  SpritesCanvasControlsComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      (0, _extends3.default)({
        bem: '$b:canvasControls e:container m:full',
        ref: 'container'
      }, this._getContainerProps()),
      _globals.ReactBEM.createElement(
        'div',
        (0, _extends3.default)({
          bem: 'b:canvasControls e:innerContainer',
          ref: 'innerContainer'
        }, this._getInnerContainerProps()),
        _globals.ReactBEM.createElement(
          'div',
          {
            bem: '$b:spritesCanvasControls',
            ref: 'container' },
          this._renderSpriteItems(),
          this._renderOverlayControls()
        )
      )
    );
  };

  return SpritesCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = SpritesCanvasControlsComponent;


SpritesCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TopBarComponent = function (_BaseComponent) {
  (0, _inherits3.default)(TopBarComponent, _BaseComponent);

  function TopBarComponent() {
    (0, _classCallCheck3.default)(this, TopBarComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  /**
   * Renders the content of this TopBarComponent
   * @return {ReactBEM.Element}
   */
  TopBarComponent.prototype.renderContent = function renderContent() {
    return this.props.children;
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  TopBarComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:topBar e:row' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell' },
        this.renderContent()
      )
    );
  };

  return TopBarComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = TopBarComponent;


TopBarComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _iterator = __webpack_require__(211);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(210);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ },
/* 34 */
/***/ function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ },
/* 35 */
/***/ function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var $at  = __webpack_require__(242)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(81)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _photoeditorsdk = __webpack_require__(29);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

var _url = __webpack_require__(261);

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global XMLHttpRequest */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TIMEOUT = 5000;
var Promise = _photoeditorsdk2.default.Promise;

var JSONLoader = function () {
  function JSONLoader(url) {
    (0, _classCallCheck3.default)(this, JSONLoader);

    this._url = url;
    this._parsedUrl = _url2.default.parse(this._url, true);
  }

  /**
   * Checks if this request is a JSONP request
   * @return {Boolean}
   */


  JSONLoader.prototype._isJSONPRequest = function _isJSONPRequest() {
    var query = this._parsedUrl.query;

    for (var key in query) {
      var value = query[key];
      if (value === '?') {
        return true;
      }
    }
    return false;
  };

  /**
   * Loads the JSON(P) from the given URL
   * @return {Promise}
   */


  JSONLoader.prototype.load = function load() {
    if (this._isJSONPRequest()) {
      return this._loadJSONP();
    } else {
      return this._loadJSON();
    }
  };

  /**
   * Loads the URL as JSON
   * @return {Promise}
   */


  JSONLoader.prototype._loadJSON = function _loadJSON() {
    var _this = this;

    return new Promise(function (resolve, reject) {
      var xhr = void 0;
      if (window.XDomainRequest) {
        xhr = new window.XDomainRequest();

        xhr.onload = function () {
          var json = JSON.parse(xhr.responseText);
          resolve(json);
        };
        xhr.onerror = function (e) {
          reject(e);
        };
      } else if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();

        xhr.onreadystatechange = function (oEvent) {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              var json = JSON.parse(xhr.responseText);
              resolve(json);
            } else {
              reject(new Error('HTTP Status ' + xhr.status));
            }
          }
        };
      }

      xhr.open('GET', _this._url, true);
      xhr.send();
    });
  };

  /**
   * Loads the URL as JSONP
   * @return {Promise}
   */


  JSONLoader.prototype._loadJSONP = function _loadJSONP() {
    var _this2 = this;

    var failed = false;
    var succeeded = false;

    var fnName = 'pesdk' + Math.round(Math.random() * 99999999999999);
    return new Promise(function (resolve, reject) {
      var node = _this2._createJSONPNode(fnName);
      window[fnName] = function (result) {
        _this2._removeJSONPNode(node);
        if (!failed) {
          succeeded = true;
          resolve(result);
        }
      };

      window.setTimeout(function () {
        if (!succeeded) {
          _this2._removeJSONPNode(node);
          failed = true;
          reject(new Error('Timeout of 5 seconds exceeded.'));
        }
      }, TIMEOUT);
    });
  };

  /**
   * Creates a JSONP <script> node inside the <head> element
   * @param  {String} fnName
   * @return {DOMElement}
   * @private
   */


  JSONLoader.prototype._createJSONPNode = function _createJSONPNode(fnName) {
    var JSONPUrl = this._buildJSONPUrl(fnName);
    var headNode = document.querySelector('head');
    var scriptNode = document.createElement('script');
    scriptNode.src = JSONPUrl;
    headNode.appendChild(scriptNode);
    return scriptNode;
  };

  /**
   * Removes the JSONP <script> node from the <head> element
   * @param  {DOMElement} node
   * @private
   */


  JSONLoader.prototype._removeJSONPNode = function _removeJSONPNode(node) {
    node.parentNode.removeChild(node);
  };

  /**
   * Builds a JSONP url for the given function name
   * @param  {String} fnName
   * @return {String}
   */


  JSONLoader.prototype._buildJSONPUrl = function _buildJSONPUrl(fnName) {
    // Find JSONP parameter
    var query = this._parsedUrl.query;

    var parameter = null;
    for (var param in query) {
      if (query[param] === '?') {
        parameter = param;
        break;
      }
    }

    delete this._parsedUrl.search;
    query[parameter] = fnName;

    return _url2.default.format(this._parsedUrl);
  };

  return JSONLoader;
}();

exports.default = JSONLoader;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _overlayComponent = __webpack_require__(103);

var _overlayComponent2 = _interopRequireDefault(_overlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ColorPickerComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ColorPickerComponent, _BaseComponent);

  function ColorPickerComponent() {
    (0, _classCallCheck3.default)(this, ColorPickerComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._value = _this.props.initialValue.clone();
    _this._bindAll('_onButtonClick', '_onValueChange', '_onColorPickerOpen', '_onColorPickerClose');

    _this._events = (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.COLORPICKER_OPEN, _this._onColorPickerOpen);

    _this.state = {
      overlayVisible: false
    };

    _this._transparentPatternCanvas = _globals.Utils.createTransparentPatternCanvas();
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  ColorPickerComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);
    this._renderColor();
  };

  /**
   * Gets called after this component has been updated
   */


  ColorPickerComponent.prototype.componentDidUpdate = function componentDidUpdate() {
    this._renderColor();
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when a colorpicker has been opened. If it is not the same
   * color picker as this, this one gets closed. This makes sure that there
   * is only one color picker open at a time
   * @param  {ColorPickerComponent} colorPicker
   * @private
   */


  ColorPickerComponent.prototype._onColorPickerOpen = function _onColorPickerOpen(colorPicker) {
    if (colorPicker === this) return;
    this.setState({ overlayVisible: false });
  };

  /**
   * Gets called when the color picker overlay tries to close itself
   * @private
   */


  ColorPickerComponent.prototype._onColorPickerClose = function _onColorPickerClose() {
    this.setState({ overlayVisible: false });
  };

  /**
   * Gets called when the color picker button has been clicked
   * @param  {Event} e
   * @private
   */


  ColorPickerComponent.prototype._onButtonClick = function _onButtonClick(e) {
    e.preventDefault();
    e.stopPropagation();

    if (!this.state.overlayVisible) {
      this._emitEvent(_globals.Constants.EVENTS.COLORPICKER_OPEN, this);
    }

    this.setState({ overlayVisible: !this.state.overlayVisible });
  };

  /**
   * Gets called when the value changes
   * @param  {Color} value
   * @private
   */


  ColorPickerComponent.prototype._onValueChange = function _onValueChange(value) {
    this._value = value;
    this._renderColor();
    this.forceUpdate();

    this.props.onChange && this.props.onChange(value);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the current color on the preview canvas
   * @private
   */


  ColorPickerComponent.prototype._renderColor = function _renderColor() {
    var canvas = this.refs.canvas;
    var context = canvas.getContext('2d');

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    var pattern = context.createPattern(this._transparentPatternCanvas, 'repeat');
    context.fillStyle = pattern;
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = this._value.toRGBA();
    context.fillRect(0, 0, canvas.width, canvas.height);
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  ColorPickerComponent.prototype.renderWithBEM = function renderWithBEM() {
    var Overlay = null;
    if (this.state.overlayVisible) {
      Overlay = _globals.ReactBEM.createElement(_overlayComponent2.default, {
        initialValue: this._value,
        onChange: this._onValueChange,
        onClose: this._onColorPickerClose,
        alpha: this.props.alpha });
    }

    var className = this.state.overlayVisible ? 'is-active' : null;

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:controls' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:colorPicker', className: className, onClick: this._onButtonClick },
        _globals.ReactBEM.createElement('canvas', { bem: 'e:preview', ref: 'canvas' }),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label' },
          this.props.label || this._t('generic.color')
        ),
        Overlay
      )
    );
  };

  return ColorPickerComponent;
}(_globals.BaseComponent);

exports.default = ColorPickerComponent;


ColorPickerComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ItemComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ItemComponent, _BaseComponent);

  function ItemComponent() {
    (0, _classCallCheck3.default)(this, ItemComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onItemDragStart', '_onItemDragStop', '_onItemDrag', '_onSpriteUpdate');
    return _this;
  }

  // -------------------------------------------------------------------------- CALCULATIONS

  /**
   * Returns the absolute position of the sprite
   * @return {Vector2}
   * @private
   */


  ItemComponent.prototype._getAbsoluteSpritePosition = function _getAbsoluteSpritePosition() {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();

    return this.props.sprite.getPosition().clone().multiply(outputDimensions);
  };

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  ItemComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);
    this.props.sprite.on('update', this._onSpriteUpdate);
  };

  /**
   * Gets called when this component is about to be unmounted
   */


  ItemComponent.prototype.componentWillUnmount = function componentWillUnmount() {
    _BaseComponent.prototype.componentWillUnmount.call(this);
    this.props.sprite.off('update', this._onSpriteUpdate);
  };

  /**
   * Gets called when this component will receive new props
   * @param  {Object} nextProps
   */


  ItemComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    this.props.sprite.off('update', this._onSpriteUpdate);
    nextProps.sprite.on('update', this._onSpriteUpdate);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when this component's sprite has been updated
   * @private
   */


  ItemComponent.prototype._onSpriteUpdate = function _onSpriteUpdate() {
    this.forceUpdate();
  };

  /**
   * Gets called when the user starts dragging this item
   * @private
   */


  ItemComponent.prototype._onItemDragStart = function _onItemDragStart() {
    var sprite = this.props.sprite;

    this._initialPosition = sprite.getPosition();

    this.props.onDragStart && this.props.onDragStart();
  };

  /**
   * Gets called while the user drags this item
   * @param  {Vector2} offset
   * @private
   */


  ItemComponent.prototype._onItemDrag = function _onItemDrag(offset) {
    var sprite = this.props.sprite;
    var editor = this.context.editor;


    var outputDimensions = editor.getOutputDimensions();
    var newPosition = this._initialPosition.clone().add(offset.divide(outputDimensions));

    sprite.setPosition(newPosition);
  };

  /**
   * Gets called when the user stops dragging this item
   * @private
   */


  ItemComponent.prototype._onItemDragStop = function _onItemDragStop() {
    this.props.onDragStop && this.props.onDragStop();
  };

  return ItemComponent;
}(_globals.BaseComponent); /*
                            * This file is part of PhotoEditorSDK.
                            *
                            * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                            * All rights reserved.
                            *
                            * Redistribution and use in source and binary forms, without
                            * modification, are permitted provided that the following license agreement
                            * is approved and a legal/financial contract was signed by the user.
                            * The license agreement can be found under following link:
                            *
                            * https://www.photoeditorsdk.com/LICENSE.txt
                            */

exports.default = ItemComponent;


ItemComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RowComponent = function (_BaseComponent) {
  (0, _inherits3.default)(RowComponent, _BaseComponent);

  function RowComponent() {
    (0, _classCallCheck3.default)(this, RowComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onClick');
    return _this;
  }
  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the button
   * @param  {Event} e
   * @private
   */


  RowComponent.prototype._onClick = function _onClick(e) {
    this.props.onClick && this.props.onClick();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this row's content
   * @return {ReactBEM.Element}
   * @private
   */


  RowComponent.prototype._renderContent = function _renderContent() {
    return null;
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  RowComponent.prototype.renderWithBEM = function renderWithBEM() {
    var rowBEM = '$e:row m:' + this._modifier;
    if (this.props.totalRows) {
      rowBEM += ' m:row-' + this.props.totalRows;
    }

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: 'b:splashScreen' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: rowBEM },
        this._renderContent()
      )
    );
  };

  return RowComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = RowComponent;


RowComponent.propTypes = {
  onClick: _globals.React.PropTypes.func
};

RowComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _fileLoader = __webpack_require__(183);

var _fileLoader2 = _interopRequireDefault(_fileLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var InvisibleUploadComponent = function (_BaseComponent) {
  (0, _inherits3.default)(InvisibleUploadComponent, _BaseComponent);

  function InvisibleUploadComponent() {
    (0, _classCallCheck3.default)(this, InvisibleUploadComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onNewFile');
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  InvisibleUploadComponent.prototype.componentDidMount = function componentDidMount() {
    this._fileLoader = new _fileLoader2.default(this.refs.fileInput);
    this._fileLoader.on('file', this._onNewFile);
  };

  /**
   * Gets called when this component is about to be unmounted
   */


  InvisibleUploadComponent.prototype.componentWillUnmount = function componentWillUnmount() {
    this._fileLoader.off('file', this._onNewFile);
    this._fileLoader.dispose();
    this._fileLoader = null;
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the FileLoader emits a new file
   * @param  {File} file
   * @private
   */


  InvisibleUploadComponent.prototype._onNewFile = function _onNewFile(file) {
    this.props.onNewFile && this.props.onNewFile(file);
  };

  // -------------------------------------------------------------------------- PUBLIC API

  /**
   * Public method for opening the file loader
   */


  InvisibleUploadComponent.prototype.open = function open() {
    this._fileLoader.open();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  InvisibleUploadComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement('input', { type: 'file', bem: 'b:hiddenFileInput', ref: 'fileInput' });
  };

  return InvisibleUploadComponent;
}(_globals.BaseComponent);

exports.default = InvisibleUploadComponent;


InvisibleUploadComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TopBarButtonComponent = function (_BaseComponent) {
  (0, _inherits3.default)(TopBarButtonComponent, _BaseComponent);

  function TopBarButtonComponent() {
    (0, _classCallCheck3.default)(this, TopBarButtonComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  TopBarButtonComponent.prototype.renderWithBEM = function renderWithBEM() {
    // Build BEM specifier
    var bem = '$e:button';
    if (this.props.style) {
      bem += ' m:' + this.props.style;
    }
    if (this.props.icon) {
      bem += ' m:withIcon';
    }

    // Build icon
    var icon = null;
    if (this.props.icon) {
      icon = _globals.ReactBEM.createElement('img', {
        bem: 'e:icon',
        src: this._getAssetPath(this.props.icon, true) });
    }

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:topBar' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: bem, onClick: this.props.onClick },
        icon,
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label' },
          this.props.label || 'Button'
        )
      )
    );
  };

  return TopBarButtonComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = TopBarButtonComponent;


TopBarButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FilterManager = function () {
  function FilterManager(options) {
    (0, _classCallCheck3.default)(this, FilterManager);

    this._options = options;
    this._categoriesById = {};
    this._categories = [{
      name: 'retro',
      filters: [_globals.SDK.Filters.CelsiusFilter, _globals.SDK.Filters.ChestFilter, _globals.SDK.Filters.FixieFilter, _globals.SDK.Filters.LeninFilter, _globals.SDK.Filters.PolaFilter, _globals.SDK.Filters.Pola669Filter, _globals.SDK.Filters.K1Filter, _globals.SDK.Filters.K2Filter, _globals.SDK.Filters.K6Filter, _globals.SDK.Filters.KDynamicFilter]
    }, {
      name: 'bw',
      filters: [_globals.SDK.Filters.BWFilter, _globals.SDK.Filters.BWHardFilter, _globals.SDK.Filters.X400Filter]
    }, {
      name: 'summer',
      filters: [_globals.SDK.Filters.FrontFilter, _globals.SDK.Filters.MellowFilter, _globals.SDK.Filters.SemiredFilter, _globals.SDK.Filters.SunnyFilter, _globals.SDK.Filters.TexasFilter]
    }, {
      name: 'winter',
      filters: [_globals.SDK.Filters.MetalFilter, _globals.SDK.Filters.A15Filter, _globals.SDK.Filters.BreezeFilter, _globals.SDK.Filters.FridgeFilter, _globals.SDK.Filters.OrchidFilter, _globals.SDK.Filters.QuoziFilter]
    }, {
      name: 'special',
      filters: [_globals.SDK.Filters.FoodFilter, _globals.SDK.Filters.GlamFilter, _globals.SDK.Filters.LomoFilter, _globals.SDK.Filters.GobblinFilter]
    }];

    this._initCategories();
  }

  /**
   * Initializes the categories
   * @private
   */


  FilterManager.prototype._initCategories = function _initCategories() {
    var _this = this;

    // Should the categories passed in by the user replace the existing ones?
    if (this._options.categories) {
      if (this._options.replaceCategories) {
        this._categories = this._options.categories;
      } else {
        this._categories = _globals.Utils.mergeCategories(this._categories, this._options.categories, 'filters');
      }
    }

    // Remove filters that should not be selectable
    if (this._options.selectableFilters) {
      var newCategories = [];
      this._categories.forEach(function (category) {
        var filters = category.filters.filter(function (f) {
          return _this._options.selectableFilters.indexOf(f.identifier) !== -1;
        });
        if (filters.length > 0) {
          newCategories.push({
            name: category.name,
            filters: filters
          });
        }
      });
      this._categories = newCategories;
    }

    var allCategory = {
      name: 'all',
      filters: this._categories.map(function (c) {
        return c.filters;
      }).reduce(function (a, b) {
        return a.concat(b);
      })
    };
    this._categories.unshift(allCategory);
    this._categories.forEach(function (c) {
      _this._categoriesById[c.name] = c;
    });
  };

  /**
   * Returns the filters for the category with the given name
   * @param  {String} categoryName
   * @return {Object[]}
   */


  FilterManager.prototype.getFiltersForCategory = function getFiltersForCategory(categoryName) {
    if (!this._categoriesById[categoryName]) {
      throw new Error('Unknown filter category \'' + categoryName + '\'');
    }
    return this._categoriesById[categoryName].filters;
  };

  /**
   * Returns the categories
   * @return {Object[]}
   */


  FilterManager.prototype.getCategories = function getCategories() {
    return this._categories;
  };

  return FilterManager;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = FilterManager;

/***/ },
/* 44 */
/***/ function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(223);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ },
/* 46 */
/***/ function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ },
/* 47 */
/***/ function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ },
/* 48 */
/***/ function(module, exports) {

module.exports = true;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(15)
  , dPs         = __webpack_require__(238)
  , enumBugKeys = __webpack_require__(47)
  , IE_PROTO    = __webpack_require__(52)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(78)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(228).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ },
/* 50 */
/***/ function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

var def = __webpack_require__(14).f
  , has = __webpack_require__(18)
  , TAG = __webpack_require__(10)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

var shared = __webpack_require__(53)('keys')
  , uid    = __webpack_require__(35);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

var global = __webpack_require__(13)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ },
/* 54 */
/***/ function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(46);
module.exports = function(it){
  return Object(defined(it));
};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(26);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

var global         = __webpack_require__(13)
  , core           = __webpack_require__(9)
  , LIBRARY        = __webpack_require__(48)
  , wksExt         = __webpack_require__(58)
  , defineProperty = __webpack_require__(14).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(10);

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(247);
var global        = __webpack_require__(13)
  , hide          = __webpack_require__(22)
  , Iterators     = __webpack_require__(23)
  , TO_STRING_TAG = __webpack_require__(10)('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ },
/* 60 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_60__;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _adjustments = __webpack_require__(106);

Object.defineProperty(exports, 'adjustments', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_adjustments).default;
  }
});

var _crop = __webpack_require__(114);

Object.defineProperty(exports, 'crop', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_crop).default;
  }
});

var _filter = __webpack_require__(116);

Object.defineProperty(exports, 'filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_filter).default;
  }
});

var _focus = __webpack_require__(119);

Object.defineProperty(exports, 'focus', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_focus).default;
  }
});

var _sticker = __webpack_require__(139);

Object.defineProperty(exports, 'sticker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sticker).default;
  }
});

var _text = __webpack_require__(145);

Object.defineProperty(exports, 'text', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_text).default;
  }
});

var _brush = __webpack_require__(109);

Object.defineProperty(exports, 'brush', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_brush).default;
  }
});

var _selectiveBlur = __webpack_require__(133);

Object.defineProperty(exports, 'selectiveBlur', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_selectiveBlur).default;
  }
});

var _frame = __webpack_require__(124);

Object.defineProperty(exports, 'frame', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_frame).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _overlayComponent = __webpack_require__(100);

var _overlayComponent2 = _interopRequireDefault(_overlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CategoryDropdownComponent = function (_BaseComponent) {
  (0, _inherits3.default)(CategoryDropdownComponent, _BaseComponent);

  function CategoryDropdownComponent() {
    (0, _classCallCheck3.default)(this, CategoryDropdownComponent);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call(this));

    _this._bindAll('_onButtonClick');

    _this.state = {
      overlayVisible: false
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the color picker button has been clicked
   * @param  {Event} e
   * @private
   */


  CategoryDropdownComponent.prototype._onButtonClick = function _onButtonClick(e) {
    e.preventDefault();
    e.stopPropagation();

    this.setState({ overlayVisible: !this.state.overlayVisible });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  CategoryDropdownComponent.prototype.renderWithBEM = function renderWithBEM() {
    var Overlay = null;

    if (this.state.overlayVisible) {
      Overlay = _globals.ReactBEM.createElement(_overlayComponent2.default, {
        items: this.props.items,
        selectedItem: this.props.selectedItem,
        onChange: this.props.onChange });
    }

    var className = this.state.overlayVisible ? 'is-active' : null;

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:controls' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:categoryDropdown', className: className, onClick: this._onButtonClick },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this.props.selectedItem.icon }),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label' },
          this.props.selectedItem.label
        ),
        Overlay
      )
    );
  };

  return CategoryDropdownComponent;
}(_globals.BaseComponent);

exports.default = CategoryDropdownComponent;


CategoryDropdownComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OverviewControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(OverviewControlsComponent, _ControlsComponent);

  function OverviewControlsComponent() {
    (0, _classCallCheck3.default)(this, OverviewControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._hasBackButton = false;
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when an item has been clicked
   * @param  {Event} e
   * @private
   */


  OverviewControlsComponent.prototype._onItemClick = function _onItemClick(controls) {
    this.props.onSwitchControls(controls);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the list items for this control
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  OverviewControlsComponent.prototype._renderListItems = function _renderListItems() {
    var _this2 = this;

    var editor = this.context.editor;


    var items = [];
    var makeItem = function makeItem(identifier) {
      var control = editor.controls.get(identifier);
      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: control.identifier,
          'data-identifier': control.identifier,
          onClick: _this2._onItemClick.bind(_this2, control) },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:button m:withLabel' },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this2._getAssetPath(control.iconPath, true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              _this2._t(control.languageKey)
            )
          )
        )
      );
    };

    var controlsOrder = this.context.options.editor.controlsOrder;

    controlsOrder.forEach(function (groupOrIdentifier) {
      if (Array.isArray(groupOrIdentifier)) {
        var group = groupOrIdentifier;

        var groupItems = [];
        group.forEach(function (identifier) {
          if (!editor.controls.isEnabled(identifier)) return;
          groupItems.push(makeItem(identifier));
        });

        if (groupItems.length) {
          items.push(groupItems);
        }
      } else {
        var identifier = groupOrIdentifier;
        if (!editor.controls.isEnabled(identifier)) return;
        items.push(makeItem(identifier));
      }
    });

    var finalItems = [];
    items.forEach(function (itemOrGroup) {
      finalItems = finalItems.concat(itemOrGroup);
      if (itemOrGroup !== items[items.length - 1]) {
        finalItems.push(_globals.ReactBEM.createElement('li', { bem: 'e:separator' }));
      }
    });

    return finalItems;
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  OverviewControlsComponent.prototype.renderControls = function renderControls() {
    var listItems = this._renderListItems();

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:list' },
      _globals.ReactBEM.createElement(
        _scrollbarComponent2.default,
        null,
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:list' },
          listItems
        )
      )
    );
  };

  return OverviewControlsComponent;
}(_controlsComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = OverviewControlsComponent;


OverviewControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FontPreviewComponent = function (_BaseComponent) {
  (0, _inherits3.default)(FontPreviewComponent, _BaseComponent);

  function FontPreviewComponent() {
    (0, _classCallCheck3.default)(this, FontPreviewComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after the component has been mounted
   */
  FontPreviewComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);
    this._renderCanvas();
  };

  /**
   * Gets called after this component has been updated
   */


  FontPreviewComponent.prototype.componentDidUpdate = function componentDidUpdate() {
    this._renderCanvas();
  };

  // -------------------------------------------------------------------------- CANVAS RENDERING

  /**
   * Renders the current font family onto the canvas
   * @private
   */


  FontPreviewComponent.prototype._renderCanvas = function _renderCanvas() {
    var canvas = this.refs.canvas;
    var editor = this.context.editor;

    var sdk = editor.getSDK();

    var pixelRatio = sdk.getPixelRatio();
    canvas.width = canvas.offsetWidth * pixelRatio;
    canvas.height = canvas.offsetHeight * pixelRatio;

    canvas.style.width = canvas.offsetWidth + 'px';
    canvas.style.height = canvas.offsetHeight + 'px';

    var context = canvas.getContext('2d');

    context.fillStyle = 'red';
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.font = (this.props.fontStyle || '') + ' ' + (this.props.fontWeight || '') + ' ' + 24 * pixelRatio + 'px ' + this.props.fontFamily;
    context.textBaseline = 'middle';
    context.textAlign = 'center';
    context.fillStyle = 'white';

    context.fillText('Abc', canvas.width / 2, canvas.height / 2);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  FontPreviewComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement('canvas', { bem: 'b:fontFamily e:canvas', ref: 'canvas' });
  };

  return FontPreviewComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = FontPreviewComponent;


FontPreviewComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SearchSuggestionComponent = function (_BaseComponent) {
  (0, _inherits3.default)(SearchSuggestionComponent, _BaseComponent);

  function SearchSuggestionComponent() {
    (0, _classCallCheck3.default)(this, SearchSuggestionComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the search suggestion
   * @private
   */


  SearchSuggestionComponent.prototype._onClick = function _onClick() {
    this.props.onClick && this.props.onClick(this.props.searchSuggestion);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  SearchSuggestionComponent.prototype.renderWithBEM = function renderWithBEM() {
    var searchSuggestion = this.props.searchSuggestion;

    var style = {
      backgroundImage: 'url(' + searchSuggestion.coverImage + ')'
    };

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: 'b:photoRoll e:libraryList' },
      _globals.ReactBEM.createElement(
        'li',
        { bem: 'e:item', style: style, onClick: this._onClick },
        _globals.ReactBEM.createElement('div', { bem: 'e:overlay' }),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:name' },
          searchSuggestion.query
        )
      )
    );
  };

  return SearchSuggestionComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = SearchSuggestionComponent;


SearchSuggestionComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _photoComponent = __webpack_require__(160);

var _photoComponent2 = _interopRequireDefault(_photoComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */
var COLUMN_WIDTH = 240;

var PhotoListComponent = function (_BaseComponent) {
  (0, _inherits3.default)(PhotoListComponent, _BaseComponent);

  function PhotoListComponent() {
    (0, _classCallCheck3.default)(this, PhotoListComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this._totalPhotosHeight = 0;
    _this.state = {
      loading: false,
      photos: []
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  PhotoListComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);

    this._loadPhotos();
  };

  /**
   * Gets called when this component has been updated
   */


  PhotoListComponent.prototype.componentDidUpdate = function componentDidUpdate() {
    if (this.refs.scrollbar) {
      this.refs.scrollbar.update();
    }
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks on a photo
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Photo} photo
   * @private
   */


  PhotoListComponent.prototype._onPhotoClicked = function _onPhotoClicked(photo) {
    this.props.onPhotoClicked && this.props.onPhotoClicked(photo);
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Returns the headline for this view
   * @return {String}
   * @private
   */


  PhotoListComponent.prototype._getHeadline = function _getHeadline() {
    return this.props.library.name;
  };

  /**
   * A method that is called whenever styles need to be fixed by the JavaScript.
   * This needs to be done thanks to older Internet Explorer browsers which have
   * a bunch of CSS bugs.
   */


  PhotoListComponent.prototype.fixStyles = function fixStyles() {
    if (_globals.Utils.Browser.isIElte(11)) {
      var cell = this.refs.cell;

      var list = this.refs.scrollbar.getList();
      if (!(cell && list)) {
        return;
      }
      var cellHeight = cell.offsetHeight;
      list.style.height = cellHeight + 'px';
    }

    if (this.refs.scrollbar) {
      this.refs.scrollbar.update();
    }
  };

  // -------------------------------------------------------------------------- LOADING

  PhotoListComponent.prototype._renderColumns = function _renderColumns() {
    var _this2 = this;

    var photos = this.state.photos;

    var columnCount = 3;
    var columnHeights = [];

    var columns = [];
    for (var i = 0; i < columnCount; i++) {
      columns.push([]);
      columnHeights.push(0);
    }

    photos.forEach(function (photo) {
      var dimensions = photo.dimensions;

      // Find shortest column

      var shortestColumnIndex = null;
      var shortestColumnHeight = Infinity;
      for (var _i = 0; _i < columnCount; _i++) {
        if (columnHeights[_i] < shortestColumnHeight) {
          shortestColumnIndex = _i;
          shortestColumnHeight = columnHeights[_i];
        }
      }

      columns[shortestColumnIndex].push(_globals.ReactBEM.createElement(_photoComponent2.default, {
        photo: photo.obj,
        onClick: _this2._onPhotoClicked.bind(_this2, photo.obj) }));
      columnHeights[shortestColumnIndex] += dimensions.y;
    });

    return columns;
  };

  /**
   * Renders the content for this component
   * @return {ReactBEM.Element}
   * @private
   */


  PhotoListComponent.prototype._renderPhotos = function _renderPhotos() {
    var columns = this._renderColumns();
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:photoRoll e:row m:fullHeight' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell', ref: 'cell' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          { direction: 'vertical', ref: 'scrollbar' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:container', ref: 'container' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:innerContainer' },
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:headline' },
                this._getHeadline()
              ),
              _globals.ReactBEM.createElement(
                'bem',
                { specifier: 'e:photoList' },
                columns.map(function (column) {
                  return _globals.ReactBEM.createElement(
                    'ul',
                    { bem: '$e:list' },
                    column
                  );
                })
              )
            )
          )
        )
      )
    );
  };

  /**
   * Loads the photos
   * @private
   */


  PhotoListComponent.prototype._loadPhotos = function _loadPhotos() {
    var _this3 = this;

    this._totalPhotosHeight = 0;

    var modal = _modalManager2.default.instance.displayProgress(this._t('loading.loading'));
    var PhotoRollProvider = this.context.options.photoRoll.provider;
    var provider = new PhotoRollProvider();

    provider.getPhotosForLibrary(this.props.library).then(function (photos) {
      return _this3._preloadPhotos(photos, modal);
    }).then(function (photos) {
      _this3.setState({ photos: photos, loading: false });
      modal.close();
    }).catch(function (e) {
      console.log(e);
      modal.close();
      _modalManager2.default.instance.displayError(_this3._t('errors.photoRollLoadFail.title'), _this3._t('errors.photoRollLoadFail.text', { error: e.message }));
    });
  };

  /**
   * Preloads the photos
   * @param {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Photo[]} photos
   * @param {Modal} modal
   * @return {Promise}
   * @private
   */


  PhotoListComponent.prototype._preloadPhotos = function _preloadPhotos(photos, modal) {
    var _this4 = this;

    var totalPhotos = photos.length;
    var loadedPhotos = 0;
    return Promise.all(photos.map(function (photo) {
      return _this4._preloadPhoto(photo).then(function (image) {
        var photoDimensions = new _globals.Vector2(image.width, image.height);
        photoDimensions.multiply(COLUMN_WIDTH / image.width);
        _this4._totalPhotosHeight += photoDimensions.y;

        loadedPhotos++;
        modal.setData({ progress: loadedPhotos / totalPhotos });

        return {
          obj: photo,
          dimensions: photoDimensions
        };
      });
    }));
  };

  /**
   * Preloads the given photo
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Photo} photo
   * @return {Promise}
   * @private
   */


  PhotoListComponent.prototype._preloadPhoto = function _preloadPhoto(photo) {
    return new Promise(function (resolve, reject) {
      var image = new window.Image();
      image.addEventListener('load', function () {
        resolve(image);
      });
      image.addEventListener('error', function () {
        resolve(image);
      });
      image.crossOrigin = 'Anonymous';
      image.src = photo.urls.thumb;
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  PhotoListComponent.prototype.renderWithBEM = function renderWithBEM() {
    if (!this.state.loading) {
      return this._renderPhotos();
    } else {
      return _globals.ReactBEM.createElement('div', null);
    }
  };

  return PhotoListComponent;
}(_globals.BaseComponent);

exports.default = PhotoListComponent;


PhotoListComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(76);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var elementSeparator = '__';
var modifierSeparator = '--';
var blockPrefix = 'pesdk-react-';

var BEMObject = function () {
  function BEMObject(parent, type, name) {
    (0, _classCallCheck3.default)(this, BEMObject);

    this._parent = parent;
    this._type = type;
    this._name = name;
  }

  /**
   * Creates a BEMObject of type "element" that has this element as parent
   * @param  {String} name
   * @return {BEMObject}
   */


  BEMObject.prototype.element = function element(name) {
    return new BEMObject(this, 'element', name);
  };

  /**
   * Creates a BEMObject of type "modifier" that has this element as parent
   * @param  {String} name
   * @return {BEMObject}
   */


  BEMObject.prototype.modifier = function modifier(name) {
    return new BEMObject(this, 'modifier', name);
  };

  /**
   * Builds the class name for this BEMObject
   * @return {String}
   */


  (0, _createClass3.default)(BEMObject, [{
    key: 'str',
    get: function get() {
      var response = this._parent ? this._parent.str : '';
      switch (this._type) {
        case 'block':
          response += '' + blockPrefix + this._name;
          break;
        case 'element':
          response += '' + elementSeparator + this._name;
          break;
        case 'modifier':
          response += '' + modifierSeparator + this._name;
          break;
      }
      return response;
    }
  }]);
  return BEMObject;
}();

exports.default = {
  /**
   * Creates a BEMObject of type "block" that has this element as parent
   * @param  {String} name
   * @return {BEMObject}
   */
  block: function block(name) {
    return new BEMObject(null, 'block', name);
  }
};

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _exporter = __webpack_require__(181);

var _exporter2 = _interopRequireDefault(_exporter);

var _imageResizer = __webpack_require__(188);

var _imageResizer2 = _interopRequireDefault(_imageResizer);

var _operations = __webpack_require__(179);

var _operations2 = _interopRequireDefault(_operations);

var _controls = __webpack_require__(176);

var _controls2 = _interopRequireDefault(_controls);

var _features = __webpack_require__(177);

var _features2 = _interopRequireDefault(_features);

var _zoom = __webpack_require__(180);

var _zoom2 = _interopRequireDefault(_zoom);

var _history = __webpack_require__(178);

var _history2 = _interopRequireDefault(_history);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The Editor class is an interface to the SDK, managing operations, rendering,
 * history, zoom etc.
 * @class
 * @memberof PhotoEditorSDK.UI.ReactUI
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Editor = function (_EventEmitter) {
  (0, _inherits3.default)(Editor, _EventEmitter);

  function Editor(ui, options, mediator) {
    var shallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    (0, _classCallCheck3.default)(this, Editor);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._ui = ui;
    _this._options = options;
    _this._mediator = mediator;
    _this._ready = false;
    _this._padding = [0, 0, 0, 0];

    if (!shallow) {
      _this._initSDK();

      _this._onZoom = _this._onZoom.bind(_this);
      _this._onUndo = _this._onUndo.bind(_this);
      _this.operations = new _operations2.default(_this, _this._sdk, _this._mediator);

      _this.history = new _history2.default(_this, _this._sdk, _this._mediator);
      _this.history.on('undo', _this._onUndo);
      _this.zoom = new _zoom2.default(_this, _this._sdk, _this._mediator);
      _this.zoom.on('set', _this._onZoom);

      _this._initSerializers();
    }

    _this.controls = new _controls2.default(_this, _this._sdk, _this._mediator);
    _this.features = new _features2.default(_this, _this._sdk, _this._mediator);

    // Rendering
    _this._running = false;
    _this._renderRequested = true;
    _this._renderCallbacks = [];
    _this._animationFrameRequest = null;

    _this.render = _this.render.bind(_this);
    _this._tick = _this._tick.bind(_this);
    return _this;
  }

  // -------------------------------------------------------------------------- INITIALIZATION

  /**
   * Sets the given image to be rendered. If the image needs to be resized to fit into a
   * WebGL texture or to match the `maxMegaPixels` option, resizing is done before setting
   * the image.
   * @param {Image} image
   * @param {Boolean} resetEditor [description]
   */


  Editor.prototype.setImage = function setImage() {
    var _this2 = this;

    var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._options.editor.image;
    var resetEditor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var renderer = this._sdk.getRenderer();
    var initialDimensions = new _globals.Vector2(image.width, image.height);
    var maxPixels = this.getMaxMegapixels() * 1000000;
    var maxDimensions = renderer.getMaxDimensions();

    if (resetEditor) {
      this.reset();
    }

    var imageResizer = new _imageResizer2.default(image, maxPixels, maxDimensions);
    var exif = null;

    var done = function done(image) {
      var dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : initialDimensions;
      var resizeReason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      _this2._setImage(image, exif, dimensions);

      _this2._initWatermark();

      _this2._ready = true;
      _this2.emit('ready');
    };

    if (!imageResizer.needsResize()) {
      done(image);
    } else {
      this.emit('resize');
      exif = this._sdk.parseExif(image);
      imageResizer.resize().then(function (_ref) {
        var canvas = _ref.canvas,
            dimensions = _ref.dimensions,
            reason = _ref.reason;

        // Flag canvas as JPEG so that export will recognize that
        // it needs to restore EXIF data
        canvas.src = 'data:image/jpeg;base64,';

        _this2.emit('resized', { dimensions: dimensions, reason: reason });
        done(canvas, dimensions, reason);
      });
    }
  };

  /**
   * Initializes the watermark operation
   * @private
   */


  Editor.prototype._initWatermark = function _initWatermark() {
    if (this._options.editor.watermarkImage) {
      this._watermarkOperation = this.operations.getOrCreate('watermark', {
        image: this._options.editor.watermarkImage
      });
    }
  };

  /**
   * Initializes the SDK
   * @private
   */


  Editor.prototype._initSDK = function _initSDK() {
    var _options = this._options,
        logLevel = _options.logLevel,
        displayWelcomeMessage = _options.displayWelcomeMessage,
        debug = _options.debug,
        apiKey = _options.apiKey;
    var _options$editor = this._options.editor,
        smoothDownscaling = _options$editor.smoothDownscaling,
        smoothUpscaling = _options$editor.smoothUpscaling,
        preferredRenderer = _options$editor.preferredRenderer,
        pixelRatio = _options$editor.pixelRatio;

    var rendererOptions = {
      logLevel: logLevel,
      debug: debug,
      displayWelcomeMessage: displayWelcomeMessage,
      pixelRatio: pixelRatio,
      smoothDownscaling: smoothDownscaling,
      smoothUpscaling: smoothUpscaling,
      transparent: true,
      apiKey: apiKey
    };
    this._sdk = new _globals.SDK(preferredRenderer, rendererOptions);
  };

  // -------------------------------------------------------------------------- ZOOMING

  /**
   * Gets called after a new zoom level has been set. Re-renders the editor.
   * @param  {Number} zoom
   * @param  {Function} [callback]
   * @private
   */


  Editor.prototype._onZoom = function _onZoom(zoom) {
    var _this3 = this;

    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    this.fixOffset();
    this.render(function () {
      _this3._mediator.emit(_globals.Constants.EVENTS.ZOOM_DONE);
      callback && callback();
    });
  };

  /**
   * Gets called after an undo happened
   * @private
   */


  Editor.prototype._onUndo = function _onUndo() {
    this.render();
  };

  /**
   * Returns the current rotation
   * @return {Number}
   */


  Editor.prototype.getRotation = function getRotation() {
    return this._sdk.getRotation();
  };

  /**
   * Sets the rotation to the given value
   * @param {Number} rotation
   */


  Editor.prototype.setRotation = function setRotation(rotation) {
    this._sdk.setRotation(rotation);
  };

  /**
   * Returns the current sprite scale
   * @return {Number}
   */


  Editor.prototype.getSpriteScale = function getSpriteScale() {
    return this._sdk.getSpriteScale();
  };

  /**
   * Sets the sprite scale to the given value
   * @param {Number} spriteScale
   */


  Editor.prototype.setSpriteScale = function setSpriteScale(spriteScale) {
    this._sdk.setSpriteScale(spriteScale);
  };

  // -------------------------------------------------------------------------- MISC PRIVATE API

  /**
   * Checks if the control with the tool identifier is enabled
   * @param  {String}  identifier
   * @return {Boolean}
   */


  Editor.prototype.isToolEnabled = function isToolEnabled(identifier) {
    return this._options.editor.tools.indexOf(identifier) !== -1;
  };

  /**
   * Returns the maximum mega pixels
   * @return {Number}
   * @private
   */


  Editor.prototype.getMaxMegapixels = function getMaxMegapixels() {
    var maxMegaPixels = this._options.editor.maxMegaPixels;

    return _globals.Utils.isMobile() ? maxMegaPixels.mobile : maxMegaPixels.desktop;
  };

  // -------------------------------------------------------------------------- MISC PUBLIC API

  /**
   * Returns the output sprite's current dimensions
   * @param {Boolean} incorporateSpriteScale = false
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Editor.prototype.getOutputDimensions = function getOutputDimensions() {
    var incorporateSpriteScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    return this._sdk.getOutputDimensions(incorporateSpriteScale);
  };

  /**
   * Returns the output texture's current dimensions
   * @param  {Boolean} incorporateSpriteScale = false
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Editor.prototype.getOutputTextureDimensions = function getOutputTextureDimensions() {
    var incorporateSpriteScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    return this._sdk.getOutputTextureDimensions(incorporateSpriteScale);
  };

  /**
   * Returns the final dimensions that the input image would have
   * after all existing operations have been applied
   * @param {Boolean} incorporateSpriteScale = false
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Editor.prototype.getFinalDimensions = function getFinalDimensions() {
    var incorporateSpriteScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    return this._sdk.getFinalDimensions(incorporateSpriteScale);
  };

  /**
   * Returns the canvas dimensions
   * @param  {Boolean} subtractPadding = true
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Editor.prototype.getCanvasDimensions = function getCanvasDimensions() {
    var subtractPadding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    var canvas = this._sdk.getCanvas();
    var dimensions = new _globals.Vector2(canvas.offsetWidth, canvas.offsetHeight);
    if (subtractPadding) {
      dimensions.subtract(this._padding[1] + this._padding[3], this._padding[0] + this._padding[2]);
    }
    return dimensions;
  };

  /**
   * Sets the given image
   * @param {Image} image
   * @param {PhotoEditorSDK.EXIF} [exif]
   * @param {PhotoEditorSDK.Math.Vector2} [dimensions]
   * @private
   */


  Editor.prototype._setImage = function _setImage() {
    var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._options.editor.image;
    var exif = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var dimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    // Invalidate caches
    this._sdk.setAllOperationsToDirty();

    this._options.editor.image = image;
    this._sdk.setImage(image, exif, dimensions);

    this.zoom.set('auto');

    this.emit('new-image');
  };

  /**
   * Exports an image
   * @param {Boolean} download = false
   * @return {Promise}
   */


  Editor.prototype.export = function _export() {
    var _this4 = this;

    var download = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (this._watermarkOperation) {
      this._watermarkOperation.setEnabled(false);
    }

    // Invalidate caches
    this._sdk.setAllOperationsToDirty();

    var options = this._options.editor.export;
    var exporter = new _exporter2.default(this._sdk, options, download);
    return exporter.export().then(function (output) {
      _this4.emit('export', output);
      _this4._mediator.emit(_globals.Constants.EVENTS.EXPORT, output, _this4);

      if (_this4._watermarkOperation) {
        _this4._watermarkOperation.setEnabled(true);
        _this4._sdk.render();
      }

      // Invalidate caches
      _this4._sdk.setAllOperationsToDirty();

      return output;
    });
  };

  // -------------------------------------------------------------------------- SERIALIZATION

  /**
   * Initializes the serializers and deserializers
   * @private
   */


  Editor.prototype._initSerializers = function _initSerializers() {
    this._serializers = {
      '1.0.0': __webpack_require__(196).default,
      '1.0.1': __webpack_require__(198).default
    };
  };

  /**
   * Serializes the editor state for the given version
   * @param  {Object} options = {}
   * @param  {String} version = '1.0.1'
   * @return {Promise}
   */


  Editor.prototype.serialize = function serialize() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '1.0.1';

    var Serializer = this._serializers[version];
    if (!Serializer) {
      return _globals.Promise.reject(new Error('No serializer for version ' + version + ' found.'));
    }
    var serializer = new Serializer(this);
    return serializer.serialize(options);
  };

  /**
   * Deserializes the given data
   * @param  {Object} data
   * @return {Promise}
   */


  Editor.prototype.deserialize = function deserialize(data) {
    var Serializer = this._serializers[data.version];
    if (!Serializer) {
      return _globals.Promise.reject(new Error('No serializer for version ' + data.version + ' found.'));
    }
    var serializer = new Serializer(this);
    return serializer.deserialize(data);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Applies the rendering offset
   * @private
   */


  Editor.prototype._applyOffset = function _applyOffset() {
    var offset = this._offset.clone();

    offset.x -= this._padding[1] / 2;
    offset.x += this._padding[3] / 2;

    offset.y -= this._padding[2] / 2;
    offset.y += this._padding[0] / 2;

    this._sdk.setOffset(offset);
  };

  /**
   * Starts the render loop
   */


  Editor.prototype.start = function start() {
    this.zoom.set('auto');
    this._animationFrameRequest = (0, _globals.requestAnimationFrame)(this._tick);
  };

  /**
   * Stops the render loop
   */


  Editor.prototype.stop = function stop() {
    this._running = false;
    if (this._animationFrameRequest) {
      (0, _globals.cancelAnimationFrame)(this._animationFrameRequest);
      this._renderCallbacks = [];
    }
  };

  /**
   * Requests a render, adds `callback` to the render callbacks
   * @param  {Function} [callback]
   */


  Editor.prototype.render = function render(callback) {
    this._renderRequested = true;
    if (callback) {
      this._renderCallbacks.push(callback);
    }
  };

  /**
   * Sets the offset to the given one
   * @param {PhotoEditorSDK.Math.Vector2} offset
   */


  Editor.prototype.setOffset = function setOffset(offset) {
    this._offset = this._clampOffset(offset);
  };

  /**
   * Returns the current offset
   * @returns {PhotoEditorSDK.Math.Vector2}
   */


  Editor.prototype.getOffset = function getOffset() {
    return this._offset;
  };

  /**
   * Makes sure the image stays inside the viewport
   */


  Editor.prototype.fixOffset = function fixOffset() {
    this.setOffset(this._sdk.getOffset());
  };

  /**
   * Fixes the given offset to make sure the image stays inside the viewport
   * @private
   */


  Editor.prototype._clampOffset = function _clampOffset(offset) {
    var renderer = this._sdk.getRenderer();
    var rendererDimensions = new _globals.Vector2(renderer.getWidth(), renderer.getHeight());
    var outputDimensions = this._sdk.getOutputDimensions(false);

    var minOffset = rendererDimensions.clone().subtract(outputDimensions).divide(2).clamp(null, new _globals.Vector2(0, 0));

    var maxOffset = outputDimensions.clone().subtract(rendererDimensions).divide(2).clamp(new _globals.Vector2(0, 0), null);

    var newOffset = offset.clone().clamp(minOffset, maxOffset).round();

    return newOffset;
  };

  /**
   * Gets called when an animation frame is being processed. Renders the
   * canvas if necessary, requests another animation frame callbacks
   * @private
   */


  Editor.prototype._tick = function _tick() {
    var _this5 = this;

    if (this._renderRequested) {
      var callbacks = this._renderCallbacks.slice(0);
      this._renderCallbacks = [];

      this._render().then(function () {
        callbacks.forEach(function (r) {
          return r();
        });
        _this5._animationFrameRequest = (0, _globals.requestAnimationFrame)(_this5._tick);
      }).catch(function (e) {
        _globals.Log.printError(e);
      });
      this._renderRequested = false;
    } else {
      this._animationFrameRequest = (0, _globals.requestAnimationFrame)(this._tick);
    }
  };

  /**
   * Triggers a render
   * @private
   */


  Editor.prototype._render = function _render() {
    var _this6 = this;

    if (!this._ready) return _globals.Promise.resolve();

    this._applyOffset();

    return this._sdk.render().then(function () {
      _this6._lastOutputBounds = _this6._sdk.getSprite().getBounds();
    }).catch(function (e) {
      _this6.emit('render-error', e);
    });
  };

  /**
   * Resets everything
   */


  Editor.prototype.reset = function reset() {
    this._sdk.reset();

    this.history.reset();
    this.operations.reset();
  };

  // -------------------------------------------------------------------------- DISPOSAL

  /**
   * Cleans this instance up
   */


  Editor.prototype.dispose = function dispose() {
    this.stop();

    this._sdk.dispose();
  };

  // -------------------------------------------------------------------------- GETTERS / SETTERS

  /**
   * Checks if the Editor is ready to render
   * @return {Boolean}
   */


  Editor.prototype.isReady = function isReady() {
    return this._ready;
  };

  /**
   * Returns the renderer
   * @return {PhotoEditorSDK.Engine.BaseRenderer}
   */


  Editor.prototype.getRenderer = function getRenderer() {
    return this._sdk.getRenderer();
  };

  /**
   * Returns the SDK
   * @return {PhotoEditorSDK}
   */


  Editor.prototype.getSDK = function getSDK() {
    return this._sdk;
  };

  /**
   * Returns the input image dimensions
   * @return {PhotoEditorSDK.Math.Vector2}s
   */


  Editor.prototype.getInputDimensions = function getInputDimensions() {
    return this._sdk.getInputDimensions();
  };

  /**
   * Returns the padding values
   * @return {Number[]}
   */


  Editor.prototype.getPadding = function getPadding() {
    return this._padding;
  };

  /**
   * Sets the padding (top, right, bottom, left)
   * @param {Number[]} padding
   */


  Editor.prototype.setPadding = function setPadding(padding) {
    if (!padding) {
      this._padding = [0, 0, 0, 0];
    } else {
      this._padding = padding;
    }
  };

  /**
   * Returns the image
   * @return {Image}
   */


  Editor.prototype.getImage = function getImage() {
    return this._options.editor.image;
  };

  /**
   * Returns the options
   * @return {Object}
   */


  Editor.prototype.getOptions = function getOptions() {
    return this._options;
  };

  /**
   * Returns the UI
   * @return {PhotoEditorSDK.UI.ReactUI}
   */


  Editor.prototype.getUI = function getUI() {
    return this._ui;
  };

  /**
   * Broadcasts a crop to all operations that need to be changed
   * @param  {PhotoEditorSDK.Operations.CropOperation} cropOperation
   * @param  {Object} options
   */


  Editor.prototype.broadcastCrop = function broadcastCrop(cropOperation, options) {
    var _this7 = this;

    var croppableOperations = ['sprite', 'selective-blur'];
    croppableOperations.forEach(function (identifier) {
      var operation = _this7.operations.get(identifier);
      if (!operation) {
        return;
      }
      operation.crop(cropOperation, options);
    });
  };

  /**
   * Broadcasts a flip to all operations that need to be changed
   * @param  {String} direction
   */


  Editor.prototype.broadcastFlip = function broadcastFlip(direction) {
    var _this8 = this;

    var flippableOperations = ['linear-focus', 'radial-focus', 'sprite', 'selective-blur'];
    flippableOperations.forEach(function (identifier) {
      var operation = _this8.operations.get(identifier);
      if (!operation) {
        return;
      }
      operation.flip(direction);
    });
  };

  /**
   * Broadcasts a rotation to all operations that need to be changed
   * @param  {Number} degrees
   */


  Editor.prototype.broadcastRotate = function broadcastRotate(degrees) {
    var _this9 = this;

    var flippableOperations = ['crop', 'linear-focus', 'radial-focus', 'sprite', 'selective-blur'];
    flippableOperations.forEach(function (identifier) {
      var operation = _this9.operations.get(identifier);
      if (!operation) {
        return;
      }
      operation.rotate(degrees);
    });
  };

  return Editor;
}(_globals.EventEmitter);

exports.default = Editor;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.SDK.OptionType; /*
                                           * This file is part of PhotoEditorSDK.
                                           *
                                           * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                           * All rights reserved.
                                           *
                                           * Redistribution and use in source and binary forms, without
                                           * modification, are permitted provided that the following license agreement
                                           * is approved and a legal/financial contract was signed by the user.
                                           * The license agreement can be found under following link:
                                           *
                                           * https://www.photoeditorsdk.com/LICENSE.txt
                                           */

var Font = function (_SDK$Configurable) {
  (0, _inherits3.default)(Font, _SDK$Configurable);

  function Font() {
    (0, _classCallCheck3.default)(this, Font);
    return (0, _possibleConstructorReturn3.default)(this, _SDK$Configurable.apply(this, arguments));
  }

  return Font;
}(_globals.SDK.Configurable);

/**
 * Specifies the available options for the Font class
 * @type {Object}
 * @ignore
 */


exports.default = Font;
Font.prototype.availableOptions = {
  name: { type: OptionType.STRING, required: true },
  fontWeight: { type: OptionType.ALL, default: 400 },
  fontFamily: { type: OptionType.STRING, required: true },
  fontStyle: { type: OptionType.STRING, default: 'normal' },
  provider: { type: OptionType.STRING, available: ['google'] },
  default: { type: OptionType.BOOLEAN, default: false }
};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

var _jsonLoader = __webpack_require__(37);

var _jsonLoader2 = _interopRequireDefault(_jsonLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var StickerManager = function () {
  function StickerManager(options) {
    (0, _classCallCheck3.default)(this, StickerManager);

    this._options = options;
    this._categoriesById = {};
    this._categories = _globals.Constants.DEFAULTS.STICKER_CATEGORIES.slice(0);

    if (this._options.categories) {
      this._addCategories(this._options.categories);
    } else {
      this._updateAllCategory();
    }
  }

  /**
   * Loads stickers from the given external URL
   * @param  {String} url
   * @return {Promise}
   */


  StickerManager.prototype.loadExternal = function loadExternal(url) {
    var _this = this;

    var loader = new _jsonLoader2.default(url);
    return loader.load().then(function (result) {
      _this._addCategories(result.categories);
    });
  };

  /**
   * Initializes the categories
   * @param {Object[]} categories
   * @private
   */


  StickerManager.prototype._addCategories = function _addCategories(categories) {
    var _this2 = this;

    var replaceCategories = this._options.replaceCategories;


    if (replaceCategories) {
      this._categories = categories.slice(0);
    } else {
      this._categories = _globals.Utils.mergeCategories(this._categories, categories, 'stickers');
    }

    // Build cat id => category hash
    this._categoriesById = {};
    this._categories.forEach(function (c) {
      _this2._categoriesById[c.name] = c;
    });

    this._updateAllCategory();
  };

  /**
   * Updates the `all` category which contains all stickers
   * @private
   */


  StickerManager.prototype._updateAllCategory = function _updateAllCategory() {
    this._allCategory = {
      name: 'all',
      label: this._options.allCategoryLabel,
      stickers: this._categories.map(function (c) {
        return c.stickers;
      }).reduce(function (a, b) {
        return a.concat(b);
      }, [])
    };
    this._categoriesById.all = this._allCategory;
  };

  /**
   * Returns the stickers for the category with the given name
   * @param  {String} categoryName
   * @return {Object[]}
   */


  StickerManager.prototype.getStickersForCategory = function getStickersForCategory(categoryName) {
    if (!this._categoriesById[categoryName]) {
      throw new Error('Unknown sticker category \'' + categoryName + '\'');
    }
    return this._categoriesById[categoryName].stickers;
  };

  /**
   * Returns the categories
   * @return {Object[]}
   */


  StickerManager.prototype.getCategories = function getCategories() {
    return [this._allCategory].concat(this._categories);
  };

  /**
   * Returns the category object for the given id
   * @param  {String} id
   * @return {Object}
   */


  StickerManager.prototype.getCategory = function getCategory(id) {
    return this._categoriesById[id];
  };

  return StickerManager;
}();

exports.default = StickerManager;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = __webpack_require__(213);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _typeof2 = __webpack_require__(33);

var _typeof3 = _interopRequireDefault(_typeof2);

var _react = __webpack_require__(60);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(88);

var _classnames2 = _interopRequireDefault(_classnames);

var _bem = __webpack_require__(67);

var _bem2 = _interopRequireDefault(_bem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function flatten(arr) {
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] instanceof Array) {
      result = result.concat(flatten(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
} /*
   * This file is part of PhotoEditorSDK.
   *
   * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, without
   * modification, are permitted provided that the following license agreement
   * is approved and a legal/financial contract was signed by the user.
   * The license agreement can be found under following link:
   *
   * https://www.photoeditorsdk.com/LICENSE.txt
   */

var BEM_TYPES = {
  b: 'block',
  e: 'element',
  m: 'modifier'
};
var ReactBEM = {
  /**
   * Parses the given ReactBEM specifier and returns an array of
   * BEM information (type, name, pass)
   * @param  {string} specifier
   * @return {Array.<Object>}
   * @private
   */
  _parseBemSpecifier: function _parseBemSpecifier(specifier) {
    if (!specifier) return [];

    var parts = specifier.split(' ');
    var data = parts.map(function (part) {
      var match = part.match(/^(\$)?([bem]):(.*)$/i);
      if (!match) {
        throw new Error('Invalid BEM specifier: ' + part);
      }

      var pass = typeof match[1] !== 'undefined';
      var type = BEM_TYPES[match[2]];
      var name = match[3];
      return { type: type, name: name, pass: pass };
    });
    return data;
  },


  /**
   * Returns the BEM info for the given node
   * @param  {Object} node
   * @return {Object}
   * @private
   */
  _getBemInfoForNode: function _getBemInfoForNode(node) {
    var isBemNode = node.type === 'bem';
    var specifier = isBemNode ? node.props.specifier : node.props.bem;

    if (isBemNode && !specifier) {
      throw new Error('<bem> elements should always have a `specifier` property');
    }

    var data = this._parseBemSpecifier(specifier);

    // <bem> nodes pass all bem information to the children
    if (isBemNode) {
      data.forEach(function (obj) {
        obj.pass = true;
      });
    }

    return { data: data, isBemNode: isBemNode };
  },


  /**
   * Used in React.Component's `render` method
   *
   * @param  {String} type
   * @param  {Object} props
   * @param  {Array.<Object>} [...children]
   * @return {Object}
   */
  createElement: function createElement(type, props) {
    for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }

    props = props || {};
    children = children.filter(function (child) {
      return child !== null && typeof child !== 'undefined';
    });
    return { type: type, props: props, children: children };
  },


  /**
   * Checks whether we can apply a bem class to the given node
   * @param  {?}  node
   * @return {Boolean}
   * @private
   */
  _isNodeBEMable: function _isNodeBEMable(node) {
    return node !== null && (typeof node === 'undefined' ? 'undefined' : (0, _typeof3.default)(node)) === 'object' && !_react2.default.isValidElement(node);
  },


  /**
   * Sets the BEM class for the given node. Iterates through its
   * children and sets their BEM class as well
   * @param  {Object} node
   * @return {Object}
   * @private
   */
  _applyBEMClasses: function _applyBEMClasses(node) {
    var _this = this;

    if (!this._isNodeBEMable(node)) return node;

    var classNames = node.props.className ? [node.props.className] : [];

    // Prepare BEM objects
    var bemInfo = this._getBemInfoForNode(node);
    var ownBemObject = node.props.__bemObject;
    var childrenBemObject = node.props.__bemObject;
    bemInfo.data.forEach(function (obj) {
      if (obj.type === 'block') {
        ownBemObject = _bem2.default.block(obj.name);
        if (obj.pass) {
          childrenBemObject = _bem2.default.block(obj.name);
        }
        classNames.push(ownBemObject.str);
      } else if (obj.type === 'element') {
        if (!ownBemObject) {
          throw new Error('Tried to create an element, but no parent block has been found.');
        }

        ownBemObject = ownBemObject.element(obj.name);
        if (obj.pass) {
          childrenBemObject = childrenBemObject.element(obj.name);
        }
        classNames.push(ownBemObject.str);
      } else if (obj.type === 'modifier') {
        if (!ownBemObject) {
          throw new Error('Tried to create a modifier, but no parent block has been found.');
        }

        if (obj.pass) {
          childrenBemObject = childrenBemObject.modifier(obj.name);
        }
        classNames.push(ownBemObject.modifier(obj.name).str);
      }
    });

    // Apply classname (if necessary)
    var className = (0, _classnames2.default)(classNames);
    if (className) {
      node.props.className = className;
    }

    node.children = flatten(node.children);

    // Pass `childrenBemObject` to child nodes
    node.children.forEach(function (child) {
      if (!_this._isNodeBEMable(child)) return;
      child.props.__bemObject = childrenBemObject;
    });

    // Apply BEM objects to children
    node.children = node.children.map(function (child) {
      return _this._applyBEMClasses(child);
    });

    node.children = flatten(node.children);

    // Remove unnecessary props
    delete node.props.__bemObject;
    delete node.props.bem;

    if (bemInfo.isBemNode) {
      if (node.children instanceof Array && node.children.length === 1) {
        node = node.children[0];
      } else {
        node = node.children;
      }
    }

    return node;
  },


  /**
   * Transforms the given ReactBEM element and its children into
   * actual ReactJS elements
   * @param  {Object} node
   * @return {React.Element}
   */
  _transformToReact: function _transformToReact(node) {
    var _this2 = this;

    if (!this._isNodeBEMable(node)) return node;

    node.children = node.children.map(function (child) {
      return _this2._transformToReact(child);
    });

    return _react2.default.createElement.apply(_react2.default, [node.type, node.props].concat((0, _toConsumableArray3.default)(node.children)));
  },


  /**
   * Transforms the given ReactBEM object and its children
   * @param  {Object} root
   * @return {React.Element}
   */
  transform: function transform(root) {
    root = this._applyBEMClasses(root);

    // Root node should be a single node, not an array. Returning the array
    // here will cause React to throw an error saying that this is a no-go
    /* istanbul ignore next */
    if (root instanceof Array) {
      return root;
    }

    root = this._transformToReact(root);
    return root;
  }
};

exports.default = ReactBEM;

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

var _filterManager = __webpack_require__(43);

var _filterManager2 = _interopRequireDefault(_filterManager);

var _stickerManager = __webpack_require__(70);

var _stickerManager2 = _interopRequireDefault(_stickerManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Deserializer = function () {
  function Deserializer(editor, data) {
    (0, _classCallCheck3.default)(this, Deserializer);

    this._editor = editor;
    this._data = data;

    this._filterManager = new _filterManager2.default(this._editor._options);
    this._stickerManager = new _stickerManager2.default(this._editor._options);
  }

  /**
   * Deserializes the given data
   * @return {Promise}
   */


  Deserializer.prototype.deserialize = function deserialize() {
    var _this = this;

    return this._validateVersion().then(function () {
      return _this._deserializeInputImage();
    }).then(function () {
      return _this._deserializeOperations();
    }).then(function () {
      return _this._editor.zoom.set('auto');
    });
  };

  /**
   * Validates the version
   * @return {Promise}
   */


  Deserializer.prototype._validateVersion = function _validateVersion() {
    if (this._data.version !== '1.0.0') {
      return Promise.reject(new Error('Invalid version ' + this._data.version + ', expected 1.0.0'));
    }
    return Promise.resolve();
  };

  /**
   * Deserializes the input image (if present)
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeInputImage = function _deserializeInputImage() {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      var _data$inputImage = _this2._data.inputImage,
          data = _data$inputImage.data,
          type = _data$inputImage.type;

      if (data && type) {
        var image = new window.Image();
        image.addEventListener('load', function () {
          _this2._editor.setImage(image);
          resolve();
        });
        image.src = 'data:' + type + ';base64,' + data;
      } else {
        resolve();
      }
    });
  };

  /**
   * Deserializes the operations
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeOperations = function _deserializeOperations() {
    var _this3 = this;

    var promises = this._data.operations.map(function (operation) {
      switch (operation.type) {
        case 'crop':
          return _this3._deserializeCropOperation(operation);
        case 'orientation':
          return _this3._deserializeOrientationOperation(operation);
        case 'filter':
          return _this3._deserializeFilterOperation(operation);
        case 'adjustments':
          return _this3._deserializeAdjustmentsOperation(operation);
        case 'sprite':
          return _this3._deserializeSpriteOperation(operation);
        case 'focus':
          return _this3._deserializeFocusOperation(operation);
      }
    });

    return Promise.all(promises);
  };

  /**
   * Deserializes the given crop operation
   * @param  {Object} operation
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeCropOperation = function _deserializeCropOperation(operation) {
    var options = operation.options;
    var scale = options.scale,
        rotation = options.rotation;

    var start = _globals.Vector2.fromObject(options.start);
    var end = _globals.Vector2.fromObject(options.end);

    // Normalize rotation
    if (rotation > Math.PI) {
      rotation -= Math.PI * 2;
    }

    this._editor.operations.getOrCreate('crop', {
      start: start, end: end, scale: scale, rotation: rotation
    });
    return Promise.resolve();
  };

  /**
   * Deserializes the given orientation operation
   * @param  {Object} operation
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeOrientationOperation = function _deserializeOrientationOperation(operation) {
    var options = operation.options;

    this._editor.operations.getOrCreate('orientation', options);
  };

  /**
   * Deserializes the given filter operation
   * @param  {Object} operation
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeFilterOperation = function _deserializeFilterOperation(operation) {
    var options = operation.options;


    var filters = this._filterManager.getFiltersForCategory('all');
    var FilterClass = void 0;
    for (var i = 0; i < filters.length; i++) {
      var Filter = filters[i];
      if (Filter.identifier === options.name) {
        FilterClass = Filter;
        break;
      }
    }

    if (!FilterClass) {
      throw new Error('Unknown filter \'' + options.name + '\'');
    }

    this._editor.operations.getOrCreate('filter', {
      filter: new FilterClass(),
      intensity: options.intensity
    });
  };

  /**
   * Deserializes the given adjustments operation
   * @param  {Object} operation
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeAdjustmentsOperation = function _deserializeAdjustmentsOperation(operation) {
    var AdjustmentsOperation = _globals.SDK.Operations.AdjustmentsOperation;
    var options = operation.options;

    var operationOptions = {};

    for (var key in options) {
      var value = options[key];
      var defaultValue = AdjustmentsOperation.prototype.availableOptions[key].default;
      operationOptions[key] = value + defaultValue;
    }

    this._editor.operations.getOrCreate('adjustments', operationOptions);
  };

  /**
   * Deserializes the given sprite operation
   * @param  {Object} operation
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeSpriteOperation = function _deserializeSpriteOperation(operation) {
    var _this4 = this;

    var options = operation.options;

    var spriteOperation = this._editor.operations.getOrCreate('sprite');
    var promises = options.sprites.map(function (sprite) {
      switch (sprite.type) {
        case 'sticker':
          return _this4._deserializeSticker(spriteOperation, sprite);
        case 'text':
          return _this4._deserializeText(spriteOperation, sprite);
        case 'brush':
          return _this4._deserializeBrush(spriteOperation, sprite);
      }
    }).filter(function (s) {
      return !!s;
    });
    return Promise.all(promises).then(function (sprites) {
      spriteOperation.setSprites(sprites);
    });
  };

  /**
   * Deserializes the given sticker for the given operation
   * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
   * @param  {Object} sprite
   * @return {PhotoEditorSDK.Operations.SpriteOperation.Sticker}
   * @private
   */


  Deserializer.prototype._deserializeSticker = function _deserializeSticker(operation, sprite) {
    var _this5 = this;

    var SpriteOperation = _globals.SDK.Operations.SpriteOperation;
    var options = sprite.options;

    var stickers = this._stickerManager.getStickersForCategory('all');

    var sticker = void 0;
    for (var i = 0; i < stickers.length; i++) {
      if (stickers[i].name === options.name) {
        sticker = stickers[i];
        continue;
      }
    }

    if (!sticker) {
      throw new Error('Unknown sticker \'' + options.name + '\'');
    }
    return new Promise(function (resolve, reject) {
      var image = new window.Image();
      image.addEventListener('load', function () {
        var adjustments = SpriteOperation.Sticker.prototype.availableOptions.adjustments.structure;
        var rotation = options.rotation,
            flipHorizontally = options.flipHorizontally,
            flipVertically = options.flipVertically;

        resolve(operation.createSticker({
          image: image,
          position: _globals.Vector2.fromObject(options.position),
          dimensions: _globals.Vector2.fromObject(options.dimensions),
          rotation: rotation,
          flipHorizontally: flipHorizontally,
          flipVertically: flipVertically,
          adjustments: {
            brightness: options.adjustments.brightness + adjustments.brightness.default,
            saturation: options.adjustments.saturation + adjustments.saturation.default,
            contrast: options.adjustments.contrast + adjustments.contrast.default
          }
        }));
      });
      image.crossOrigin = 'Anonymous';
      image.src = _this5._editor.getUI().getAssetPath(sticker.images.mediaBase.uri);
    });
  };

  /**
   * Deserializes the given text for the given operation
   * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
   * @param  {Object} text
   * @return {PhotoEditorSDK.Operations.SpriteOperation.Text}
   * @private
   */


  Deserializer.prototype._deserializeText = function _deserializeText(operation, text) {
    var options = text.options;
    var fontSize = options.fontSize,
        lineHeight = options.lineHeight,
        fontFamily = options.fontFamily,
        fontWeight = options.fontWeight,
        alignment = options.alignment,
        rotation = options.rotation,
        maxWidth = options.maxWidth,
        color = options.color,
        backgroundColor = options.backgroundColor;

    return Promise.resolve(operation.createText({
      fontSize: fontSize,
      lineHeight: lineHeight,
      fontFamily: fontFamily,
      fontWeight: fontWeight,
      alignment: alignment,
      rotation: rotation,
      maxWidth: maxWidth,
      text: options.text,
      color: _globals.Color.fromArray(color),
      backgroundColor: _globals.Color.fromArray(backgroundColor),
      position: _globals.Vector2.fromObject(options.position)
    }));
  };

  /**
   * Deserializes the given brush for the given operation
   * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
   * @param  {Object} brush
   * @return {PhotoEditorSDK.Operations.SpriteOperation.Brush}
   * @private
   */


  Deserializer.prototype._deserializeBrush = function _deserializeBrush(operation, brush) {
    var options = brush.options;
    var paths = options.paths;


    var brushObject = operation.createBrush();
    paths.forEach(function (path) {
      var color = path.color,
          size = path.size,
          points = path.points;

      var colorObject = new _globals.Color(color[0], color[1], color[2], color[3]);
      var pathObject = brushObject.createPath(size, 1, colorObject);
      points.forEach(function (point) {
        pathObject.addControlPoint(_globals.Vector2.fromObject(point));
      });
    });
    return Promise.resolve(brushObject);
  };

  /**
   * Deserializes the given focus operation
   * @param  {Object} operation
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeFocusOperation = function _deserializeFocusOperation(operation) {
    var options = operation.options.options;

    switch (operation.options.type) {
      case 'radial':
        {
          var position = options.position,
              radius = options.radius,
              gradientRadius = options.gradientRadius,
              blurRadius = options.blurRadius;

          this._editor.operations.getOrCreate('radial-focus', {
            position: _globals.Vector2.fromObject(position),
            radius: radius,
            gradientRadius: gradientRadius,
            blurRadius: blurRadius
          });
        }
        break;
      case 'linear':
        {
          var start = options.start,
              end = options.end,
              size = options.size,
              gradientSize = options.gradientSize,
              _blurRadius = options.blurRadius;

          this._editor.operations.getOrCreate('linear-focus', {
            start: _globals.Vector2.fromObject(start),
            end: _globals.Vector2.fromObject(end),
            size: size,
            gradientSize: gradientSize,
            blurRadius: _blurRadius
          });
        }
        break;
    }
  };

  /**
   * Returns the input dimensions for the given operation
   * @param  {PhotoEditorSDK.Operation} operation
   * @return {PhotoEditorSDK.Math.Vector2}
   * @private
   */


  Deserializer.prototype._getInputDimensionsForOperation = function _getInputDimensionsForOperation(operation) {
    var operationFound = false;
    var inputDimensions = this._editor.getInputDimensions();

    this._editor.operations.getStack().forEach(function (op) {
      if (op === operation) operationFound = true;
      if (operationFound) return;
      inputDimensions = op.getNewDimensions(inputDimensions);
    });

    return inputDimensions;
  };

  return Deserializer;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = Deserializer;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TWICE_PI = Math.PI * 2; /*
                             * This file is part of PhotoEditorSDK.
                             *
                             * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                             * All rights reserved.
                             *
                             * Redistribution and use in source and binary forms, without
                             * modification, are permitted provided that the following license agreement
                             * is approved and a legal/financial contract was signed by the user.
                             * The license agreement can be found under following link:
                             *
                             * https://www.photoeditorsdk.com/LICENSE.txt
                             */

var Serializer = function () {
  function Serializer(editor) {
    (0, _classCallCheck3.default)(this, Serializer);

    this._editor = editor;

    this._serializeOperations = this._serializeOperations.bind(this);
  }

  // -------------------------------------------------------------------------- SERIALIZATION

  /**
   * Serializes the editor state
   * @param {Object} options = {}
   * @return {Promise}
   */


  Serializer.prototype.serialize = function serialize() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._options = _globals.SDKUtils.defaults(options, {
      image: true
    });

    var data = {
      version: '1.0.0'
    };

    return this._serializeInputImage(data).then(this._serializeOperations);
  };

  /**
   * Serializes the input image as base64 and attaches it to `data`
   * @param  {Object} data
   * @return {Promise}
   * @private
   */


  Serializer.prototype._serializeInputImage = function _serializeInputImage(data) {
    var image = this._editor.getImage();

    if (!this._options.image) {
      data.inputImage = {
        width: image.width,
        height: image.height
      };
      return Promise.resolve(data);
    }

    var sdk = new _globals.SDK('webgl', { image: image });

    return sdk.export(_globals.RenderType.DATA_URL, _globals.ImageFormat.PNG).then(function (dataUrl) {
      var width = image.width,
          height = image.height;

      data.inputImage = {
        type: _globals.ImageFormat.PNG,
        data: dataUrl.replace(/^data:image\/(.*?);base64,/, ''),
        width: width,
        height: height
      };
      return data;
    });
  };

  /**
   * Serializes the operations and attaches them to `data`
   * @param  {Object} data
   * @return {Promise}
   * @private
   */


  Serializer.prototype._serializeOperations = function _serializeOperations(data) {
    var _this = this;

    var operations = [];
    var stack = this._editor.operations.getStack();
    stack.forEach(function (operation) {
      operations.push(_this._serializeOperation(operation));
    });
    data.operations = operations;
    return Promise.resolve(data);
  };

  /**
   * Serializes the given operation
   * @param  {PhotoEditorSDK.Operation} operation
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeOperation = function _serializeOperation(operation) {
    switch (operation.constructor.identifier) {
      case 'crop':
        return this._serializeCropOperation(operation);
      case 'orientation':
        return this._serializeOrientationOperation(operation);
      case 'filter':
        return this._serializeFilterOperation(operation);
      case 'adjustments':
        return this._serializeAdjustmentsOperation(operation);
      case 'sprite':
        return this._serializeSpriteOperation(operation);
      case 'radial-focus':
        return this._serializeRadialFocusOperation(operation);
      case 'linear-focus':
        return this._serializeLinearFocusOperation(operation);
      default:
        throw new Error('Unable to serialize operation of type ' + operation.constructor.identifier);
    }
  };

  /**
   * Serializes the given crop operation
   * @param  {PhotoEditorSDK.Operation.CropOperation} operation
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeCropOperation = function _serializeCropOperation(operation) {
    var options = operation.serializeOptions(['start', 'end', 'rotation', 'scale'], true);
    options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;
    return {
      type: 'crop',
      options: options
    };
  };

  /**
   * Serializes the given orientation operation
   * @param  {PhotoEditorSDK.Operation.OrientationOperation} operation
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeOrientationOperation = function _serializeOrientationOperation(operation) {
    return {
      type: 'orientation',
      options: operation.serializeOptions(['flipVertically', 'flipHorizontally', 'rotation'], true)
    };
  };

  /**
   * Serializes the given filter operation
   * @param  {PhotoEditorSDK.Operations.FilterOperation} operation
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeFilterOperation = function _serializeFilterOperation(operation) {
    return {
      type: 'filter',
      options: {
        intensity: operation.getIntensity(),
        name: operation.getFilter().constructor.identifier
      }
    };
  };

  /**
   * Serializes the given adjustments operation
   * @param  {PhotoEditorSDK.Operations.AdjustmentsOperation} operation
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeAdjustmentsOperation = function _serializeAdjustmentsOperation(operation) {
    var availableOptions = operation.availableOptions;

    var options = {};
    for (var optionName in availableOptions) {
      var option = availableOptions[optionName];
      var value = operation.getOption(optionName);
      if (value !== option.default) {
        options[optionName] = value - option.default; // scale to -1...1
      }
    }
    return {
      type: 'adjustments',
      options: options
    };
  };

  /**
   * Serializes the given sprite operation
   * @return {PhotoEditorSDK.Operations.SpriteOperation} operation
   * @private
   */


  Serializer.prototype._serializeSpriteOperation = function _serializeSpriteOperation(operation) {
    var _this2 = this;

    var sprites = operation.getSprites().map(function (sprite) {
      if (sprite instanceof operation.constructor.Sticker) {
        return _this2._serializeSticker(operation, sprite);
      } else if (sprite instanceof operation.constructor.Text) {
        return _this2._serializeText(operation, sprite);
      } else if (sprite instanceof operation.constructor.Brush) {
        return _this2._serializeBrush(operation, sprite);
      }
    });

    return {
      type: 'sprite',
      options: {
        sprites: sprites
      }
    };
  };

  /**
   * Serializes the given sticker
   * @param  {PhotoEditorSDK.Operation} operation
   * @param  {PhotoEditorSDK.Operations.SpriteOperation.Sticker} sprite
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeSticker = function _serializeSticker(operation, sprite) {
    var adjustments = sprite.getAdjustments();

    var options = sprite.serializeOptions(['name', 'position', 'dimensions', 'flipVertically', 'flipHorizontally', 'rotation'], true);
    options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;

    var adjustmentsOptions = adjustments.availableOptions;
    options.adjustments = {
      brightness: adjustments.getBrightness() - adjustmentsOptions.brightness.default,
      saturation: adjustments.getSaturation() - adjustmentsOptions.saturation.default,
      contrast: adjustments.getContrast() - adjustmentsOptions.contrast.default
    };

    return {
      type: 'sticker',
      options: options
    };
  };

  /**
   * Serializes the given text sprite
   * @param  {PhotoEditorSDK.Operation} operation
   * @param  {PhotoEditorSDK.Operations.SpriteOperation.Text} sprite
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeText = function _serializeText(operation, sprite) {
    var options = sprite.serializeOptions(['fontSize', 'lineHeight', 'fontFamily', 'fontWeight', 'alignment', 'color', 'backgroundColor', 'position', 'rotation', 'text', 'maxWidth'], true);
    options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;

    return {
      type: 'text',
      options: options
    };
  };

  /**
   * Serializes the given brush sprite
   * @param  {PhotoEditorSDK.Operation} operation
   * @param  {PhotoEditorSDK.Operations.SpriteOperation.Brush} sprite
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeBrush = function _serializeBrush(operation, sprite) {
    var _this3 = this;

    return {
      type: 'brush',
      options: {
        paths: sprite.getPaths().map(function (path) {
          return _this3._serializePath(path);
        })
      }
    };
  };

  /**
   * Serializes the given path
   * @param  {PhotoEditorSDK.Operations.SpriteOperation.Brush.Path} path
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializePath = function _serializePath(path) {
    var options = path.serializeOptions(['color', 'thickness'], true);

    options.size = options.thickness;
    delete options.thickness;

    options.points = path.getControlPoints().map(function (point) {
      return point.getPosition().toObject();
    });
    return options;
  };

  /**
   * Serializes the given radial focus operation
   * @param  {PhotoEditorSDK.Operations.RadialFocusOperation} operation
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeRadialFocusOperation = function _serializeRadialFocusOperation(operation) {
    return {
      type: 'focus',
      options: {
        type: 'radial',
        options: operation.serializeOptions(['position', 'radius', 'gradientRadius', 'blurRadius'], true)
      }
    };
  };

  /**
   * Serializes the given linear focus operation
   * @param  {PhotoEditorSDK.Operations.LinearFocusOperation} operation
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeLinearFocusOperation = function _serializeLinearFocusOperation(operation) {
    return {
      type: 'focus',
      options: {
        type: 'linear',
        options: operation.serializeOptions(['start', 'end', 'blurRadius', 'size', 'gradientSize'], true)
      }
    };
  };

  /**
   * Returns the input dimensions for the given operation
   * @param  {PhotoEditorSDK.Operation} operation
   * @return {PhotoEditorSDK.Math.Vector2}
   * @private
   */


  Serializer.prototype._getInputDimensionsForOperation = function _getInputDimensionsForOperation(operation) {
    var operationFound = false;
    var inputDimensions = this._editor.getInputDimensions();

    this._editor.operations.getStack().forEach(function (op) {
      if (op === operation) operationFound = true;
      if (operationFound) return;
      inputDimensions = op.getNewDimensions(inputDimensions);
    });

    return inputDimensions;
  };

  return Serializer;
}();

exports.default = Serializer;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var maxLogLevel = 'warn';

var LEVELS = [{ type: 'trace', background: '#EEEEEE', color: '#AAAAAA' }, { type: 'info', background: '#BDE5F8', color: '#00529B' }, { type: 'warn', background: '#FEEFB3', color: '#9F6000' }, { type: 'error', background: '#FFBABA', color: '#D8000C' }, { type: 'log', background: '#EEEEEE', color: '#1f4f6b' }];
var LEVEL_TYPES = LEVELS.map(function (l) {
  return l.type;
});

var Log = {};

Log.setLevel = function (_level) {
  maxLogLevel = _level;
};
Log.canLog = function (type) {
  if (maxLogLevel === null) return false;
  var currentLevelIndex = LEVEL_TYPES.indexOf(type);
  var maxLevelIndex = LEVEL_TYPES.indexOf(maxLogLevel);
  if (currentLevelIndex < maxLevelIndex) return false;
  return true;
};
Log.hasColorfulOutput = function () {
  return (!process || process && process.browser) && typeof navigator !== 'undefined' && navigator.userAgent.match(/Gecko|WebKit/i) && !navigator.userAgent.match(/Trident/);
};

Log.printError = function (e) {
  var lines = e.stack.split('\n');
  lines.forEach(function (line) {
    Log.error('Error', line);
  });
};

LEVELS.forEach(function (level) {
  var type = level.type,
      background = level.background,
      color = level.color;

  Log[type] = function (tag) {
    if (!Log.canLog(type)) return;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var output = args.map(function (a) {
      return typeof a === 'string' ? a : a.toString();
    }).join(' ');
    if (!Log.hasColorfulOutput()) {
      return console.log('PhotoEditorSDK | ' + tag + ' | ' + output);
    }
    console.log('%c  %c PhotoEditorSDK %c  %c ' + tag + ' %c  ' + output + '  %c  ', 'background: #43ADEB; line-height: 20px; padding: 4px 0', 'background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0', 'background: #43ADEB; line-height: 20px; padding: 4px 0', 'background: ' + background + '; color: ' + color + '; line-height: 20px; padding: 4px 0; font-weight: bold', 'background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0', 'background: #43ADEB; line-height: 20px; padding: 4px 0');
  };
});

exports.default = Log;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(91)))

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(219), __esModule: true };

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _defineProperty = __webpack_require__(75);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(44)
  , TAG = __webpack_require__(10)('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(26)
  , document = __webpack_require__(13).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(16) && !__webpack_require__(25)(function(){
  return Object.defineProperty(__webpack_require__(78)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(44);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var LIBRARY        = __webpack_require__(48)
  , $export        = __webpack_require__(17)
  , redefine       = __webpack_require__(85)
  , hide           = __webpack_require__(22)
  , has            = __webpack_require__(18)
  , Iterators      = __webpack_require__(23)
  , $iterCreate    = __webpack_require__(232)
  , setToStringTag = __webpack_require__(51)
  , getPrototypeOf = __webpack_require__(240)
  , ITERATOR       = __webpack_require__(10)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(34)
  , createDesc     = __webpack_require__(28)
  , toIObject      = __webpack_require__(19)
  , toPrimitive    = __webpack_require__(56)
  , has            = __webpack_require__(18)
  , IE8_DOM_DEFINE = __webpack_require__(79)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(16) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(84)
  , hiddenKeys = __webpack_require__(47).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

var has          = __webpack_require__(18)
  , toIObject    = __webpack_require__(19)
  , arrayIndexOf = __webpack_require__(225)(false)
  , IE_PROTO     = __webpack_require__(52)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(22);

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(54)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(77)
  , ITERATOR  = __webpack_require__(10)('iterator')
  , Iterators = __webpack_require__(23);
module.exports = __webpack_require__(9).getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(91)))

/***/ },
/* 90 */
/***/ function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ },
/* 91 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _loadingScreenComponent = __webpack_require__(158);

var _loadingScreenComponent2 = _interopRequireDefault(_loadingScreenComponent);

var _splashScreenComponent = __webpack_require__(169);

var _splashScreenComponent2 = _interopRequireDefault(_splashScreenComponent);

var _photoRollScreenComponent = __webpack_require__(163);

var _photoRollScreenComponent2 = _interopRequireDefault(_photoRollScreenComponent);

var _webcamScreenComponent = __webpack_require__(173);

var _webcamScreenComponent2 = _interopRequireDefault(_webcamScreenComponent);

var _editorScreenComponent = __webpack_require__(157);

var _editorScreenComponent2 = _interopRequireDefault(_editorScreenComponent);

var _screenComponent = __webpack_require__(21);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _modalContainerComponent = __webpack_require__(151);

var _modalContainerComponent2 = _interopRequireDefault(_modalContainerComponent);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AppComponent = function (_React$Component) {
  (0, _inherits3.default)(AppComponent, _React$Component);

  function AppComponent() {
    (0, _classCallCheck3.default)(this, AppComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this._screens = {
      loading: _loadingScreenComponent2.default,
      splash: _splashScreenComponent2.default,
      photoRoll: _photoRollScreenComponent2.default,
      webcam: _webcamScreenComponent2.default,
      editor: _editorScreenComponent2.default,
      empty: _screenComponent2.default
    };

    var initialScreen = void 0;
    if (_this.props.options.preloader) {
      initialScreen = 'loading';
    }

    _this._screenAfterLoading;
    if (_this.props.options.editor.image) {
      _this._screenAfterLoading = 'editor';
    } else {
      _this._screenAfterLoading = 'splash';
    }

    if (!initialScreen) {
      initialScreen = _this._screenAfterLoading;
    }

    _this._previousScreensStack = [];
    _this.state = {
      activeScreen: _this._screens[initialScreen],
      activeScreenName: initialScreen,
      screens: (0, _defineProperty3.default)({}, initialScreen, _this._screens[initialScreen])
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Checks if the app has a previous screen on the stack
   * @return {Boolean}
   */


  AppComponent.prototype.hasPreviousScreen = function hasPreviousScreen() {
    return !!this._previousScreensStack.length;
  };

  /**
   * Returns the previous screen
   * @return {Screen}
   */


  AppComponent.prototype.getPreviousScreen = function getPreviousScreen() {
    var stack = this._previousScreensStack;
    return stack[stack.length - 1];
  };

  /**
   * Switches to the screen with the given name
   * @param  {String} name
   */


  AppComponent.prototype.switchToScreen = function switchToScreen(name) {
    var _this2 = this;

    var Screen = null;
    if (name === 'back') {
      Screen = this._previousScreensStack.pop();
      if (!Screen) {
        throw new Error('Unable to switch to previous screen - no previous screen found.');
      }
    } else {
      if (name === 'post-loading') name = this._screenAfterLoading;

      Screen = this._screens[name];
      if (!Screen) {
        throw new Error('Unknown screen `' + name + '`');
      }

      this._previousScreensStack.push(this.state.activeScreen);
    }

    if (!this.state.screens[name]) {
      this.state.screens[name] = Screen;
    }

    // Retain editor component
    if (this.state.activeScreenName !== 'editor') {
      delete this.state.screens[this.state.activeScreenName];
    }

    return new _globals.Promise(function (resolve) {
      _this2.setState({ activeScreen: Screen, activeScreenName: name }, function () {
        resolve();
      });
    });
  };

  /**
   * Gets called when an image is ready for editing
   * @param {Image} image
   * @param {Boolean} resetEditor
   */


  AppComponent.prototype.setImage = function setImage(image, resetEditor) {
    var _this3 = this;

    var options = this.props.options;

    options.editor.image = image;

    var firstEditorLaunch = !this.refs.editorScreen;
    this.switchToScreen('editor').then(function () {
      if (!firstEditorLaunch) {
        _this3.refs.editorScreen.setImage(image, resetEditor);
      }
    });
  };

  /**
   * Exports an image
   * @param {Boolean} download = false
   * @return {Promise}
   */


  AppComponent.prototype.export = function _export() {
    if (this.state.activeScreen !== this._screens.editor) {
      return _globals.Promise.reject(new Error('Unable to export: Active screen is not the editor screen.'));
    }

    if (this.state.screens.editor) {
      var _refs$editorScreen;

      return (_refs$editorScreen = this.refs.editorScreen).export.apply(_refs$editorScreen, arguments);
    }
  };

  /**
   * Returns the editor
   * @return {PhotoEditorSDK.UI.ReactUI.Editor}
   */


  AppComponent.prototype.getEditor = function getEditor() {
    if (this.state.activeScreen !== this._screens.editor) {
      return _globals.Promise.reject(new Error('Unable to get editor: Active screen is not the editor screen.'));
    }

    if (this.state.screens.editor) {
      return this.refs.editorScreen.getEditor();
    }
  };

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  AppComponent.prototype.serialize = function serialize() {
    var _refs$editorScreen2;

    if (!this.state.screens.editor) {
      return _globals.Promise.reject(new Error('Editor screen unavailable'));
    }
    return (_refs$editorScreen2 = this.refs.editorScreen).serialize.apply(_refs$editorScreen2, arguments);
  };

  /**
   * Deserializes the given data
   * @param  {Object} data
   * @return {Promise}
   */


  AppComponent.prototype.deserialize = function deserialize(data) {
    if (!this.state.screens.editor) {
      return _globals.Promise.reject(new Error('Editor screen unavailable'));
    }
    return this.refs.editorScreen.deserialize(data);
  };

  /**
   * Returns the context passed to all children
   * @return {Object}
   */


  AppComponent.prototype.getChildContext = function getChildContext() {
    return {
      ui: this.props.ui,
      options: this.props.options,
      mediator: this.props.mediator
    };
  };

  /**
   * Renders the existing screens
   * @return {ScreenComponent[]}
   * @private
   */


  AppComponent.prototype._renderScreens = function _renderScreens() {
    var renderedScreens = [];

    for (var name in this.state.screens) {
      var Screen = this.state.screens[name];
      var visible = this.state.activeScreen === Screen;
      renderedScreens.push(_globals.ReactBEM.createElement(Screen, { ref: name + 'Screen', app: this, visible: visible }));
    }

    return renderedScreens;
  };

  /**
   * Renders this component
   * @return {React.Component}
   */


  AppComponent.prototype.render = function render() {
    return _globals.ReactBEM.transform(_globals.ReactBEM.createElement(
      'div',
      { bem: 'b:editor' },
      _globals.ReactBEM.createElement(_modalContainerComponent2.default, {
        modalManager: _modalManager2.default.instance }),
      this._renderScreens()
    ));
  };

  return AppComponent;
}(_globals.React.Component); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = AppComponent;


AppComponent.childContextTypes = {
  ui: _globals.React.PropTypes.object.isRequired,
  mediator: _globals.React.PropTypes.object.isRequired,
  options: _globals.React.PropTypes.object.isRequired
};

AppComponent.propTypes = {
  ui: _globals.React.PropTypes.object.isRequired,
  mediator: _globals.React.PropTypes.object.isRequired,
  options: _globals.React.PropTypes.object.isRequired
};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _google = __webpack_require__(185);

var _google2 = _interopRequireDefault(_google);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FontLoader = function () {
  function FontLoader(fonts) {
    (0, _classCallCheck3.default)(this, FontLoader);

    this._fonts = fonts;
    this._loadedFonts = [];
  }

  /**
   * Sets the fonts
   * @param {Font[]} fonts
   */


  FontLoader.prototype.setFonts = function setFonts(fonts) {
    this._fonts = fonts;
  };

  /**
   * Checks if the font loader needs to load something
   * @return {Boolean}
   */


  FontLoader.prototype.needsToLoad = function needsToLoad() {
    for (var i = 0; i < this._fonts.length; i++) {
      var provider = this._fonts[i].getProvider();
      if (!provider) continue;
      return true;
    }
  };

  /**
   * Returns a string identifier for the given font
   * @param  {Font} font
   * @return {String}
   * @private
   */


  FontLoader.prototype._getFontIdentifier = function _getFontIdentifier(font) {
    return font.getName() + '-' + font.getFontWeight() + '-' + font.getFontFamily() + '-' + font.getFontStyle();
  };

  /**
   * Checks if the given font has already been loaded
   * @param  {Font} font
   */


  FontLoader.prototype.fontLoaded = function fontLoaded(font) {
    var identifier = this._getFontIdentifier(font);
    return this._loadedFonts.indexOf(identifier) !== -1;
  };

  /**
   * Sets the given font to loaded
   * @param {Font} font
   */


  FontLoader.prototype.setFontLoaded = function setFontLoaded(font) {
    if (!this.fontLoaded(font)) {
      var identifier = this._getFontIdentifier(font);
      this._loadedFonts.push(identifier);
    }
  };

  /**
   * Loads the given fonts
   * @param  {Object[]} fonts
   */


  FontLoader.prototype.load = function load() {
    var _this = this;

    var fonts = this._fonts.slice();
    var loaders = {
      google: new _google2.default()
    };

    fonts.filter(function (font) {
      return !_this.fontLoaded(font);
    }).forEach(function (font) {
      var provider = font.getProvider();
      if (!provider) return;

      var loader = loaders[provider];
      loader.add(font);
    });

    var promises = [];
    for (var name in loaders) {
      promises.push(loaders[name].load());
    }
    return Promise.all(promises).then(function () {
      fonts.forEach(function (font) {
        _this.setFontLoaded(font);
      });
    });
  };

  return FontLoader;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */


exports.default = FontLoader;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _provider = __webpack_require__(193);

Object.defineProperty(exports, 'Provider', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_provider).default;
  }
});

var _library = __webpack_require__(191);

Object.defineProperty(exports, 'Library', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_library).default;
  }
});

var _searchSuggestion = __webpack_require__(194);

Object.defineProperty(exports, 'SearchSuggestion', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_searchSuggestion).default;
  }
});

var _photo = __webpack_require__(192);

Object.defineProperty(exports, 'Photo', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_photo).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 95 */
/***/ function(module, exports) {

module.exports = {
	"controls": {
		"overview": {
			"filters": "Filter",
			"adjustments": "Korrekturen",
			"crop": "Zuschneiden",
			"blur": "Weichzeichnen",
			"frame": "Rahmen",
			"sticker": "Sticker",
			"text": "Text",
			"brush": "Malen",
			"selective-blur": "Sel. Unschärfe"
		},
		"text": {
			"foreground": "Vordergrund",
			"background": "Hintergrund",
			"size": "Größe",
			"font": "Schriftart",
			"alignment": "Ausrichtung",
			"takeToFront": "Nach oben"
		},
		"adjustments": {
			"brightness": "Helligkeit",
			"contrast": "Kontrast",
			"saturation": "Sättigung",
			"gamma": "Gamma",
			"exposure": "Belichtung",
			"shadows": "Schatten",
			"highlights": "Lichter",
			"clarity": "Klarheit"
		},
		"crop": {
			"none": "Original",
			"custom": "Manuell",
			"square": "Quadratisch",
			"4-3": "4:3",
			"16-9": "16:9",
			"social": "Social Media",
			"fb-ad": "Facebook Ad",
			"fb-post": "Facebook Post",
			"fb-cover": "Facebook Cover",
			"rotation": "Drehung"
		},
		"focus": {
			"none": "Original",
			"radial": "Kreisförmig",
			"linear": "Linear",
			"blurRadius": "Radius"
		},
		"selectiveBlur": {
			"blurRadius": "Radius",
			"thickness": "Dicke"
		},
		"filters": {
			"intensity": "Intensität",
			"categories": {
				"all": "Alle",
				"retro": "Retro",
				"bw": "Schwarz & Weiß",
				"summer": "Sommer",
				"winter": "Winter",
				"special": "Spezial"
			}
		},
		"sticker": {
			"brightness": "Helligkeit",
			"contrast": "Kontrast",
			"saturation": "Sättigung",
			"blur": "Weichzeichnen",
			"flip": "Spiegeln",
			"flip-v": "Spiegeln (V)",
			"flip-h": "Spiegeln (H)",
			"takeToFront": "Nach oben",
			"categories": {
				"all": "Alle"
			}
		},
		"brush": {
			"thickness": "Dicke",
			"color": "Farbe"
		},
		"frame": {
			"noFrame": "Kein Rahmen",
			"scale": "Größe"
		}
	},
	"webcam": {
		"headline": "Mache ein Foto!"
	},
	"editor": {
		"headline": "Foto editieren",
		"new": "Neu",
		"backgroundImage": "Hintergrundbild",
		"undo": "Rückgängig",
		"export": "Speichern"
	},
	"splash": {
		"upload": {
			"button": "Lade ein Foto hoch",
			"description": "Klicke hier, um ein Foto von deinem Rechner hochzuladen oder lade es per Drag-and-Drop hoch"
		},
		"webcam": {
			"headline": "Webcam",
			"description": "Klicke hier, um ein Foto mit deiner Webcam zu machen"
		},
		"photoRoll": {
			"headline": "Kostenloses Bildmaterial",
			"description": "Suche dir eines von tausenden Stock Photos aus."
		}
	},
	"photoRoll": {
		"search": {
			"placeholder": "Nach Fotos suchen",
			"noSearchResults": "Entschuldigung, aber wir konnten für <strong>\"${query}\"</strong> leider keine Ergebnisse finden.",
			"results": {
				"headline": "Suchergebnisse für \"${query}\""
			}
		}
	},
	"generic": {
		"back": "Zurück",
		"cancel": "Abbrechen",
		"color": "Farbe"
	},
	"loading": {
		"resizing": "Bild wird bearbeitet...",
		"exporting": "Exportiere...",
		"loading": "Lade..."
	},
	"warnings": {
		"imageResized_maxMegaPixels": {
			"title": "Bild verkleinert",
			"text": "Da dein Bild die maximale Größe von ${maxMegaPixels} Megapixeln überschreitet, wurde es auf ${width}x${height} Pixel verkleinert."
		},
		"imageResized_maxDimensions": {
			"title": "Bild verkleinert",
			"text": "Aufgrund von Hardware-Beschränkungen wurde das Bild auf ${width}x${height} Pixel verkleinert."
		}
	},
	"errors": {
		"imageLoadFail": {
			"title": "Bild konnte nicht geladen werden",
			"text": "Beim Laden des Bildes unter ${path} ist ein Fehler aufgetreten."
		},
		"webcamUnavailable": {
			"title": "Webcam nicht verfügbar",
			"text": "Webcam-Bild kann nicht dargestellt werden. (Fehler: ${error})"
		},
		"webcamNotSupported": {
			"title": "Webcam nicht unterstützt",
			"text": "Dein Browser unterstützt das Webcam-Feature leider noch nicht."
		},
		"renderingError": {
			"title": "Rendering-Fehler",
			"text": "Beim Rendern des Bildes ist ein Fehler aufgetreten."
		},
		"context_lost": {
			"title": "Es ist ein Fehler aufgetreten",
			"text": "Dein Browser hat zu lange gebraucht, um das Bild zu generieren. Bitte versuche es noch einmal."
		},
		"context_lost_limit": {
			"title": "Es ist ein Fehler aufgetreten",
			"text": "Bild-Generierung ist mehrmals fehlgeschlagen."
		},
		"loadingStickersFailed": {
			"title": "Laden der Sticker fehlgeschlagen"
		},
		"loadingFontsFailed": {
			"title": "Laden der Schriftarten fehlgeschlagen",
			"text": "Einige Schriftarten sind möglicherweise nicht verfügbar."
		},
		"photoRollLoadFail": {
			"title": "Laden der Photo Roll fehlgeschlagen",
			"text": "Die Photo Roll konnte nicht geladen werden: ${error}"
		},
		"title": "Es ist ein Fehler aufgetreten"
	}
};

/***/ },
/* 96 */
/***/ function(module, exports) {

module.exports = {
	"controls": {
		"overview": {
			"filters": "Filters",
			"adjustments": "Adjust",
			"crop": "Crop",
			"focus": "Focus",
			"frame": "Frame",
			"sticker": "Sticker",
			"text": "Text",
			"brush": "Brush",
			"selective-blur": "Selective Blur"
		},
		"text": {
			"foreground": "Foreground",
			"background": "Background",
			"size": "Size",
			"font": "Font",
			"alignment": "Alignment",
			"takeToFront": "To Front"
		},
		"adjustments": {
			"brightness": "Brightness",
			"contrast": "Contrast",
			"saturation": "Saturation",
			"exposure": "Exposure",
			"gamma": "Gamma",
			"shadows": "Shadows",
			"highlights": "Highlights",
			"clarity": "Clarity"
		},
		"crop": {
			"none": "Original",
			"custom": "Custom",
			"square": "Square",
			"4-3": "4:3",
			"16-9": "16:9",
			"social": "Social Media",
			"fb-ad": "Facebook Ad",
			"fb-post": "Facebook Post",
			"fb-cover": "Facebook Cover",
			"rotation": "Rotation"
		},
		"focus": {
			"none": "None",
			"radial": "Radial",
			"linear": "Linear",
			"blurRadius": "Blur radius"
		},
		"selectiveBlur": {
			"blurRadius": "Blur radius",
			"thickness": "Thickness"
		},
		"filters": {
			"intensity": "Intensity",
			"categories": {
				"all": "All",
				"retro": "Retro",
				"bw": "Black & White",
				"summer": "Summer",
				"winter": "Winter",
				"special": "Special"
			}
		},
		"sticker": {
			"brightness": "Brightness",
			"contrast": "Contrast",
			"saturation": "Saturation",
			"blur": "Blur",
			"flip": "Flip",
			"flip-v": "Flip (V)",
			"flip-h": "Flip (H)",
			"takeToFront": "To Front",
			"categories": {
				"all": "All"
			}
		},
		"brush": {
			"thickness": "Thickness",
			"color": "Color"
		},
		"frame": {
			"noFrame": "No Frame",
			"scale": "Scale"
		}
	},
	"webcam": {
		"headline": "Take a photo!"
	},
	"editor": {
		"headline": "Edit Photo",
		"new": "New",
		"backgroundImage": "Background Image",
		"undo": "Undo",
		"export": "Export"
	},
	"splash": {
		"upload": {
			"button": "Upload your image",
			"description": "Upload a picture from your library or just drag and drop"
		},
		"webcam": {
			"headline": "Webcam",
			"description": "Take a picture with your webcam or phone"
		},
		"photoRoll": {
			"headline": "Free stock footage",
			"description": "Select from thousands of Free Stock Photos"
		}
	},
	"photoRoll": {
		"search": {
			"placeholder": "Search for photos",
			"noSearchResults": "Sorry, but we couldn't find any photos for <strong>\"${query}\"</strong>.",
			"results": {
				"headline": "Search results for \"${query}\""
			}
		}
	},
	"generic": {
		"back": "Back",
		"cancel": "Cancel",
		"color": "Color"
	},
	"loading": {
		"resizing": "Resizing...",
		"exporting": "Exporting...",
		"loading": "Loading..."
	},
	"warnings": {
		"imageResized_maxMegaPixels": {
			"title": "Image resized",
			"text": "Your image exceeds the maximum size of ${maxMegaPixels} megapixels and has therefore been resized to ${width}x${height} pixels."
		},
		"imageResized_maxDimensions": {
			"title": "Image resized",
			"text": "Due to hardware limitations your image has been resized to ${width}x${height} pixels."
		}
	},
	"errors": {
		"imageLoadFail": {
			"title": "Failed to load image",
			"text": "Failed to load the image at ${path}"
		},
		"webcamUnavailable": {
			"title": "Webcam unavailable",
			"text": "Unable to display webcam image (Error: ${error})"
		},
		"webcamNotSupported": {
			"title": "Webcam not supported",
			"text": "The webcam feature is not supported by your browser."
		},
		"renderingError": {
			"title": "Error while rendering",
			"text": "An error has occurred while rendering the image."
		},
		"context_lost": {
			"title": "An error has occurred",
			"text": "Your browser took too long to render the image. Please try applying less operations."
		},
		"context_lost_limit": {
			"title": "An error has occurred",
			"text": "Your browser failed multiple times while rendering the image."
		},
		"loadingStickersFailed": {
			"title": "Failed to load stickers"
		},
		"loadingFontsFailed": {
			"title": "Failed to load fonts",
			"text": "Some fonts might not be available."
		},
		"photoRollLoadFail": {
			"title": "Failed to load Photo Roll",
			"text": "Failed to load photos for the photo roll: ${error}"
		},
		"title": "An error has occurred"
	}
};

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BackButtonComponent = function (_BaseComponent) {
  (0, _inherits3.default)(BackButtonComponent, _BaseComponent);

  function BackButtonComponent() {
    (0, _classCallCheck3.default)(this, BackButtonComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  BackButtonComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:controls' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:largeButton' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:largeButton', onClick: this.props.onClick },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/back.png', true) })
        )
      )
    );
  };

  return BackButtonComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = BackButtonComponent;


BackButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(60);

var _react2 = _interopRequireDefault(_react);

var _reactBem = __webpack_require__(71);

var _reactBem2 = _interopRequireDefault(_reactBem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BaseComponent = function (_React$Component) {
  (0, _inherits3.default)(BaseComponent, _React$Component);

  function BaseComponent() {
    (0, _classCallCheck3.default)(this, BaseComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this._events = {};
    _this._needsStyleFixes = false;

    _this._bindAll('_onSharedStateUpdate', 'fixStyles');
    return _this;
  }

  // -------------------------------------------------------------------------- WORKAROUNDS

  /**
   * A method that is called whenever styles need to be fixed by the JavaScript.
   * This needs to be done thanks to older Internet Explorer browsers which have
   * a bunch of CSS bugs.
   */


  BaseComponent.prototype.fixStyles = function fixStyles() {};

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  BaseComponent.prototype.componentDidMount = function componentDidMount() {
    this._bindEvents();
    if (this.props.sharedState) {
      this.props.sharedState.on('update', this._onSharedStateUpdate);
    }

    if (this._needsStyleFixes) {
      this.fixStyles();
      if (this.context.options.responsive) {
        window.addEventListener('resize', this.fixStyles);
      }
    }
  };

  /**
   * Gets called before this component is unmounted
   */


  BaseComponent.prototype.componentWillUnmount = function componentWillUnmount() {
    this._unbindEvents();

    if (this.props.sharedState) {
      this.props.sharedState.off('update', this._onSharedStateUpdate);
    }

    if (this.context.options.responsive && this._needsStyleFixes) {
      window.removeEventListener('resize', this.fixStyles);
    }
  };

  /**
   * Gets called when this component is about to receive new properties
   * @param  {Object} nextProps
   */


  BaseComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.sharedState) {
      if (this.props.sharedState) {
        this.props.sharedState.off('update', this._onSharedStateUpdate);
      }
      nextProps.sharedState.on('update', this._onSharedStateUpdate);
    }
  };

  // -------------------------------------------------------------------------- HELPER FUNCTIONS

  /**
   * Binds the instance methods with the given names
   * to the class context
   * @param  {Array.<String>} ...fnNames
   * @protected
   */


  BaseComponent.prototype._bindAll = function _bindAll() {
    var _this2 = this;

    for (var _len2 = arguments.length, fnNames = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      fnNames[_key2] = arguments[_key2];
    }

    fnNames.forEach(function (name) {
      if (typeof _this2[name] !== 'function') {
        throw new Error('_bindAll: ' + _this2.constructor.name + '.' + name + ' is not a function.');
      }
      _this2[name] = _this2[name].bind(_this2);
    });
  };

  /**
   * Returns the translation for `key`
   * @param  {String} key
   * @param  {Object} [interpolationOptions]
   * @return {String}
   */


  BaseComponent.prototype._t = function _t(key, interpolationOptions) {
    return this.context.ui.translate(key, interpolationOptions);
  };

  /**
   * A helper method for UI.helpers.assetPath
   * @param {?} ...args
   * @protected
   */


  BaseComponent.prototype._getAssetPath = function _getAssetPath() {
    var _context$ui;

    return (_context$ui = this.context.ui).getAssetPath.apply(_context$ui, arguments);
  };

  // -------------------------------------------------------------------------- SHARED STATE

  /**
   * Gets called when the shared state did change
   * @param  {Object} oldState
   * @param  {Object} newState
   * @private
   */


  BaseComponent.prototype._onSharedStateUpdate = function _onSharedStateUpdate(oldState, newState) {
    this.sharedStateDidChange(newState);

    if (this.shouldSharedComponentUpdate(oldState, newState)) {
      this.forceUpdate();
    }
  };

  /**
   * Checks if the component should change from the given state
   * @param  {Object} oldState
   * @param  {Object} newState
   * @return {Boolean}
   */


  BaseComponent.prototype.shouldSharedComponentUpdate = function shouldSharedComponentUpdate(oldState, newState) {
    return true;
  };

  /**
   * Gets called when the shared state did change
   * @param {Object} newState
   */


  BaseComponent.prototype.sharedStateDidChange = function sharedStateDidChange(newState) {};

  /**
   * Sets the given state on the shared state
   * @param {Object} state
   * @param {Boolean} update
   */


  BaseComponent.prototype.setSharedState = function setSharedState(state, update) {
    this.props.sharedState.set(state, update);
  };

  /**
   * Returns the shared state value for the given property
   * @param {String} prop
   * @return {*}
   */


  BaseComponent.prototype.getSharedState = function getSharedState(prop) {
    return this.props.sharedState.get(prop);
  };

  /**
   * Forces an update of the shared state
   */


  BaseComponent.prototype.forceSharedUpdate = function forceSharedUpdate() {
    this.props.sharedState.broadcastUpdate();
  };

  // -------------------------------------------------------------------------- EVENT HANDLING

  /**
   * Binds the events in _events
   * @protected
   */


  BaseComponent.prototype._bindEvents = function _bindEvents() {
    for (var eventName in this._events) {
      var handler = this._events[eventName];
      this.context.mediator.on(eventName, handler);
    }
  };

  /**
   * Unbinds the events in _events
   * @protected
   */


  BaseComponent.prototype._unbindEvents = function _unbindEvents() {
    for (var eventName in this._events) {
      var handler = this._events[eventName];
      this.context.mediator.off(eventName, handler);
    }
  };

  /**
   * Emits an event with the given event name and arguments through
   * the mediator
   * @param  {String} eventName
   * @param  {Array.<*>} ...args
   * @protected
   */


  BaseComponent.prototype._emitEvent = function _emitEvent(eventName) {
    var _context$mediator;

    for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    (_context$mediator = this.context.mediator).emit.apply(_context$mediator, [eventName].concat(args));
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this element
   * @return {ReactBEM.element}
   */


  BaseComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _reactBem2.default.createElement('div');
  };

  /**
   * Transforms the ReactBEM.element returned by `renderWithBEM` into
   * React.Element objects with proper class names
   * @return {React.Element}
   */


  BaseComponent.prototype.render = function render() {
    return _reactBem2.default.transform(this.renderWithBEM());
  };

  return BaseComponent;
}(_react2.default.Component);

exports.default = BaseComponent;


BaseComponent.contextTypes = {
  editor: _react2.default.PropTypes.object,
  ui: _react2.default.PropTypes.object,
  options: _react2.default.PropTypes.object,
  mediator: _react2.default.PropTypes.object,
  editorScreen: _react2.default.PropTypes.object
};

BaseComponent.propTypes = {
  sharedState: _react2.default.PropTypes.any
};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ButtonComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ButtonComponent, _BaseComponent);

  function ButtonComponent() {
    (0, _classCallCheck3.default)(this, ButtonComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  ButtonComponent.prototype.renderWithBEM = function renderWithBEM() {
    var bemSpecifier = 'b:button';
    if (this.props.uppercase) {
      bemSpecifier += ' m:uppercase';
    }

    return _globals.ReactBEM.createElement(
      'button',
      { bem: bemSpecifier, className: this.props.className, onClick: this.props.onClick },
      this.props.children
    );
  };

  return ButtonComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = ButtonComponent;


ButtonComponent.propTypes = {
  onClick: _globals.React.PropTypes.func,
  children: _globals.React.PropTypes.any.isRequired,
  className: _globals.React.PropTypes.string
};

ButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CategoryDropdownOverlayComponent = function (_BaseComponent) {
  (0, _inherits3.default)(CategoryDropdownOverlayComponent, _BaseComponent);

  function CategoryDropdownOverlayComponent() {
    (0, _classCallCheck3.default)(this, CategoryDropdownOverlayComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks on an item
   * @param  {Object} item
   * @private
   */
  CategoryDropdownOverlayComponent.prototype._onItemClick = function _onItemClick(item) {
    this.props.onChange && this.props.onChange(item);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the list items
   * @return {Array.<React.Element>}
   * @private
   */


  CategoryDropdownOverlayComponent.prototype._renderListItems = function _renderListItems() {
    var _this2 = this;

    return this.props.items.map(function (item) {
      var active = item.name === _this2.props.selectedItem.name;
      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: '$e:item',
          className: active ? ' is-active' : '',
          onClick: _this2._onItemClick.bind(_this2, item) },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: item.icon }),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label' },
          item.label
        )
      );
    });
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  CategoryDropdownOverlayComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:categoryDropdown $e:overlay' },
      _globals.ReactBEM.createElement(
        'ul',
        { bem: '$e:list' },
        this._renderListItems()
      )
    );
  };

  return CategoryDropdownOverlayComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = CategoryDropdownOverlayComponent;


CategoryDropdownOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var AlphaComponent = function (_BaseComponent) {
  (0, _inherits3.default)(AlphaComponent, _BaseComponent);

  function AlphaComponent() {
    (0, _classCallCheck3.default)(this, AlphaComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onKnobDrag', '_onKnobDragStart');

    _this._value = _this.props.initialValue.clone();
    _this._transparentPatternCanvas = _globals.Utils.createTransparentPatternCanvas();
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after this component has been mounted
   */


  AlphaComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);
    this._renderCanvas();
  };

  /**
   * Gets called when this component receives new props or state
   * @param  {Object} newProps
   * @return {Boolean}
   */


  AlphaComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(newProps) {
    var initialValue = newProps.initialValue;

    if (initialValue !== this._value) {
      this._value = initialValue.clone();
      this._renderCanvas();
      return true;
    }
    return false;
  };

  // -------------------------------------------------------------------------- DRAG EVENTS

  /**
   * Gets called when the user starts dragging the knob
   * @param  {Vector2} position
   * @param  {Event} e
   * @private
   */


  AlphaComponent.prototype._onKnobDragStart = function _onKnobDragStart(position, e) {
    if (e.target === this.refs.knob) {
      this._initialAlpha = this._value.a;
    } else {
      this._setAlphaFromPosition(position);
    }
  };

  /**
   * Gets called while the user drags the knob
   * @param  {Vector2} offset
   * @param  {Event} e
   * @private
   */


  AlphaComponent.prototype._onKnobDrag = function _onKnobDrag(offset, e) {
    var canvas = this.refs.canvas;
    var canvasWidth = canvas.offsetWidth;

    var alphaChange = offset.x / canvasWidth;
    this._setAlpha(this._initialAlpha + alphaChange);
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the style object for the knob
   * @return {Object}
   * @private
   */


  AlphaComponent.prototype._getKnobStyle = function _getKnobStyle() {
    return {
      left: (this._value.a * 100).toFixed(2) + '%',
      top: '50%'
    };
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Sets the alpha value of the color to the given one
   * @param {Number} a
   * @private
   */


  AlphaComponent.prototype._setAlpha = function _setAlpha(a) {
    this._value.a = a;
    this._value.a = Math.min(1, Math.max(0, this._value.a));
    this.forceUpdate();
    this.props.onChange && this.props.onChange(this._value);
  };

  /**
   * Sets the alpha from the given cursor position
   * @param {Vector2} position
   * @private
   */


  AlphaComponent.prototype._setAlphaFromPosition = function _setAlphaFromPosition(position) {
    var canvas = this.refs.canvas;
    this._initialAlpha = position.x / canvas.offsetWidth;
    this._setAlpha(this._initialAlpha);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the canvas with the current color
   * @private
   */


  AlphaComponent.prototype._renderCanvas = function _renderCanvas() {
    var canvas = this.refs.canvas;
    var context = canvas.getContext('2d');

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // Fill with pattern
    var pattern = context.createPattern(this._transparentPatternCanvas, 'repeat');
    context.fillStyle = pattern;
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Create gradient
    var gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
    var color = this._value.clone();
    color.a = 0;
    gradient.addColorStop(0, color.toRGBA());
    gradient.addColorStop(1, this._value.toHex());

    // Draw gradient
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas.width, canvas.height);
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  AlphaComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:colorPicker $e:alpha' },
      _globals.ReactBEM.createElement(
        _draggableComponent2.default,
        {
          onStart: this._onKnobDragStart,
          onDrag: this._onKnobDrag },
        _globals.ReactBEM.createElement(
          'div',
          null,
          _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' }),
          _globals.ReactBEM.createElement('div', {
            bem: 'e:knob $b:knob m:transparent',
            ref: 'knob',
            style: this._getKnobStyle() })
        )
      )
    );
  };

  return AlphaComponent;
}(_globals.BaseComponent);

exports.default = AlphaComponent;


AlphaComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var HueComponent = function (_BaseComponent) {
  (0, _inherits3.default)(HueComponent, _BaseComponent);

  function HueComponent() {
    (0, _classCallCheck3.default)(this, HueComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onKnobDrag', '_onKnobDragStart');

    _this._value = _this.props.initialValue.clone();
    var hsvArr = _this._value.toHSV();
    var h = hsvArr[0];
    var s = hsvArr[1];
    var v = hsvArr[2];
    _this._hsvColor = { h: h, s: s, v: v };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after this component has been mounted
   */


  HueComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);
    this._renderCanvas();
  };

  /**
   * Gets called when this component receives new props or state
   * @param  {Object} newProps
   * @return {Boolean}
   */


  HueComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(newProps) {
    var initialValue = newProps.initialValue;

    if (initialValue !== this._value) {
      this._value = initialValue.clone();
      var hsvArr = this._value.toHSV();
      var h = hsvArr[0];
      var s = hsvArr[1];
      var v = hsvArr[2];
      this._hsvColor = { h: h, s: s, v: v };
      this._renderCanvas();
      return true;
    }
    return false;
  };

  // -------------------------------------------------------------------------- DRAG EVENTS

  /**
   * Gets called when the user starts dragging the knob
   * @param  {Vector2} position
   * @param  {Event} e
   * @private
   */


  HueComponent.prototype._onKnobDragStart = function _onKnobDragStart(position, e) {
    if (e.target === this.refs.knob) {
      this._initialHue = this._hsvColor.h;
    } else {
      this._setValueFromPosition(position);
    }
  };

  /**
   * Gets called while the user drags the knob
   * @param  {Vector2} offset
   * @param  {Event} e
   * @private
   */


  HueComponent.prototype._onKnobDrag = function _onKnobDrag(offset, e) {
    var canvas = this.refs.canvas;

    var canvasHeight = canvas.offsetHeight;

    var hueChange = offset.y / canvasHeight;
    this._setHue(this._initialHue + hueChange);
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the style object for the knob
   * @return {Object}
   * @private
   */


  HueComponent.prototype._getKnobStyle = function _getKnobStyle() {
    return {
      left: '50%',
      top: (this._hsvColor.h * 100).toFixed(2) + '%'
    };
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Sets the hue value of the color to the given one
   * @param {Number} h
   * @private
   */


  HueComponent.prototype._setHue = function _setHue(h) {
    var _hsvColor = this._hsvColor,
        s = _hsvColor.s,
        v = _hsvColor.v;

    h = Math.min(1, Math.max(0, h));
    s = Math.max(0.01, Math.min(s, 0.99));
    v = Math.max(0.01, Math.min(v, 0.99));

    this._value = _globals.Color.fromHSV(h, s, v, this._value.a);
    this._hsvColor = { h: h, s: s, v: v };
    this.forceUpdate();
    this.props.onChange && this.props.onChange(this._value);
  };

  /**
   * Sets the value from the given cursor position
   * @param {Vector2} position
   * @private
   */


  HueComponent.prototype._setValueFromPosition = function _setValueFromPosition(position) {
    var canvas = this.refs.canvas;

    this._initialHue = position.y / canvas.offsetHeight;
    this._setHue(this._initialHue);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the hue colors to the canvas
   * @private
   */


  HueComponent.prototype._renderCanvas = function _renderCanvas() {
    var canvas = this.refs.canvas;

    var context = canvas.getContext('2d');

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    for (var y = 0; y < canvas.height; y++) {
      var ratio = y / canvas.height;
      var color = _globals.Color.fromHSV(ratio, 1, 1);

      context.strokeStyle = color.toRGBA();
      context.beginPath();
      context.moveTo(0, y);
      context.lineTo(canvas.width, y);
      context.stroke();
    }
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  HueComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:colorPicker $e:hue' },
      _globals.ReactBEM.createElement(
        _draggableComponent2.default,
        {
          onStart: this._onKnobDragStart,
          onDrag: this._onKnobDrag },
        _globals.ReactBEM.createElement(
          'div',
          null,
          _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' }),
          _globals.ReactBEM.createElement('div', {
            bem: 'e:knob $b:knob m:transparent',
            ref: 'knob',
            style: this._getKnobStyle() })
        )
      )
    );
  };

  return HueComponent;
}(_globals.BaseComponent);

exports.default = HueComponent;


HueComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _alphaComponent = __webpack_require__(101);

var _alphaComponent2 = _interopRequireDefault(_alphaComponent);

var _saturationComponent = __webpack_require__(104);

var _saturationComponent2 = _interopRequireDefault(_saturationComponent);

var _hueComponent = __webpack_require__(102);

var _hueComponent2 = _interopRequireDefault(_hueComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ColorPickerOverlayComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ColorPickerOverlayComponent, _BaseComponent);

  function ColorPickerOverlayComponent() {
    (0, _classCallCheck3.default)(this, ColorPickerOverlayComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._value = _this.props.initialValue.clone();
    var hsvArr = _this._value.toHSV();
    var h = hsvArr[0];
    var s = hsvArr[1];
    var v = hsvArr[2];
    _this._hsv = { h: h, s: s, v: v };

    _this._bindAll('_onElementClick', '_onColorChange', '_onDocumentClick');
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  ColorPickerOverlayComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);

    document.addEventListener('click', this._onDocumentClick);
  };

  /**
   * Gets called when this component is about to be unmounted
   */


  ColorPickerOverlayComponent.prototype.componentWillUnmount = function componentWillUnmount() {
    _BaseComponent.prototype.componentWillUnmount.call(this);

    document.removeEventListener('click', this._onDocumentClick);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks anywhere on the screen. If the click is outside
   * of the color picker and the color picker is visible, we hide this color picker.
   * @param  {Event} e
   * @private
   */


  ColorPickerOverlayComponent.prototype._onDocumentClick = function _onDocumentClick(e) {
    for (var element = e.target; element; element = element.parentNode) {
      if (element === this.refs.root) {
        return;
      }
    }
    this.props.onClose && this.props.onClose();
  };

  /**
   * Catches clicks on the element and makes sure that no click event is triggered
   * on the parent element
   * @param  {Event} e
   * @private
   */


  ColorPickerOverlayComponent.prototype._onElementClick = function _onElementClick(e) {
    e.stopPropagation();
  };

  /**
   * Gets called when the color changes
   * @param  {Color} color
   * @private
   */


  ColorPickerOverlayComponent.prototype._onColorChange = function _onColorChange(color) {
    this._value = color;
    this.props.onChange && this.props.onChange(color);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  ColorPickerOverlayComponent.prototype.renderWithBEM = function renderWithBEM() {
    var alphaComponent = void 0;
    if (this.props.alpha !== false) {
      alphaComponent = _globals.ReactBEM.createElement(_alphaComponent2.default, {
        initialValue: this._value,
        onChange: this._onColorChange
      });
    }

    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:colorPicker $e:overlay', onClick: this._onElementClick, ref: 'root' },
      alphaComponent,
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:bottom' },
        _globals.ReactBEM.createElement(_saturationComponent2.default, {
          initialValue: this._value,
          onChange: this._onColorChange
        }),
        _globals.ReactBEM.createElement(_hueComponent2.default, {
          initialValue: this._value,
          onChange: this._onColorChange
        })
      )
    );
  };

  return ColorPickerOverlayComponent;
}(_globals.BaseComponent);

exports.default = ColorPickerOverlayComponent;


ColorPickerOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SaturationComponent = function (_BaseComponent) {
  (0, _inherits3.default)(SaturationComponent, _BaseComponent);

  function SaturationComponent() {
    (0, _classCallCheck3.default)(this, SaturationComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onKnobDrag', '_onKnobDragStart');

    _this._value = _this.props.initialValue.clone();
    var hsvArr = _this._value.toHSV();
    var h = hsvArr[0];
    var s = hsvArr[1];
    var v = hsvArr[2];
    _this._hsvColor = { h: h, s: s, v: v };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after this component has been mounted
   */


  SaturationComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);
    this._renderCanvas();
  };

  /**
   * Gets called when this component receives new props or state
   * @param  {Object} newProps
   * @return {Boolean}
   */


  SaturationComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(newProps) {
    var initialValue = newProps.initialValue;

    if (initialValue !== this._value) {
      this._value = initialValue.clone();
      var hsvArr = this._value.toHSV();
      var h = hsvArr[0];
      var s = hsvArr[1];
      var v = hsvArr[2];
      this._hsvColor = { h: h, s: s, v: v };
      this._renderCanvas();
      return true;
    }
    return false;
  };

  // -------------------------------------------------------------------------- DRAG EVENTS

  /**
   * Gets called when the user starts dragging the knob
   * @param  {Vector} position
   * @param  {Event} e
   * @private
   */


  SaturationComponent.prototype._onKnobDragStart = function _onKnobDragStart(position, e) {
    if (e.target === this.refs.knob) {
      this._initialValue = this._hsvColor.v;
      this._initialSaturation = this._hsvColor.s;
    } else {
      this._setValuesFromPosition(position);
    }
  };

  /**
   * Gets called while the user drags the knob
   * @param  {Vector2} offset
   * @param  {Event} e
   * @private
   */


  SaturationComponent.prototype._onKnobDrag = function _onKnobDrag(offset, e) {
    var canvas = this.refs.canvas;

    var canvasWidth = canvas.offsetWidth;
    var canvasHeight = canvas.offsetHeight;

    var saturationChange = offset.x / canvasWidth;
    var valueChange = offset.y / canvasHeight * -1;

    var h = this._hsvColor.h;

    this._setHSV(h, this._initialSaturation + saturationChange, this._initialValue + valueChange);
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the style object for the knob
   * @return {Object}
   * @private
   */


  SaturationComponent.prototype._getKnobStyle = function _getKnobStyle() {
    var _hsvColor = this._hsvColor,
        s = _hsvColor.s,
        v = _hsvColor.v;


    return {
      left: (s * 100).toFixed(2) + '%',
      top: ((1 - v) * 100).toFixed(2) + '%'
    };
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Sets the HSV values of the color to the given values
   * @param {Number} h
   * @param {Number} s
   * @param {Number} v
   * @private
   */


  SaturationComponent.prototype._setHSV = function _setHSV(h, s, v) {
    s = Math.max(0.01, Math.min(s, 0.99));
    v = Math.max(0.01, Math.min(v, 0.99));
    this._value = _globals.Color.fromHSV(h, s, v, this._value.a);
    this._hsvColor = { h: h, s: s, v: v };

    this.forceUpdate();
    this.props.onChange && this.props.onChange(this._value);
  };

  /**
   * Sets the values from the given cursor position
   * @param {Vector2} position
   * @private
   */


  SaturationComponent.prototype._setValuesFromPosition = function _setValuesFromPosition(position) {
    var canvas = this.refs.canvas;

    this._initialSaturation = position.x / canvas.offsetWidth;
    this._initialValue = 1 - position.y / canvas.offsetHeight;

    var h = this._hsvColor.h;

    this._setHSV(h, this._initialSaturation, this._initialValue);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the current color to the canvas
   * @private
   */


  SaturationComponent.prototype._renderCanvas = function _renderCanvas() {
    var canvas = this.refs.canvas;

    var context = canvas.getContext('2d');

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);

    for (var y = 0; y < canvas.height; y++) {
      var value = (canvas.height - y) / canvas.height;
      for (var x = 0; x < canvas.width; x++) {
        var saturation = x / canvas.width;
        var color = _globals.Color.fromHSV(this._hsvColor.h, saturation, value);
        var r = color.r,
            g = color.g,
            b = color.b,
            a = color.a;


        var index = (y * canvas.width + x) * 4;

        imageData.data[index] = r * 255;
        imageData.data[index + 1] = g * 255;
        imageData.data[index + 2] = b * 255;
        imageData.data[index + 3] = a * 255;
      }
    }

    context.putImageData(imageData, 0, 0);
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  SaturationComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:colorPicker $e:saturation' },
      _globals.ReactBEM.createElement(
        _draggableComponent2.default,
        {
          onStart: this._onKnobDragStart,
          onDrag: this._onKnobDrag },
        _globals.ReactBEM.createElement(
          'div',
          null,
          _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' }),
          _globals.ReactBEM.createElement('div', {
            bem: 'e:knob $b:knob m:transparent',
            ref: 'knob',
            style: this._getKnobStyle() })
        )
      )
    );
  };

  return SaturationComponent;
}(_globals.BaseComponent);

exports.default = SaturationComponent;


SaturationComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _sliderOverlayComponent = __webpack_require__(12);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

var _miniSliderComponent = __webpack_require__(125);

var _miniSliderComponent2 = _interopRequireDefault(_miniSliderComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ITEMS = [{
  identifier: 'brightness',
  isAvailable: function isAvailable(editor) {
    return editor.isToolEnabled('brightness');
  },
  minValue: -1,
  midValue: 0,
  maxValue: 1
}, {
  identifier: 'saturation',
  isAvailable: function isAvailable(editor) {
    return editor.isToolEnabled('saturation');
  },
  minValue: 0,
  midValue: 1,
  maxValue: 2
}, {
  identifier: 'contrast',
  isAvailable: function isAvailable(editor) {
    return editor.isToolEnabled('contrast');
  },
  minValue: 0,
  midValue: 1,
  maxValue: 2
}, {
  identifier: 'gamma',
  isAvailable: function isAvailable(editor) {
    return editor.isToolEnabled('gamma');
  },
  minValue: 0.5,
  midValue: 1,
  maxValue: 3
}, {
  identifier: 'clarity',
  isAvailable: function isAvailable(editor) {
    return editor.isToolEnabled('clarity');
  },
  minValue: -1,
  midValue: 0,
  maxValue: 1
}, {
  identifier: 'exposure',
  isAvailable: function isAvailable(editor) {
    return editor.isToolEnabled('exposure');
  },
  minValue: -1,
  midValue: 0,
  maxValue: 1
}, {
  identifier: 'shadows',
  isAvailable: function isAvailable(editor) {
    return editor.isToolEnabled('shadows');
  },
  minValue: 0,
  midValue: 1,
  maxValue: 2
}, {
  identifier: 'highlights',
  isAvailable: function isAvailable(editor) {
    return editor.isToolEnabled('highlights');
  },
  minValue: -1,
  midValue: 0,
  maxValue: 1
}]; /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var AdjustmentsControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(AdjustmentsControlsComponent, _ControlsComponent);

  function AdjustmentsControlsComponent() {
    (0, _classCallCheck3.default)(this, AdjustmentsControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._bindAll('_onSliderValueChange');

    var editor = _this.context.editor;

    _this._operation = editor.operations.getOrCreate('adjustments');

    _this.state = { selectedControls: null };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the back button
   * @param {Event} e
   * @private
   */


  AdjustmentsControlsComponent.prototype._onBackClick = function _onBackClick(e) {
    var editor = this.context.editor;

    var operationExistedBefore = this.getSharedState('operationExistedBefore');
    var initialOptions = this.getSharedState('initialOptions');

    if (!this._operation.optionsEqual(initialOptions)) {
      editor.history.add(this._operation, initialOptions, operationExistedBefore);
    }

    var defaultOptions = this._operation.getDefaultOptions();
    if (this._operation.optionsEqual(defaultOptions)) {
      editor.operations.remove(this._operation);
    }

    _ControlsComponent.prototype._onBackClick.call(this, e);
  };

  /**
   * Gets called when the user changes the slider value
   * @param  {Number} value
   * @private
   */


  AdjustmentsControlsComponent.prototype._onSliderValueChange = function _onSliderValueChange(value) {
    var selectedControls = this.state.selectedControls;
    var identifier = selectedControls.identifier,
        minValue = selectedControls.minValue,
        midValue = selectedControls.midValue,
        maxValue = selectedControls.maxValue;


    value = value < 0 ? midValue + (midValue - minValue) * value / 100 : midValue + (maxValue - midValue) * value / 100;

    this._operation.setOption(identifier, value);

    var editor = this.context.editor;

    editor.render();
  };

  /**
   * Gets called when the user clicks one of the three buttons
   * @param {Object} controlsItem
   * @param {Event} e
   * @private
   */


  AdjustmentsControlsComponent.prototype._onButtonClick = function _onButtonClick(controlsItem, e) {
    this.setState({ selectedControls: controlsItem });
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Builds the props hash passed to the sliders
   * @return {Object}
   */


  AdjustmentsControlsComponent.prototype._buildSliderProps = function _buildSliderProps(controls) {
    var identifier = controls.identifier,
        minValue = controls.minValue,
        midValue = controls.midValue,
        maxValue = controls.maxValue;


    var value = this._operation ? this._operation.getOption(identifier) : midValue;

    var sliderValue = (value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue)) * 100;

    return {
      minValue: -100,
      maxValue: 100,
      value: sliderValue,
      valueUnit: '%',
      positiveValuePrefix: '+',
      label: this._t('controls.adjustments.' + identifier),
      middleDot: true,
      onChange: this._onSliderValueChange
    };
  };

  // -------------------------------------------------------------------------- RENDERING

  AdjustmentsControlsComponent.prototype.renderOverlayControls = function renderOverlayControls() {
    var selectedControls = this.state.selectedControls;

    if (!selectedControls) return;

    var sliderProps = this._buildSliderProps(selectedControls);
    return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, sliderProps);
  };

  /**
   * Renders the list items
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  AdjustmentsControlsComponent.prototype._renderListItems = function _renderListItems() {
    var _this2 = this;

    return ITEMS.filter(function (item) {
      return item.isAvailable(_this2.context.editor);
    }).map(function (item) {
      var isSelected = _this2.state.selectedControls === item;
      var className = isSelected ? 'is-active' : null;

      var miniSlider = void 0;
      /* eslint-disable no-constant-condition */
      if (!isSelected && false) {
        // Mini sliders temporarily disabled
        var sliderProps = _this2._buildSliderProps(item);
        miniSlider = _globals.ReactBEM.createElement(
          'bem',
          { specifier: 'b:adjustmentsControls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:miniSlider' },
            _globals.ReactBEM.createElement(_miniSliderComponent2.default, sliderProps)
          )
        );
      }
      /* eslint-enable no-constant-condition */

      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: item.identifier,
          'data-identifier': item.identifier },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:button m:withLabel', onClick: _this2._onButtonClick.bind(_this2, item), className: className },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this2._getAssetPath('controls/adjustments/' + item.identifier + '.png', true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              _this2._t('controls.adjustments.' + item.identifier)
            ),
            miniSlider
          )
        )
      );
    });
  };

  /**
   * Renders the controls of this component
   * @return {ReactBEM.Element}
   */


  AdjustmentsControlsComponent.prototype.renderControls = function renderControls() {
    var listItems = this._renderListItems();

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:list' },
      _globals.ReactBEM.createElement(
        _scrollbarComponent2.default,
        null,
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:list' },
          listItems
        )
      )
    );
  };

  return AdjustmentsControlsComponent;
}(_controlsComponent2.default);

exports.default = AdjustmentsControlsComponent;


AdjustmentsControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _adjustmentsControlsComponent = __webpack_require__(105);

var _adjustmentsControlsComponent2 = _interopRequireDefault(_adjustmentsControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TOOLS = ['brightness', 'clarity', 'contrast', 'exposure', 'highlights', 'saturation', 'shadows', 'gamma'];

/**
 * The adjustments controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */

var AdjustmentsControls = function (_Controls) {
  (0, _inherits3.default)(AdjustmentsControls, _Controls);

  function AdjustmentsControls() {
    (0, _classCallCheck3.default)(this, AdjustmentsControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  /**
   * Gets called when the user enters these controls
   * @this {AdjustmentsControlsComponent}
   * @param {SharedState} sharedState
   * @override
   * @ignore
   */
  AdjustmentsControls.onEnter = function onEnter(sharedState) {
    var editor = this.context.editor;

    var operationExistedBefore = editor.operations.exists('adjustments');
    var operation = editor.operations.getOrCreate('adjustments');
    var initialOptions = operation.serializeOptions();

    this.setSharedState({ operation: operation, operationExistedBefore: operationExistedBefore, initialOptions: initialOptions });
  };

  /**
   * Checks if this control is available to the user
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {Boolean}
   * @override
   * @ignore
   */


  AdjustmentsControls.isAvailable = function isAvailable(editor) {
    return TOOLS.filter(function (tool) {
      return editor.isToolEnabled(tool);
    }).length > 0;
  };

  /**
   * Returns the assets that should be preloaded for this control
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {String[]}
   */


  AdjustmentsControls.getPreloadAssets = function getPreloadAssets(editor) {
    return TOOLS.filter(function (tool) {
      return editor.isToolEnabled(tool);
    }).map(function (tool) {
      return 'controls/adjustments/' + tool + '.png';
    });
  };

  return AdjustmentsControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


AdjustmentsControls.controlsComponent = _adjustmentsControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
AdjustmentsControls.identifier = 'adjustments';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
AdjustmentsControls.iconPath = 'controls/overview/adjustments.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
AdjustmentsControls.languageKey = 'controls.overview.adjustments';

/**
 * The default options for this control
 * @type {Object}
 */
AdjustmentsControls.defaultOptions = {};

exports.default = AdjustmentsControls;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _spritesCanvasControlsComponent = __webpack_require__(31);

var _spritesCanvasControlsComponent2 = _interopRequireDefault(_spritesCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushCanvasControlsComponent = function (_SpritesCanvasControl) {
  (0, _inherits3.default)(BrushCanvasControlsComponent, _SpritesCanvasControl);

  function BrushCanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, BrushCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _SpritesCanvasControl.call.apply(_SpritesCanvasControl, [this].concat(args)));

    _this._windowResized = false;
    _this._drawing = false;
    _this._bindAll('_onMouseEnter', '_onMouseLeave', '_onMouseDown', '_onMouseMove', '_onMouseUp', '_onMouseMoveOnCanvas', '_onWindowResize');

    _this._lastDrawPosition = null;

    _this._events = _globals.SDKUtils.extend(_this._events, (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.WINDOW_RESIZE, _this._onWindowResize));

    _this.state = {
      cursorVisible: false,
      cursorPosition: new _globals.Vector2()
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  BrushCanvasControlsComponent.prototype.componentDidMount = function componentDidMount() {
    _SpritesCanvasControl.prototype.componentDidMount.call(this);
    this._updateContainerRect();
  };

  /**
   * Gets called when this component has been updated
   */


  BrushCanvasControlsComponent.prototype.componentDidUpdate = function componentDidUpdate() {
    if (this._windowResized) {
      this._updateContainerRect();
      this._windowResized = false;
    }
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the window has been resized
   * @private
   */


  BrushCanvasControlsComponent.prototype._onWindowResize = function _onWindowResize() {
    this._windowResized = true;
  };

  /**
   * Gets called when an operation has been removed
   * @param  {Operation} operation
   * @private
   */


  BrushCanvasControlsComponent.prototype._onOperationRemoved = function _onOperationRemoved(operation) {
    void 0;
  };

  /**
   * Gets called when an operation has been updated
   * @param  {Operation} operation
   * @private
   */


  BrushCanvasControlsComponent.prototype._onOperationUpdated = function _onOperationUpdated(operation) {
    if (operation === this.getSharedState('operation')) {
      this.forceUpdate();
    }
  };

  /**
   * Gets called when the user presses a mouse button
   * @param  {Event} e
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseDown = function _onMouseDown(e) {
    e.preventDefault();

    this._optionsBeforeDraw = this.getSharedState('operation').serializeOptions();
    delete this._optionsBeforeDraw.enabled;

    this._operationExistedBeforeDraw = this.getSharedState('operationExistedBefore');
    this.setSharedState({ operationExistedBefore: true }, false);

    var outputDimensions = this.context.editor.getOutputDimensions();
    var cursorPosition = this._getCursorPosition(e);

    var brush = this.getSharedState('brush');
    var thickness = this.getSharedState('thickness') / outputDimensions.min();
    var color = this.getSharedState('color');
    var hardness = this.getSharedState('hardness');
    this._drawing = true;
    this._currentPath = brush.createPath(thickness, hardness, color);
    this._currentPath.addControlPoint(cursorPosition.clone().divide(outputDimensions));

    document.addEventListener('mousemove', this._onMouseMove);
    document.addEventListener('touchmove', this._onMouseMove);
    document.addEventListener('mouseup', this._onMouseUp);
    document.addEventListener('touchend', this._onMouseUp);
  };

  /**
   * Gets called when the user releases a mouse button
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseUp = function _onMouseUp() {
    this._currentPath.setClosed(true);

    var editor = this.context.editor;

    var outputTextureDimensions = editor.getOutputTextureDimensions();
    this.getSharedState('brush').render(outputTextureDimensions);

    this._currentPath = null;
    this._drawing = false;

    editor.history.add(this.getSharedState('operation'), this._optionsBeforeDraw, this._operationExistedBeforeDraw);

    document.removeEventListener('mousemove', this._onMouseMove);
    document.removeEventListener('touchmove', this._onMouseMove);
    document.removeEventListener('mouseup', this._onMouseUp);
    document.removeEventListener('touchend', this._onMouseUp);
  };

  /**
   * Gets called when the user enters the canvas
   * @param {Event} event
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseEnter = function _onMouseEnter(e) {
    var cursorPosition = this._getCursorPosition(e);
    this.setState({
      cursorVisible: true,
      cursorPosition: cursorPosition
    });
    this._onMouseMove(e);
  };

  /**
   * Gets called when the user leaves the canvas
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseLeave = function _onMouseLeave() {
    this.setState({
      cursorVisible: false
    });
  };

  /**
   * Gets called while the user moves the mouse
   * @param {Event} e
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseMove = function _onMouseMove(e) {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();
    var outputTextureDimensions = editor.getOutputTextureDimensions();

    var zoom = editor.zoom.get();
    var cursorPosition = this._getCursorPosition(e);
    this.setState({ cursorPosition: cursorPosition });

    var shouldDraw = void 0;
    if (!this._lastDrawPosition) {
      shouldDraw = true;
    } else {
      var brushSize = this.getSharedState('thickness');
      var distance = this._lastDrawPosition.clone().subtract(cursorPosition).abs().len() / zoom;
      shouldDraw = distance >= brushSize / 10;
    }

    if (this._drawing && shouldDraw) {
      this._currentPath.addControlPoint(cursorPosition.clone().divide(outputDimensions));

      this.getSharedState('brush').render(outputTextureDimensions);

      this._lastDrawPosition = cursorPosition.clone();
    }
  };

  /**
   * Gets called while the user moves the mouse on top of the canvas. Updates
   * the cursor cursor position
   * @param  {Event} e
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseMoveOnCanvas = function _onMouseMoveOnCanvas(e) {
    var cursorPosition = this._getCursorPosition(e);
    this.setState({ cursorPosition: cursorPosition });
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the cursor's style object
   * @return {Object}
   * @private
   */


  BrushCanvasControlsComponent.prototype._getCursorStyle = function _getCursorStyle() {
    var thickness = this.getSharedState('thickness');
    var color = this.getSharedState('color');

    var cursorPosition = this.state.cursorPosition;

    return {
      left: cursorPosition.x,
      top: cursorPosition.y,
      width: thickness,
      height: thickness,
      background: color.toRGBA(),
      marginLeft: thickness * -0.5,
      marginTop: thickness * -0.5
    };
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Updates the container bounding rect
   * @private
   */


  BrushCanvasControlsComponent.prototype._updateContainerRect = function _updateContainerRect() {
    this._containerBoundingRect = this.refs.innerContainer.getBoundingClientRect();
  };

  /**
   * Returns the cursor position for the given event
   * @param  {Event} event
   * @private
   */


  BrushCanvasControlsComponent.prototype._getCursorPosition = function _getCursorPosition(event) {
    var position = _globals.Utils.getEventPosition(event);
    var boundingRect = this._containerBoundingRect;
    return position.subtract(boundingRect.left, boundingRect.top);
  };

  /**
   * Returns the properties for the outer container
   * @return {Object}
   * @private
   */


  BrushCanvasControlsComponent.prototype._getContainerProps = function _getContainerProps() {
    var props = _SpritesCanvasControl.prototype._getContainerProps.call(this);

    props.onMouseDown = props.onTouchStart = this._onMouseDown;
    return props;
  };

  /**
   * Returns the properties for the canvas container
   * @return {Object}
   * @private
   */


  BrushCanvasControlsComponent.prototype._getInnerContainerProps = function _getInnerContainerProps() {
    var props = _SpritesCanvasControl.prototype._getInnerContainerProps.call(this);

    // This disables the hit testing for this sub control
    delete props.onClick;

    props.onMouseEnter = this._onMouseEnter;
    props.onMouseLeave = this._onMouseLeave;
    props.onMouseMove = this._onMouseMoveOnCanvas;
    return props;
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * This renders controls on top of the sprites
   * @return {ReactBEM.Element}
   * @private
   */


  BrushCanvasControlsComponent.prototype._renderOverlayControls = function _renderOverlayControls() {
    var cursorClass = this.state.cursorVisible ? 'is-visible' : null;
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:brushCanvasControls' },
      _globals.ReactBEM.createElement('div', { bem: 'e:cursor', className: cursorClass, style: this._getCursorStyle() })
    );
  };

  return BrushCanvasControlsComponent;
}(_spritesCanvasControlsComponent2.default);

exports.default = BrushCanvasControlsComponent;


BrushCanvasControlsComponent.contextTypes = _spritesCanvasControlsComponent2.default.contextTypes;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _sliderComponent = __webpack_require__(30);

var _sliderComponent2 = _interopRequireDefault(_sliderComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _colorPickerComponent = __webpack_require__(38);

var _colorPickerComponent2 = _interopRequireDefault(_colorPickerComponent);

var _presetPreviewItemComponent = __webpack_require__(110);

var _presetPreviewItemComponent2 = _interopRequireDefault(_presetPreviewItemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(BrushControlsComponent, _ControlsComponent);

  function BrushControlsComponent() {
    var _this$_events;

    (0, _classCallCheck3.default)(this, BrushControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._hasDoneButton = false;
    _this._brushOptions = {
      thickness: _this.getSharedState('thickness'),
      color: _this.getSharedState('color').clone()
    };

    _this._hasPresets = _this.props.options.thicknessPresets && _this.props.options.thicknessPresets.length > 0;
    _this._hasSlider = !_this._hasPresets;

    _this._bindAll('_onThicknessUpdated', '_onColorUpdated', '_onOperationUpdated', '_onOperationRemoved');

    _this.state = {
      thicknessControlsEnabled: false
    };

    _this._events = (_this$_events = {}, (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated), (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  BrushControlsComponent.prototype.componentDidMount = function componentDidMount() {
    _ControlsComponent.prototype.componentDidMount.call(this);

    var editor = this.context.editor;

    editor.zoom.set('auto');
    editor.features.disable('zoom', 'drag');
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks a thickness preset
   * @param  {Number} thickness
   * @private
   */


  BrushControlsComponent.prototype._onThicknessClick = function _onThicknessClick(thickness) {
    this._onThicknessUpdated(thickness);
    this.forceUpdate();
  };

  /**
   * Gets called when an operation has been removed
   * @param  {Operation} operation
   * @private
   */


  BrushControlsComponent.prototype._onOperationRemoved = function _onOperationRemoved(operation) {
    if (operation !== this.getSharedState('operation')) return;
    if (this._backButtonClicked) return;

    // Operation can be removed by the undo button. We need
    // to make sure we re-create the operation for the lifetime
    // of this control
    var editor = this.context.editor;

    var newOperation = editor.operations.getOrCreate('sprite');

    var brush = newOperation.createBrush();
    newOperation.addSprite(brush);

    this.setSharedState({
      operation: newOperation,
      brush: brush,
      operationExistedBefore: false,
      initialOptions: {}
    });

    editor.render();
  };

  /**
   * Gets called when an operation has been updated
   * @param  {Operation} operation
   * @private
   */


  BrushControlsComponent.prototype._onOperationUpdated = function _onOperationUpdated(operation) {
    var _this2 = this;

    if (operation === this.getSharedState('operation')) {
      // SpriteOperation re-creates all sprites when they're mass-assigned,
      // so we need to find the new instance by matching against the previous ID
      var previousBrush = this.getSharedState('brush');
      if (previousBrush) {
        var brush = operation.getSprites().filter(function (s) {
          return s.getId() === previousBrush.getId();
        })[0];
        this.setSharedState({ brush: brush });
      }

      // Trigger brush canvas rendering
      operation.setEnabled(true);
      this.context.editor.render(function () {
        operation.setEnabled(false);
        _this2.context.editor.render();
      });
    }
  };

  /**
   * Gets called when the thickness has been updated
   * @param {Number} thickness
   * @private
   */


  BrushControlsComponent.prototype._onThicknessUpdated = function _onThicknessUpdated(thickness) {
    this.setSharedState({ thickness: thickness });
    this._brushOptions.thickness = thickness;
  };

  /**
   * Gets called when the color has been updated
   * @param  {Color} color
   * @private
   */


  BrushControlsComponent.prototype._onColorUpdated = function _onColorUpdated(color) {
    this.setSharedState({ color: color });
    this._brushOptions.color = color.clone();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the thickness list items
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  BrushControlsComponent.prototype._renderThicknessItems = function _renderThicknessItems() {
    var _this3 = this;

    var thicknessPresets = this.props.options.thicknessPresets;

    var maxThickness = Math.max.apply(null, thicknessPresets);
    return thicknessPresets.map(function (thickness) {
      var isActive = _this3.getSharedState('thickness') === thickness;
      return _globals.ReactBEM.createElement(_presetPreviewItemComponent2.default, {
        thickness: thickness,
        maxThickness: maxThickness,
        active: isActive,
        key: thickness,
        onClick: _this3._onThicknessClick.bind(_this3, thickness) });
    });
  };

  /**
   * Renders the controls of this component
   * @return {ReactBEM.Element}
   */


  BrushControlsComponent.prototype.renderControls = function renderControls() {
    var editor = this.context.editor;

    var zoom = editor.zoom.get();
    var items = [];

    if (this._hasSlider) {
      var finalDimensions = editor.getFinalDimensions();
      var minThickness = 1;
      var maxThickness = Math.round(finalDimensions.clone().multiply(zoom).min() / 2);
      var currentWidth = this._brushOptions.thickness;

      items.push(_globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:slider' },
        _globals.ReactBEM.createElement(_sliderComponent2.default, {
          style: 'large',
          minValue: minThickness,
          maxValue: maxThickness,
          valueUnit: 'px',
          middleDot: false,
          label: this._t('controls.brush.thickness'),
          onChange: this._onThicknessUpdated,
          value: currentWidth })
      ));
    } else if (this._hasPresets) {
      items.push(_globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:list' },
        _globals.ReactBEM.createElement(
          _scrollbarComponent2.default,
          null,
          _globals.ReactBEM.createElement(
            'ul',
            { bem: '$e:list' },
            this._renderThicknessItems()
          )
        )
      ));
    }

    items.push(_globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:colorPicker' },
      _globals.ReactBEM.createElement(_colorPickerComponent2.default, {
        initialValue: this._brushOptions.color.clone(),
        onChange: this._onColorUpdated })
    ));

    return items;
  };

  return BrushControlsComponent;
}(_controlsComponent2.default);

exports.default = BrushControlsComponent;


BrushControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _brushControlsComponent = __webpack_require__(108);

var _brushControlsComponent2 = _interopRequireDefault(_brushControlsComponent);

var _brushCanvasControlsComponent = __webpack_require__(107);

var _brushCanvasControlsComponent2 = _interopRequireDefault(_brushCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The brush controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushControls = function (_Controls) {
  (0, _inherits3.default)(BrushControls, _Controls);

  function BrushControls() {
    (0, _classCallCheck3.default)(this, BrushControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  /**
   * Gets called when the user leaves these controls
   * @this {StickersControlsComponent}
   * @override
   * @ignore
   */
  BrushControls.onExit = function onExit() {
    var editor = this.context.editor;

    var operation = this.getSharedState('operation');

    operation.setEnabled(true);

    editor.zoom.undo();
    editor.features.enable('zoom', 'drag');
    editor.render();
  };

  /**
   * Gets called when the user enters these controls
   * @this {BrushControlsComponent}
   * @param {SharedState} sharedState
   * @param {Object} options
   * @override
   * @ignore
   */


  BrushControls.onEnter = function onEnter(sharedState, options) {
    var editor = this.context.editor;


    editor.zoom.set('auto', function () {
      operation.setEnabled(false);
      editor.render();
    });

    var outputDimensions = editor.getOutputDimensions();
    var operationExistedBefore = editor.operations.exists('sprite');
    var operation = editor.operations.getOrCreate('sprite');
    var brush = operation.createBrush();
    var initialOptions = operation.serializeOptions();
    operation.addSprite(brush);

    var thickness = Math.max(outputDimensions.min() * 0.05, 1);
    if (options.thicknessPresets && options.thicknessPresets.length > 0) {
      thickness = options.thicknessPresets[0];
    }

    var color = new _globals.Color(1, 0, 0, 1);
    var hardness = 1;

    this.setSharedState({
      operationExistedBefore: operationExistedBefore, operation: operation, brush: brush, initialOptions: initialOptions, thickness: thickness, color: color, hardness: hardness
    });
  };

  /**
   * Checks if this control is available to the user
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {Boolean}
   * @override
   * @ignore
   */


  BrushControls.isAvailable = function isAvailable(editor) {
    return editor.isToolEnabled('brush');
  };

  /**
   * Returns the assets that should be preloaded for this control
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {String[]}
   */


  BrushControls.getPreloadAssets = function getPreloadAssets() {
    return ['controls/brush/thickness.png'];
  };

  return BrushControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


BrushControls.controlsComponent = _brushControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
BrushControls.canvasControlsComponent = _brushCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
BrushControls.identifier = 'brush';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
BrushControls.iconPath = 'controls/overview/brush.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
BrushControls.languageKey = 'controls.overview.brush';

/**
 * The default options for this control
 * @type {Object}
 */
BrushControls.defaultOptions = {
  thicknessPresets: []
};

exports.default = BrushControls;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PresetPreviewItemComponent = function (_BaseComponent) {
  (0, _inherits3.default)(PresetPreviewItemComponent, _BaseComponent);

  function PresetPreviewItemComponent() {
    (0, _classCallCheck3.default)(this, PresetPreviewItemComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after the component has been mounted
   */
  PresetPreviewItemComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);
    this._renderCanvas();
  };

  /**
   * Gets called after this component has been updated
   */


  PresetPreviewItemComponent.prototype.componentDidUpdate = function componentDidUpdate() {
    this._renderCanvas();
  };

  // -------------------------------------------------------------------------- CANVAS RENDERING

  /**
   * Renders the current font family onto the canvas
   * @private
   */


  PresetPreviewItemComponent.prototype._renderCanvas = function _renderCanvas() {
    var canvas = this.refs.canvas;

    var context = canvas.getContext('2d');

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    var _props = this.props,
        maxThickness = _props.maxThickness,
        thickness = _props.thickness;

    var diameter = canvas.width * (thickness / maxThickness);
    var radius = diameter / 2;

    context.fillStyle = 'white';
    context.beginPath();
    context.arc(canvas.width / 2, canvas.height / 2, radius, 0, 2 * Math.PI);
    context.fill();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  PresetPreviewItemComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:controls $e:list' },
      _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          onClick: this.props.onClick },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:button m:withLabel', className: this.props.active ? 'is-active' : null },
            _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              this.props.thickness
            )
          )
        )
      )
    );
  };

  return PresetPreviewItemComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = PresetPreviewItemComponent;


PresetPreviewItemComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _canvasControlsComponent = __webpack_require__(20);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MIN_DIMENSIONS = new _globals.Vector2(50, 50); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CropCanvasControlsComponent = function (_CanvasControlsCompon) {
  (0, _inherits3.default)(CropCanvasControlsComponent, _CanvasControlsCompon);

  function CropCanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, CropCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _CanvasControlsCompon.call.apply(_CanvasControlsCompon, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this._bindAll('_onCenterDragStart', '_onCenterDrag');

    _this.state = {
      dimensions: _this.getSharedState('initialDimensions')
    };
    return _this;
  }

  /**
   * Fixes styles in IE
   */


  CropCanvasControlsComponent.prototype.fixStyles = function fixStyles() {
    if (_globals.Utils.Browser.isIElte(11)) {
      var editor = this.context.editor;
      var container = this.refs.container;


      var canvasDimensions = editor.getCanvasDimensions(false);
      var cellHeight = canvasDimensions.y;
      container.style.height = cellHeight + 'px';
    }
  };

  /**
   * Gets called when the shared state did change
   * @param {Object} newState
   */


  CropCanvasControlsComponent.prototype.sharedStateDidChange = function sharedStateDidChange(newState) {
    if (newState !== this.getSharedState('ratio')) {
      this._updateDimensions();
    }
  };

  /**
   * Updates the dimensions display
   * @private
   */


  CropCanvasControlsComponent.prototype._updateDimensions = function _updateDimensions() {
    var operation = this.getSharedState('operation');
    var ratio = this.getSharedState('ratio') || { ratio: '*' };

    var dimensions = void 0;
    if (ratio.dimensions) {
      dimensions = ratio.dimensions.clone();
    } else {
      var inputDimensions = operation.getInputDimensions();
      var start = this.getSharedState('start');
      var end = this.getSharedState('end');
      var cropSize = end.clone().subtract(start);
      dimensions = cropSize.multiply(inputDimensions).floor();
    }

    this.setState({ dimensions: dimensions });
  };

  // -------------------------------------------------------------------------- CENTER DRAGGING

  /**
   * Gets called when the user stars dragging the center
   * @private
   */


  CropCanvasControlsComponent.prototype._onCenterDragStart = function _onCenterDragStart() {
    var start = this.getSharedState('start');
    var end = this.getSharedState('end');

    this._initialValues = {
      start: start.clone(),
      end: end.clone(),
      size: end.clone().subtract(start)
    };
  };

  /**
   * Gets called while the user drags the center
   * @param {Vector2} offset
   * @private
   */


  CropCanvasControlsComponent.prototype._onCenterDrag = function _onCenterDrag(offset) {
    var editor = this.context.editor;
    var _initialValues = this._initialValues,
        start = _initialValues.start,
        size = _initialValues.size;

    var outputDimensions = editor.getOutputDimensions();
    var cropDifference = offset.clone().divide(outputDimensions);

    var minStart = new _globals.Vector2(0, 0);
    var maxStart = new _globals.Vector2(1, 1).subtract(size);

    var newStart = start.clone().add(cropDifference).clamp(minStart, maxStart);
    var newEnd = newStart.clone().add(size);

    this.setSharedState({ start: newStart, end: newEnd });
  };

  // -------------------------------------------------------------------------- KNOB DRAGGING

  /**
   * Gets called when the user starts dragging a knob
   * @param {String} optionName
   * @private
   */


  CropCanvasControlsComponent.prototype._onKnobDragStart = function _onKnobDragStart(optionName) {
    this._currentDragOption = optionName;

    this._initialValues = {
      start: this.getSharedState('start').clone(),
      end: this.getSharedState('end').clone()
    };
  };

  /**
   * Gets called while the user drags a knob
   * @param {String} optionName
   * @param {Vector2} offset
   * @private
   */


  CropCanvasControlsComponent.prototype._onKnobDrag = function _onKnobDrag(optionName, offset) {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();

    var _ref = this.getSharedState('ratio') || { ratio: '*' },
        ratio = _ref.ratio,
        dimensions = _ref.dimensions;

    if (dimensions && !ratio) {
      ratio = dimensions.x / dimensions.y;
    }

    var newSize = this._initialValues.end.clone().subtract(this._initialValues.start).multiply(outputDimensions);

    // Calculate max size and new size
    var maxSize = void 0;
    if (optionName === 'start') {
      newSize.subtract(offset);
      maxSize = this._initialValues.end.clone().multiply(outputDimensions);
    } else if (optionName === 'end') {
      newSize.add(offset);
      maxSize = new _globals.Vector2(1, 1).subtract(this._initialValues.start).multiply(outputDimensions);
    }

    newSize.x = Math.min(Math.max(MIN_DIMENSIONS.x, newSize.x), maxSize.x);
    if (ratio !== '*') {
      newSize.y = newSize.x / ratio;
    }
    newSize.y = Math.min(Math.max(MIN_DIMENSIONS.y, newSize.y), maxSize.y);
    if (ratio !== '*') {
      newSize.x = newSize.y * ratio;
    }

    if (optionName === 'start') {
      var newStart = this._initialValues.end.clone().subtract(newSize.clone().divide(outputDimensions));
      this.setSharedState({ start: newStart }, false);
      this._updateDimensions();
    } else if (optionName === 'end') {
      var newEnd = this._initialValues.start.clone().add(newSize.clone().divide(outputDimensions));
      this.setSharedState({ end: newEnd }, false);
      this._updateDimensions();
    }
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Returns the dimensions according to the current crop dimensions
   * @private
   */


  CropCanvasControlsComponent.prototype._calculateDimensions = function _calculateDimensions() {
    var editor = this.context.editor;

    var start = this.getSharedState('start');
    var end = this.getSharedState('end');

    return end.clone().subtract(start).multiply(editor.getInputDimensions()).round();
  };

  // -------------------------------------------------------------------------- RESIZING / STYLING

  /**
   * Returns the styles (width / height) for the crop areas that define the
   * crop size
   * @return {Object}
   * @private
   */


  CropCanvasControlsComponent.prototype._getAreaStyles = function _getAreaStyles() {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();
    var canvasDimensions = editor.getCanvasDimensions();

    var start = this.getSharedState('start').clone().multiply(outputDimensions).floor();
    var end = this.getSharedState('end').clone().multiply(outputDimensions).ceil();
    var size = end.clone().subtract(start);

    var offset = canvasDimensions.clone().subtract(outputDimensions).divide(2).floor();

    var padding = editor.getPadding();
    start.add(offset).add(0, padding[0]);

    return {
      topLeft: this._getDimensionsStyles(start.x, start.y),
      topCenter: this._getDimensionsStyles(size.x, start.y),
      centerLeft: this._getDimensionsStyles(start.x, size.y),
      center: this._getDimensionsStyles(size.x, size.y)
    };
  };

  /**
   * Returns the dimensions style (width / height) for the given dimensions
   * @param {Number} x
   * @param {Number} y
   * @return {Object}
   * @private
   */


  CropCanvasControlsComponent.prototype._getDimensionsStyles = function _getDimensionsStyles(x, y) {
    // Table cells and rows can't have a width / height of 0
    return {
      width: Math.max(1, x),
      height: Math.max(1, y)
    };
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  CropCanvasControlsComponent.prototype.renderWithBEM = function renderWithBEM() {
    var ratio = this.getSharedState('ratio');
    var dimensions = this.state.dimensions;


    var canvasContent = void 0;
    if (ratio) {
      var areaStyles = this._getAreaStyles();
      canvasContent = _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:cropCanvasControls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:row' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:dark', style: areaStyles.topLeft },
            '\xA0'
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:dark', style: areaStyles.topCenter },
            '\xA0'
          ),
          _globals.ReactBEM.createElement('div', { bem: 'e:cell m:dark' })
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:row' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:dark', style: areaStyles.centerLeft },
            '\xA0'
          ),
          _globals.ReactBEM.createElement(
            _draggableComponent2.default,
            {
              onStart: this._onCenterDragStart,
              onDrag: this._onCenterDrag },
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:cell m:bordered', style: areaStyles.center },
              _globals.ReactBEM.createElement(
                _draggableComponent2.default,
                {
                  onStart: this._onKnobDragStart.bind(this, 'start'),
                  onDrag: this._onKnobDrag.bind(this, 'start') },
                _globals.ReactBEM.createElement(
                  'div',
                  { bem: 'e:knob m:topLeft $b:knob' },
                  _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-down.png', true) })
                )
              ),
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:dimensions' },
                dimensions.x + 'x' + dimensions.y
              ),
              _globals.ReactBEM.createElement(
                _draggableComponent2.default,
                {
                  onStart: this._onKnobDragStart.bind(this, 'end'),
                  onDrag: this._onKnobDrag.bind(this, 'end') },
                _globals.ReactBEM.createElement(
                  'div',
                  { bem: 'e:knob m:bottomRight $b:knob' },
                  _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-down.png', true) })
                )
              )
            )
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:dark' },
            '\xA0'
          )
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:row' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:dark' },
            '\xA0'
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:dark' },
            '\xA0'
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:dark' },
            '\xA0'
          )
        )
      );
    } else {
      canvasContent = _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:cropCanvasControls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:dimensions' },
          dimensions.x + 'x' + dimensions.y
        )
      );
    }

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'b:canvasControls e:container m:full', ref: 'container' },
      canvasContent
    );
  };

  return CropCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = CropCanvasControlsComponent;


CropCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _sliderOverlayComponent = __webpack_require__(12);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CropControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(CropControlsComponent, _ControlsComponent);

  function CropControlsComponent() {
    (0, _classCallCheck3.default)(this, CropControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._bindAll('_selectRatio', '_onRotationChange', '_reapplyRatio');

    _this.state = { ratio: null };
    _this._ratios = _this.constructor.getRatios(_this.props.options);

    _this._events = (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.CROP_REAPPLY_RATIO, _this._reapplyRatio);

    _this._selectInitialRatio(!_this.getSharedState('cropOperationExistedBefore'));
    return _this;
  }

  // -------------------------------------------------------------------------- INITIALIZATION

  /**
   * Initializes the available ratios
   * @param {Object} options
   * @return {Object[]}
   */


  CropControlsComponent.getRatios = function getRatios(options) {
    var ratios = options.ratios,
        replaceRatios = options.replaceRatios,
        selectableRatios = options.selectableRatios;

    ratios = ratios || [];

    var availableRatios = void 0;
    availableRatios = _globals.Constants.DEFAULTS.CROP_RATIOS;
    if (replaceRatios) {
      availableRatios = ratios;
    } else {
      availableRatios = availableRatios.concat(ratios);
    }

    if (selectableRatios && selectableRatios.length) {
      availableRatios = _globals.Utils.select(availableRatios, selectableRatios, function (r) {
        return r.name;
      });
    }

    return availableRatios;
  };

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Checks if the component should change from the given state
   * @param  {Object} oldState
   * @param  {Object} newState
   * @return {Boolean}
   */


  CropControlsComponent.prototype.shouldSharedComponentUpdate = function shouldSharedComponentUpdate(oldState, newState) {
    return oldState.ratio !== newState.ratio;
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the rotation has been chagned (by using the slider)
   * @param  {Number} rotation
   * @private
   */


  CropControlsComponent.prototype._onRotationChange = function _onRotationChange(rotation) {
    var editor = this.context.editor;

    rotation = rotation * Math.PI / 180;
    editor.setRotation(rotation);

    // Update sprite scale
    this._updateSpriteScale();

    editor.render();
    this.setSharedState({ rotation: rotation });
  };

  /**
   * Updates the sprite scale so that the cropped area fits
   * inside the sprite
   * @private
   */


  CropControlsComponent.prototype._updateSpriteScale = function _updateSpriteScale() {
    var editor = this.context.editor;

    var rotatedSpriteDimensions = this._getRotatedSpriteDimensions();
    var dimensions = editor.getOutputDimensions(false);

    var distanceToCorner = dimensions.clone().multiply(0.5);
    distanceToCorner.subtract(rotatedSpriteDimensions.clone().divide(2));
    distanceToCorner.abs();

    var scale = 1;
    if (distanceToCorner.y > distanceToCorner.x) {
      scale = distanceToCorner.y * 2 / dimensions.y + 1;
    } else {
      scale = distanceToCorner.x * 2 / dimensions.x + 1;
    }
    editor.setSpriteScale(scale);
  };

  /**
   * Gets the outer bounding dimensions of the rotated sprite
   * @return {PhotoEditorSDK.Math.Vector2}
   * @private
   */


  CropControlsComponent.prototype._getRotatedSpriteDimensions = function _getRotatedSpriteDimensions() {
    var editor = this.context.editor;

    var rotation = editor.getRotation();

    var outputDimensions = editor.getOutputDimensions(false);

    return new _globals.Vector2(Math.abs(outputDimensions.x * Math.cos(rotation)) + Math.abs(outputDimensions.y * Math.sin(rotation)), Math.abs(outputDimensions.x * Math.sin(rotation)) + Math.abs(outputDimensions.y * Math.cos(rotation)));
  };

  /**
   * Calculates the texture scale using the current settings
   * @return {Number}
   * @private
   */


  CropControlsComponent.prototype._calculateTextureScale = function _calculateTextureScale() {
    var cropOperation = this.getSharedState('operation');
    var ratio = this.getSharedState('ratio');
    if (!ratio.dimensions) {
      return 1;
    }

    var start = this.getSharedState('start');
    var end = this.getSharedState('end');

    var size = end.clone().subtract(start);
    var cropDimensions = cropOperation.getInputDimensions().multiply(size);
    return ratio.dimensions.x / cropDimensions.x;
  };

  /**
   * Returns all the history items for all operations
   * @private
   */


  CropControlsComponent.prototype._getHistoryItems = function _getHistoryItems() {
    var historyItems = [];

    var cropHistoryItem = this._getCropHistoryItem();
    if (cropHistoryItem) {
      historyItems.push(cropHistoryItem);
    }

    var orientationHistoryItem = this._getOrientationHistoryItem();
    if (orientationHistoryItem) {
      historyItems.push(orientationHistoryItem);
    }

    return historyItems;
  };

  /**
   * Returns the history item for the crop operation
   * @private
   */


  CropControlsComponent.prototype._getCropHistoryItem = function _getCropHistoryItem() {
    var editor = this.context.editor;

    var cropOperation = this.getSharedState('operation');
    var initialCropOptions = this.getSharedState('initialCropOptions');
    var cropOperationExistedBefore = this.getSharedState('cropOperationExistedBefore');
    if (!cropOperation.optionsEqual(initialCropOptions)) {
      return {
        operation: cropOperation,
        options: initialCropOptions,
        existent: cropOperationExistedBefore,
        undo: function undo(operation, newOptions) {
          editor.broadcastCrop(operation, newOptions);
        }
      };
    }
  };

  /**
   * Returns the history item for the orientation operation
   * @private
   */


  CropControlsComponent.prototype._getOrientationHistoryItem = function _getOrientationHistoryItem() {
    var editor = this.context.editor;

    var orientationOperation = this.getSharedState('orientationOperation');
    var initialOrientationOptions = this.getSharedState('initialOrientationOptions');
    var orientationOperationExistedBefore = this.getSharedState('orientationOperationExistedBefore');
    if (!orientationOperation.optionsEqual(initialOrientationOptions)) {
      return {
        operation: orientationOperation,
        options: initialOrientationOptions,
        existent: orientationOperationExistedBefore,
        undo: function undo(operation, newOptions) {
          if (operation.getRotation() !== newOptions.rotation) {
            editor.broadcastRotate(newOptions.rotation - operation.getRotation());
          }

          var rotation = newOptions.rotation;
          var inverseFlip = rotation === 90 || rotation === 270;
          if (operation.getFlipVertically() !== newOptions.flipVertically) {
            editor.broadcastFlip(inverseFlip ? 'horizontal' : 'vertical');
          } else if (operation.getFlipHorizontally() !== newOptions.flipHorizontally) {
            editor.broadcastFlip(inverseFlip ? 'vertical' : 'horizontal');
          }
        }
      };
    }
  };

  /**
   * Re-applies the current ratio
   * @private
   */


  CropControlsComponent.prototype._reapplyRatio = function _reapplyRatio() {
    var ratio = this.getSharedState('ratio');
    this._selectRatio(ratio);
  };

  /**
   * Gets called when the user clicks the back button
   * @param {Event} e
   * @private
   */


  CropControlsComponent.prototype._onBackClick = function _onBackClick(e) {
    var editor = this.context.editor;


    var ratio = this.getSharedState('ratio');
    var cropOperation = this.getSharedState('operation');
    var orientationOperation = this.getSharedState('orientationOperation');

    var rotation = editor.getRotation();
    var start = this.getSharedState('start');
    var end = this.getSharedState('end');
    if ((ratio === null || start.equals(0, 0) && end.equals(1, 1)) && rotation === 0) {
      editor.operations.remove(cropOperation);
    } else {
      // Calculate texture scale
      var textureScale = this._calculateTextureScale();

      var options = {
        rotation: rotation,
        scale: editor.getSpriteScale(),
        start: start,
        end: end,
        textureScale: textureScale,
        enabled: true
      };

      editor.broadcastCrop(cropOperation, options);
      cropOperation.set(options);
    }

    if (orientationOperation.getRotation() === 0 && !orientationOperation.getFlipVertically() && !orientationOperation.getFlipHorizontally()) {
      editor.operations.remove(orientationOperation);
    }

    // Reset editor transforms
    editor.setPadding(false);
    editor.setRotation(0);
    editor.setSpriteScale(1);

    // Handle history
    var historyItems = this._getHistoryItems();
    if (historyItems.length) {
      editor.history.add(historyItems);
    }

    // Enable zoom and drag again, reset zoom
    editor.features.enable('zoom', 'drag');
    editor.zoom.undo();

    _ControlsComponent.prototype._onBackClick.call(this, e);
  };

  // -------------------------------------------------------------------------- RATIO HANDLING

  /**
   * Selects the initial ratio
   * @param {Boolean} setDefaultOptions = true
   * @private
   */


  CropControlsComponent.prototype._selectInitialRatio = function _selectInitialRatio() {
    var setDefaultOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    var operation = this.getSharedState('operation');
    var selectedRatio = null;
    var ratios = _globals.SDKUtils.flatten(this._ratios);

    // 1. Selected ratio stored in operation
    var operationRatio = operation._ratio;
    if (operationRatio) {
      var matchingRatios = ratios.filter(function (ratio) {
        return ratio === operationRatio;
      });
      selectedRatio = matchingRatios[0];
    }

    // 2. First ratio with `selected` flag
    if (!selectedRatio) {
      var selectedRatios = ratios.filter(function (ratio) {
        return ratio.selected;
      });
      selectedRatio = selectedRatios.pop();
    }

    // 3. First ratio
    if (!selectedRatio) {
      selectedRatio = ratios[0];
    }

    return this._selectRatio(selectedRatio, setDefaultOptions, false);
  };

  /**
   * Selects the given ratio
   * @param {String} ratio
   * @param {Boolean} setDefaultOptions = true
   * @param {Boolean} update = true
   * @private
   */


  CropControlsComponent.prototype._selectRatio = function _selectRatio(ratio) {
    var setDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var operation = this.getSharedState('operation');
    if (setDefaultOptions && ratio) {
      this._setDefaultOptionsForRatio(ratio, update);
    }
    operation._ratio = ratio;

    var newSharedState = {
      ratio: ratio
    };
    var editor = this.context.editor;

    if (!ratio) {
      editor.setPadding(false);
      editor.setRotation(0);
      editor.setSpriteScale(1);

      newSharedState.rotation = 0;
      newSharedState.start = new _globals.Vector2(0, 0);
      newSharedState.end = new _globals.Vector2(1, 1);
    } else {
      editor.setPadding(this.getSharedState('activePadding'));
    }
    editor.render();
    this.setSharedState(newSharedState, update);
  };

  /**
   * Sets the default options (start / end) for the given ratio
   * @param {Object} ratio
   * @param {Boolean} update = false
   * @private
   */


  CropControlsComponent.prototype._setDefaultOptionsForRatio = function _setDefaultOptionsForRatio(_ref) {
    var ratio = _ref.ratio,
        name = _ref.name,
        dimensions = _ref.dimensions;
    var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var editor = this.context.editor;

    var start = new _globals.Vector2();
    var end = new _globals.Vector2();

    if (dimensions && !ratio) {
      ratio = dimensions.x / dimensions.y;
    }

    if (ratio === '*') {
      start = new _globals.Vector2(0, 0);
      end = new _globals.Vector2(1, 1);
    } else {
      var outputDimensions = editor.getOutputDimensions();
      var canvasRatio = outputDimensions.x / outputDimensions.y;
      if (canvasRatio <= ratio) {
        var height = 1 / outputDimensions.y * (outputDimensions.x / ratio);
        start.set(0, (1.0 - height) / 2);
        end.set(1.0, 1 - start.y);
      } else {
        var width = 1 / outputDimensions.x * (ratio * outputDimensions.y);
        start.set((1 - width) / 2, 0);
        end.set(1 - start.x, 1.0);
      }
    }

    this.setSharedState({ start: start, end: end }, update);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the overlay controls of this component
   * @return {ReactBEM.Element}
   */


  CropControlsComponent.prototype.renderOverlayControls = function renderOverlayControls() {
    var rotation = this.getSharedState('rotation') * 180 / Math.PI;
    if (!this.getSharedState('ratio')) return null;
    return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
      value: rotation,
      minValue: -45,
      middleDot: true,
      maxValue: 45,
      valueUnit: '\xB0',
      label: this._t('controls.crop.rotation'),
      onChange: this._onRotationChange });
  };

  /**
   * Renders the list items for this controls
   * @return {ReactBEM.Element[]}
   * @private
   */


  CropControlsComponent.prototype._renderListItems = function _renderListItems() {
    var _this2 = this;

    var items = [];
    var makeItem = function makeItem(ratio) {
      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: ratio.name,
          'data-identifier': ratio.name },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:button m:withLabel',
              className: _this2.getSharedState('ratio') === ratio ? 'is-active' : null,
              onClick: _this2._selectRatio.bind(_this2, ratio) },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this2._getAssetPath('controls/crop/' + ratio.name + '.png', true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              _this2._t('controls.crop.' + ratio.name)
            )
          )
        )
      );
    };

    this._ratios.forEach(function (groupOrRatio) {
      if (Array.isArray(groupOrRatio)) {
        var group = groupOrRatio;

        var groupItems = [];
        group.forEach(function (ratio) {
          groupItems.push(makeItem(ratio));
        });

        if (groupItems.length) {
          items.push(groupItems);
        }
      } else {
        var ratio = groupOrRatio;
        items.push(makeItem(ratio));
      }
    });

    var finalItems = [];
    items.forEach(function (itemOrGroup) {
      finalItems = finalItems.concat(itemOrGroup);
      if (Array.isArray(itemOrGroup) && itemOrGroup !== items[items.length - 1]) {
        finalItems.push(_globals.ReactBEM.createElement('li', { bem: 'e:separator' }));
      }
    });

    var noCropItem = _globals.ReactBEM.createElement(
      'li',
      {
        bem: 'e:item',
        'data-identifier': 'none',
        key: 'noCrop' },
      _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:button m:withLabel',
            className: !this.getSharedState('ratio') ? 'is-active' : null,
            onClick: this._selectRatio.bind(this, null) },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/crop/none.png', true) }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this._t('controls.crop.none')
          )
        )
      )
    );

    return [noCropItem, _globals.ReactBEM.createElement('li', { bem: 'e:separator' })].concat(finalItems);
  };

  /**
   * Renders the controls of this component
   * @return {ReactBEM.Element}
   */


  CropControlsComponent.prototype.renderControls = function renderControls() {
    var listItems = this._renderListItems();

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:list' },
      _globals.ReactBEM.createElement(
        _scrollbarComponent2.default,
        null,
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:list' },
          listItems
        )
      )
    );
  };

  return CropControlsComponent;
}(_controlsComponent2.default);

exports.default = CropControlsComponent;


CropControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _topBarComponent = __webpack_require__(32);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CropTopBarComponent = function (_TopBarComponent) {
  (0, _inherits3.default)(CropTopBarComponent, _TopBarComponent);

  function CropTopBarComponent() {
    (0, _classCallCheck3.default)(this, CropTopBarComponent);
    return (0, _possibleConstructorReturn3.default)(this, _TopBarComponent.apply(this, arguments));
  }

  /**
   * Gets called when the user clicks one of the rotate buttons
   * @param  {String} direction
   * @private
   */
  CropTopBarComponent.prototype._onRotateClick = function _onRotateClick(direction) {
    var degrees = void 0;
    if (direction === 'cw') {
      degrees = 90;
    } else if (direction === 'ccw') {
      degrees = -90;
    }

    var editor = this.context.editor;

    var operation = this.getSharedState('orientationOperation');
    var newRotation = (operation.getRotation() + degrees) % 360;

    operation.set({ rotation: newRotation });

    var newState = {
      orientationRotation: newRotation
    };

    var ratio = this.getSharedState('ratio');
    if (!ratio.dimensions) {
      var start = this.getSharedState('start');
      var end = this.getSharedState('end');
      var tempStart = start.clone();
      if (direction === 'cw') {
        start.set(1.0 - end.y, tempStart.x);
        end.set(1.0 - tempStart.y, end.x);
      } else if (direction === 'ccw') {
        start.set(tempStart.y, 1.0 - end.x);
        end.set(end.y, 1.0 - tempStart.x);
      }
      newState.start = start;
      newState.end = end;
    }

    if (ratio.dimensions) {
      this._emitEvent(_globals.Constants.EVENTS.CROP_REAPPLY_RATIO);
    }

    this.setSharedState(newState);

    editor.broadcastRotate(degrees);
    editor.zoom.set('auto');
  };

  /**
   * Gets called when the user clicks one of the flip buttons
   * @private
   */


  CropTopBarComponent.prototype._onFlipClick = function _onFlipClick(direction) {
    var _setSharedState;

    var editor = this.context.editor;

    var operation = this.getSharedState('orientationOperation');

    var newFlip = !this.getSharedState('flip' + direction);
    var newRotation = this.getSharedState('rotation') * -1;
    this.setSharedState((_setSharedState = {}, (0, _defineProperty3.default)(_setSharedState, 'flip' + direction, newFlip), (0, _defineProperty3.default)(_setSharedState, 'rotation', newRotation), _setSharedState));
    editor.setRotation(newRotation);
    operation.flip(direction);

    var start = this.getSharedState('start');
    var end = this.getSharedState('end');
    var tmpStart = start.clone();
    if (direction === 'horizontal') {
      start.set(1.0 - end.x, start.y);
      end.set(1.0 - tmpStart.x, end.y);
    } else if (direction === 'vertical') {
      start.set(start.x, 1.0 - end.y);
      end.set(end.x, 1.0 - tmpStart.y);
    }

    this.setSharedState({ start: start, end: end });

    editor.broadcastFlip(direction);
    editor.render();
  };

  /**
   * Checks if the component should change from the given state
   * @param  {Object} oldState
   * @param  {Object} newState
   * @return {Boolean}
   */


  CropTopBarComponent.prototype.shouldSharedComponentUpdate = function shouldSharedComponentUpdate(oldState, newState) {
    return false;
  };

  /**
   * Renders the content of this OverviewTopBarComponent
   * @return {ReactBEM.Element}
   */


  CropTopBarComponent.prototype.renderContent = function renderContent() {
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:topBar' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:iconButton', onClick: this._onFlipClick.bind(this, 'vertical') },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/crop/flip-v.png', true) })
      ),
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:iconButton', onClick: this._onFlipClick.bind(this, 'horizontal') },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/crop/flip-h.png', true) })
      ),
      _globals.ReactBEM.createElement('div', { bem: 'e:space' }),
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:iconButton', onClick: this._onRotateClick.bind(this, 'ccw') },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/crop/rotate-ccw.png', true) })
      ),
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:iconButton', onClick: this._onRotateClick.bind(this, 'cw') },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/crop/rotate-cw.png', true) })
      )
    );
  };

  return CropTopBarComponent;
}(_topBarComponent2.default);

exports.default = CropTopBarComponent;


CropTopBarComponent.contextTypes = _topBarComponent2.default.contextTypes;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _cropControlsComponent = __webpack_require__(112);

var _cropControlsComponent2 = _interopRequireDefault(_cropControlsComponent);

var _cropCanvasControlsComponent = __webpack_require__(111);

var _cropCanvasControlsComponent2 = _interopRequireDefault(_cropCanvasControlsComponent);

var _cropTopBarComponent = __webpack_require__(113);

var _cropTopBarComponent2 = _interopRequireDefault(_cropTopBarComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The crop controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var CropControls = function (_Controls) {
  (0, _inherits3.default)(CropControls, _Controls);

  function CropControls() {
    (0, _classCallCheck3.default)(this, CropControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  /**
   * Gets called when the user enters these controls
   * @this {CropControlsComponent}
   * @param {SharedState} sharedState
   * @override
   * @ignore
   */
  CropControls.onEnter = function onEnter(sharedState) {
    var editor = this.context.editor;


    var cropOperationExistedBefore = editor.operations.exists('crop');
    var cropOperation = editor.operations.getOrCreate('crop');
    cropOperation.setEnabled(false, false);

    var orientationOperationExistedBefore = editor.operations.exists('orientation');
    var orientationOperation = editor.operations.getOrCreate('orientation');

    var defaultOptions = {
      end: new _globals.Vector2(1, 1),
      rotation: 0,
      start: new _globals.Vector2(0, 0),
      scale: 1,
      textureScale: 1
    };

    var inputDimensions = cropOperation.getInputDimensions();
    var initialDimensions = cropOperation.getNewDimensions(inputDimensions);

    var initialCropOptions = defaultOptions;
    if (cropOperationExistedBefore) {
      initialCropOptions = cropOperation.serializeOptions();
      delete initialCropOptions.enabled;
    }

    editor.broadcastCrop(cropOperation, defaultOptions);

    // Reset start and end so that SpriteOperation gets an update and repositions
    // the stickers
    cropOperation.set(defaultOptions, cropOperationExistedBefore);

    var initialOrientationOptions = orientationOperation.serializeOptions();
    delete initialOrientationOptions.enabled;

    var activePadding = [10, 0, 58 + 10, 0];
    editor.setSpriteScale(initialCropOptions.scale);
    editor.setRotation(initialCropOptions.rotation);
    editor.setPadding(activePadding);
    editor.zoom.set('auto', function () {
      // Disable zoom and drag while we're cropping
      editor.features.disable('zoom', 'drag');
    }, false);

    this.setSharedState({
      initialCropOptions: initialCropOptions,
      initialOrientationOptions: initialOrientationOptions,
      operation: cropOperation,
      orientationOperation: orientationOperation,
      activePadding: activePadding,
      orientationOperationExistedBefore: orientationOperationExistedBefore,
      cropOperationExistedBefore: cropOperationExistedBefore,
      start: _globals.Vector2.fromObject(initialCropOptions.start),
      end: _globals.Vector2.fromObject(initialCropOptions.end),
      rotation: initialCropOptions.rotation,
      orientationRotation: orientationOperation.getRotation(),
      flipVertically: orientationOperation.getFlipVertically(),
      flipHorizontally: orientationOperation.getFlipHorizontally(),
      initialDimensions: initialDimensions,
      inputDimensions: inputDimensions
    });
  };

  /**
   * Checks if this control is available to the user
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {Boolean}
   * @ignore
   */


  CropControls.isAvailable = function isAvailable(editor) {
    return editor.isToolEnabled('crop');
  };

  /**
   * Returns the assets that should be preloaded for this control
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {String[]}
   */


  CropControls.getPreloadAssets = function getPreloadAssets(editor) {
    var options = editor.getOptions();
    var cropOptions = _globals.SDKUtils.defaults(options.editor.controlsOptions.crop, this.defaultOptions);

    var assets = ['controls/crop/rotate-ccw.png', 'controls/crop/rotate-cw.png', 'controls/crop/flip-h.png', 'controls/crop/flip-v.png'];

    // Add ratios
    var ratios = _cropControlsComponent2.default.getRatios(cropOptions);
    ratios.forEach(function (itemOrGroup) {
      if (Array.isArray(itemOrGroup)) {
        itemOrGroup.forEach(function (_ref) {
          var name = _ref.name;

          assets.push('controls/crop/' + name + '.png');
        });
      } else {
        assets.push('controls/crop/' + itemOrGroup.name + '.png');
      }
    });

    return assets;
  };

  return CropControls;
}(_controls2.default);

/**
 * This control's top bar component. Used for the upper part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.TopBarControlsComponent}
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

CropControls.topBarControlsComponent = _cropTopBarComponent2.default;

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
CropControls.controlsComponent = _cropControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
CropControls.canvasControlsComponent = _cropCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
CropControls.identifier = 'crop';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
CropControls.iconPath = 'controls/overview/crop.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
CropControls.languageKey = 'controls.overview.crop';

/**
 * The default options for this control
 * @type {Object}
 * @property {Object[]} [ratios = []]
 * @property {Boolean} [replaceRatios = false]
 * @property {String[]} [availableRatios = null]
 */
CropControls.defaultOptions = {};

exports.default = CropControls;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _categoryDropdownComponent = __webpack_require__(62);

var _categoryDropdownComponent2 = _interopRequireDefault(_categoryDropdownComponent);

var _sliderOverlayComponent = __webpack_require__(12);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

var _filterManager = __webpack_require__(43);

var _filterManager2 = _interopRequireDefault(_filterManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FilterControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(FilterControlsComponent, _ControlsComponent);

  function FilterControlsComponent() {
    (0, _classCallCheck3.default)(this, FilterControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._bindAll('_onItemClick', '_onOperationUpdated', '_onSliderValueChange', '_onCategoryChange');
    _this._operation = _this.getSharedState('operation');

    _this._events = (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated);

    _this._initFilterManager();

    _this.state = {
      category: 'all'
    };
    return _this;
  }

  // -------------------------------------------------------------------------- INITIALIZATION

  /**
   * Initializes the filter manager
   * @private
   */


  FilterControlsComponent.prototype._initFilterManager = function _initFilterManager() {
    this._filterManager = new _filterManager2.default(this.props.options);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the slider value has been changed
   * @param {Number} value
   * @private
   */


  FilterControlsComponent.prototype._onSliderValueChange = function _onSliderValueChange(value) {
    this._operation.setIntensity(value / 100);

    var editor = this.context.editor;

    editor.render();
  };

  /**
   * Gets called when the user switches the category
   * @param  {Object} category
   * @private
   */


  FilterControlsComponent.prototype._onCategoryChange = function _onCategoryChange(category) {
    var _this2 = this;

    this.setState({ category: category.name }, function () {
      _this2.refs.scrollbar.update();
    });
  };

  /**
   * Gets called when an operation has been updated
   * @param  {Operation} operation
   * @private
   */


  FilterControlsComponent.prototype._onOperationUpdated = function _onOperationUpdated(operation) {
    // The undo button might change this operation's selected filter or intensity.
    // Update the component to reflect the change
    if (operation === this._operation) {
      this.forceUpdate();
    }
  };

  /**
   * Gets called when the user clicks an item
   * @param {Class} Filter
   * @param {Event} e
   * @private
   */


  FilterControlsComponent.prototype._onItemClick = function _onItemClick(Filter, e) {
    this._operation.set({
      filter: new Filter({ intensity: 1 }),
      intensity: 1
    });

    var editor = this.context.editor;

    editor.render();
    this.forceUpdate();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the overlay controls of this component
   * @return {ReactBEM.Element}
   */


  FilterControlsComponent.prototype.renderOverlayControls = function renderOverlayControls() {
    var currentFilter = this._operation.getFilter();
    if (currentFilter.isIdentity) return null;

    var intensity = this._operation.getIntensity();
    return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
      minValue: 0,
      maxValue: 100,
      value: intensity * 100,
      valueUnit: '%',
      positiveValuePrefix: '+',
      label: this._t('controls.filters.intensity'),
      onChange: this._onSliderValueChange });
  };

  /**
   * Renders the list items for this control
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  FilterControlsComponent.prototype._renderListItems = function _renderListItems() {
    var _this3 = this;

    var currentFilter = this._operation.getFilter();

    var filters = this._filterManager.getFiltersForCategory(this.state.category);
    return [_globals.SDK.Filters.IdentityFilter].concat(filters).map(function (filter) {
      var identifier = filter.identifier;
      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: identifier,
          onClick: _this3._onItemClick.bind(_this3, filter) },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: '$e:button m:withInlineLabel' },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this3._getAssetPath('controls/filters/' + identifier + '.png', true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: '$e:inlineLabel', className: currentFilter instanceof filter ? 'is-active' : null },
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:label' },
                filter.displayName
              )
            )
          )
        )
      );
    });
  };

  /**
   * Renders the category dropdown (if present)
   * @return {ReactBEM.Element}
   * @private
   */


  FilterControlsComponent.prototype._renderCategoryDropdown = function _renderCategoryDropdown() {
    var _this4 = this;

    var categories = this._filterManager.getCategories();
    var categoryDropdownVisible = !this.props.options.hideCategories && categories.length > 1;
    if (!categoryDropdownVisible) {
      return null;
    }

    var categoryItems = categories.map(function (c) {
      return {
        name: c.name,
        label: _this4._t('controls.filters.categories.' + c.name),
        icon: _this4._getAssetPath('controls/filters/categories/' + c.name + '.png', true)
      };
    });
    var selectedCategory = {
      name: this.state.category,
      label: this._t('controls.filters.categories.' + this.state.category),
      icon: this._getAssetPath('controls/filters/categories/' + this.state.category + '.png', true)
    };

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:categoryDropdown' },
      _globals.ReactBEM.createElement(_categoryDropdownComponent2.default, {
        items: categoryItems,
        selectedItem: selectedCategory,
        onChange: this._onCategoryChange })
    );
  };

  /**
   * Renders the controls of this component
   * @return {ReactBEM.Element}
   */


  FilterControlsComponent.prototype.renderControls = function renderControls() {
    var listItems = this._renderListItems();
    var categoryDropdown = this._renderCategoryDropdown();

    return [categoryDropdown, _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:list' },
      _globals.ReactBEM.createElement(
        _scrollbarComponent2.default,
        { ref: 'scrollbar' },
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:list' },
          listItems
        )
      )
    )];
  };

  return FilterControlsComponent;
}(_controlsComponent2.default);

exports.default = FilterControlsComponent;


FilterControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _filterControlsComponent = __webpack_require__(115);

var _filterControlsComponent2 = _interopRequireDefault(_filterControlsComponent);

var _filterManager = __webpack_require__(43);

var _filterManager2 = _interopRequireDefault(_filterManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The filters controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FiltersControls = function (_Controls) {
  (0, _inherits3.default)(FiltersControls, _Controls);

  function FiltersControls() {
    (0, _classCallCheck3.default)(this, FiltersControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  /**
   * Gets called when the user enters these controls
   * @this {FiltersControlsComponent}
   * @param {SharedState} sharedState
   * @override
   * @ignore
   */
  FiltersControls.onEnter = function onEnter(sharedState) {
    var editor = this.context.editor;

    var operationExistedBefore = editor.operations.exists('filter');
    var operation = editor.operations.getOrCreate('filter');
    var initialOptions = operation.serializeOptions(['filter', 'intensity']);

    this.setSharedState({ operation: operation, operationExistedBefore: operationExistedBefore, initialOptions: initialOptions });
  };

  /**
   * Gets called when the user leaves these controls
   * @this {StickersControlsComponent}
   * @override
   * @ignore
   */


  FiltersControls.onExit = function onExit() {
    var initialOptions = this.getSharedState('initialOptions');
    var FilterConstructor = this._operation.getFilter().constructor;
    var InitialFilterConstructor = initialOptions.filter.constructor;
    var intensity = this._operation.getIntensity();
    if (FilterConstructor !== initialOptions.filter.constructor || intensity !== initialOptions.intensity) {
      var editor = this.context.editor;

      editor.history.add(this._operation, {
        filter: new InitialFilterConstructor(),
        intensity: intensity
      }, this.getSharedState('operationExistedBefore'));
    }

    if (FilterConstructor.isIdentity) {
      var _editor = this.context.editor;

      _editor.operations.remove(this._operation);
    }
  };

  /**
   * Checks if this control is available to the user
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {Boolean}
   * @override
   */


  FiltersControls.isAvailable = function isAvailable(editor) {
    return editor.isToolEnabled(this.identifier);
  };

  /**
   * Returns the assets that should be preloaded for this control
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {String[]}
   */


  FiltersControls.getPreloadAssets = function getPreloadAssets(editor) {
    var options = editor.getOptions();
    var filterOptions = _globals.SDKUtils.defaults(options.editor.controlsOptions.filter, this.defaultOptions);
    var filterManager = new _filterManager2.default(filterOptions);

    var assets = [];
    var categories = filterManager.getCategories();
    categories.forEach(function (category) {
      assets.push('controls/filters/categories/' + category.name + '.png');
      var filters = filterManager.getFiltersForCategory(category.name);
      filters.forEach(function (filter) {
        assets.push('controls/filters/' + filter.identifier + '.png');
      });
    });

    return assets;
  };

  return FiltersControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


FiltersControls.controlsComponent = _filterControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
FiltersControls.identifier = 'filter';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
FiltersControls.iconPath = 'controls/overview/filters.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
FiltersControls.languageKey = 'controls.overview.filters';

/**
 * The default options for this control
 * @type {Object}
 * @property {PhotoEditorSDK.Filter[]} [categories = []]
 * @property {Boolean} [replaceCategories = false]
 * @property {String[]} [selectableFilters = null]
 */
FiltersControls.defaultOptions = {
  categories: [],
  replaceCategories: false,
  selectableFilters: null,
  hideCategories: false
};

exports.default = FiltersControls;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _canvasControlsComponent = __webpack_require__(20);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

var _linearFocusCanvasControlsComponent = __webpack_require__(120);

var _linearFocusCanvasControlsComponent2 = _interopRequireDefault(_linearFocusCanvasControlsComponent);

var _radialFocusCanvasControlsComponent = __webpack_require__(121);

var _radialFocusCanvasControlsComponent2 = _interopRequireDefault(_radialFocusCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FocusCanvasControlsComponent = function (_CanvasControlsCompon) {
  (0, _inherits3.default)(FocusCanvasControlsComponent, _CanvasControlsCompon);

  function FocusCanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, FocusCanvasControlsComponent);
    return (0, _possibleConstructorReturn3.default)(this, _CanvasControlsCompon.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Returns the appropriate canvas controls for the given operation
   * @param  {PhotoEditorSDK.Operation} operation
   * @return {ReactBEM.Element}
   * @private
   */
  FocusCanvasControlsComponent.prototype._getControlsForOperation = function _getControlsForOperation(operation) {
    if (!operation) return null;

    switch (operation.constructor.identifier) {
      case 'linear-focus':
        return _linearFocusCanvasControlsComponent2.default;
      case 'radial-focus':
        return _radialFocusCanvasControlsComponent2.default;
    }
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  FocusCanvasControlsComponent.prototype.renderWithBEM = function renderWithBEM() {
    var operation = this.getSharedState('operation');
    var Controls = this._getControlsForOperation(operation);
    if (!Controls) return _globals.ReactBEM.createElement('div', null);
    return _globals.ReactBEM.createElement(Controls, this.props);
  };

  return FocusCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = FocusCanvasControlsComponent;


FocusCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _sliderOverlayComponent = __webpack_require__(12);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ITEMS = [{ toolName: 'radial-focus', iconName: 'radial', languageKey: 'controls.focus.radial' }, { toolName: 'linear-focus', iconName: 'linear', languageKey: 'controls.focus.linear' }];

var FocusControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(FocusControlsComponent, _ControlsComponent);

  function FocusControlsComponent() {
    (0, _classCallCheck3.default)(this, FocusControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._bindAll('_onBlurRadiusChange', '_onOperationRemoved');
    _this._removedOperation = null;

    _this._events = (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the slider value has changed
   * @param {Number} value
   * @private
   */


  FocusControlsComponent.prototype._onBlurRadiusChange = function _onBlurRadiusChange(value) {
    var operation = this.getSharedState('operation');
    var inputDimensions = this.getSharedState('inputDimensions');
    operation.setBlurRadius(value / inputDimensions.min());

    var editor = this.context.editor;

    editor.render();
  };

  /**
   * Gets called when the user clicks one of the buttons
   * @param {Object} toolName
   * @param {Event} e
   * @private
   */


  FocusControlsComponent.prototype._onButtonClick = function _onButtonClick(toolName, e) {
    var editor = this.context.editor;

    var previousOperation = this.getSharedState('operation');
    if (previousOperation) {
      this._removedOperation = previousOperation;
      editor.operations.remove(previousOperation);
    }

    var newOperation = null;
    if (toolName) {
      newOperation = editor.operations.getOrCreate(toolName);
    }

    this.setSharedState({ operation: newOperation });
    editor.render();
  };

  /**
   * Gets called when an operation has been removed
   * @param  {Operation} operation
   * @private
   */


  FocusControlsComponent.prototype._onOperationRemoved = function _onOperationRemoved(operation) {
    var currentOperation = this.getSharedState('operation');
    if (!currentOperation || operation !== currentOperation || operation === this._removedOperation) return;
    if (this._backButtonClicked) return;

    var editor = this.context.editor;

    var identifier = currentOperation.constructor.identifier;
    var newOperation = editor.operations.getOrCreate(identifier);

    this.setSharedState({
      operation: newOperation,
      operationExistedBefore: false,
      initialOptions: {}
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the overlay controls of this component
   * @return {ReactBEM.Element}
   */


  FocusControlsComponent.prototype.renderOverlayControls = function renderOverlayControls() {
    var focusOperation = this.getSharedState('operation');
    if (!focusOperation) return null;

    var inputDimensions = this.getSharedState('inputDimensions');
    var shortestSide = inputDimensions.min();
    var value = focusOperation.getBlurRadius() * shortestSide;
    return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
      minValue: 0,
      maxValue: Math.min(180, Math.round(shortestSide * 0.1)),
      valueUnit: 'px',
      middleDot: false,
      label: this._t('controls.focus.blurRadius'),
      onChange: this._onBlurRadiusChange,
      value: value });
  };

  /**
   * Renders the list items for this control
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  FocusControlsComponent.prototype._renderListItems = function _renderListItems() {
    var _this2 = this;

    var focusOperation = this.getSharedState('operation');

    var editor = this.context.editor;

    var noFocusItem = _globals.ReactBEM.createElement(
      'li',
      {
        bem: 'e:item',
        key: 'none' },
      _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          {
            bem: '$e:button m:withLabel',
            className: !focusOperation ? 'is-active' : null,
            onClick: this._onButtonClick.bind(this, null) },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/focus/none.png', true) }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this._t('controls.focus.none')
          )
        )
      )
    );

    return [noFocusItem].concat(ITEMS.filter(function (_ref) {
      var toolName = _ref.toolName;
      return editor.isToolEnabled(toolName);
    }).map(function (_ref2) {
      var toolName = _ref2.toolName,
          iconName = _ref2.iconName,
          languageKey = _ref2.languageKey;

      var isActive = focusOperation && focusOperation.constructor.identifier === toolName;
      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          'data-identifier': toolName,
          key: toolName },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            {
              bem: '$e:button m:withLabel',
              className: isActive ? 'is-active' : null,
              onClick: _this2._onButtonClick.bind(_this2, toolName) },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: _this2._getAssetPath('controls/focus/' + iconName + '.png', true) }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: 'e:label' },
              _this2._t(languageKey)
            )
          )
        )
      );
    }));
  };

  /**
   * Renders the controls of this component
   * @return {ReactBEM.Element}
   */


  FocusControlsComponent.prototype.renderControls = function renderControls() {
    var listItems = this._renderListItems();

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:list' },
      _globals.ReactBEM.createElement(
        _scrollbarComponent2.default,
        null,
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:list' },
          listItems
        )
      )
    );
  };

  return FocusControlsComponent;
}(_controlsComponent2.default);

exports.default = FocusControlsComponent;


FocusControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _focusControlsComponent = __webpack_require__(118);

var _focusControlsComponent2 = _interopRequireDefault(_focusControlsComponent);

var _focusCanvasControlsComponent = __webpack_require__(117);

var _focusCanvasControlsComponent2 = _interopRequireDefault(_focusCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The focus controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var FocusControls = function (_Controls) {
  (0, _inherits3.default)(FocusControls, _Controls);

  function FocusControls() {
    (0, _classCallCheck3.default)(this, FocusControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  /**
   * Checks if this control is available to the user
   * @param  {Editor} editor
   * @return {Boolean}
   * @ignore
   */
  FocusControls.isAvailable = function isAvailable(editor) {
    return editor.isToolEnabled('radial-focus') || editor.isToolEnabled('linear-focus');
  };

  /**
   * Gets called when the user leaves these controls
   * @this {FocusControlsComponent}
   * @override
   * @ignore
   */


  FocusControls.onExit = function onExit() {
    var editor = this.context.editor;

    editor.features.enable('zoom', 'drag');

    var initialOptions = this.getSharedState('initialOptions');
    var initialOperation = this.getSharedState('initialOperation');
    var operation = this.getSharedState('operation');

    if (!operation && initialOperation || operation && initialOperation && operation.constructor === initialOperation.constructor) {
      editor.history.add(initialOperation, initialOptions, true);
    }

    if (operation && !initialOperation) {
      editor.history.add(operation, {}, false);
    }

    if (operation && initialOperation && operation.constructor !== initialOperation.constructor) {
      editor.history.add([{
        operation: initialOperation,
        options: initialOptions,
        existent: true
      }, {
        operation: operation,
        options: {},
        existent: false
      }]);
    }
  };

  /**
   * Gets called when the user enters these controls
   * @this {FocusControlsComponent}
   * @param {SharedState} sharedState
   * @override
   * @ignore
   */


  FocusControls.onEnter = function onEnter(sharedState) {
    var editor = this.context.editor;

    var operation = editor.operations.get('linear-focus') || editor.operations.get('radial-focus');

    var initialOptions = {};
    if (operation) {
      initialOptions = operation.serializeOptions();
      delete initialOptions.enabled;
    }

    this.setSharedState({
      operation: operation,
      initialOperation: operation,
      operationExistedBefore: !!operation,
      initialOptions: initialOptions,
      inputDimensions: editor.getOutputDimensions()
    });
  };

  /**
   * Returns the assets that should be preloaded for this control
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {String[]}
   */


  FocusControls.getPreloadAssets = function getPreloadAssets(editor) {
    var assets = [];
    if (editor.isToolEnabled('radial-focus')) {
      assets.push('controls/focus/radial.png');
    }
    if (editor.isToolEnabled('linear-focus')) {
      assets.push('controls/focus/linear.png');
    }

    return assets;
  };

  return FocusControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

FocusControls.controlsComponent = _focusControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
FocusControls.canvasControlsComponent = _focusCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
FocusControls.identifier = 'focus';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
FocusControls.iconPath = 'controls/overview/focus.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
FocusControls.languageKey = 'controls.overview.focus';

/**
 * The default options for this control
 * @type {Object}
 */
FocusControls.defaultOptions = {};

exports.default = FocusControls;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _canvasControlsComponent = __webpack_require__(20);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LinearFocusCanvasControlsComponent = function (_CanvasControlsCompon) {
  (0, _inherits3.default)(LinearFocusCanvasControlsComponent, _CanvasControlsCompon);

  function LinearFocusCanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, LinearFocusCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _CanvasControlsCompon.call.apply(_CanvasControlsCompon, [this].concat(args)));

    _this._bindAll('_onCenterDragStart', '_onCenterDrag', '_onKnobDragStart', '_onKnobDrag', '_onOperationUpdated');

    _this.state = {
      areaPosition: new _globals.Vector2(),
      areaDimensions: new _globals.Vector2(),
      knobPosition: new _globals.Vector2()
    };
    _this._operation = _this.getSharedState('operation');

    _this._events = (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called after the canvas has been zoomed in or out
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._onCanvasZoomDone = function _onCanvasZoomDone() {
    this._setStylesFromOptions();
  };

  /**
   * Gets called when an operation has been updated
   * @param  {Operation} operation
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._onOperationUpdated = function _onOperationUpdated(operation) {
    if (operation !== this.getSharedState('operation')) return;
    this._setStylesFromOptions();
  };

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when the shared state did change
   * @param {Object} newState
   */


  LinearFocusCanvasControlsComponent.prototype.sharedStateDidChange = function sharedStateDidChange(newState) {
    if (newState.operation) {
      this._operation = newState.operation;
      if (this._operation.constructor.identifier === 'linear-focus') this._setStylesFromOptions();
    }
  };

  /**
   * Gets called when this component has been mounted
   */


  LinearFocusCanvasControlsComponent.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    _CanvasControlsCompon.prototype.componentDidMount.call(this);

    var editor = this.context.editor;

    editor.zoom.set('auto', function () {
      editor.features.disable('zoom', 'drag');
      _this2._setStylesFromOptions();
    });
  };

  // -------------------------------------------------------------------------- CENTER DRAGGING

  /**
   * Gets called when the user stars dragging the center
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._onCenterDragStart = function _onCenterDragStart() {
    this._initialStart = this._operation.getStart();
    this._initialEnd = this._operation.getEnd();
    this._initialDist = this._initialEnd.clone().subtract(this._initialStart);
  };

  /**
   * Gets called while the user drags the center
   * @param {Vector2} offset
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._onCenterDrag = function _onCenterDrag(offset) {
    var editor = this.context.editor;


    var outputDimensions = editor.getOutputDimensions();
    var relativeOffset = offset.clone().divide(outputDimensions);

    var newStart = this._initialStart.clone().add(relativeOffset).clamp(new _globals.Vector2(0, 0), new _globals.Vector2(1, 1).subtract(this._initialDist));
    var newEnd = newStart.clone().add(this._initialDist);

    this._operation.set({
      start: newStart,
      end: newEnd
    });

    editor.render();
    this._setStylesFromOptions();
    this.forceUpdate();
  };

  // -------------------------------------------------------------------------- GRADIENT KNOB DRAG

  /**
   * Gets called when the user stars dragging the gradient knob
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._onKnobDragStart = function _onKnobDragStart(e) {
    this._initialKnobPosition = this.state.knobPosition.clone();
  };

  /**
   * Gets called while the user drags the gradient knob
   * @param {Vector2} offset
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._onKnobDrag = function _onKnobDrag(offset) {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();

    var newKnobPosition = this._initialKnobPosition.clone().add(offset).clamp(new _globals.Vector2(0, 0), outputDimensions);

    var distanceFromCenter = newKnobPosition.clone().subtract(this.state.areaPosition);

    var start = this.state.areaPosition.clone().add(-distanceFromCenter.y, distanceFromCenter.x).divide(outputDimensions);
    var end = this.state.areaPosition.clone().add(distanceFromCenter.y, -distanceFromCenter.x).divide(outputDimensions);
    var size = distanceFromCenter.len() * 2;

    this._operation.set({
      start: start,
      end: end,
      size: size / outputDimensions.min(),
      gradientSize: size / outputDimensions.min()
    });
    this.setState({
      knobPosition: newKnobPosition,
      areaDimensions: new _globals.Vector2(this.state.areaDimensions.x, size)
    });
    editor.render();
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the CSS styles for the area div
   * @return {Object}
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._getAreaStyle = function _getAreaStyle() {
    var dist = this.state.knobPosition.clone().subtract(this.state.areaPosition);
    var degrees = Math.atan2(dist.x, dist.y) * (180 / Math.PI);
    var transform = 'rotate(' + (-degrees).toFixed(2) + 'deg)';

    return {
      width: this.state.areaDimensions.x,
      height: this.state.areaDimensions.y,
      left: this.state.areaPosition.x,
      top: this.state.areaPosition.y,
      marginLeft: this.state.areaDimensions.x * -0.5,
      marginTop: this.state.areaDimensions.y * -0.5,
      transform: transform,
      MozTransform: transform,
      msTransform: transform,
      WebkitTransform: transform
    };
  };

  /**
   * Returns the CSS styles for the knob
   * @return {Object}
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._getKnobStyle = function _getKnobStyle() {
    return {
      left: this.state.knobPosition.x,
      top: this.state.knobPosition.y
    };
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Sets the dimensions and position values from the current operation options
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._setStylesFromOptions = function _setStylesFromOptions() {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();

    var start = this._operation.getStart().clone().multiply(outputDimensions);
    var end = this._operation.getEnd().clone().multiply(outputDimensions);
    var size = this._operation.getSize() * outputDimensions.min();

    var dist = end.clone().subtract(start);
    var middle = start.clone().add(dist.clone().divide(2));

    var areaSize = new _globals.Vector2(outputDimensions.len() * 2, size);

    var totalDist = dist.len();
    var factor = dist.clone().divide(totalDist).divide(2);

    this.setState({
      areaDimensions: areaSize,
      areaPosition: middle.clone(),
      knobPosition: middle.clone().add(-size * factor.y, size * factor.x)
    });
  };

  /**
   * Returns the container style
   * @return {Object}
   * @private
   */


  LinearFocusCanvasControlsComponent.prototype._getContainerStyle = function _getContainerStyle() {
    var _context$editor$getSD = this.context.editor.getSDK().getSprite().getBounds(),
        x = _context$editor$getSD.x,
        y = _context$editor$getSD.y,
        width = _context$editor$getSD.width,
        height = _context$editor$getSD.height;

    return {
      left: x,
      top: y,
      width: width,
      height: height
    };
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  LinearFocusCanvasControlsComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'b:canvasControls e:container m:full', ref: 'container', style: this._getContainerStyle() },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:linearFocusCanvasControls' },
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onCenterDragStart,
            onDrag: this._onCenterDrag },
          _globals.ReactBEM.createElement('div', { bem: 'e:area', style: this._getAreaStyle() })
        ),
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onKnobDragStart,
            onDrag: this._onKnobDrag },
          _globals.ReactBEM.createElement('div', { bem: 'e:knob $b:knob', style: this._getKnobStyle() })
        )
      )
    );
  };

  return LinearFocusCanvasControlsComponent;
}(_canvasControlsComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = LinearFocusCanvasControlsComponent;


LinearFocusCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _canvasControlsComponent = __webpack_require__(20);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RadialFocusCanvasControlsComponent = function (_CanvasControlsCompon) {
  (0, _inherits3.default)(RadialFocusCanvasControlsComponent, _CanvasControlsCompon);

  function RadialFocusCanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, RadialFocusCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _CanvasControlsCompon.call.apply(_CanvasControlsCompon, [this].concat(args)));

    _this._bindAll('_onCenterDragStart', '_onCenterDrag', '_onKnobDragStart', '_onKnobDrag', '_onOperationUpdated');

    _this.state = {
      areaPosition: new _globals.Vector2(),
      areaDimensions: new _globals.Vector2(),
      knobPosition: new _globals.Vector2()
    };
    _this._knobChangedManually = false;
    _this._operation = _this.getSharedState('operation');

    _this._events = (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called after the canvas has been zoomed in or out
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._onCanvasZoomDone = function _onCanvasZoomDone() {
    this._setStylesFromOptions();
  };

  /**
   * Gets called when an operation has been updated
   * @param  {Operation} operation
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._onOperationUpdated = function _onOperationUpdated(operation) {
    if (operation !== this.getSharedState('operation')) return;
    this._knobChangedManually = false;
    this._setStylesFromOptions();
  };

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when the shared state did change
   * @param {Object} newState
   */


  RadialFocusCanvasControlsComponent.prototype.sharedStateDidChange = function sharedStateDidChange(newState) {
    if (newState.operation) {
      this._operation = newState.operation;
      if (this._operation.constructor.identifier === 'radial-focus') this._setStylesFromOptions();
    }
  };

  /**
   * Gets called when this component has been mounted
   */


  RadialFocusCanvasControlsComponent.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    _CanvasControlsCompon.prototype.componentDidMount.call(this);
    var editor = this.context.editor;

    editor.zoom.set('auto', function () {
      editor.features.disable('zoom', 'drag');
      _this2._setStylesFromOptions();
    });
  };

  // -------------------------------------------------------------------------- CENTER DRAGGING

  /**
   * Gets called when the user stars dragging the center
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._onCenterDragStart = function _onCenterDragStart() {
    this._initialPosition = this._operation.getPosition();
    this._initialKnobPosition = this.state.knobPosition.clone();
  };

  /**
   * Gets called while the user drags the center
   * @param {Vector2} offset
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._onCenterDrag = function _onCenterDrag(offset) {
    var editor = this.context.editor;


    var outputDimensions = editor.getOutputDimensions();
    var relativeOffset = offset.clone().divide(outputDimensions);
    var newPosition = this._initialPosition.clone().add(relativeOffset);

    var newKnobPosition = this._initialKnobPosition.clone().add(offset);

    this._operation.set({
      position: newPosition
    });

    this.state.knobPosition = newKnobPosition;

    editor.render();
    this._setStylesFromOptions();
  };

  // -------------------------------------------------------------------------- GRADIENT KNOB DRAG

  /**
   * Gets called when the user stars dragging the gradient knob
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._onKnobDragStart = function _onKnobDragStart(e) {
    this._knobChangedManually = true;
    this._initialKnobPosition = this.state.knobPosition.clone();
  };

  /**
   * Gets called while the user drags the gradient knob
   * @param {Vector2} offset
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._onKnobDrag = function _onKnobDrag(offset) {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();

    var newKnobPosition = this._initialKnobPosition.clone().add(offset).clamp(new _globals.Vector2(0, 0), outputDimensions);

    var position = this._operation.getPosition().clone().multiply(outputDimensions);

    var radius = newKnobPosition.clone().subtract(position).abs().len();
    var gradientRadius = radius / 2;

    this.setState({
      knobPosition: newKnobPosition,
      areaDimensions: new _globals.Vector2(radius * 2, radius * 2)
    });
    this._operation.set({
      radius: radius / outputDimensions.min(),
      gradientRadius: gradientRadius / outputDimensions.min()
    });

    editor.render();
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the CSS styles for the area div
   * @return {Object}
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._getAreaStyle = function _getAreaStyle() {
    return {
      width: this.state.areaDimensions.x,
      height: this.state.areaDimensions.y,
      left: this.state.areaPosition.x,
      top: this.state.areaPosition.y,
      marginLeft: this.state.areaDimensions.x * -0.5,
      marginTop: this.state.areaDimensions.y * -0.5
    };
  };

  /**
   * Returns the CSS styles for the knob
   * @return {Object}
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._getKnobStyle = function _getKnobStyle() {
    return {
      left: this.state.knobPosition.x,
      top: this.state.knobPosition.y
    };
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Sets the dimensions and position values from the current operation options
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._setStylesFromOptions = function _setStylesFromOptions() {
    var editor = this.context.editor;


    var outputDimensions = editor.getOutputDimensions();
    var position = this._operation.getPosition().clone().multiply(outputDimensions);

    var radius = this._operation.getRadius() * outputDimensions.min();
    var diameter = radius * 2;
    var areaSize = new _globals.Vector2(diameter, diameter);

    var newState = {
      areaDimensions: areaSize,
      areaPosition: position
    };

    if (!this._knobChangedManually) {
      newState.knobPosition = position.clone().add(radius, 0);
    }

    this.setState(newState);
  };

  /**
   * Returns the container style
   * @return {Object}
   * @private
   */


  RadialFocusCanvasControlsComponent.prototype._getContainerStyle = function _getContainerStyle() {
    var editor = this.context.editor;

    var _editor$getSDK$getSpr = editor.getSDK().getSprite().getBounds(),
        x = _editor$getSDK$getSpr.x,
        y = _editor$getSDK$getSpr.y,
        width = _editor$getSDK$getSpr.width,
        height = _editor$getSDK$getSpr.height;

    return {
      left: x,
      top: y,
      width: width,
      height: height
    };
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  RadialFocusCanvasControlsComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'b:canvasControls e:container m:full', ref: 'container', style: this._getContainerStyle() },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:radialFocusCanvasControls' },
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onCenterDragStart,
            onDrag: this._onCenterDrag },
          _globals.ReactBEM.createElement('div', { bem: 'e:area', style: this._getAreaStyle() })
        ),
        _globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onKnobDragStart,
            onDrag: this._onKnobDrag },
          _globals.ReactBEM.createElement('div', { bem: 'e:knob $b:knob', style: this._getKnobStyle() })
        )
      )
    );
  };

  return RadialFocusCanvasControlsComponent;
}(_canvasControlsComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = RadialFocusCanvasControlsComponent;


RadialFocusCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _frameManager = __webpack_require__(190);

var _frameManager2 = _interopRequireDefault(_frameManager);

var _frameItemComponent = __webpack_require__(123);

var _frameItemComponent2 = _interopRequireDefault(_frameItemComponent);

var _colorPickerComponent = __webpack_require__(38);

var _colorPickerComponent2 = _interopRequireDefault(_colorPickerComponent);

var _sliderOverlayComponent = __webpack_require__(12);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FrameOverviewControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(FrameOverviewControlsComponent, _ControlsComponent);

  function FrameOverviewControlsComponent() {
    var _this$_events;

    (0, _classCallCheck3.default)(this, FrameOverviewControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._operation = _this.getSharedState('operation');
    _this._bindAll('_onScaleChange', '_onColorChange', '_onOperationUpdated', '_onOperationRemoved');

    _this._events = (_this$_events = {}, (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated), (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved), _this$_events);

    _this._initFrameManager();
    return _this;
  }

  // -------------------------------------------------------------------------- FRAMES

  /**
   * Initializes the frame manager
   * @private
   */


  FrameOverviewControlsComponent.prototype._initFrameManager = function _initFrameManager() {
    this._frameManager = new _frameManager2.default(this.context.ui, this.props.options);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when an operation has been updated
   * @param  {Operation} operation
   * @private
   */


  FrameOverviewControlsComponent.prototype._onOperationUpdated = function _onOperationUpdated(operation) {
    if (operation === this.getSharedState('operation')) {
      this.forceSharedUpdate();
    }
  };

  /**
   * Gets called when an operation has been removed
   * @param  {Operation} operation
   * @private
   */


  FrameOverviewControlsComponent.prototype._onOperationRemoved = function _onOperationRemoved(operation) {
    if (operation !== this.getSharedState('operation')) return;
    if (this._backButtonClicked) return;

    // Operation can be removed by the undo button. We need
    // to make sure we re-create the operation for the lifetime
    // of this control
    var editor = this.context.editor;

    var newOperation = editor.operations.getOrCreate('frame');

    this.setSharedState({
      operation: newOperation,
      frame: null,
      operationExistedBefore: false,
      initialOptions: {}
    });

    editor.render();
  };

  /**
   * Gets called when the scale has been changed
   * @param  {Number} scale
   * @private
   */


  FrameOverviewControlsComponent.prototype._onScaleChange = function _onScaleChange(scale) {
    var editor = this.context.editor;


    var inputDimensions = this.getSharedState('inputDimensions');
    this._operation.setScale(scale / inputDimensions.min());

    editor.render();
  };

  /**
   * Gets called when the tint color has been changed
   * @param  {PhotoEditorSDK.Color} color
   * @private
   */


  FrameOverviewControlsComponent.prototype._onColorChange = function _onColorChange(color) {
    var operation = this.getSharedState('operation');
    operation.setTintColor(color.clone());

    var editor = this.context.editor;

    editor.render();
  };

  /**
   * Gets called when the user clicks the back button
   * @param {Event} e
   * @private
   */


  FrameOverviewControlsComponent.prototype._onBackClick = function _onBackClick(e) {
    this._backButtonClicked = true;
    this.props.onSwitchControls('home');
  };

  /**
   * Gets called when a frame has been clicked
   * @param  {Object} frame
   * @private
   */


  FrameOverviewControlsComponent.prototype._onFrameClick = function _onFrameClick(frame) {
    var _this2 = this;

    var editor = this.context.editor;

    var operation = this.getSharedState('operation');
    if (frame === null) {
      operation.setFrame(null);
      editor.render();
      return this.forceSharedUpdate();
    }

    var loadingModal = void 0;
    var loadTimeout = setTimeout(function () {
      loadingModal = _modalManager2.default.instance.displayLoading(_this2._t('loading.loading'));
    }, 100);

    frame.load().then(function () {
      if (loadingModal) loadingModal.close();
      if (loadTimeout) {
        clearTimeout(loadTimeout);
        loadTimeout = null;
      }

      var frameObject = frame.getFrame();
      operation.setFrame(frameObject);

      var editor = _this2.context.editor;

      editor.render();

      _this2.setSharedState({ frame: frame });
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the overlay controls of this component
   * @return {ReactBEM.Element}
   */


  FrameOverviewControlsComponent.prototype.renderOverlayControls = function renderOverlayControls() {
    var frame = this.getSharedState('frame');

    if (!frame) return null;

    var inputDimensions = this.getSharedState('inputDimensions');

    var minThickness = 5;
    var maxThickness = Math.round(0.3 * inputDimensions.min());
    var currentScale = this._operation.getScale() * inputDimensions.min();

    return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
      minValue: minThickness,
      maxValue: maxThickness,
      value: currentScale,
      valueUnit: 'px',
      middleDot: false,
      label: this._t('controls.frame.scale'),
      onChange: this._onScaleChange });
  };

  /**
   * Renders the list items for this control
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  FrameOverviewControlsComponent.prototype._renderListItems = function _renderListItems() {
    var _this3 = this;

    var frames = this._frameManager.getFrames();
    var currentFrame = this.getSharedState('operation').getFrame();

    var noFrameItem = _globals.ReactBEM.createElement(
      'li',
      {
        bem: 'e:item',
        key: 'no-frame',
        onClick: this._onFrameClick.bind(this, null) },
      _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:button m:withLabel',
            className: !currentFrame ? 'is-active' : null },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/frame/no-frame.png', true) }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this._t('controls.frame.noFrame')
          )
        )
      )
    );

    return [noFrameItem].concat(frames.map(function (frame, i) {
      return _globals.ReactBEM.createElement(_frameItemComponent2.default, {
        frame: frame,
        active: currentFrame && currentFrame.name === frame.getName(),
        onClick: _this3._onFrameClick.bind(_this3, frame) });
    }));
  };

  /**
   * Renders the controls of this component
   * @return {ReactBEM.Element}
   */


  FrameOverviewControlsComponent.prototype.renderControls = function renderControls() {
    var frame = this.getSharedState('operation').getFrame();
    var listItems = this._renderListItems();

    var items = [_globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:list' },
      _globals.ReactBEM.createElement(
        _scrollbarComponent2.default,
        { ref: 'scrollbar' },
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:list' },
          listItems
        )
      )
    )];

    if (frame && frame.tintable) {
      var operation = this.getSharedState('operation');
      items.push(_globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:colorPicker' },
        _globals.ReactBEM.createElement(_colorPickerComponent2.default, {
          initialValue: operation.getTintColor().clone(),
          onChange: this._onColorChange })
      ));
    }

    return items;
  };

  return FrameOverviewControlsComponent;
}(_controlsComponent2.default);

exports.default = FrameOverviewControlsComponent;


FrameOverviewControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FrameItemComponent = function (_BaseComponent) {
  (0, _inherits3.default)(FrameItemComponent, _BaseComponent);

  function FrameItemComponent() {
    (0, _classCallCheck3.default)(this, FrameItemComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this.state = {
      frame: _this.props.frame
    };
    return _this;
  }

  /**
   * Gets called when this component has been mounted
   */


  FrameItemComponent.prototype.componentDidMount = function componentDidMount() {
    this._renderFrame();
  };

  /**
   * Gets called when this component is about to receive new properties
   * @param  {Object} nextProps
   */


  FrameItemComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (this.props.frame !== nextProps.frame) {
      this.setState({ frame: nextProps.frame }, function () {
        _this2._renderFrame();
      });
    }
  };

  /**
   * Renders the frame onto the canvas
   * @private
   */


  FrameItemComponent.prototype._renderFrame = function _renderFrame() {
    var editor = this.context.editor;

    var sdk = editor.getSDK();

    var frame = this.props.frame;


    var resolvedFramePath = this._getAssetPath(frame.getIcon());
    var canvas = this.refs['canvas-' + frame.getName()];

    var pixelRatio = sdk.getPixelRatio();
    canvas.width = canvas.offsetWidth * pixelRatio;
    canvas.height = canvas.offsetHeight * pixelRatio;

    canvas.style.width = canvas.offsetWidth + 'px';
    canvas.style.height = canvas.offsetHeight + 'px';

    var context = canvas.getContext('2d');

    var image = new window.Image();
    image.addEventListener('load', function () {
      var scale = Math.min(canvas.width / image.width, canvas.height / image.height);
      var drawSize = new _globals.Vector2(image.width, image.height).multiply(scale);
      var drawPosition = new _globals.Vector2(canvas.width, canvas.height).divide(2).subtract(drawSize.clone().divide(2));

      context.drawImage(image, 0, 0, image.width, image.height, drawPosition.x, drawPosition.y, drawSize.x, drawSize.y);
    });
    image.src = resolvedFramePath;
  };

  /**
   * Renders this element
   * @return {ReactBEM.element}
   */


  FrameItemComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: 'b:controls e:list' },
      _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: this.props.frame.getName(),
          onClick: this.props.onClick },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:controls' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:button m:withInlineLabel' },
            _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas m:large', ref: 'canvas-' + this.props.frame.getName() }),
            _globals.ReactBEM.createElement(
              'div',
              { bem: '$e:inlineLabel', className: this.props.active ? 'is-active' : null },
              _globals.ReactBEM.createElement(
                'div',
                { bem: 'e:label' },
                this.props.frame.getLabel()
              )
            )
          )
        )
      )
    );
  };

  return FrameItemComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = FrameItemComponent;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _frameControlsComponent = __webpack_require__(122);

var _frameControlsComponent2 = _interopRequireDefault(_frameControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The frame controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FrameControls = function (_Controls) {
  (0, _inherits3.default)(FrameControls, _Controls);

  function FrameControls() {
    (0, _classCallCheck3.default)(this, FrameControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  /**
   * Gets called when the user leaves these controls
   * @this {FrameControlsComponent}
   * @override
   * @ignore
   */
  FrameControls.onExit = function onExit() {
    var editor = this.context.editor;

    var operation = this.getSharedState('operation');
    var initialOptions = this.getSharedState('initialOptions');

    var frame = operation.getFrame();
    var scale = operation.getScale();

    if ((frame && frame.name) !== (initialOptions.frame && initialOptions.frame.name) || scale !== initialOptions.scale) {
      editor.history.add(operation, this.getSharedState('initialOptions'), this.getSharedState('operationExistedBefore'));
    }

    if (!operation.getFrame()) {
      editor.operations.remove(operation);
    }

    editor.zoom.undo();
    editor.features.enable('zoom', 'drag');
    editor.render();
  };

  /**
   * Gets called when the user enters these controls
   * @this {FrameControlsComponent}
   * @param {SharedState} sharedState
   * @override
   * @ignore
   */


  FrameControls.onEnter = function onEnter(sharedState) {
    var editor = this.context.editor;

    var operationExistedBefore = editor.operations.exists('frame');
    var operation = editor.operations.getOrCreate('frame');
    var initialOptions = operation.serializeOptions();

    this.setSharedState({
      operation: operation,
      operationExistedBefore: operationExistedBefore,
      initialOptions: initialOptions,
      inputDimensions: operation.getInputDimensions(),
      frame: operation.getFrame()
    });
  };

  /**
   * Checks if this control is available to the user
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {Boolean}
   * @override
   * @ignore
   */


  FrameControls.isAvailable = function isAvailable(editor) {
    return editor.isToolEnabled('frame');
  };

  return FrameControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


FrameControls.controlsComponent = _frameControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
FrameControls.identifier = 'frame';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
FrameControls.iconPath = 'controls/overview/frame.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
FrameControls.languageKey = 'controls.overview.frame';

/**
 * The default options for this control
 * @type {Object}
 * @property {Object[]} [frames = []]
 */
FrameControls.defaultOptions = {
  frames: []
};

exports.default = FrameControls;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(24);

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MiniSliderComponent = function (_BaseComponent) {
  (0, _inherits3.default)(MiniSliderComponent, _BaseComponent);

  function MiniSliderComponent() {
    (0, _classCallCheck3.default)(this, MiniSliderComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this.state = {
      value: _this.props.value || 0,
      sliderPosition: 0,
      foregroundLeft: 0,
      foregroundWidth: 0
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after the component has been mounted
   */


  MiniSliderComponent.prototype.componentDidMount = function componentDidMount() {
    // Trigger a re-render to position the knob
    this._setValue(this.state.value, false);
  };

  /**
   * Gets called when this component receives new props
   * @param  {Object} props
   */


  MiniSliderComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
    if (props.value !== this.state.value) {
      this._setValue(props.value, false);
    }
  };

  /**
   * Returns the style for the knob (position)
   * @return {Object}
   * @private
   */


  MiniSliderComponent.prototype._getKnobStyle = function _getKnobStyle() {
    return { left: this.state.sliderPosition };
  };

  /**
   * Returns the style for the foreground bar
   * @return {Object}
   * @private
   */


  MiniSliderComponent.prototype._getForegroundStyle = function _getForegroundStyle() {
    return {
      left: this.state.foregroundLeft,
      width: this.state.foregroundWidth
    };
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Decides whether or not this slider should have a middle dot on the bar
   * @private
   */


  MiniSliderComponent.prototype._displayMiddleDot = function _displayMiddleDot() {
    return this.props.middleDot !== false;
  };

  /**
   * Sets the value to the given value, updates the slider position
   * @param {Number} value
   * @param {Boolean} emitChange = true
   * @private
   */


  MiniSliderComponent.prototype._setValue = function _setValue(value) {
    var emitChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    value = Math.round(value);
    var _props = this.props,
        minValue = _props.minValue,
        maxValue = _props.maxValue;

    var progress = (value - minValue) / (maxValue - minValue);

    // Calculate slider position
    var bar = this.refs.bar;

    var barWidth = bar.offsetWidth;
    var sliderPosition = barWidth * progress;

    // Calculate foreground position and width
    var foregroundWidth = progress * barWidth;
    var foregroundLeft = 0;
    if (this._displayMiddleDot()) {
      foregroundWidth = Math.abs(progress - 0.5) * barWidth;
      foregroundLeft = progress < 0.5 ? barWidth * 0.5 - foregroundWidth : '50%';
    }

    this.setState({ value: value, sliderPosition: sliderPosition, foregroundWidth: foregroundWidth, foregroundLeft: foregroundLeft });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  MiniSliderComponent.prototype.renderWithBEM = function renderWithBEM() {
    var foregroundProps = {
      style: this._getForegroundStyle()
    };

    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:miniSlider' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:bar', ref: 'bar' },
        _globals.ReactBEM.createElement('div', { bem: '$e:background' }),
        _globals.ReactBEM.createElement('div', (0, _extends3.default)({ bem: '$e:foreground' }, foregroundProps)),
        _globals.ReactBEM.createElement('div', { bem: 'e:knob', style: this._getKnobStyle() })
      )
    );
  };

  return MiniSliderComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


exports.default = MiniSliderComponent;


MiniSliderComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _topBarComponent = __webpack_require__(130);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _overviewControlsComponent = __webpack_require__(63);

var _overviewControlsComponent2 = _interopRequireDefault(_overviewControlsComponent);

var _overviewCanvasControlsComponent = __webpack_require__(127);

var _overviewCanvasControlsComponent2 = _interopRequireDefault(_overviewCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverviewControls = function (_Controls) {
  (0, _inherits3.default)(OverviewControls, _Controls);

  function OverviewControls() {
    (0, _classCallCheck3.default)(this, OverviewControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  return OverviewControls;
}(_controls2.default);

/**
 * This control's top bar controls component. Used for the sub-header part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


OverviewControls.topBarControlsComponent = _topBarComponent2.default;

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
OverviewControls.controlsComponent = _overviewControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
OverviewControls.canvasControlsComponent = _overviewCanvasControlsComponent2.default;

exports.default = OverviewControls;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _canvasControlsComponent = __webpack_require__(20);

var _canvasControlsComponent2 = _interopRequireDefault(_canvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverviewCanvasControlsComponent = function (_CanvasControlsCompon) {
  (0, _inherits3.default)(OverviewCanvasControlsComponent, _CanvasControlsCompon);

  function OverviewCanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, OverviewCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _CanvasControlsCompon.call.apply(_CanvasControlsCompon, [this].concat(args)));

    _this._bindAll('_onClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks somewhere on the canvas
   * @param  {Event} e
   * @private
   */


  OverviewCanvasControlsComponent.prototype._onClick = function _onClick(e) {
    this._performHitTest(_globals.Utils.getEventPosition(e));
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the container style
   * @return {Object}
   * @private
   */


  OverviewCanvasControlsComponent.prototype._getContainerStyle = function _getContainerStyle() {
    if (!this.context.editor.isReady()) {
      return { left: 0, top: 0, width: 1, height: 1 };
    }

    var _context$editor$getSD = this.context.editor.getSDK().getSprite().getBounds(),
        x = _context$editor$getSD.x,
        y = _context$editor$getSD.y,
        width = _context$editor$getSD.width,
        height = _context$editor$getSD.height;

    return {
      left: x,
      top: y,
      width: width,
      height: height
    };
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  OverviewCanvasControlsComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      {
        bem: '$b:canvasControls e:container m:full',
        ref: 'container' },
      _globals.ReactBEM.createElement('div', {
        bem: '$b:canvasControls e:innerContainer',
        ref: 'innerContainer',
        style: this._getContainerStyle(),
        onClick: this._onClick,
        onTouchStart: this._onClick })
    );
  };

  return OverviewCanvasControlsComponent;
}(_canvasControlsComponent2.default);

exports.default = OverviewCanvasControlsComponent;


OverviewCanvasControlsComponent.contextTypes = _canvasControlsComponent2.default.contextTypes;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _buttonComponent = __webpack_require__(42);

var _buttonComponent2 = _interopRequireDefault(_buttonComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ExportButtonComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ExportButtonComponent, _BaseComponent);

  function ExportButtonComponent() {
    (0, _classCallCheck3.default)(this, ExportButtonComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onButtonClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the button has been clicked
   * @private
   */


  ExportButtonComponent.prototype._onButtonClick = function _onButtonClick() {
    var _this2 = this;

    var _context = this.context,
        options = _context.options,
        editor = _context.editor,
        editorScreen = _context.editorScreen;

    var exportOptions = options.editor.export;

    editorScreen.switchToControls('home', null, function () {
      var loadingModal = _modalManager2.default.instance.displayLoading(_this2._t('loading.exporting'));

      // Give it some time to display the loading modal
      setTimeout(function () {
        editor.export(exportOptions.download).then(function () {
          loadingModal.close();
        }).catch(function (e) {
          _modalManager2.default.instance.displayError(_this2._t('errors.title'), e.message);
          loadingModal.close();
        });
      }, 100);
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  ExportButtonComponent.prototype.renderWithBEM = function renderWithBEM() {
    var options = this.context.options;

    if (!options.editor.export.showButton) return null;

    return _globals.ReactBEM.createElement(_buttonComponent2.default, {
      style: 'blue',
      label: this._t('editor.export'),
      icon: 'editor/export.png',
      onClick: this._onButtonClick });
  };

  return ExportButtonComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = ExportButtonComponent;


ExportButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _buttonComponent = __webpack_require__(42);

var _buttonComponent2 = _interopRequireDefault(_buttonComponent);

var _invisibleUploadComponent = __webpack_require__(41);

var _invisibleUploadComponent2 = _interopRequireDefault(_invisibleUploadComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NewFileButtonComponent = function (_BaseComponent) {
  (0, _inherits3.default)(NewFileButtonComponent, _BaseComponent);

  function NewFileButtonComponent() {
    (0, _classCallCheck3.default)(this, NewFileButtonComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onNewFile', '_onButtonClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user has selected a new file
   * @param {Image} image
   */


  NewFileButtonComponent.prototype._onNewFile = function _onNewFile(image) {
    var editor = this.context.editor;

    editor.reset();
    editor.setImage(image);
    editor.zoom.set('auto');
  };

  /**
   * Gets called when the button has been clicked
   * @private
   */


  NewFileButtonComponent.prototype._onButtonClick = function _onButtonClick() {
    var options = this.context.options;

    var webcamEnabled = options.enableWebcam === false || _globals.Utils.isMobile();
    var photoRollEnabled = !!options.photoRoll.provider;
    if (webcamEnabled && !photoRollEnabled) {
      this.refs.upload.open();
    } else if (photoRollEnabled) {
      this.props.app.switchToScreen('photoRoll');
    } else {
      this.props.app.switchToScreen('splash');
    }
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  NewFileButtonComponent.prototype.renderWithBEM = function renderWithBEM() {
    var options = this.context.options;


    var buttonLabel = null;
    if (options.photoRoll.provider) {
      buttonLabel = this._t('editor.backgroundImage');
    } else {
      buttonLabel = this._t('editor.new');
    }

    return _globals.ReactBEM.createElement(
      'div',
      null,
      _globals.ReactBEM.createElement(_invisibleUploadComponent2.default, { onNewFile: this._onNewFile, ref: 'upload' }),
      _globals.ReactBEM.createElement(_buttonComponent2.default, {
        label: buttonLabel,
        icon: 'editor/new.png',
        onClick: this._onButtonClick })
    );
  };

  return NewFileButtonComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = NewFileButtonComponent;


NewFileButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _topBarComponent = __webpack_require__(32);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _newFileButtonComponent = __webpack_require__(129);

var _newFileButtonComponent2 = _interopRequireDefault(_newFileButtonComponent);

var _exportButtonComponent = __webpack_require__(128);

var _exportButtonComponent2 = _interopRequireDefault(_exportButtonComponent);

var _undoButtonComponent = __webpack_require__(131);

var _undoButtonComponent2 = _interopRequireDefault(_undoButtonComponent);

var _zoomComponent = __webpack_require__(132);

var _zoomComponent2 = _interopRequireDefault(_zoomComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverviewTopBarComponent = function (_TopBarComponent) {
  (0, _inherits3.default)(OverviewTopBarComponent, _TopBarComponent);

  function OverviewTopBarComponent() {
    (0, _classCallCheck3.default)(this, OverviewTopBarComponent);
    return (0, _possibleConstructorReturn3.default)(this, _TopBarComponent.apply(this, arguments));
  }

  /**
   * Renders the content of this OverviewTopBarComponent
   * @return {ReactBEM.Element}
   */
  OverviewTopBarComponent.prototype.renderContent = function renderContent() {
    var newFileButton = null;
    if (this.context.options.enableUpload) {
      newFileButton = _globals.ReactBEM.createElement(_newFileButtonComponent2.default, { app: this.props.app });
    }

    var zoomComponent = null;
    if (this.context.options.editor.enableZoom) {
      zoomComponent = _globals.ReactBEM.createElement(_zoomComponent2.default, null);
    }

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:topBar' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:left' },
        newFileButton
      ),
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:right' },
        _globals.ReactBEM.createElement(_undoButtonComponent2.default, null),
        _globals.ReactBEM.createElement(_exportButtonComponent2.default, null)
      ),
      zoomComponent
    );
  };

  return OverviewTopBarComponent;
}(_topBarComponent2.default);

exports.default = OverviewTopBarComponent;


OverviewTopBarComponent.contextTypes = _topBarComponent2.default.contextTypes;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _buttonComponent = __webpack_require__(42);

var _buttonComponent2 = _interopRequireDefault(_buttonComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var UndoButtonComponent = function (_BaseComponent) {
  (0, _inherits3.default)(UndoButtonComponent, _BaseComponent);

  function UndoButtonComponent() {
    var _this$_events;

    (0, _classCallCheck3.default)(this, UndoButtonComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onButtonClick', '_onHistoryUpdated', '_onFeaturesUpdated');

    _this._events = (_this$_events = {}, (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.HISTORY_UPDATED, _this._onHistoryUpdated), (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.FEATURES_UPDATED, _this._onFeaturesUpdated), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the features have been enabled or disabled
   * @private
   */


  UndoButtonComponent.prototype._onFeaturesUpdated = function _onFeaturesUpdated() {
    this.forceUpdate();
  };

  /**
   * Gets called when the history has been updated
   * @private
   */


  UndoButtonComponent.prototype._onHistoryUpdated = function _onHistoryUpdated() {
    this.forceUpdate();
  };

  /**
   * Gets called when the button has been clicked
   * @private
   */


  UndoButtonComponent.prototype._onButtonClick = function _onButtonClick() {
    var editor = this.context.editor;

    editor.history.undo();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  UndoButtonComponent.prototype.renderWithBEM = function renderWithBEM() {
    var editor = this.context.editor;

    if (!editor.history.isAvailable()) return null;

    return _globals.ReactBEM.createElement(_buttonComponent2.default, {
      label: this._t('editor.undo'),
      icon: 'editor/undo.png',
      onClick: this._onButtonClick });
  };

  return UndoButtonComponent;
}(_globals.BaseComponent);

exports.default = UndoButtonComponent;


UndoButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ZoomComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ZoomComponent, _BaseComponent);

  function ZoomComponent() {
    var _this$_events;

    (0, _classCallCheck3.default)(this, ZoomComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onZoomOutClick', '_onZoomInClick', '_onZoomDone', '_onFeaturesUpdated');

    _this._events = (_this$_events = {}, (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.ZOOM_DONE, _this._onZoomDone), (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.FEATURES_UPDATED, _this._onFeaturesUpdated), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the features have been updated
   * @private
   */


  ZoomComponent.prototype._onFeaturesUpdated = function _onFeaturesUpdated() {
    this.forceUpdate();
  };

  /**
   * Gets called when the new zoom level has been applied
   * @private
   */


  ZoomComponent.prototype._onZoomDone = function _onZoomDone() {
    this.forceUpdate();
  };

  /**
   * Gets called when the user clicks the "zoom out" button
   * @param {Event} e
   * @private
   */


  ZoomComponent.prototype._onZoomOutClick = function _onZoomOutClick(e) {
    var editor = this.context.editor;

    if (!editor.features.isEnabled('zoom')) return;

    editor.zoom.zoomOut();
  };

  /**
   * Gets called when the user clicks the "zoom in" button
   * @param {Event} e
   * @private
   */


  ZoomComponent.prototype._onZoomInClick = function _onZoomInClick(e) {
    var editor = this.context.editor;

    if (!editor.features.isEnabled('zoom')) return;

    editor.zoom.zoomIn();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  ZoomComponent.prototype.renderWithBEM = function renderWithBEM() {
    var editor = this.context.editor;

    var zoom = editor.zoom.get();
    var enabled = editor.features.isEnabled('zoom');

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: 'b:editorScreen' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:zoom' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:button m:zoomOut',
            onClick: this._onZoomOutClick,
            className: enabled ? null : 'is-disabled' },
          _globals.ReactBEM.createElement('img', { bem: 'e:image', src: this._getAssetPath('controls/minus.png', true) })
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label' },
          'Zoom',
          _globals.ReactBEM.createElement('br', null),
          Math.round(zoom * 100),
          '%'
        ),
        _globals.ReactBEM.createElement(
          'div',
          {
            bem: '$e:button m:zoomIn',
            onClick: this._onZoomInClick,
            className: enabled ? null : 'is-disabled' },
          _globals.ReactBEM.createElement('img', { bem: 'e:image', src: this._getAssetPath('controls/plus.png', true) })
        )
      )
    );
  };

  return ZoomComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = ZoomComponent;


ZoomComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _selectiveBlurControlsComponent = __webpack_require__(135);

var _selectiveBlurControlsComponent2 = _interopRequireDefault(_selectiveBlurControlsComponent);

var _selectiveBlurCanvasControlsComponent = __webpack_require__(134);

var _selectiveBlurCanvasControlsComponent2 = _interopRequireDefault(_selectiveBlurCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The selective blur controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var SelectiveBlurControls = function (_Controls) {
  (0, _inherits3.default)(SelectiveBlurControls, _Controls);

  function SelectiveBlurControls() {
    (0, _classCallCheck3.default)(this, SelectiveBlurControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  /**
   * Gets called when the user leaves these controls
   * @this {SelectiveBlurControlsComponent}
   * @override
   * @ignore
   */
  SelectiveBlurControls.onExit = function onExit() {
    var editor = this.context.editor;

    var operation = this.getSharedState('operation');

    if (operation.getPaths().length === 0) {
      editor.operations.remove(operation);
    }

    editor.zoom.undo();
    editor.features.enable('zoom', 'drag');
    editor.render();
  };

  /**
   * Gets called when the user enters these controls
   * @this {SelectiveBlurControlsComponent}
   * @param {SharedState} sharedState
   * @param {Object} options
   * @override
   * @ignore
   */


  SelectiveBlurControls.onEnter = function onEnter(sharedState, options) {
    var editor = this.context.editor;


    editor.zoom.set('auto', function () {
      editor.render();
    });

    var outputDimensions = editor.getOutputDimensions();
    var operationExistedBefore = editor.operations.exists('selective-blur');
    var operation = editor.operations.getOrCreate('selective-blur');
    var initialOptions = operation.serializeOptions();
    var brush = operation.getBrush();

    var thickness = outputDimensions.min() * 0.1;
    var hardness = 1;

    var inputDimensions = operation.getInputDimensions();

    this.setSharedState({
      operationExistedBefore: operationExistedBefore, operation: operation, brush: brush, initialOptions: initialOptions, thickness: thickness, hardness: hardness, inputDimensions: inputDimensions
    });
  };

  /**
   * Checks if this control is available to the user
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {Boolean}
   * @override
   * @ignore
   */


  SelectiveBlurControls.isAvailable = function isAvailable(editor) {
    return editor.isToolEnabled('selective-blur');
  };

  return SelectiveBlurControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

SelectiveBlurControls.controlsComponent = _selectiveBlurControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
SelectiveBlurControls.canvasControlsComponent = _selectiveBlurCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
SelectiveBlurControls.identifier = 'selective-blur';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
SelectiveBlurControls.iconPath = 'controls/overview/selective-blur.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
SelectiveBlurControls.languageKey = 'controls.overview.selective-blur';

/**
 * The default options for this control
 * @type {Object}
 */
SelectiveBlurControls.defaultOptions = {};

exports.default = SelectiveBlurControls;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _spritesCanvasControlsComponent = __webpack_require__(31);

var _spritesCanvasControlsComponent2 = _interopRequireDefault(_spritesCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushCanvasControlsComponent = function (_SpritesCanvasControl) {
  (0, _inherits3.default)(BrushCanvasControlsComponent, _SpritesCanvasControl);

  function BrushCanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, BrushCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _SpritesCanvasControl.call.apply(_SpritesCanvasControl, [this].concat(args)));

    _this._windowResized = false;
    _this._drawing = false;
    _this._bindAll('_onMouseEnter', '_onMouseLeave', '_onMouseDown', '_onMouseMove', '_onMouseUp', '_onMouseMoveOnCanvas', '_onWindowResize');

    _this._lastDrawPosition = null;

    _this._events = _globals.SDKUtils.extend(_this._events, (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.WINDOW_RESIZE, _this._onWindowResize));

    _this.state = {
      cursorVisible: false,
      cursorPosition: new _globals.Vector2()
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  BrushCanvasControlsComponent.prototype.componentDidMount = function componentDidMount() {
    _SpritesCanvasControl.prototype.componentDidMount.call(this);
    this._updateContainerRect();
  };

  /**
   * Gets called when this component has been updated
   */


  BrushCanvasControlsComponent.prototype.componentDidUpdate = function componentDidUpdate() {
    if (this._windowResized) {
      this._updateContainerRect();
      this._windowResized = false;
    }
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the window has been resized
   * @private
   */


  BrushCanvasControlsComponent.prototype._onWindowResize = function _onWindowResize() {
    this._windowResized = true;
  };

  /**
   * Gets called when an operation has been removed
   * @param  {Operation} operation
   * @private
   */


  BrushCanvasControlsComponent.prototype._onOperationRemoved = function _onOperationRemoved(operation) {};

  /**
   * Gets called when an operation has been updated
   * @param  {Operation} operation
   * @private
   */


  BrushCanvasControlsComponent.prototype._onOperationUpdated = function _onOperationUpdated(operation) {
    if (operation === this.getSharedState('operation')) {
      this.forceUpdate();
    }
  };

  /**
   * Gets called when the user presses a mouse button
   * @param  {Event} e
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseDown = function _onMouseDown(e) {
    e.preventDefault();

    var operation = this.getSharedState('operation');
    this._optionsBeforeDraw = operation.serializeOptions();
    delete this._optionsBeforeDraw.enabled;

    this._operationExistedBeforeDraw = this.getSharedState('operationExistedBefore');
    this.setSharedState({ operationExistedBefore: true }, false);

    var outputDimensions = this.context.editor.getOutputDimensions();
    var cursorPosition = this._getCursorPosition(e);

    var thickness = this.getSharedState('thickness') / outputDimensions.min();
    var hardness = this.getSharedState('hardness');
    this._drawing = true;
    this._currentPath = operation.createPath(thickness, hardness);
    this._currentPath.addControlPoint(cursorPosition.clone().divide(outputDimensions));

    document.addEventListener('mousemove', this._onMouseMove);
    document.addEventListener('touchmove', this._onMouseMove);
    document.addEventListener('mouseup', this._onMouseUp);
    document.addEventListener('touchend', this._onMouseUp);
  };

  /**
   * Gets called when the user releases a mouse button
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseUp = function _onMouseUp() {
    this._currentPath.setClosed(true);

    var editor = this.context.editor;

    editor.render();

    this._currentPath = null;
    this._drawing = false;

    editor.history.add(this.getSharedState('operation'), this._optionsBeforeDraw, this._operationExistedBeforeDraw);

    document.removeEventListener('mousemove', this._onMouseMove);
    document.removeEventListener('touchmove', this._onMouseMove);
    document.removeEventListener('mouseup', this._onMouseUp);
    document.removeEventListener('touchend', this._onMouseUp);
  };

  /**
   * Gets called when the user enters the canvas
   * @param {Event} event
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseEnter = function _onMouseEnter(e) {
    var cursorPosition = this._getCursorPosition(e);
    this.setState({
      cursorVisible: true,
      cursorPosition: cursorPosition
    });
    this._onMouseMove(e);
  };

  /**
   * Gets called when the user leaves the canvas
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseLeave = function _onMouseLeave() {
    this.setState({
      cursorVisible: false
    });
  };

  /**
   * Gets called while the user moves the mouse
   * @param {Event} e
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseMove = function _onMouseMove(e) {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();

    var zoom = editor.zoom.get();
    var cursorPosition = this._getCursorPosition(e);
    this.setState({ cursorPosition: cursorPosition });

    var shouldDraw = void 0;
    if (!this._lastDrawPosition) {
      shouldDraw = true;
    } else {
      var brushSize = this.getSharedState('thickness');
      var distance = this._lastDrawPosition.clone().subtract(cursorPosition).abs().len() / zoom;
      shouldDraw = distance >= brushSize / 10;
    }

    if (this._drawing && shouldDraw) {
      this._currentPath.addControlPoint(cursorPosition.clone().divide(outputDimensions));
      this._lastDrawPosition = cursorPosition.clone();

      editor.render();
    }
  };

  /**
   * Gets called while the user moves the mouse on top of the canvas. Updates
   * the cursor cursor position
   * @param  {Event} e
   * @private
   */


  BrushCanvasControlsComponent.prototype._onMouseMoveOnCanvas = function _onMouseMoveOnCanvas(e) {
    var cursorPosition = this._getCursorPosition(e);
    this.setState({ cursorPosition: cursorPosition });
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the cursor's style object
   * @return {Object}
   * @private
   */


  BrushCanvasControlsComponent.prototype._getCursorStyle = function _getCursorStyle() {
    var thickness = this.getSharedState('thickness');

    var cursorPosition = this.state.cursorPosition;

    return {
      left: cursorPosition.x,
      top: cursorPosition.y,
      width: thickness,
      height: thickness,
      marginLeft: thickness * -0.5,
      marginTop: thickness * -0.5
    };
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Updates the container bounding rect
   * @private
   */


  BrushCanvasControlsComponent.prototype._updateContainerRect = function _updateContainerRect() {
    this._containerBoundingRect = this.refs.innerContainer.getBoundingClientRect();
  };

  /**
   * Returns the cursor position for the given event
   * @param  {Event} event
   * @private
   */


  BrushCanvasControlsComponent.prototype._getCursorPosition = function _getCursorPosition(event) {
    var position = _globals.Utils.getEventPosition(event);
    var boundingRect = this._containerBoundingRect;
    return position.subtract(boundingRect.left, boundingRect.top);
  };

  /**
   * Returns the properties for the outer container
   * @return {Object}
   * @private
   */


  BrushCanvasControlsComponent.prototype._getContainerProps = function _getContainerProps() {
    var props = _SpritesCanvasControl.prototype._getContainerProps.call(this);

    props.onMouseDown = props.onTouchStart = this._onMouseDown;
    return props;
  };

  /**
   * Returns the properties for the canvas container
   * @return {Object}
   * @private
   */


  BrushCanvasControlsComponent.prototype._getInnerContainerProps = function _getInnerContainerProps() {
    var props = _SpritesCanvasControl.prototype._getInnerContainerProps.call(this);

    // This disables the hit testing for this sub control
    delete props.onClick;

    props.onMouseEnter = this._onMouseEnter;
    props.onMouseLeave = this._onMouseLeave;
    props.onMouseMove = this._onMouseMoveOnCanvas;
    return props;
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the sprite items
   * @return {Array.<SpriteItemComponent>}
   * @private
   */


  BrushCanvasControlsComponent.prototype._renderSpriteItems = function _renderSpriteItems() {
    return null;
  };

  /**
   * This renders controls on top of the sprites
   * @return {ReactBEM.Element}
   * @private
   */


  BrushCanvasControlsComponent.prototype._renderOverlayControls = function _renderOverlayControls() {
    var cursorClass = this.state.cursorVisible ? 'is-visible' : null;
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:selectiveBlurCanvasControls' },
      _globals.ReactBEM.createElement('div', { bem: 'e:cursor', className: cursorClass, style: this._getCursorStyle() })
    );
  };

  return BrushCanvasControlsComponent;
}(_spritesCanvasControlsComponent2.default);

exports.default = BrushCanvasControlsComponent;


BrushCanvasControlsComponent.contextTypes = _spritesCanvasControlsComponent2.default.contextTypes;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _sliderComponent = __webpack_require__(30);

var _sliderComponent2 = _interopRequireDefault(_sliderComponent);

var _sliderOverlayComponent = __webpack_require__(12);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(BrushControlsComponent, _ControlsComponent);

  function BrushControlsComponent() {
    var _this$_events;

    (0, _classCallCheck3.default)(this, BrushControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._hasDoneButton = false;
    _this._brushThickness = _this.getSharedState('thickness');

    _this._bindAll('_onOperationUpdated', '_onOperationRemoved', '_onThicknessUpdated', '_onBlurRadiusChange');

    _this.state = {
      thicknessControlsEnabled: false
    };

    _this._events = (_this$_events = {}, (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.OPERATION_UPDATED, _this._onOperationUpdated), (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.OPERATION_REMOVED, _this._onOperationRemoved), _this$_events);
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  BrushControlsComponent.prototype.componentDidMount = function componentDidMount() {
    _ControlsComponent.prototype.componentDidMount.call(this);

    var editor = this.context.editor;

    editor.zoom.set('auto');
    editor.features.disable('zoom', 'drag');
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when an operation has been removed
   * @param  {Operation} operation
   * @private
   */


  BrushControlsComponent.prototype._onOperationRemoved = function _onOperationRemoved(operation) {
    if (operation !== this.getSharedState('operation')) return;
    if (this._backButtonClicked) return;

    // Operation can be removed by the undo button. We need
    // to make sure we re-create the operation for the lifetime
    // of this control
    var editor = this.context.editor;

    var newOperation = editor.operations.getOrCreate('selective-blur');
    var brush = newOperation.getBrush();

    this.setSharedState({
      operation: newOperation,
      brush: brush,
      operationExistedBefore: false,
      initialOptions: {}
    });

    editor.render();
  };

  /**
   * Gets called when an operation has been updated
   * @param  {Operation} operation
   * @private
   */


  BrushControlsComponent.prototype._onOperationUpdated = function _onOperationUpdated(operation) {
    if (operation === this.getSharedState('operation')) {
      var editor = this.context.editor;

      editor.render();
      this.forceUpdate();
    }
  };

  /**
   * Gets called when the thickness has been updated
   * @param {Number} thickness
   * @private
   */


  BrushControlsComponent.prototype._onThicknessUpdated = function _onThicknessUpdated(thickness) {
    this.setSharedState({ thickness: thickness });
    this._brushThickness = thickness;
  };

  /**
   * Gets called when the slider value has changed
   * @param {Number} value
   * @param {Number} previousValue
   * @param {Boolean} released
   * @private
   */


  BrushControlsComponent.prototype._onBlurRadiusChange = function _onBlurRadiusChange(value, previousValue) {
    var released = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var inputDimensions = this.getSharedState('inputDimensions');
    this.getSharedState('operation').setBlurRadius(value / inputDimensions.min());

    var editor = this.context.editor;

    editor.render();

    if (released) {
      editor.history.add(this.getSharedState('operation'), { blurRadius: previousValue / inputDimensions.min() }, true);
    }
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the overlay controls of this component
   * @return {ReactBEM.Element}
   */


  BrushControlsComponent.prototype.renderOverlayControls = function renderOverlayControls() {
    var inputDimensions = this.getSharedState('inputDimensions');
    var shortestSide = inputDimensions.min();
    var value = this.getSharedState('operation').getBlurRadius() * shortestSide;

    return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
      minValue: 0,
      maxValue: Math.min(180, Math.round(shortestSide * 0.1)),
      value: value,
      valueUnit: 'px',
      label: this._t('controls.selectiveBlur.blurRadius'),
      onChange: this._onBlurRadiusChange });
  };

  /**
   * Renders the controls of this component
   * @return {ReactBEM.Element}
   */


  BrushControlsComponent.prototype.renderControls = function renderControls() {
    var editor = this.context.editor;

    var zoom = editor.zoom.get();
    var items = [];

    var finalDimensions = editor.getFinalDimensions();
    var minThickness = 1;
    var maxThickness = Math.round(finalDimensions.clone().multiply(zoom).min() / 2);
    var currentWidth = this._brushThickness;

    items.push(_globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:slider' },
      _globals.ReactBEM.createElement(_sliderComponent2.default, {
        style: 'large',
        minValue: minThickness,
        maxValue: maxThickness,
        valueUnit: 'px',
        middleDot: false,
        label: this._t('controls.brush.thickness'),
        onChange: this._onThicknessUpdated,
        value: currentWidth })
    ));

    return items;
  };

  return BrushControlsComponent;
}(_controlsComponent2.default);

exports.default = BrushControlsComponent;


BrushControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _itemComponent = __webpack_require__(39);

var _itemComponent2 = _interopRequireDefault(_itemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BrushItemComponent = function (_ItemComponent) {
  (0, _inherits3.default)(BrushItemComponent, _ItemComponent);

  function BrushItemComponent() {
    (0, _classCallCheck3.default)(this, BrushItemComponent);
    return (0, _possibleConstructorReturn3.default)(this, _ItemComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */
  BrushItemComponent.prototype.componentDidMount = function componentDidMount() {
    _ItemComponent.prototype.componentDidMount.call(this);

    var canvas = this.props.sprite.getCanvas();
    this._appendCanvas(canvas);
  };

  /**
   * Gets called when this component is about to receive new properties
   * @param  {Object} nextProps
   */


  BrushItemComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.sprite !== this.props.sprite) {
      var canvas = this.props.sprite.getCanvas();
      canvas.parentNode.removeChild(canvas);
      var newCanvas = nextProps.sprite.getCanvas();
      this._appendCanvas(newCanvas);
    }
  };

  /**
   * Appends and styles the given canvas
   * @param  {HTMLCanvasElement} canvas
   * @private
   */


  BrushItemComponent.prototype._appendCanvas = function _appendCanvas(canvas) {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();
    canvas.style.width = outputDimensions.x + 'px';
    canvas.style.height = outputDimensions.y + 'px';
    this.refs.brush.appendChild(canvas);
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Checks if this item is currently selected
   * @return {Boolean}
   */


  BrushItemComponent.prototype._isSelected = function _isSelected() {
    return this.getSharedState('brush') === this.props.sprite;
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  BrushItemComponent.prototype.renderWithBEM = function renderWithBEM() {
    var brushClassName = this._isSelected() ? 'is-selected' : null;
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: 'b:spritesCanvasControls' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item e:container m:full', ref: 'container' },
        _globals.ReactBEM.createElement('div', {
          bem: '$e:brush',
          className: brushClassName,
          ref: 'brush' })
      )
    );
  };

  return BrushItemComponent;
}(_itemComponent2.default);

exports.default = BrushItemComponent;


BrushItemComponent.contextTypes = _itemComponent2.default.contextTypes;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _itemComponent = __webpack_require__(39);

var _itemComponent2 = _interopRequireDefault(_itemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StickerItemComponent = function (_ItemComponent) {
  (0, _inherits3.default)(StickerItemComponent, _ItemComponent);

  function StickerItemComponent() {
    (0, _classCallCheck3.default)(this, StickerItemComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ItemComponent.call.apply(_ItemComponent, [this].concat(args)));

    _this._bindAll('_onRotateKnobDragStart', '_onRotateKnobDrag', '_onRotateKnobDragStop');
    _this._id = _globals.SDKUtils.getUUID();
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user starts dragging a knob
   * @param  {String} side
   * @param  {Vector2} position
   * @param  {Event} e
   * @private
   */


  StickerItemComponent.prototype._onKnobDragStart = function _onKnobDragStart(side, position, e) {
    var sprite = this.props.sprite;

    switch (side) {
      case 'bottom':
        this._initialPosition = this._getBottomDragKnobPosition();
        break;
      case 'top':
        this._initialPosition = this._getTopDragKnobPosition();
        break;
    }

    this._initialDimensions = sprite.getDimensions().clone();

    this.props.onDragStart && this.props.onDragStart();
  };

  /**
   * Gets called while the user drags a sticker
   * @param  {String} side
   * @param  {Vector2} offset
   * @param  {Event} e
   * @private
   */


  StickerItemComponent.prototype._onKnobDrag = function _onKnobDrag(side, offset, e) {
    var sprite = this.props.sprite;

    var stickerPosition = this._getAbsoluteSpritePosition();
    var newKnobPosition = this._initialPosition.clone().add(offset);

    // Calculate new rotation and dimensions from new knob position
    var knobDistanceFromCenter = newKnobPosition.clone().subtract(stickerPosition);

    var initialKnobDistanceFromCenter = this._initialPosition.clone().subtract(stickerPosition);

    if (this.props.options.fixedRatio) {
      var halfDimensions = this._getStickerDimensions().divide(2).abs();

      var initialDistanceFromCenter = this._initialPosition.clone().subtract(stickerPosition);

      var radians = void 0;

      switch (side) {
        case 'bottom':
          radians = Math.atan2(knobDistanceFromCenter.y, knobDistanceFromCenter.x) - Math.atan2(halfDimensions.y, halfDimensions.x);
          break;
        case 'top':
          radians = Math.atan2(knobDistanceFromCenter.y, knobDistanceFromCenter.x) - Math.atan2(-halfDimensions.y, -halfDimensions.x);
          break;
      }

      var newDimensions = this._initialDimensions.clone().multiply(knobDistanceFromCenter.len() / initialDistanceFromCenter.len());

      sprite.set({
        dimensions: newDimensions,
        rotation: radians
      });
    } else {
      var zoom = this.context.editor.zoom.get();
      var rotation = sprite.getRotation();
      var cos = Math.cos(rotation * -1);
      var sin = Math.sin(rotation * -1);

      var localDistanceToCenter = new _globals.Vector2(knobDistanceFromCenter.x * cos - knobDistanceFromCenter.y * sin, knobDistanceFromCenter.x * sin + knobDistanceFromCenter.y * cos);

      var previousLocalDistanceToCenter = new _globals.Vector2(initialKnobDistanceFromCenter.x * cos - initialKnobDistanceFromCenter.y * sin, initialKnobDistanceFromCenter.x * sin + initialKnobDistanceFromCenter.y * cos);

      var distanceToCenterDiff = void 0;

      switch (side) {
        case 'bottom':
          distanceToCenterDiff = localDistanceToCenter.clone().subtract(previousLocalDistanceToCenter);
          break;
        case 'top':
          distanceToCenterDiff = previousLocalDistanceToCenter.clone().subtract(localDistanceToCenter);
          break;
      }

      var _newDimensions = this._initialDimensions.clone().add(distanceToCenterDiff.clone().divide(zoom).multiply(2));

      sprite.set({
        dimensions: _newDimensions
      });
    }
  };

  /**
   * Gets called when the user stops dragging a knob
   * @private
   */


  StickerItemComponent.prototype._onKnobDragStop = function _onKnobDragStop() {
    this.props.onDragStop && this.props.onDragStop();
  };

  /**
   * Gets called when the user starts dragging the rotate knob
   * @param  {Vector2} position
   * @param  {Event} e
   * @private
   */


  StickerItemComponent.prototype._onRotateKnobDragStart = function _onRotateKnobDragStart(position, e) {
    this._initialPosition = this._getRotateKnobPosition();
    this.props.onDragStart && this.props.onDragStart();
  };

  /**
   * Gets called when the user stops dragging the rotate knob
   * @private
   */


  StickerItemComponent.prototype._onRotateKnobDragStop = function _onRotateKnobDragStop() {
    this.props.onDragStop && this.props.onDragStop();
  };

  /**
   * Gets called while the user drags a sticker
   * @param  {Vector2} offset
   * @param  {Event} e
   * @private
   */


  StickerItemComponent.prototype._onRotateKnobDrag = function _onRotateKnobDrag(offset, e) {
    var sprite = this.props.sprite;

    var stickerPosition = this._getAbsoluteSpritePosition();
    var newKnobPosition = this._initialPosition.clone().add(offset);

    var halfDimensions = this._getStickerDimensions().divide(2);

    // Calculate new rotation and dimensions from new knob position
    var knobDistanceFromCenter = newKnobPosition.clone().subtract(stickerPosition);

    var radians = void 0;
    radians = Math.atan2(knobDistanceFromCenter.y, knobDistanceFromCenter.x) - Math.atan2(-halfDimensions.y, halfDimensions.x);

    sprite.set({
      rotation: radians
    });
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the style object for the bottom right drag knob
   * @return {Object}
   * @private
   */


  StickerItemComponent.prototype._getBottomDragKnobStyle = function _getBottomDragKnobStyle() {
    var knobPosition = this._getBottomDragKnobPosition();

    return {
      left: knobPosition.x,
      top: knobPosition.y
    };
  };

  /**
   * Returns the style object for the top right drag knob
   * @return {Object}
   * @private
   */


  StickerItemComponent.prototype._getTopDragKnobStyle = function _getTopDragKnobStyle() {
    var knobPosition = this._getTopDragKnobPosition();

    return {
      left: knobPosition.x,
      top: knobPosition.y
    };
  };

  /**
   * Returns the style object for the rotate knob
   * @return {Object}
   * @private
   */


  StickerItemComponent.prototype._getRotateKnobStyle = function _getRotateKnobStyle() {
    var knobPosition = this._getRotateKnobPosition();

    return {
      left: knobPosition.x,
      top: knobPosition.y
    };
  };

  /**
   * Builds the style object for this sticker
   * @return {Object}
   * @private
   */


  StickerItemComponent.prototype._getStickerStyle = function _getStickerStyle() {
    var sprite = this.props.sprite;


    var processedDimensions = this._getStickerDimensions().abs();
    var spritePosition = this._getAbsoluteSpritePosition().subtract(processedDimensions.clone().divide(2));

    var degrees = sprite.getRotation() * 180 / Math.PI;
    var transform = 'rotate(' + degrees.toFixed(2) + 'deg)';

    var spriteDimensions = sprite.getDimensions();

    var flipVertically = sprite.getFlipVertically();
    if (spriteDimensions.y < 0) flipVertically = !flipVertically;
    if (flipVertically) {
      transform += ' scaleY(-1)';
    }

    var flipHorizontally = sprite.getFlipHorizontally();
    if (spriteDimensions.x < 0) flipHorizontally = !flipHorizontally;
    if (flipHorizontally) {
      transform += ' scaleX(-1)';
    }

    return {
      top: spritePosition.y,
      left: spritePosition.x,
      width: processedDimensions.x,
      height: processedDimensions.y,
      WebkitTransform: transform,
      msTransform: transform,
      MozTransform: transform,
      OTransform: transform
    };
  };

  // -------------------------------------------------------------------------- CALCULATIONS

  /**
   * Calculates the sticker dimensions
   * @param  {Object} sticker
   * @return {Vector2}
   * @private
   */


  StickerItemComponent.prototype._getStickerDimensions = function _getStickerDimensions() {
    var sprite = this.props.sprite;
    var editor = this.context.editor;


    return sprite.getDimensions().clone().multiply(editor.zoom.get());
  };

  /**
   * Calculates the rotate button knob's position
   * @return {PhotoEditorSDK.Math.Vector2}
   * @private
   */


  StickerItemComponent.prototype._getRotateKnobPosition = function _getRotateKnobPosition() {
    var sprite = this.props.sprite;

    var stickerPosition = this._getAbsoluteSpritePosition();
    var stickerRotation = sprite.getRotation();

    // Calculate sin and cos for rotation
    var sin = Math.sin(stickerRotation || 0);
    var cos = Math.cos(stickerRotation || 0);

    // Calculate sticker dimensions
    var halfDimensions = this._getStickerDimensions().divide(2);

    // Calculate knob position
    return stickerPosition.clone().add(halfDimensions.x * cos + halfDimensions.y * sin, halfDimensions.x * sin - halfDimensions.y * cos);
  };

  /**
   * Calculates the drag bottom right knob's position
   * @return {Vector2}
   * @private
   */


  StickerItemComponent.prototype._getBottomDragKnobPosition = function _getBottomDragKnobPosition() {
    var sprite = this.props.sprite;

    var stickerPosition = this._getAbsoluteSpritePosition();
    var stickerRotation = sprite.getRotation();

    // Calculate sin and cos for rotation
    var sin = Math.sin(stickerRotation || 0);
    var cos = Math.cos(stickerRotation || 0);

    // Calculate sticker dimensions
    var halfDimensions = this._getStickerDimensions().divide(2);

    // Calculate knob position
    return stickerPosition.clone().add(halfDimensions.x * cos - halfDimensions.y * sin, halfDimensions.x * sin + halfDimensions.y * cos);
  };

  /**
   * Calculates the drag top right knob's position
   * @return {Vector2}
   * @private
   */


  StickerItemComponent.prototype._getTopDragKnobPosition = function _getTopDragKnobPosition() {
    var sprite = this.props.sprite;

    var stickerPosition = this._getAbsoluteSpritePosition();
    var stickerRotation = sprite.getRotation();

    // Calculate sin and cos for rotation
    var sin = Math.sin(stickerRotation || 0);
    var cos = Math.cos(stickerRotation || 0);

    // Calculate sticker dimensions
    var halfDimensions = this._getStickerDimensions(sprite).divide(2);

    // Calculate knob position
    return stickerPosition.clone().subtract(halfDimensions.x * cos - halfDimensions.y * sin, halfDimensions.x * sin + halfDimensions.y * cos);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the knobs for this item
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  StickerItemComponent.prototype._renderKnobs = function _renderKnobs() {
    var knobs = [];
    if (this.props.selected) {
      knobs = [_globals.ReactBEM.createElement(
        _draggableComponent2.default,
        {
          onStart: this._onKnobDragStart.bind(this, 'bottom'),
          onStop: this._onKnobDragStop.bind(this, 'bottom'),
          onDrag: this._onKnobDrag.bind(this, 'bottom') },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:knob $b:knob', style: this._getBottomDragKnobStyle() },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-down.png', true) })
        )
      ), _globals.ReactBEM.createElement(
        _draggableComponent2.default,
        {
          onStart: this._onKnobDragStart.bind(this, 'top'),
          onStop: this._onKnobDragStop.bind(this, 'top'),
          onDrag: this._onKnobDrag.bind(this, 'top') },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:knob $b:knob', style: this._getTopDragKnobStyle() },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-down.png', true) })
        )
      )];

      if (!this.props.options.fixedRatio) {
        knobs.push(_globals.ReactBEM.createElement(
          _draggableComponent2.default,
          {
            onStart: this._onRotateKnobDragStart,
            onStop: this._onRotateKnobDragStop,
            onDrag: this._onRotateKnobDrag },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:knob $b:knob', style: this._getRotateKnobStyle() },
            _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/rotate.png', true) })
          )
        ));
      }
    }
    return knobs;
  };

  /**
   * Renders the SVG filters
   * @return {ReactBEM.Element}
   * @private
   */


  StickerItemComponent.prototype._renderSVGFilter = function _renderSVGFilter() {
    var sprite = this.props.sprite;

    var adjustments = sprite.getAdjustments();
    var brightness = adjustments.getBrightness();
    var saturation = adjustments.getSaturation();
    var contrast = adjustments.getContrast();

    var filtersSVG = '<filter id=\'pesdk-sticker-' + this._id + '-filter\'>\n        <feComponentTransfer>\n          <feFuncR type=\'linear\' intercept=\'' + brightness + '\' />\n          <feFuncG type=\'linear\' intercept=\'' + brightness + '\' />\n          <feFuncB type=\'linear\' intercept=\'' + brightness + '\' />\n        </feComponentTransfer>\n        <feColorMatrix type=\'saturate\' values=\'' + saturation + '\' />\n        <feComponentTransfer>\n          <feFuncR type=\'linear\' slope=\'' + contrast + '\' intercept=\'' + (-(0.5 * contrast) + 0.5) + '\' />\n          <feFuncG type=\'linear\' slope=\'' + contrast + '\' intercept=\'' + (-(0.5 * contrast) + 0.5) + '\' />\n          <feFuncB type=\'linear\' slope=\'' + contrast + '\' intercept=\'' + (-(0.5 * contrast) + 0.5) + '\' />\n        </feComponentTransfer>\n      </filter>';

    // We added `key: Math.random()` because in Safari, dangerouslySetInnerHTML
    // would not update without that...
    // https://github.com/facebook/react/issues/2863
    return _globals.ReactBEM.createElement(
      'svg',
      { width: '0', height: '0', 'color-interpolation-filters': 'sRGB', is: 'svg' },
      _globals.ReactBEM.createElement('defs', {
        key: Math.random(),
        dangerouslySetInnerHTML: {
          __html: filtersSVG
        }
      })
    );
  };

  /**
   * Renders the draggable item
   * @return {ReactBEM.Element}
   * @private
   */


  StickerItemComponent.prototype._renderItem = function _renderItem() {
    var sprite = this.props.sprite;

    var stickerStyle = this._getStickerStyle();
    var className = this.props.selected ? 'is-selected' : null;

    var baseURL = window.location.href.replace(window.location.hash, '');
    var stickerImageStyle = { filter: 'url("' + baseURL + '#pesdk-sticker-' + this._id + '-filter")' };

    return _globals.ReactBEM.createElement(
      _draggableComponent2.default,
      {
        onStart: this._onItemDragStart,
        onStop: this._onItemDragStop,
        onDrag: this._onItemDrag,
        disabled: !this.props.selected },
      _globals.ReactBEM.createElement(
        'div',
        {
          bem: '$e:sticker',
          style: stickerStyle,
          className: className },
        _globals.ReactBEM.createElement(
          'svg',
          { width: stickerStyle.width, height: stickerStyle.height, 'color-interpolation-filters': 'sRGB', is: 'svg' },
          _globals.ReactBEM.createElement('image', {
            xlinkHref: sprite.getImage().src,
            width: stickerStyle.width,
            height: stickerStyle.height,
            style: stickerImageStyle
          })
        )
      )
    );
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  StickerItemComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: 'b:spritesCanvasControls' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item e:container' },
        this._renderSVGFilter(),
        this._renderItem(),
        this._renderKnobs()
      )
    );
  };

  return StickerItemComponent;
}(_itemComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = StickerItemComponent;


StickerItemComponent.contextTypes = _itemComponent2.default.contextTypes;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _draggableComponent = __webpack_require__(11);

var _draggableComponent2 = _interopRequireDefault(_draggableComponent);

var _itemComponent = __webpack_require__(39);

var _itemComponent2 = _interopRequireDefault(_itemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TextItemComponent = function (_ItemComponent) {
  (0, _inherits3.default)(TextItemComponent, _ItemComponent);

  function TextItemComponent() {
    (0, _classCallCheck3.default)(this, TextItemComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ItemComponent.call.apply(_ItemComponent, [this].concat(args)));

    _this._bindAll('_onTextChange', '_onItemDoubleClick', '_onItemTouchStart', '_onItemTouchEnd', '_onResizeKnobDragStart', '_onResizeKnobDrag', '_onResizeKnobDragStop', '_onRotationKnobDragStart', '_onRotationKnobDrag', '_onRotationKnobDragStop');

    _this.state = {
      editMode: false
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user has changed the text
   * @param  {Event} e
   * @private
   */


  TextItemComponent.prototype._onTextChange = function _onTextChange(e) {
    var sprite = this.props.sprite;

    sprite.setText(e.target.value);
  };

  /**
   * Gets called when the user double clicks the text. Turns the sprite into
   * editing mode.
   * @private
   */


  TextItemComponent.prototype._onItemDoubleClick = function _onItemDoubleClick() {
    this.enterEditMode();
  };

  /**
   * Enters the edit mode
   */


  TextItemComponent.prototype.enterEditMode = function enterEditMode() {
    var _this2 = this;

    var sprite = this.props.sprite;

    if (!sprite._edited) {
      sprite.setText('');
      this.refs.textarea.value = '';
      sprite._edited = true;
      this.forceUpdate();
    }
    this.setState({ editMode: true }, function () {
      _this2.refs.textarea.focus();
      _this2.refs.textarea.select();
    });
  };

  /**
   * Gets called when the user starts touching the item
   * @param {Event} e
   * @private
   */


  TextItemComponent.prototype._onItemTouchStart = function _onItemTouchStart(e) {
    this._initialTouchPosition = _globals.Utils.getEventPosition(e);
    this._tapStartAt = (0, _globals.now)();
  };

  /**
   * Gets called when the user stops touching the item
   * @private
   */


  TextItemComponent.prototype._onItemTouchEnd = function _onItemTouchEnd() {
    // Recognize double tap
    if ((0, _globals.now)() - this._tapStartAt <= 100) {
      // Touch didn't last longer than 100ms => recognized as tap
      if (typeof this._lastTapAt !== 'undefined' && (0, _globals.now)() - this._lastTapAt <= 300) {
        // Last tap was no longer than 300ms ago => recognized as double tap
        this._onItemDoubleClick();
      }
      this._lastTapAt = (0, _globals.now)();
    }
  };

  // -------------------------------------------------------------------------- ROTATION DRAGGING

  /**
   * Gets called when the user starts dragging the resize knob
   * @param  {Vector2} position
   * @param  {Event} e
   * @private
   */


  TextItemComponent.prototype._onRotationKnobDragStart = function _onRotationKnobDragStart(position, e) {
    this._dragging = true;
    this._initialPosition = this._getRotationKnobPosition();

    this.props.onDragStart && this.props.onDragStart();
  };

  /**
   * Gets called while the user rotates the text
   * @param  {Vector2} offset
   * @param  {Event} e
   * @private
   */


  TextItemComponent.prototype._onRotationKnobDrag = function _onRotationKnobDrag(offset, e) {
    var sprite = this.props.sprite;
    var editor = this.context.editor;


    var spritePosition = this._getAbsoluteSpritePosition();
    var newKnobPosition = this._initialPosition.clone().add(offset);

    // Calculate new rotation and scale from new knob position
    var knobDistanceFromCenter = newKnobPosition.clone().subtract(spritePosition);

    var boundingBox = sprite.getBoundingBox(editor.getSDK(), editor.getOutputDimensions());
    var radians = Math.atan2(knobDistanceFromCenter.y, knobDistanceFromCenter.x) - Math.atan2(boundingBox.y, boundingBox.x / 2);

    sprite.setRotation(radians);
  };

  /**
   * Gets called when the user stops rotating the text
   * @param  {Event} e
   * @private
   */


  TextItemComponent.prototype._onRotationKnobDragStop = function _onRotationKnobDragStop(e) {
    this.props.onDragStop && this.props.onDragStop();
  };

  // -------------------------------------------------------------------------- RESIZE DRAGGING

  /**
   * Gets called when the user starts resizing the text
   * @param  {Vector2} position
   * @param  {Event} e
   * @private
   */


  TextItemComponent.prototype._onResizeKnobDragStart = function _onResizeKnobDragStart(position, e) {
    this._initialPosition = this._getResizeKnobPosition();

    this.props.onDragStart && this.props.onDragStart();
  };

  /**
   * Gets called while the user resizes the text
   * @param  {Vector2} offset
   * @param  {Event} e
   * @private
   */


  TextItemComponent.prototype._onResizeKnobDrag = function _onResizeKnobDrag(offset, e) {
    var sprite = this.props.sprite;

    var textRotation = sprite.getRotation();

    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();

    var cos = Math.cos(textRotation);
    var sin = Math.sin(textRotation);

    var newKnobPosition = this._initialPosition.clone().add(offset);
    var position = this._getAbsoluteSpritePosition();
    var distanceToPosition = newKnobPosition.clone().subtract(position);

    var newMaxWidth = Math.max((distanceToPosition.x * cos + distanceToPosition.y * sin) / outputDimensions.x * 2, 0.1);
    sprite.setMaxWidth(newMaxWidth);
  };

  /**
   * Gets called when the user stops resizing the text
   * @param  {Event} e
   * @private
   */


  TextItemComponent.prototype._onResizeKnobDragStop = function _onResizeKnobDragStop(e) {
    this.props.onDragStop && this.props.onDragStop();
  };

  // -------------------------------------------------------------------------- STYLING

  /**
   * Returns the style object for the rotation knob
   * @return {Object}
   * @private
   */


  TextItemComponent.prototype._getRotationKnobStyle = function _getRotationKnobStyle() {
    var position = this._getRotationKnobPosition();
    return {
      left: position.x,
      top: position.y
    };
  };

  /**
   * Returns the style object for the resize knob
   * @return {Object}
   * @private
   */


  TextItemComponent.prototype._getResizeKnobStyle = function _getResizeKnobStyle() {
    var position = this._getResizeKnobPosition();
    return {
      left: position.x,
      top: position.y
    };
  };

  /**
   * Returns the style object for the given text object
   * @return {Object}
   * @private
   */


  TextItemComponent.prototype._getTextStyle = function _getTextStyle() {
    var editor = this.context.editor;
    var sprite = this.props.sprite;

    var sdk = editor.getSDK();
    var outputDimensions = editor.getOutputDimensions();
    var style = sprite.getDOMStyle(sdk, outputDimensions);

    var spritePosition = this._getAbsoluteSpritePosition();
    var boundingBox = sprite.getBoundingBox(sdk, outputDimensions);
    style.height = Math.min(boundingBox.y, outputDimensions.y - spritePosition.y);

    return style;
  };

  /**
   * Returns the style object for the item container
   * @return {Object}
   * @private
   */


  TextItemComponent.prototype._getItemContainerStyle = function _getItemContainerStyle() {
    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();

    var sprite = this.props.sprite;

    var textPosition = sprite.getPosition().clone().multiply(outputDimensions);

    var degrees = sprite.getRotation() * 180 / Math.PI;
    var transform = 'rotateZ(' + degrees.toFixed(2) + 'deg)';
    var transformOrigin = '50% 0';

    var maxWidth = sprite.getMaxWidth() * outputDimensions.x;
    return {
      width: maxWidth,
      left: textPosition.x,
      top: textPosition.y,
      marginLeft: maxWidth * -0.5,
      transform: transform,
      MozTransform: transform,
      msTransform: transform,
      WebkitTransform: transform,
      transformOrigin: transformOrigin,
      MozTransformOrigin: transformOrigin,
      msTransformOrigin: transformOrigin,
      WebkitTransformOrigin: transformOrigin
    };
  };

  // -------------------------------------------------------------------------- CALCULATIONS

  /**
   * Returns the position of the rotation knob
   * @return {Vector2}
   * @private
   */


  TextItemComponent.prototype._getRotationKnobPosition = function _getRotationKnobPosition() {
    var sprite = this.props.sprite;
    var editor = this.context.editor;


    var sin = Math.sin(sprite.getRotation());
    var cos = Math.cos(sprite.getRotation());

    var outputDimensions = editor.getOutputDimensions();
    var boundingBox = sprite.getBoundingBox(editor.getSDK(), outputDimensions);
    var halfDimensions = boundingBox.clone().divide(2);
    var position = sprite.getPosition().clone().multiply(outputDimensions).add(halfDimensions.x * cos - boundingBox.y * sin, halfDimensions.x * sin + boundingBox.y * cos);
    return position;
  };

  /**
   * Returns the position of the resize knob
   * @return {Vector2}
   * @private
   */


  TextItemComponent.prototype._getResizeKnobPosition = function _getResizeKnobPosition() {
    var sprite = this.props.sprite;
    var editor = this.context.editor;


    var sin = Math.sin(sprite.getRotation());
    var cos = Math.cos(sprite.getRotation());

    var outputDimensions = editor.getOutputDimensions();
    var boundingBox = sprite.getBoundingBox(editor.getSDK(), outputDimensions);
    var halfDimensions = boundingBox.clone().divide(2);
    var position = sprite.getPosition().clone().multiply(outputDimensions).add(halfDimensions.x * cos, halfDimensions.x * sin);
    return position;
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the knobs for this item
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  TextItemComponent.prototype._renderKnobs = function _renderKnobs() {
    var knobs = [];
    if (this.props.selected && !this.state.editMode) {
      knobs = [_globals.ReactBEM.createElement(
        _draggableComponent2.default,
        {
          onStart: this._onRotationKnobDragStart,
          onDrag: this._onRotationKnobDrag,
          onStop: this._onRotationKnobDragStop },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:knob m:rotate $b:knob', style: this._getRotationKnobStyle() },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon m:larger', src: this._getAssetPath('controls/knobs/rotate.png', true) })
        )
      ), _globals.ReactBEM.createElement(
        _draggableComponent2.default,
        {
          onStart: this._onResizeKnobDragStart,
          onDrag: this._onResizeKnobDrag,
          onStop: this._onResizeKnobDragStop },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:knob m:resize $b:knob', style: this._getResizeKnobStyle() },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/knobs/resize-diagonal-up.png', true) })
        )
      )];
    }
    return knobs;
  };

  /**
   * Renders the draggable item
   * @return {ReactBEM.Element}
   * @private
   */


  TextItemComponent.prototype._renderItem = function _renderItem() {
    var sprite = this.props.sprite;


    var content = [];
    content = [_globals.ReactBEM.createElement('textarea', {
      bem: 'e:content',
      ref: 'textarea',
      style: this._getTextStyle(),
      defaultValue: sprite.getText(),
      disabled: !this.state.editMode,
      onChange: this._onTextChange })];

    if (!this.state.editMode) {
      content.push(_globals.ReactBEM.createElement('div', {
        bem: 'e:disabledOverlay',
        onDoubleClick: this._onItemDoubleClick,
        onTouchStart: this._onItemTouchStart,
        onTouchEnd: this._onItemTouchEnd }));
    }

    return _globals.ReactBEM.createElement(
      _draggableComponent2.default,
      {
        onStart: this._onItemDragStart,
        onStop: this._onItemDragStop,
        onDrag: this._onItemDrag,
        disabled: !this.props.selected || this.props.selected && this.state.editMode },
      _globals.ReactBEM.createElement(
        'div',
        {
          bem: '$e:text',
          style: this._getItemContainerStyle(),
          className: this.props.selected ? 'is-selected' : null },
        content
      )
    );
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  TextItemComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: 'b:spritesCanvasControls' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item e:container' },
        this._renderItem(),
        this._renderKnobs()
      )
    );
  };

  return TextItemComponent;
}(_itemComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = TextItemComponent;


TextItemComponent.contextTypes = _itemComponent2.default.contextTypes;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _stickerControlsComponent = __webpack_require__(141);

var _stickerControlsComponent2 = _interopRequireDefault(_stickerControlsComponent);

var _stickerCanvasControlsComponent = __webpack_require__(140);

var _stickerCanvasControlsComponent2 = _interopRequireDefault(_stickerCanvasControlsComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Sticker = _globals.SDK.Operations.SpriteOperation.Sticker; /*
                                                                * This file is part of PhotoEditorSDK.
                                                                *
                                                                * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                                * All rights reserved.
                                                                *
                                                                * Redistribution and use in source and binary forms, without
                                                                * modification, are permitted provided that the following license agreement
                                                                * is approved and a legal/financial contract was signed by the user.
                                                                * The license agreement can be found under following link:
                                                                *
                                                                * https://www.photoeditorsdk.com/LICENSE.txt
                                                                */

/**
 * The sticker controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var StickerControls = function (_Controls) {
  (0, _inherits3.default)(StickerControls, _Controls);

  function StickerControls() {
    (0, _classCallCheck3.default)(this, StickerControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  /**
   * Gets called when the user leaves these controls
   * @this {StickerControlsComponent}
   * @override
   * @ignore
   */
  StickerControls.onExit = function onExit() {
    var editor = this.context.editor;

    var operation = this.getSharedState('operation');

    if (!this.getSharedState('skipHistory')) {
      editor.history.add(operation, this.getSharedState('initialOptions'), this.getSharedState('operationExistedBefore'));
    }

    operation.setEnabled(true);

    editor.zoom.undo();
    editor.features.enable('zoom', 'drag');
    editor.render();
  };

  /**
   * Gets called when the user enters these controls
   * @this {StickerControlsComponent}
   * @param {SharedState} sharedState
   * @override
   * @ignore
   */


  StickerControls.onEnter = function onEnter(sharedState) {
    var editor = this.context.editor;

    var operationExistedBefore = editor.operations.exists('sprite');
    var operation = editor.operations.getOrCreate('sprite');
    var sprites = operation.getSprites();
    var stickers = operation.getSpritesOfType(Sticker);
    var initialOptions = operation.serializeOptions();

    operation.setEnabled(false);
    editor.zoom.set('auto');
    editor.features.disable('zoom', 'drag');

    this.setSharedState({
      operationExistedBefore: operationExistedBefore, operation: operation, sprites: sprites, stickers: stickers, initialOptions: initialOptions
    });
  };

  /**
   * Checks if there is something at the given position that
   * would cause the UI to switch to this control on click
   * @param  {PhotoEditorSDK.Math.Vector2} position
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {*}
   * @override
   * @ignore
   */


  StickerControls.clickAtPosition = function clickAtPosition(position, editor) {
    if (!editor.operations.exists('sprite')) return false;

    var operation = editor.operations.getOrCreate('sprite');
    var sprites = operation.getSpritesAtPosition(position, editor.getOutputTextureDimensions()).filter(function (s) {
      return s instanceof Sticker;
    });

    if (sprites.length) {
      return { selectedSprite: sprites[0] };
    } else {
      return false;
    }
  };

  /**
   * Checks if this control is available to the user
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {Boolean}
   * @override
   * @ignore
   */


  StickerControls.isAvailable = function isAvailable(editor) {
    return editor.isToolEnabled('sticker');
  };

  return StickerControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


StickerControls.controlsComponent = _stickerControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
StickerControls.canvasControlsComponent = _stickerCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
StickerControls.identifier = 'sticker';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
StickerControls.iconPath = 'controls/overview/sticker.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
StickerControls.languageKey = 'controls.overview.sticker';

/**
 * The default options for this control
 * @type {Object}
 * @property {Object[]} [categories = []]
 * @property {Boolean} [replaceCategories = false]
 * @property {String[]} [selectableStickers = null]
 * @property {Boolean} [tooltips = false]
 */
StickerControls.defaultOptions = {
  categories: null,
  replaceCategories: false,
  selectableStickers: null,
  tooltips: false,
  hideCategories: false,
  fixedRatio: true,
  smoothDownscaling: false
};

exports.default = StickerControls;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _spritesCanvasControlsComponent = __webpack_require__(31);

var _spritesCanvasControlsComponent2 = _interopRequireDefault(_spritesCanvasControlsComponent);

var _stickerControlsOverlayComponent = __webpack_require__(142);

var _stickerControlsOverlayComponent2 = _interopRequireDefault(_stickerControlsOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StickerCanvasControlsComponent = function (_SpritesCanvasControl) {
  (0, _inherits3.default)(StickerCanvasControlsComponent, _SpritesCanvasControl);

  function StickerCanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, StickerCanvasControlsComponent);
    return (0, _possibleConstructorReturn3.default)(this, _SpritesCanvasControl.apply(this, arguments));
  }

  /**
   * This renders controls on top of the sprites
   * @return {ReactBEM.Element}
   * @private
   */
  StickerCanvasControlsComponent.prototype._renderOverlayControls = function _renderOverlayControls() {
    if (!this.getSharedState('selectedSprite')) return;

    return _globals.ReactBEM.createElement(_stickerControlsOverlayComponent2.default, {
      onFlip: this._onSpriteFlip,
      onTakeToFront: this._onSpriteTakeToFront,
      onRemove: this._onSpriteRemove });
  };

  return StickerCanvasControlsComponent;
}(_spritesCanvasControlsComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


exports.default = StickerCanvasControlsComponent;


StickerCanvasControlsComponent.contextTypes = _spritesCanvasControlsComponent2.default.contextTypes;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(24);

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _categoryDropdownComponent = __webpack_require__(62);

var _categoryDropdownComponent2 = _interopRequireDefault(_categoryDropdownComponent);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _stickerManager = __webpack_require__(70);

var _stickerManager2 = _interopRequireDefault(_stickerManager);

var _stickerItemComponent = __webpack_require__(143);

var _stickerItemComponent2 = _interopRequireDefault(_stickerItemComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StickerOverviewControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(StickerOverviewControlsComponent, _ControlsComponent);

  function StickerOverviewControlsComponent() {
    (0, _classCallCheck3.default)(this, StickerOverviewControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._bindAll('_onStickerMouseLeave', '_renderTooltipCanvas', '_onCategoryChange', '_onBeforeHistoryUndo');
    _this._events = (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.HISTORY_BEFORE_UNDO, _this._onBeforeHistoryUndo);

    _this._operation = _this.getSharedState('operation');
    _this._sprites = _this.getSharedState('sprites');
    _this._stickers = _this.getSharedState('stickers');

    _this._initStickerManager();

    _this.state = {
      category: _this._stickerManager.getCategory('all')
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called before a history item is being undone
   * @param  {Object} historyObject
   * @private
   */


  StickerOverviewControlsComponent.prototype._onBeforeHistoryUndo = function _onBeforeHistoryUndo(historyObject) {
    var operation = historyObject.operation,
        options = historyObject.options;

    if (operation !== this.getSharedState('operation')) return;

    var sprites = options.sprites;

    if (sprites.indexOf(this.getSharedState('selectedSprite')) === -1) {
      // Currently selected sprite is being removed. Leave control without adding history item.
      this.setSharedState({ skipHistory: true }, false);
      this.props.onSwitchControls('home');
    }
  };

  /**
   * Gets called when the user switches the category
   * @param  {Object} category
   * @private
   */


  StickerOverviewControlsComponent.prototype._onCategoryChange = function _onCategoryChange(category) {
    var _this2 = this;

    this.setState({ category: category }, function () {
      _this2.refs.scrollbar.update();
    });
  };

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component is mounted
   */


  StickerOverviewControlsComponent.prototype.componentDidMount = function componentDidMount() {
    _ControlsComponent.prototype.componentDidMount.call(this);

    if (this.props.options.stickersJSONPath) {
      this._loadExternalStickers();
    }

    var editor = this.context.editor;

    editor.zoom.set('auto', function () {
      editor.features.disable('zoom', 'drag');
    });
  };

  // -------------------------------------------------------------------------- EXTERNAL STICKER LOADING

  /**
   * Loads the stickers from an external JSON source
   * @private
   */


  StickerOverviewControlsComponent.prototype._loadExternalStickers = function _loadExternalStickers() {
    var _this3 = this;

    // Display loading modal after 100ms
    var loadingModal = null;
    var loadTimeout = setTimeout(function () {
      loadingModal = _modalManager2.default.instance.displayLoading(_this3._t('loading.loading'));
    }, 100);

    // Called when loading is done. Cancels the loading timeout
    // or closes the loadingModal in case it has been opened
    var doneLoading = function doneLoading() {
      if (loadTimeout) {
        clearTimeout(loadTimeout);
        loadTimeout = null;
      }
      if (loadingModal) loadingModal.close();
    };

    this._stickerManager.loadExternal(this.props.options.stickersJSONPath).then(function (result) {
      doneLoading();
      _this3.forceUpdate(function () {
        _this3.refs.scrollbar.update();
      });
    }).catch(function (e) {
      doneLoading();

      console.error(e);
      var errorModal = _modalManager2.default.instance.displayError(_this3._t('errors.loadingStickersFailed.title'), e.message);
      errorModal.on('close', function () {
        _this3.props.onBack();
      });
    });
  };

  // -------------------------------------------------------------------------- STICKER RENDERING

  /**
   * Renders the sticker on the tooltip canvas
   * @private
   */


  StickerOverviewControlsComponent.prototype._renderTooltipCanvas = function _renderTooltipCanvas() {
    var _this4 = this;

    var hoveredSticker = this.state.hoveredSticker;

    var image = new window.Image();
    image.addEventListener('load', function () {
      if (!_this4.state.tooltipVisible || _this4.state.hoveredSticker !== hoveredSticker) {
        return;
      }

      var canvas = _this4.refs.tooltipCanvas;
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      var context = canvas.getContext('2d');
      var scale = Math.min(canvas.width / image.width, canvas.height / image.height);
      var drawSize = new _globals.Vector2(image.width, image.height).multiply(scale);
      var drawPosition = new _globals.Vector2(canvas.width, canvas.height).divide(2).subtract(drawSize.clone().divide(2));

      context.drawImage(image, 0, 0, image.width, image.height, drawPosition.x, drawPosition.y, drawSize.x, drawSize.y);
    });

    var resolvedStickerPath = this._getAssetPath((hoveredSticker.images.mediaMedium || hoveredSticker.images.mediaBase).uri);
    image.crossOrigin = 'Anonymous';
    image.src = resolvedStickerPath;
  };

  // -------------------------------------------------------------------------- STICKERS

  /**
   * Initializes the sticker manager
   * @private
   */


  StickerOverviewControlsComponent.prototype._initStickerManager = function _initStickerManager() {
    var options = _globals.SDKUtils.defaults(this.props.options, {
      allCategoryLabel: this._t('controls.sticker.categories.all')
    });
    this._stickerManager = new _stickerManager2.default(options);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the back button
   * @param {Event} e
   * @private
   */


  StickerOverviewControlsComponent.prototype._onBackClick = function _onBackClick(e) {
    this._backButtonClicked = true;
    this.props.onSwitchControls('home');
  };

  /**
   * Gets called when a sticker has been clicked
   * @param  {Object} sticker
   * @private
   */


  StickerOverviewControlsComponent.prototype._onStickerClick = function _onStickerClick(sticker) {
    var _this5 = this;

    var resolvedStickerPath = this._getAssetPath(sticker.images.mediaBase.uri);
    var image = new window.Image();

    var loadingModal = void 0;
    var loadTimeout = setTimeout(function () {
      loadingModal = _modalManager2.default.instance.displayLoading(_this5._t('loading.loading'));
    }, 100);

    image.addEventListener('load', function () {
      if (loadingModal) loadingModal.close();
      if (loadTimeout) {
        clearTimeout(loadTimeout);
        loadTimeout = null;
      }

      var editor = _this5.context.editor;


      var scale = _this5._calculateInitialStickerScale(sticker, image);
      var sprite = _this5._operation.createSticker({
        name: sticker.name,
        image: image,
        position: new _globals.Vector2(0.5, 0.5),
        dimensions: new _globals.Vector2(image.width, image.height).multiply(scale),
        rotation: 0,
        smoothDownscaling: _this5.props.options.smoothDownscaling
      });
      _this5._operation.addSprite(sprite);
      _this5._stickers.push(sprite);

      editor.render(function () {
        // Broadcast new state
        _this5.setSharedState({
          selectedSprite: sprite,
          sprites: _this5._sprites,
          stickers: _this5._stickers
        });
      });
    });

    image.addEventListener('error', function () {
      if (loadingModal) loadingModal.close();
      if (loadTimeout) {
        clearTimeout(loadTimeout);
        loadTimeout = null;
      }

      _modalManager2.default.instance.displayError(_this5._t('errors.imageLoadFail.title'), _this5._t('errors.imageLoadFail.text', { path: image.src }));
    });

    image.crossOrigin = 'Anonymous';
    image.src = resolvedStickerPath;
  };

  /**
   * Calculates the initial sticker scale
   * @param  {Object} sticker
   * @param  {Image} image
   * @return {Number}
   * @private
   */


  StickerOverviewControlsComponent.prototype._calculateInitialStickerScale = function _calculateInitialStickerScale(sticker, image) {
    var operation = this.getSharedState('operation');
    var inputDimensions = operation.getInputDimensions().multiply(0.9);
    var imageDimensions = new _globals.Vector2(image.width, image.height);

    var overlap = imageDimensions.clone().subtract(inputDimensions);

    if (overlap.x <= 0 && overlap.y <= 0) return 1;

    if (overlap.x > overlap.y) {
      return inputDimensions.x / imageDimensions.x;
    } else {
      return inputDimensions.y / imageDimensions.y;
    }
  };

  /**
   * Gets called when the user starts hovering a sticker
   * @param  {String} stickerPath
   * @param  {Event} e
   * @private
   */


  StickerOverviewControlsComponent.prototype._onStickerMouseEnter = function _onStickerMouseEnter(stickerPath, e) {
    var _this6 = this;

    this.setState({
      tooltipVisible: true,
      hoveredSticker: stickerPath,
      hoveredStickerElement: e.currentTarget
    }, function () {
      _this6._renderTooltipCanvas();
      _this6._updateTooltipPosition();
    });
  };

  /**
   * Updates the tooltip position to match the currently hovered
   * sticker's position
   * @private
   */


  StickerOverviewControlsComponent.prototype._updateTooltipPosition = function _updateTooltipPosition() {
    var el = this.state.hoveredStickerElement;
    var parent = this.refs.root;
    var boundingRect = el.getBoundingClientRect();
    var parentBoundingRect = parent.getBoundingClientRect();

    this.setState({
      tooltipPosition: boundingRect.left - parentBoundingRect.left
    });
  };

  /**
   * Gets called when the user does no longer hover a sticker
   * @private
   */


  StickerOverviewControlsComponent.prototype._onStickerMouseLeave = function _onStickerMouseLeave() {
    this.setState({
      tooltipVisible: false,
      hoveredSticker: null
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the list items for this control
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  StickerOverviewControlsComponent.prototype._renderListItems = function _renderListItems() {
    var _this7 = this;

    var stickers = this._stickerManager.getStickersForCategory(this.state.category.name);
    return stickers.map(function (sticker, i) {
      var options = _this7.props.options;


      var itemEvents = options.tooltips ? {
        onMouseEnter: _this7._onStickerMouseEnter.bind(_this7, sticker),
        onMouseLeave: _this7._onStickerMouseLeave
      } : null;

      return _globals.ReactBEM.createElement(_stickerItemComponent2.default, (0, _extends3.default)({
        sticker: sticker,
        onClick: _this7._onStickerClick.bind(_this7, sticker)
      }, itemEvents));
    });
  };

  /**
   * Renders the tooltip (if present)
   * @return {ReactBEM.Element}
   * @private
   */


  StickerOverviewControlsComponent.prototype._renderTooltip = function _renderTooltip() {
    var tooltipVisible = this.props.options.tooltips && this.state.tooltipVisible;

    var style = {
      left: this.state.tooltipPosition
    };

    return tooltipVisible ? _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:empty' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:stickersControls $e:tooltip',
          style: style },
        _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'tooltipCanvas' })
      )
    ) : null;
  };

  /**
   * Renders the category dropdown (if present)
   * @return {ReactBEM.Element}
   * @private
   */


  StickerOverviewControlsComponent.prototype._renderCategoryDropdown = function _renderCategoryDropdown() {
    var _this8 = this;

    var categories = this._stickerManager.getCategories();
    var categoryDropdownVisible = !this.props.options.hideCategories && categories.length > 1;
    if (!categoryDropdownVisible) {
      return null;
    }

    var categoryItems = categories.map(function (c) {
      return {
        name: c.name,
        label: c.label,
        icon: _this8._getAssetPath('controls/stickers/categories/' + c.name + '.png', true)
      };
    });
    var selectedCategory = {
      name: this.state.category.name,
      label: this.state.category.label,
      icon: this._getAssetPath('controls/stickers/categories/' + this.state.category.name + '.png', true)
    };

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:categoryDropdown' },
      _globals.ReactBEM.createElement(_categoryDropdownComponent2.default, {
        items: categoryItems,
        selectedItem: selectedCategory,
        onChange: this._onCategoryChange })
    );
  };

  /**
   * Renders the controls of this component
   * @return {ReactBEM.Element}
   */


  StickerOverviewControlsComponent.prototype.renderControls = function renderControls() {
    var listItems = this._renderListItems();
    var tooltip = this._renderTooltip();
    var categoryDropdown = this._renderCategoryDropdown();

    return [tooltip, categoryDropdown, _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:list' },
      _globals.ReactBEM.createElement(
        _scrollbarComponent2.default,
        { ref: 'scrollbar' },
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:list' },
          listItems
        )
      )
    )];
  };

  return StickerOverviewControlsComponent;
}(_controlsComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = StickerOverviewControlsComponent;


StickerOverviewControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StickerControlsOverlayComponent = function (_BaseComponent) {
  (0, _inherits3.default)(StickerControlsOverlayComponent, _BaseComponent);

  function StickerControlsOverlayComponent() {
    (0, _classCallCheck3.default)(this, StickerControlsOverlayComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks one of the flip items
   * @param  {String} direction
   * @param  {Event} e
   * @private
   */
  StickerControlsOverlayComponent.prototype._onFlipClick = function _onFlipClick(direction, e) {
    e.preventDefault();
    e.stopPropagation();

    this.props.onFlip && this.props.onFlip(direction);
  };

  /**
   * Gets called when the user clicks the `take to front` item
   * @param  {Event} e
   * @private
   */


  StickerControlsOverlayComponent.prototype._onTakeToFrontClick = function _onTakeToFrontClick(e) {
    e.preventDefault();
    e.stopPropagation();

    this.props.onTakeToFront && this.props.onTakeToFront();
  };

  /**
   * Gets called when the user clicks the `remove` item
   * @param  {Event} e
   * @private
   */


  StickerControlsOverlayComponent.prototype._onRemoveClick = function _onRemoveClick(e) {
    e.preventDefault();
    e.stopPropagation();

    this.props.onRemove && this.props.onRemove();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the items of this component
   * @return {Array.<ReactBEM.Element>}
   */


  StickerControlsOverlayComponent.prototype._renderItems = function _renderItems() {
    return [_globals.ReactBEM.createElement(
      'div',
      { bem: '$e:item', onClick: this._onFlipClick.bind(this, 'h') },
      _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/flip-h.png', true) })
    ), _globals.ReactBEM.createElement(
      'div',
      { bem: '$e:item', onClick: this._onFlipClick.bind(this, 'v') },
      _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/flip-v.png', true) })
    ), _globals.ReactBEM.createElement(
      'div',
      { bem: '$e:item', onClick: this._onTakeToFrontClick.bind(this) },
      _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/take-to-front.png', true) })
    ), _globals.ReactBEM.createElement('div', { bem: '$e:separator' }), _globals.ReactBEM.createElement(
      'div',
      { bem: '$e:item', onClick: this._onRemoveClick.bind(this) },
      _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/remove.png', true) })
    )];
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  StickerControlsOverlayComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      {
        bem: '$b:spritesControlsOverlay' },
      this._renderItems()
    );
  };

  return StickerControlsOverlayComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = StickerControlsOverlayComponent;


StickerControlsOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StickerOverviewControlsComponent = function (_BaseComponent) {
  (0, _inherits3.default)(StickerOverviewControlsComponent, _BaseComponent);

  function StickerOverviewControlsComponent() {
    (0, _classCallCheck3.default)(this, StickerOverviewControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this.state = {
      sticker: _this.props.sticker
    };
    return _this;
  }

  /**
   * Gets called when this component has been mounted
   */


  StickerOverviewControlsComponent.prototype.componentDidMount = function componentDidMount() {
    this._renderSticker();
  };

  /**
   * Gets called when this component is about to receive new properties
   * @param  {Object} nextProps
   */


  StickerOverviewControlsComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (this.props.sticker !== nextProps.sticker) {
      this.setState({ sticker: nextProps.sticker }, function () {
        _this2._renderSticker();
      });
    }
  };

  /**
   * Renders the sticker onto the canvas
   * @private
   */


  StickerOverviewControlsComponent.prototype._renderSticker = function _renderSticker() {
    var editor = this.context.editor;

    var sdk = editor.getSDK();

    var sticker = this.props.sticker;


    var resolvedStickerPath = this._getAssetPath(sticker.images.mediaThumb.uri);
    var canvas = this.refs['canvas-' + sticker.name];

    var pixelRatio = sdk.getPixelRatio();
    canvas.width = canvas.offsetWidth * pixelRatio;
    canvas.height = canvas.offsetHeight * pixelRatio;

    canvas.style.width = canvas.offsetWidth + 'px';
    canvas.style.height = canvas.offsetHeight + 'px';

    var context = canvas.getContext('2d');

    var image = new window.Image();
    image.addEventListener('load', function () {
      var scale = Math.min(canvas.width / image.width, canvas.height / image.height);
      var drawSize = new _globals.Vector2(image.width, image.height).multiply(scale);
      var drawPosition = new _globals.Vector2(canvas.width, canvas.height).divide(2).subtract(drawSize.clone().divide(2));

      context.drawImage(image, 0, 0, image.width, image.height, drawPosition.x, drawPosition.y, drawSize.x, drawSize.y);
    });
    image.crossOrigin = 'Anonymous';
    image.src = resolvedStickerPath;
  };

  /**
   * Renders this element
   * @return {ReactBEM.element}
   */


  StickerOverviewControlsComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'li',
      {
        bem: '$b:stickersControls $e:item',
        key: this.props.sticker.name,
        onClick: this.props.onClick,
        onMouseEnter: this.props.onMouseEnter,
        onMouseLeave: this.props.onMouseLeave },
      _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas-' + this.props.sticker.name })
    );
  };

  return StickerOverviewControlsComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = StickerOverviewControlsComponent;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _fontPreviewComponent = __webpack_require__(64);

var _fontPreviewComponent2 = _interopRequireDefault(_fontPreviewComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FontComponent = function (_BaseComponent) {
  (0, _inherits3.default)(FontComponent, _BaseComponent);

  function FontComponent() {
    (0, _classCallCheck3.default)(this, FontComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks one one of the list items
   * @param  {Object} font
   * @param  {Event} e
   * @private
   */
  FontComponent.prototype._onListItemClick = function _onListItemClick(font, e) {
    this.props.onChange && this.props.onChange(font);
  };

  // -------------------------------------------------------------------------- LIST ITEMS

  /**
   * Renders the list items
   * @return {Array.<ReactBEM.Element>}
   * @private
   */


  FontComponent.prototype._renderListItems = function _renderListItems() {
    var _this2 = this;

    var fonts = this.props.fonts;


    return fonts.map(function (font, i) {
      var _props = _this2.props,
          fontFamily = _props.fontFamily,
          fontWeight = _props.fontWeight,
          fontStyle = _props.fontStyle;

      var isSelected = font.optionsEqual({ fontFamily: fontFamily, fontWeight: fontWeight, fontStyle: fontStyle });
      var className = isSelected ? 'is-active' : null;

      return _globals.ReactBEM.createElement(
        'li',
        {
          bem: 'e:item',
          key: i,
          className: className,
          onClick: _this2._onListItemClick.bind(_this2, font) },
        _globals.ReactBEM.createElement(_fontPreviewComponent2.default, {
          fontFamily: font.getFontFamily(),
          fontWeight: font.getFontWeight(),
          fontStyle: font.getFontStyle() }),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label' },
          font.getFontFamily()
        )
      );
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  FontComponent.prototype.renderWithBEM = function renderWithBEM() {
    var listItems = this._renderListItems();

    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:controls e:overlay m:dark m:large' },
      _globals.ReactBEM.createElement(
        _scrollbarComponent2.default,
        null,
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$b:fontFamily e:list' },
          listItems
        )
      )
    );
  };

  return FontComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = FontComponent;


FontComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _textCanvasControlsComponent = __webpack_require__(146);

var _textCanvasControlsComponent2 = _interopRequireDefault(_textCanvasControlsComponent);

var _textControlsComponent = __webpack_require__(147);

var _textControlsComponent2 = _interopRequireDefault(_textControlsComponent);

var _fontManager = __webpack_require__(189);

var _fontManager2 = _interopRequireDefault(_fontManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Text = _globals.SDK.Operations.SpriteOperation.Text; /*
                                                          * This file is part of PhotoEditorSDK.
                                                          *
                                                          * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                          * All rights reserved.
                                                          *
                                                          * Redistribution and use in source and binary forms, without
                                                          * modification, are permitted provided that the following license agreement
                                                          * is approved and a legal/financial contract was signed by the user.
                                                          * The license agreement can be found under following link:
                                                          *
                                                          * https://www.photoeditorsdk.com/LICENSE.txt
                                                          */

/**
 * The text controls
 * @class
 * @extends PhotoEditorSDK.UI.ReactUI.Control
 * @memberof PhotoEditorSDK.UI.ReactUI.Controls
 */
var TextControls = function (_Controls) {
  (0, _inherits3.default)(TextControls, _Controls);

  function TextControls() {
    (0, _classCallCheck3.default)(this, TextControls);
    return (0, _possibleConstructorReturn3.default)(this, _Controls.apply(this, arguments));
  }

  /**
   * Gets called when the user leaves these controls
   * @this {StickersControlsComponent}
   * @ignore
   */
  TextControls.onExit = function onExit() {
    var editor = this.context.editor;

    var operation = this.getSharedState('operation');

    if (!this.getSharedState('skipHistory')) {
      editor.history.add(operation, this.getSharedState('initialOptions'), this.getSharedState('operationExistedBefore'));
    }

    operation.setEnabled(true);

    editor.zoom.undo();
    editor.features.enable('zoom', 'drag');
    editor.render();
  };

  /**
   * Gets called when the user enters these controls
   * @this {StickerControlsComponent}
   * @param {SharedState} sharedState
   * @override
   * @ignore
   */


  TextControls.onEnter = function onEnter(sharedState, options) {
    var editor = this.context.editor;

    var operationExistedBefore = editor.operations.exists('sprite');
    var operation = editor.operations.getOrCreate('sprite');
    var sprites = operation.getSprites();
    var initialOptions = operation.serializeOptions();

    var fontManager = new _fontManager2.default(options);
    var defaultFont = fontManager.getDefaultFont();

    this.setSharedState({
      operationExistedBefore: operationExistedBefore,
      operation: operation,
      sprites: sprites,
      initialOptions: initialOptions,
      fontManager: fontManager,
      defaultFont: defaultFont,
      fonts: fontManager.getFonts()
    });

    operation.setEnabled(false);
    editor.render();
  };

  /**
   * Checks if there is something at the given position that
   * would cause the UI to switch to this control on click
   * @param  {PhotoEditorSDK.Math.Vector2} position
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {*}
   * @ignore
   */


  TextControls.clickAtPosition = function clickAtPosition(position, editor) {
    if (!editor.operations.exists('sprite')) return false;

    var operation = editor.operations.getOrCreate('sprite');
    var sprites = operation.getSpritesAtPosition(position, editor.getOutputTextureDimensions()).filter(function (s) {
      return s instanceof Text;
    });

    if (sprites.length) {
      return { selectedSprite: sprites[0] };
    } else {
      return false;
    }
  };

  /**
   * Checks if this control is available to the user
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {Boolean}
   * @ignore
   */


  TextControls.isAvailable = function isAvailable(editor) {
    return editor.isToolEnabled('text');
  };

  /**
   * Returns the assets that should be preloaded for this control
   * @param  {PhotoEditorSDK.UI.ReactUI.Editor} editor
   * @return {String[]}
   */


  TextControls.getPreloadAssets = function getPreloadAssets(editor) {
    return ['controls/text/align_left.png', 'controls/text/align_right.png', 'controls/text/align_center.png', 'controls/text/minus.png', 'controls/text/plus.png'];
  };

  return TextControls;
}(_controls2.default);

/**
 * This control's controls component. Used for the lower controls part of the editor.
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */


TextControls.controlsComponent = _textControlsComponent2.default;

/**
 * This control's canvas component. Used for the upper controls part of the editor (on
 * top of the canvas)
 * @type {PhotoEditorSDK.UI.ReactUI.ControlsComponent}
 * @ignore
 */
TextControls.canvasControlsComponent = _textCanvasControlsComponent2.default;

/**
 * This control's identifier
 * @type {String}
 * @default
 */
TextControls.identifier = 'text';

/**
 * This control's icon path
 * @type {String}
 * @ignore
 */
TextControls.iconPath = 'controls/overview/text.png';

/**
 * The language key that should be used when displaying this filter
 * @type {String}
 * @ignore
 */
TextControls.languageKey = 'controls.overview.text';

/**
 * The default options for this control
 * @type {Object}
 * @property {Object[]} [additionalFonts = []]
 * @property {Boolean} [replaceFonts = false]
 * @property {String[]} [selectableFonts = null]
 */
TextControls.defaultOptions = {
  additionalFonts: [],
  replaceFonts: false,
  selectableFonts: null,
  defaultText: null
};

exports.default = TextControls;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _spritesCanvasControlsComponent = __webpack_require__(31);

var _spritesCanvasControlsComponent2 = _interopRequireDefault(_spritesCanvasControlsComponent);

var _textControlsOverlayComponent = __webpack_require__(148);

var _textControlsOverlayComponent2 = _interopRequireDefault(_textControlsOverlayComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TextCanvasControlsComponent = function (_SpritesCanvasControl) {
  (0, _inherits3.default)(TextCanvasControlsComponent, _SpritesCanvasControl);

  function TextCanvasControlsComponent() {
    (0, _classCallCheck3.default)(this, TextCanvasControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _SpritesCanvasControl.call.apply(_SpritesCanvasControl, [this].concat(args)));

    _this._bindAll('_onTextEdit');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the selected item is deselected
   * @private
   */


  TextCanvasControlsComponent.prototype._onItemBlur = function _onItemBlur() {
    var sprite = this.getSharedState('selectedSprite');
    if (sprite && sprite.getText() === '') {
      sprite.setText(_globals.Constants.DEFAULTS.TEXT);
      sprite._edited = false;
    }
  };

  /**
   * Gets called when the user removes the selected sprite
   * @private
   */


  TextCanvasControlsComponent.prototype._onSpriteRemove = function _onSpriteRemove() {
    _SpritesCanvasControl.prototype._onSpriteRemove.call(this);
    this.props.onSwitchControls('home');
  };

  /**
   * Gets called when the clicks the edit button
   * @private
   */


  TextCanvasControlsComponent.prototype._onTextEdit = function _onTextEdit() {
    var sprite = this.getSharedState('selectedSprite');
    this.refs['sprite-' + sprite.getId()].enterEditMode();
  };

  /**
   * This renders controls on top of the sprites
   * @return {ReactBEM.Element}
   * @private
   */


  TextCanvasControlsComponent.prototype._renderOverlayControls = function _renderOverlayControls() {
    if (!this.getSharedState('selectedSprite')) return;

    return _globals.ReactBEM.createElement(_textControlsOverlayComponent2.default, {
      onTakeToFront: this._onSpriteTakeToFront,
      onRemove: this._onSpriteRemove,
      onEdit: this._onTextEdit });
  };

  return TextCanvasControlsComponent;
}(_spritesCanvasControlsComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


exports.default = TextCanvasControlsComponent;


TextCanvasControlsComponent.contextTypes = _spritesCanvasControlsComponent2.default.contextTypes;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _colorPickerComponent = __webpack_require__(38);

var _colorPickerComponent2 = _interopRequireDefault(_colorPickerComponent);

var _sliderOverlayComponent = __webpack_require__(12);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

var _fontPreviewComponent = __webpack_require__(64);

var _fontPreviewComponent2 = _interopRequireDefault(_fontPreviewComponent);

var _fontComponent = __webpack_require__(144);

var _fontComponent2 = _interopRequireDefault(_fontComponent);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ALIGNMENTS = ['left', 'center', 'right'];

var TextControlsComponent = function (_ControlsComponent) {
  (0, _inherits3.default)(TextControlsComponent, _ControlsComponent);

  function TextControlsComponent() {
    (0, _classCallCheck3.default)(this, TextControlsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ControlsComponent.call.apply(_ControlsComponent, [this].concat(args)));

    _this._bindAll('_onFontSizeChange', '_onFontChange', '_onAlignmentClick', '_onTakeToFrontClick', '_onForegroundColorChange', '_onBackgroundColorChange', '_onBeforeHistoryUndo');
    _this._events = (0, _defineProperty3.default)({}, _globals.Constants.EVENTS.HISTORY_BEFORE_UNDO, _this._onBeforeHistoryUndo);
    _this._operation = _this.getSharedState('operation');
    _this._fontLoader = _this.context.ui.getFontLoader();
    _this._fontLoader.setFonts(_this.getSharedState('fonts'));

    _this.state = { mode: null, loading: true };

    var editor = _this.context.editor;

    editor.render();

    _this._fonts = _this.getSharedState('fonts');
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  TextControlsComponent.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    _ControlsComponent.prototype.componentDidMount.call(this);

    var editor = this.context.editor;

    editor.zoom.set('auto', function () {
      editor.features.disable('zoom', 'drag');
    });

    var fontsLoaded = function fontsLoaded() {
      _this2._createText();
      _this2.setState({ loading: false });
    };

    if (this._fontLoader.needsToLoad()) {
      this._loadFonts().then(fontsLoaded.bind(this));
    } else {
      fontsLoaded();
    }
  };

  /**
   * Loads the fonts
   * @return {Promise}
   * @private
   */


  TextControlsComponent.prototype._loadFonts = function _loadFonts() {
    var _this3 = this;

    var loadingModal = _modalManager2.default.instance.displayLoading(this._t('loading.loading'));
    return this._fontLoader.load().then(function () {
      loadingModal.close();
    }).catch(function (e) {
      loadingModal.close();
      _modalManager2.default.instance.displayWarning(_this3._t('errors.loadingFontsFailed.title'), _this3._t('errors.loadingFontsFailed.text'));
    });
  };

  /**
   * Creates a new text object
   * @private
   */


  TextControlsComponent.prototype._createText = function _createText() {
    var editor = this.context.editor;

    var selectedSprite = this.getSharedState('selectedSprite');
    var operation = this.getSharedState('operation');
    var defaultFont = this.getSharedState('defaultFont');
    var options = this.props.options;


    var outputDimensions = editor.getOutputDimensions();
    if (!selectedSprite) {
      var sdk = editor.getSDK();
      var renderer = sdk.getRenderer();

      var maxTextureSize = renderer.getMaxTextureSize();
      var text = operation.createText({
        text: options.defaultText || _globals.Constants.DEFAULTS.TEXT,
        position: new _globals.Vector2(0.5, 0.5),
        maxWidth: 0.5,
        maxHeight: maxTextureSize ? maxTextureSize / outputDimensions.y : 3,
        fontSize: 0.08,
        fontFamily: defaultFont.getFontFamily(),
        fontWeight: defaultFont.getFontWeight(),
        fontStyle: defaultFont.getFontStyle(),
        alignment: 'center'
      });
      operation.addSprite(text);
      this.setSharedState({ selectedSprite: text });
    }
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called before a history item is being undone
   * @param  {Object} historyObject
   * @private
   */


  TextControlsComponent.prototype._onBeforeHistoryUndo = function _onBeforeHistoryUndo(historyObject) {
    var operation = historyObject.operation,
        options = historyObject.options;

    if (operation !== this.getSharedState('operation')) return;

    var sprites = options.sprites;

    if (sprites.indexOf(this.getSharedState('selectedSprite')) === -1) {
      // Currently selected sprite is being removed. Leave control without adding history item.
      this.setSharedState({ skipHistory: true }, false);
      this.props.onSwitchControls('home');
    }
  };

  /**
   * Gets called when the user clicks the back button
   * @param {Event} e
   * @private
   */


  TextControlsComponent.prototype._onBackClick = function _onBackClick(e) {
    var editor = this.context.editor;

    editor.render();
    this._backButtonClicked = true;
    this.props.onSwitchControls('home');
  };

  /**
   * Gets called when the shared state has changed
   * @param  {Object} newState
   */


  TextControlsComponent.prototype.sharedStateDidChange = function sharedStateDidChange(newState) {
    if ('selectedSprite' in newState) {
      this.forceUpdate();
    }
  };

  /**
   * Gets called when the font size has been changed
   * @param  {Number} fontSize
   * @private
   */


  TextControlsComponent.prototype._onFontSizeChange = function _onFontSizeChange(fontSize) {
    var outputDimensions = this.context.editor.getOutputDimensions();
    var selectedText = this.getSharedState('selectedSprite');
    selectedText.setFontSize(fontSize / outputDimensions.y);
    this.forceUpdate();
  };

  /**
   * Gets called when the font family or weight has been changed
   * @param  {Object} font
   * @private
   */


  TextControlsComponent.prototype._onFontChange = function _onFontChange(font) {
    var selectedText = this.getSharedState('selectedSprite');
    selectedText.setFontFamily(font.getFontFamily());
    selectedText.setFontWeight(font.getFontWeight());
    selectedText.setFontStyle(font.getFontStyle());
    this.forceUpdate();
  };

  /**
   * Gets called when the user clicks the alignment button
   * @param  {Event} e
   * @private
   */


  TextControlsComponent.prototype._onAlignmentClick = function _onAlignmentClick(e) {
    var selectedText = this.getSharedState('selectedSprite');
    var alignment = selectedText.getAlignment();

    var currentIndex = ALIGNMENTS.indexOf(alignment);
    var nextIndex = (currentIndex + 1) % ALIGNMENTS.length;
    var newAlignment = ALIGNMENTS[nextIndex];

    selectedText.setAlignment(newAlignment);
    this.forceSharedUpdate();
  };

  /**
   * Gets called when the user clicks the "take to front" button
   * @param  {Event} e
   * @private
   */


  TextControlsComponent.prototype._onTakeToFrontClick = function _onTakeToFrontClick(e) {
    var operation = this.getSharedState('operation');
    operation.takeSpriteToFront(this.getSharedState('selectedSprite'));
    this.forceSharedUpdate();
  };

  /**
   * Gets called when the user changes the foreground color
   * @param  {Color} color
   * @private
   */


  TextControlsComponent.prototype._onForegroundColorChange = function _onForegroundColorChange(color) {
    var selectedText = this.getSharedState('selectedSprite');
    selectedText.setColor(color);
  };

  /**
   * Gets called when the user changes the background color
   * @param  {Color} color
   * @private
   */


  TextControlsComponent.prototype._onBackgroundColorChange = function _onBackgroundColorChange(color) {
    var selectedText = this.getSharedState('selectedSprite');
    selectedText.setBackgroundColor(color);
  };

  // -------------------------------------------------------------------------- MODES

  /**
   * Switches to the given mode
   * @param  {String} mode
   * @private
   */


  TextControlsComponent.prototype._switchToMode = function _switchToMode(mode) {
    if (mode === this.state.mode) mode = null;

    this.setState({ mode: mode });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the overlay controls of this component
   * @return {ReactBEM.Element}
   */


  TextControlsComponent.prototype.renderOverlayControls = function renderOverlayControls() {
    switch (this.state.mode) {
      case 'size':
        return this._renderFontSizeOverlayControl();
      case 'font':
        return this._renderFontFamilyOverlayControl();
      default:
        return null;
    }
  };

  // -------------------------------------------------------------------------- FONT SIZE

  /**
   * Renders the font size overlay control (slider)
   * @return {ReactBEM.Element}
   * @private
   */


  TextControlsComponent.prototype._renderFontSizeOverlayControl = function _renderFontSizeOverlayControl() {
    var selectedText = this.getSharedState('selectedSprite');
    if (!selectedText) return;

    var editor = this.context.editor;

    var outputDimensions = editor.getOutputDimensions();

    var maxFontSize = Math.round(outputDimensions.y);
    var fontSize = Math.round(selectedText.getFontSize() * outputDimensions.y);
    return _globals.ReactBEM.createElement(_sliderOverlayComponent2.default, {
      value: fontSize,
      maxValue: maxFontSize,
      label: this._t('controls.text.size'),
      onChange: this._onFontSizeChange });
  };

  /**
   * Renders the font size list item
   * @return {Component}
   * @private
   */


  TextControlsComponent.prototype._renderSizeItem = function _renderSizeItem() {
    var selectedText = this.getSharedState('selectedSprite');
    if (!selectedText) return;

    var outputDimensions = this.context.editor.getOutputDimensions();

    var fontSize = selectedText.getFontSize();
    var className = this.state.mode === 'size' ? 'is-active' : null;

    return _globals.ReactBEM.createElement(
      'li',
      {
        bem: 'e:item',
        key: 'size' },
      _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          {
            bem: '$e:button m:withLabel',
            className: className,
            'data-identifier': 'fontSize',
            onClick: this._switchToMode.bind(this, 'size') },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'b:fontSize e:text' },
            Math.round(fontSize * outputDimensions.y)
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this._t('controls.text.size')
          )
        )
      )
    );
  };

  // -------------------------------------------------------------------------- FONT FAMILY

  /**
   * Renders the font family overlay control
   * @return {ReactBEM.Element}
   * @private
   */


  TextControlsComponent.prototype._renderFontFamilyOverlayControl = function _renderFontFamilyOverlayControl() {
    var selectedText = this.getSharedState('selectedSprite');
    if (!selectedText) return;

    return _globals.ReactBEM.createElement(_fontComponent2.default, {
      fontFamily: selectedText.getFontFamily(),
      fontWeight: selectedText.getFontWeight(),
      fontStyle: selectedText.getFontStyle(),
      fonts: this._fonts,
      onChange: this._onFontChange });
  };

  /**
   * Renders the font list item
   * @return {Component}
   * @private
   */


  TextControlsComponent.prototype._renderFontItem = function _renderFontItem() {
    var selectedText = this.getSharedState('selectedSprite');
    if (!selectedText) return;

    var className = this.state.mode === 'font' ? 'is-active' : null;
    return _globals.ReactBEM.createElement(
      'li',
      {
        bem: 'e:item',
        key: 'font' },
      _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          {
            bem: '$e:button m:withLabel',
            className: className,
            'data-identifier': 'font',
            onClick: this._switchToMode.bind(this, 'font') },
          _globals.ReactBEM.createElement(_fontPreviewComponent2.default, {
            fontFamily: selectedText.getFontFamily(),
            fontWeight: selectedText.getFontWeight(),
            fontStyle: selectedText.getFontStyle() }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this._t('controls.text.font')
          )
        )
      )
    );
  };

  // -------------------------------------------------------------------------- ALIGNMENT

  /**
   * Renders the text alignment list item
   * @return {Component}
   * @private
   */


  TextControlsComponent.prototype._renderAlignmentItem = function _renderAlignmentItem() {
    var selectedText = this.getSharedState('selectedSprite');
    if (!selectedText) return;

    var alignment = selectedText.getAlignment();

    return _globals.ReactBEM.createElement(
      'li',
      {
        bem: 'e:item',
        key: 'alignment' },
      _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          {
            bem: '$e:button m:withLabel',
            onClick: this._onAlignmentClick,
            'data-identifier': 'alignment' },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/text/align_' + alignment + '.png', true) }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this._t('controls.text.alignment')
          )
        )
      )
    );
  };

  /**
   * Renders the "take to front" list item
   * @return {Component}
   * @private
   */


  TextControlsComponent.prototype._renderTakeToFrontItem = function _renderTakeToFrontItem() {
    return _globals.ReactBEM.createElement(
      'li',
      {
        bem: 'e:item',
        key: 'takeToFront' },
      _globals.ReactBEM.createElement(
        'bem',
        { specifier: '$b:controls' },
        _globals.ReactBEM.createElement(
          'div',
          {
            bem: '$e:button m:withLabel',
            onClick: this._onTakeToFrontClick },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/take_to_front.png', true) }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this._t('controls.text.takeToFront')
          )
        )
      )
    );
  };

  /**
   * Renders this component
   * @return {Array.<ReactBEM.Element>}
   */


  TextControlsComponent.prototype.renderControls = function renderControls() {
    if (this.state.loading) return _globals.ReactBEM.createElement('div', null);

    var listItems = [this._renderSizeItem(), this._renderFontItem(), this._renderAlignmentItem()];

    var selectedText = this.getSharedState('selectedSprite');

    var foregroundColor = selectedText.getColor().clone();
    var backgroundColor = selectedText.getBackgroundColor().clone();

    return [_globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:list' },
      _globals.ReactBEM.createElement(
        _scrollbarComponent2.default,
        { ref: 'scrollbar' },
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:list' },
          listItems
        )
      )
    ), _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:colorPicker' },
      _globals.ReactBEM.createElement(_colorPickerComponent2.default, {
        initialValue: foregroundColor,
        label: this._t('controls.text.foreground'),
        onChange: this._onForegroundColorChange })
    ), _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:cell m:colorPicker' },
      _globals.ReactBEM.createElement(_colorPickerComponent2.default, {
        initialValue: backgroundColor,
        label: this._t('controls.text.background'),
        onChange: this._onBackgroundColorChange })
    )];
  };

  return TextControlsComponent;
}(_controlsComponent2.default);

exports.default = TextControlsComponent;


TextControlsComponent.contextTypes = _controlsComponent2.default.contextTypes;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TextControlsOverlayComponent = function (_BaseComponent) {
  (0, _inherits3.default)(TextControlsOverlayComponent, _BaseComponent);

  function TextControlsOverlayComponent() {
    (0, _classCallCheck3.default)(this, TextControlsOverlayComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the `edit` item
   * @param  {Event} e
   * @private
   */
  TextControlsOverlayComponent.prototype._onEditClick = function _onEditClick(e) {
    e.preventDefault();
    e.stopPropagation();

    this.props.onEdit && this.props.onEdit();
  };

  /**
   * Gets called when the user clicks the `take to front` item
   * @param  {Event} e
   * @private
   */


  TextControlsOverlayComponent.prototype._onTakeToFrontClick = function _onTakeToFrontClick(e) {
    e.preventDefault();
    e.stopPropagation();

    this.props.onTakeToFront && this.props.onTakeToFront();
  };

  /**
   * Gets called when the user clicks the `remove` item
   * @param  {Event} e
   * @private
   */


  TextControlsOverlayComponent.prototype._onRemoveClick = function _onRemoveClick(e) {
    e.preventDefault();
    e.stopPropagation();

    this.props.onRemove && this.props.onRemove();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the items of this component
   * @return {Array.<ReactBEM.Element>}
   */


  TextControlsOverlayComponent.prototype._renderItems = function _renderItems() {
    var items = [_globals.ReactBEM.createElement(
      'div',
      { bem: '$e:item', onClick: this._onTakeToFrontClick.bind(this) },
      _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/take-to-front.png', true) })
    )];

    if (_globals.Utils.isMobile()) {
      items = items.concat([_globals.ReactBEM.createElement('div', { bem: '$e:separator' }), _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:item', onClick: this._onEditClick.bind(this) },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/edit.png', true) })
      )]);
    }

    items = items.concat([_globals.ReactBEM.createElement('div', { bem: '$e:separator' }), _globals.ReactBEM.createElement(
      'div',
      { bem: '$e:item', onClick: this._onRemoveClick.bind(this) },
      _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/sprites/remove.png', true) })
    )]);

    return items;
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  TextControlsOverlayComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      {
        bem: '$b:spritesControlsOverlay' },
      this._renderItems()
    );
  };

  return TextControlsOverlayComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = TextControlsOverlayComponent;


TextControlsOverlayComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DoneButtonComponent = function (_BaseComponent) {
  (0, _inherits3.default)(DoneButtonComponent, _BaseComponent);

  function DoneButtonComponent() {
    (0, _classCallCheck3.default)(this, DoneButtonComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  DoneButtonComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:controls' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell m:largeButton' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: '$e:largeButton', onClick: this.props.onClick },
          _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/tick.png', true) })
        )
      )
    );
  };

  return DoneButtonComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = DoneButtonComponent;


DoneButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HeaderComponent = function (_BaseComponent) {
  (0, _inherits3.default)(HeaderComponent, _BaseComponent);

  function HeaderComponent() {
    (0, _classCallCheck3.default)(this, HeaderComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onCloseClick');
    return _this;
  }

  /**
   * Gets called when the user clicks the close button
   * @private
   */


  HeaderComponent.prototype._onCloseClick = function _onCloseClick() {
    this.context.mediator.emit(_globals.Constants.EVENTS.CLOSE);
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  HeaderComponent.prototype.renderWithBEM = function renderWithBEM() {
    var closeButton = void 0;
    if (this.context.options.showCloseButton) {
      closeButton = _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:close', onClick: this._onCloseClick },
        _globals.ReactBEM.createElement('img', { bem: 'e:image', src: this._getAssetPath('close.png', true) })
      );
    }

    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:header' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:label' },
        this.context.options.title
      ),
      closeButton
    );
  };

  return HeaderComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


exports.default = HeaderComponent;


HeaderComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _loadingModalComponent = __webpack_require__(153);

var _loadingModalComponent2 = _interopRequireDefault(_loadingModalComponent);

var _warningModalComponent = __webpack_require__(155);

var _warningModalComponent2 = _interopRequireDefault(_warningModalComponent);

var _errorModalComponent = __webpack_require__(152);

var _errorModalComponent2 = _interopRequireDefault(_errorModalComponent);

var _progressModalComponent = __webpack_require__(154);

var _progressModalComponent2 = _interopRequireDefault(_progressModalComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ModalContainerComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ModalContainerComponent, _BaseComponent);

  function ModalContainerComponent() {
    (0, _classCallCheck3.default)(this, ModalContainerComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._modalManager = _this.props.modalManager;
    _this._bindAll('_onModalManagerUpdate');
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  ModalContainerComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);

    this._modalManager.on('update', this._onModalManagerUpdate);
  };

  /**
   * Gets called when this component is about to be unmounted
   */


  ModalContainerComponent.prototype.componentWillUnmount = function componentWillUnmount() {
    _BaseComponent.prototype.componentWillUnmount.call(this);

    this._modalManager.off('update', this._onModalManagerUpdate);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the modal manager updates
   * @private
   */


  ModalContainerComponent.prototype._onModalManagerUpdate = function _onModalManagerUpdate() {
    this.forceUpdate();
  };

  /**
   * Gets called when a modal is closed. Removes it from the manager.
   * @param  {Modal} modal
   * @private
   */


  ModalContainerComponent.prototype._onModalClosed = function _onModalClosed(modal) {
    this._modalManager.removeModal(modal);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the modals
   * @return {Array.<React.Component>}
   */


  ModalContainerComponent.prototype._renderModals = function _renderModals() {
    var _this2 = this;

    var modals = this._modalManager.getModals();
    return modals.map(function (modal) {
      var ModalComponent = void 0;

      switch (modal.type) {
        case 'loading':
          ModalComponent = _loadingModalComponent2.default;
          break;
        case 'warning':
          ModalComponent = _warningModalComponent2.default;
          break;
        case 'error':
          ModalComponent = _errorModalComponent2.default;
          break;
        case 'progress':
          ModalComponent = _progressModalComponent2.default;
          break;
      }

      return _globals.ReactBEM.createElement(ModalComponent, {
        modal: modal,
        onClose: _this2._onModalClosed.bind(_this2, modal) });
    });
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  ModalContainerComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      null,
      this._renderModals()
    );
  };

  return ModalContainerComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = ModalContainerComponent;


ModalContainerComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ErrorModalComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ErrorModalComponent, _BaseComponent);

  function ErrorModalComponent() {
    (0, _classCallCheck3.default)(this, ErrorModalComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onClose');
    return _this;
  }

  /**
   * Gets called when the user clicks the close button
   * @private
   */


  ErrorModalComponent.prototype._onClose = function _onClose() {
    this.props.modal.close();
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  ErrorModalComponent.prototype.renderWithBEM = function renderWithBEM() {
    var modal = this.props.modal;

    var modalElement = _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:modal m:error' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:title' },
        modal.title
      ),
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:text' },
        modal.text
      ),
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:button b:button m:inline', onClick: this._onClose },
        'OK'
      )
    );

    var content = modal.overlay ? _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:overlay' },
      modalElement
    ) : modalElement;

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:modals' },
      content
    );
  };

  return ErrorModalComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = ErrorModalComponent;


ErrorModalComponent.propTypes = {
  modal: _globals.React.PropTypes.object
};

ErrorModalComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LoadingModalComponent = function (_BaseComponent) {
  (0, _inherits3.default)(LoadingModalComponent, _BaseComponent);

  function LoadingModalComponent() {
    (0, _classCallCheck3.default)(this, LoadingModalComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  LoadingModalComponent.prototype.renderWithBEM = function renderWithBEM() {
    var modal = this.props.modal;
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:modals' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:overlay' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:modal m:loading' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:text' },
            modal.text
          )
        )
      )
    );
  };

  return LoadingModalComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = LoadingModalComponent;


LoadingModalComponent.propTypes = {
  modal: _globals.React.PropTypes.object
};

LoadingModalComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ProgressModalComponent = function (_BaseComponent) {
  (0, _inherits3.default)(ProgressModalComponent, _BaseComponent);

  function ProgressModalComponent() {
    (0, _classCallCheck3.default)(this, ProgressModalComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  ProgressModalComponent.prototype.renderWithBEM = function renderWithBEM() {
    var modal = this.props.modal;
    var progress = modal.data.progress;

    var progressStyle = {
      width: ((progress || 0) * 100).toFixed(2) + '%'
    };
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:modals' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:overlay' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:modal m:loading' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:text' },
            modal.text
          ),
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: 'b:loadingModal' },
            _globals.ReactBEM.createElement(
              'div',
              { bem: '$e:progressBar' },
              _globals.ReactBEM.createElement('div', { bem: 'e:progress', style: progressStyle })
            )
          )
        )
      )
    );
  };

  return ProgressModalComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = ProgressModalComponent;


ProgressModalComponent.propTypes = {
  modal: _globals.React.PropTypes.object
};

ProgressModalComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WarningModalComponent = function (_BaseComponent) {
  (0, _inherits3.default)(WarningModalComponent, _BaseComponent);

  function WarningModalComponent() {
    (0, _classCallCheck3.default)(this, WarningModalComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  WarningModalComponent.prototype.renderWithBEM = function renderWithBEM() {
    var modal = this.props.modal;
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:modals' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:modal m:warning' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:title' },
          modal.title
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:text' },
          modal.text
        ),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:button b:button m:inline', onClick: this.props.onClose },
          'OK'
        )
      )
    );
  };

  return WarningModalComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = WarningModalComponent;


WarningModalComponent.propTypes = {
  modal: _globals.React.PropTypes.object
};

WarningModalComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(4);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CanvasComponent = function (_BaseComponent) {
  (0, _inherits3.default)(CanvasComponent, _BaseComponent);

  function CanvasComponent() {
    var _this$_events;

    (0, _classCallCheck3.default)(this, CanvasComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onDragStart', '_onDragMove', '_onDragEnd', '_onWindowResize', '_onFeaturesUpdated', '_onZoomChange');

    _this._events = (_this$_events = {}, (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.WINDOW_RESIZE, _this._onWindowResize), (0, _defineProperty3.default)(_this$_events, _globals.Constants.EVENTS.FEATURES_UPDATED, _this._onFeaturesUpdated), _this$_events);

    _this._initialRenderDone = false;

    _this.state = {
      canvasPosition: new _globals.Vector2(),
      canvasOffset: new _globals.Vector2()
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called after the window has been resized
   * @private
   */


  CanvasComponent.prototype._onWindowResize = function _onWindowResize() {
    var editor = this.context.editor;

    var sdk = editor.getSDK();
    sdk.resizeTo(this._getContainerDimensions());
    editor.zoom.set('auto');
  };

  /**
   * Gets called when features (e.g. drag) are updated
   * @param {String[]} identifiers
   * @private
   */


  CanvasComponent.prototype._onFeaturesUpdated = function _onFeaturesUpdated(identifiers) {
    if (identifiers.indexOf('drag') !== -1) {
      this.forceUpdate();
    }
  };

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after this component has been mounted
   */


  CanvasComponent.prototype.componentDidMount = function componentDidMount() {
    _BaseComponent.prototype.componentDidMount.call(this);

    var editor = this.context.editor;

    var renderer = editor.getRenderer();

    var _refs = this.refs,
        canvasCell = _refs.canvasCell,
        canvas = _refs.canvas;

    var width = canvasCell.offsetWidth;
    var height = canvasCell.offsetHeight;
    renderer.setCanvas(canvas);
    renderer.resizeTo(new _globals.Vector2(width, height), true);

    editor.zoom.on('set', this._onZoomChange);
  };

  /**
   * Gets called when this component is about to be unmounted
   */


  CanvasComponent.prototype.componentWillUnmount = function componentWillUnmount() {
    var editor = this.context.editor;

    editor.zoom.off('set', this._onZoomChange);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the zoom has changed
   * @private
   */


  CanvasComponent.prototype._onZoomChange = function _onZoomChange() {
    this.forceUpdate();
  };

  // -------------------------------------------------------------------------- DRAGGING

  /**
   * Gets called when the user starts dragging the canvas
   * @param {React.SyntheticEvent} e
   * @private
   */


  CanvasComponent.prototype._onDragStart = function _onDragStart(e) {
    var editor = this.context.editor;

    if (!editor.features.isEnabled('drag')) return;

    e.preventDefault();

    this._dragStartPosition = _globals.Utils.getEventPosition(e.nativeEvent);
    this._dragInitialOffset = editor.getOffset().clone();
    document.addEventListener('mousemove', this._onDragMove);
    document.addEventListener('touchmove', this._onDragMove);
    document.addEventListener('mouseup', this._onDragEnd);
    document.addEventListener('touchend', this._onDragEnd);
  };

  /**
   * Gets called while the user drags the canvas
   * @param {DOMEvent} e
   * @private
   */


  CanvasComponent.prototype._onDragMove = function _onDragMove(e) {
    var eventPosition = _globals.Utils.getEventPosition(e);
    var diffFromStart = eventPosition.clone().subtract(this._dragStartPosition);

    var newOffset = this._dragInitialOffset.clone().add(diffFromStart);

    var editor = this.context.editor;

    var lastOffset = editor.getOffset().clone();
    editor.setOffset(newOffset);
    if (!editor.getOffset().equals(lastOffset)) {
      editor.render();
    }
  };

  /**
   * Gets called when the user stops dragging the canvas
   * @param {DOMEvent} e
   * @private
   */


  CanvasComponent.prototype._onDragEnd = function _onDragEnd(e) {
    document.removeEventListener('mousemove', this._onDragMove);
    document.removeEventListener('touchmove', this._onDragMove);
    document.removeEventListener('mouseup', this._onDragEnd);
    document.removeEventListener('touchend', this._onDragEnd);
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Returns the container's dimensions
   * @return {Vector2}
   * @private
   */


  CanvasComponent.prototype._getContainerDimensions = function _getContainerDimensions() {
    var canvasCell = this.refs.canvasCell;

    return new _globals.Vector2(canvasCell.offsetWidth, canvasCell.offsetHeight);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Returns the style properties for the draggable canvas area
   * @private
   */


  CanvasComponent.prototype._getDraggableStyle = function _getDraggableStyle() {
    return {
      top: this.state.canvasPosition.y + this.state.canvasOffset.y,
      left: this.state.canvasPosition.x + this.state.canvasOffset.x
    };
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  CanvasComponent.prototype.renderWithBEM = function renderWithBEM() {
    var canvasContent = null;
    var containerContent = null;
    if (this.props.largeControls) {
      containerContent = this.props.children;
    } else {
      canvasContent = this.props.children;
    }

    var editor = this.context.editor;

    var zoomAllowsDrag = editor.isReady() && editor.zoom.get() > editor.zoom.getDefault();
    var dragEnabled = editor.features.isEnabled('drag') && zoomAllowsDrag;

    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:canvas e:container e:row' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:container e:cell', ref: 'canvasCell' },
        _globals.ReactBEM.createElement(
          'div',
          {
            bem: 'e:innerContainer',
            className: dragEnabled ? 'is-draggable' : null,
            onTouchStart: this._onDragStart,
            onMouseDown: this._onDragStart,
            style: this._getDraggableStyle() },
          _globals.ReactBEM.createElement('canvas', {
            bem: 'e:canvas',
            ref: 'canvas' }),
          canvasContent
        ),
        containerContent
      )
    );
  };

  return CanvasComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = CanvasComponent;


CanvasComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _overviewControlsComponent = __webpack_require__(63);

var _overviewControlsComponent2 = _interopRequireDefault(_overviewControlsComponent);

var _screenComponent = __webpack_require__(21);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _canvasComponent = __webpack_require__(156);

var _canvasComponent2 = _interopRequireDefault(_canvasComponent);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _overview = __webpack_require__(126);

var _overview2 = _interopRequireDefault(_overview);

var _editor3 = __webpack_require__(68);

var _editor4 = _interopRequireDefault(_editor3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */
var WINDOW_RESIZE_DELAY = 500;

var EditorScreenComponent = function (_ScreenComponent) {
  (0, _inherits3.default)(EditorScreenComponent, _ScreenComponent);

  function EditorScreenComponent() {
    (0, _classCallCheck3.default)(this, EditorScreenComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ScreenComponent.call.apply(_ScreenComponent, [this].concat(args)));

    _this._overviewControls = _overviewControlsComponent2.default;

    _this._bindAll('switchToControls', '_startEditor', '_onWindowResize', '_onWindowResizeDone', '_onImageResize', '_onNewImage', '_onRenderError');

    _this._previousControlsStack = [];
    _this.state = {
      zoom: null,
      controls: _overview2.default,
      dragEnabled: true,
      sharedState: new _globals.SharedState()
    };

    _this._editor = new _editor4.default(_this.context.ui, _this.context.options, _this.context.mediator);
    _this._editor.on('new-image', _this._onNewImage);
    _this._editor.on('ready', _this._startEditor);
    _this._editor.on('resize', _this._onImageResize);
    _this._editor.on('render-error', _this._onRenderError);

    _this._forceControls = _this.context.options.editor.forceControls;
    _this._forceControlIndex = 0;
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called after this component has been mounted
   */


  EditorScreenComponent.prototype.componentDidMount = function componentDidMount() {
    _ScreenComponent.prototype.componentDidMount.call(this);

    var image = this.context.options.editor.image;

    this.setImage(image);
    this._editor.render();

    this._switchToNextForceControl();

    var options = this.context.options;

    if (options.responsive) {
      window.addEventListener('resize', this._onWindowResize);
    }
  };

  /**
   * Gets called before this component is unmounted
   */


  EditorScreenComponent.prototype.componentWillUnmount = function componentWillUnmount() {
    _ScreenComponent.prototype.componentWillUnmount.call(this);

    this._editor.dispose();
    var options = this.context.options;

    if (options.responsive) {
      window.removeEventListener('resize', this._onWindowResize);
    }
  };

  /**
   * Sets the zoom level and starts the editor rendering
   * @private
   */


  EditorScreenComponent.prototype._startEditor = function _startEditor() {
    this._editor.start();
  };

  // -------------------------------------------------------------------------- FORCE CONTROLS

  /**
   * Switches to the next forced control
   * @private
   */


  EditorScreenComponent.prototype._switchToNextForceControl = function _switchToNextForceControl() {
    if (this._forceControlIndex < this._forceControls.length) {
      var _forceControls$_force = this._forceControls[this._forceControlIndex],
          control = _forceControls$_force.control,
          options = _forceControls$_force.options;

      var availableControls = this._editor.controls.getAvailable();
      var controlObject = availableControls[control];

      var fixedOptions = _globals.SDKUtils.defaults({
        forcedControl: true
      }, options);

      if (!controlObject) {
        throw new Error('Force controls: Could not find control with identifier `' + control + '`');
      }

      this.switchToControls(controlObject, {}, null, fixedOptions);
      this._forceControlIndex++;
    }
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when an error occurred while rendering
   * @param  {Event} e
   * @private
   */


  EditorScreenComponent.prototype._onRenderError = function _onRenderError(e) {
    _modalManager2.default.instance.displayError(this._t('errors.renderingError.title'), this._t('errors.renderingError.text'), true);
    _globals.Log.error(this.constructor.name, 'An error occurred while rendering: ' + e.message);
    _globals.Log.printError(e);
  };

  /**
   * Gets called when the image has been changed
   * @private
   */


  EditorScreenComponent.prototype._onNewImage = function _onNewImage() {
    this.switchToControls(_overview2.default);
  };

  /**
   * Gets called when the editor starts resizing an image
   * @private
   */


  EditorScreenComponent.prototype._onImageResize = function _onImageResize() {
    var _this2 = this;

    var loadingModal = _modalManager2.default.instance.displayLoading(this._t('loading.resizing'));
    this._editor.once('resized', function (_ref) {
      var dimensions = _ref.dimensions,
          reason = _ref.reason;

      loadingModal.close();

      if (_this2.context.options.editor.displayResizeMessage) {
        _modalManager2.default.instance.displayWarning(_this2._t('warnings.imageResized_' + reason + '.title'), _this2._t('warnings.imageResized_' + reason + '.text', {
          maxMegaPixels: _this2._editor.getMaxMegapixels(),
          width: dimensions.x,
          height: dimensions.y
        }));
      }
    });
  };

  /**
   * Gets called on window resize
   * @private
   */


  EditorScreenComponent.prototype._onWindowResize = function _onWindowResize() {
    if (this._resizeTimeout) {
      window.clearTimeout(this._resizeTimeout);
      this._resizeTimeout = null;
    }
    this._resizeTimeout = window.setTimeout(this._onWindowResizeDone, WINDOW_RESIZE_DELAY);
  };

  /**
   * Gets called `WINDOW_RESIZE_DELAY` ms after the last resize event has been called
   * @private
   */


  EditorScreenComponent.prototype._onWindowResizeDone = function _onWindowResizeDone() {
    this._emitEvent(_globals.Constants.EVENTS.WINDOW_RESIZE);
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Switches to the given controls
   * @param  {Component} controls
   * @param  {Object} [initialState] = {}
   * @param  {Function} [callback]
   * @param  {Object} [controlOptions]
   */


  EditorScreenComponent.prototype.switchToControls = function switchToControls(controls) {
    var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var controlOptions = arguments[3];

    var newControls = null;
    if (controls === 'back') {
      newControls = this._previousControlsStack.pop();
    } else if (controls === 'home') {
      // When a control switches to `home`, override this action
      // with switching to the next force control (if present)
      if (this._forceControlIndex < this._forceControls.length) {
        return this._switchToNextForceControl();
      }

      newControls = _overview2.default;
      this._previousControlsStack = [];
    } else {
      newControls = controls;
      this._previousControlsStack.push(this.state.controls);
    }

    var controlsChanged = this.state.controls !== newControls;

    // If the previous controls have an `onExit` method, call it
    // with the controls as `this`
    if (this.state.controls.onExit) {
      this.state.controls.onExit.call(this.refs.controls);
    }

    this.state.sharedState.clear();
    this.state.sharedState.set(initialState, false);

    var controlsOptions = _globals.SDKUtils.defaults(controlOptions || this.context.options.editor.controlsOptions[newControls.identifier], newControls.defaultOptions);

    // If the new controls have an `onEnter` method, call it
    if (newControls.onEnter) {
      newControls.onEnter.call(this.refs.controls, this.state.sharedState, controlsOptions);
    }

    if (controlsChanged) {
      this.setState({
        controls: newControls,
        controlsOptions: controlsOptions
      }, callback);
    } else {
      // No need to re-set the state. Call callback immediately
      return callback && callback();
    }
  };

  /**
   * Returns the zoom level
   * @return {Number}
   */


  EditorScreenComponent.prototype.getZoom = function getZoom() {
    return this.state.zoom;
  };

  /**
   * Exports an image
   * @param {Boolean} download = false
   * @return {Promise}
   */


  EditorScreenComponent.prototype.export = function _export() {
    var _this3 = this;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return new Promise(function (resolve, reject) {
      _this3.switchToControls('home', {}, function () {
        var _editor;

        (_editor = _this3._editor).export.apply(_editor, args).then(resolve).catch(reject);
      });
    });
  };

  /**
   * Returns the editor
   * @return {PhotoEditorSDK.UI.ReactUI.Editor}
   */


  EditorScreenComponent.prototype.getEditor = function getEditor() {
    return this._editor;
  };

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  EditorScreenComponent.prototype.serialize = function serialize() {
    var _editor2;

    return (_editor2 = this._editor).serialize.apply(_editor2, arguments);
  };

  /**
   * Deserializes the given data
   * @param  {Object} data
   * @return {Promise}
   */


  EditorScreenComponent.prototype.deserialize = function deserialize(data) {
    return this._editor.deserialize(data);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Decides whether the undo button should be displayed
   * @return {Boolean}
   * @private
   */


  EditorScreenComponent.prototype._showUndoButton = function _showUndoButton() {
    return this._editor.history.isAvailable();
  };

  /**
   * Returns the context passed to all children
   * @return {Object}
   */


  EditorScreenComponent.prototype.getChildContext = function getChildContext() {
    return {
      editor: this._editor,
      ui: this.context.ui,
      options: this.context.options,
      editorScreen: this,
      mediator: this.context.mediator
    };
  };

  /**
   * Sets the image to the given one
   * @param {Image} image
   * @param {Boolean} resetEditor
   */


  EditorScreenComponent.prototype.setImage = function setImage(image, resetEditor) {
    this._editor.setImage(image, resetEditor);
  };

  /**
   * Renders this screen
   * @return {ReactBEM.Element}
   * @private
   */


  EditorScreenComponent.prototype._renderScreen = function _renderScreen() {
    var ControlsComponent = this.state.controls.controlsComponent;
    var CanvasControlsComponent = this.state.controls.canvasControlsComponent;
    if (!CanvasControlsComponent) {
      CanvasControlsComponent = _overview2.default.canvasControlsComponent;
    }
    var TopBarControlsComponent = this.state.controls.topBarControlsComponent;
    if (!TopBarControlsComponent) {
      TopBarControlsComponent = _overview2.default.topBarControlsComponent;
    }

    var controls = void 0,
        canvasControls = void 0,
        topBarControls = void 0;

    if (TopBarControlsComponent && this.context.options.showTopBar) {
      topBarControls = _globals.ReactBEM.createElement(TopBarControlsComponent, {
        sharedState: this.state.sharedState,
        options: this.state.controlsOptions,
        app: this.props.app,
        ref: 'topBarControls' });
    }

    if (ControlsComponent) {
      controls = _globals.ReactBEM.createElement(ControlsComponent, {
        onSwitchControls: this.switchToControls,
        sharedState: this.state.sharedState,
        options: this.state.controlsOptions,
        app: this.props.app,
        key: this.state.controls.identifier + '-controls',
        ref: 'controls' });
    }

    if (CanvasControlsComponent) {
      canvasControls = _globals.ReactBEM.createElement(CanvasControlsComponent, {
        onSwitchControls: this.switchToControls,
        sharedState: this.state.sharedState,
        options: this.state.controlsOptions,
        app: this.props.app,
        key: this.state.controls.identifier + '-canvasControls',
        ref: 'canvasControls' });
    }

    var bemSpecifier = '$b:editorScreen';
    if (!this.context.options.showHeader) {
      bemSpecifier += ' m:noHeader';
    }

    return _globals.ReactBEM.createElement(
      'div',
      { bem: bemSpecifier },
      topBarControls,
      _globals.ReactBEM.createElement(
        _canvasComponent2.default,
        {
          ref: 'canvas',
          largeControls: this.state.controls.largeCanvasControls },
        canvasControls
      ),
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:controls $e:container e:row' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell' },
          controls
        )
      )
    );
  };

  return EditorScreenComponent;
}(_screenComponent2.default);

exports.default = EditorScreenComponent;


EditorScreenComponent.childContextTypes = {
  ui: _globals.React.PropTypes.object.isRequired,
  editor: _globals.React.PropTypes.object.isRequired,
  mediator: _globals.React.PropTypes.object.isRequired,
  options: _globals.React.PropTypes.object.isRequired,
  editorScreen: _globals.React.PropTypes.object.isRequired
};

EditorScreenComponent.contextTypes = _screenComponent2.default.contextTypes;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _preloader = __webpack_require__(195);

var _preloader2 = _interopRequireDefault(_preloader);

var _screenComponent = __webpack_require__(21);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LoadingScreenComponent = function (_ScreenComponent) {
  (0, _inherits3.default)(LoadingScreenComponent, _ScreenComponent);

  function LoadingScreenComponent() {
    (0, _classCallCheck3.default)(this, LoadingScreenComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ScreenComponent.call.apply(_ScreenComponent, [this].concat(args)));

    _this.state = { progress: 0 };

    _this._preloader = new _preloader2.default(_this.context.ui, _this.context.options, _this.context.mediator);
    _this._preloader.on('progress', function (progress) {
      _this.state.progress = progress;
    });
    _this._preloader.on('done', function () {
      _this.props.app.switchToScreen('post-loading');
    });
    return _this;
  }

  /**
   * Gets called when this component has been mounted
   */


  LoadingScreenComponent.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    _ScreenComponent.prototype.componentDidMount.call(this);
    var _window = window,
        devicePixelRatio = _window.devicePixelRatio;

    this._canvas = this.refs.canvas;
    this._canvas.width = this._canvas.offsetWidth * devicePixelRatio;
    this._canvas.height = this._canvas.offsetHeight * devicePixelRatio;
    this._context = this._canvas.getContext('2d');

    this._preloaderImage = new window.Image();
    this._preloaderImage.addEventListener('load', function () {
      _this2._preloader.load();
      (0, _globals.requestAnimationFrame)(_this2._tick);
    });
    this._preloaderImage.crossOrigin = 'Anonymous';
    this._preloaderImage.src = this.context.ui.getAssetPath('preloader.png', true);

    this._running = true;
    this._tick = this._tick.bind(this);
  };

  /**
   * Gets called when this component is about to be unmounted
   */


  LoadingScreenComponent.prototype.componentWillUnmount = function componentWillUnmount() {
    _ScreenComponent.prototype.componentWillUnmount.call(this);
    this._running = false;
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * @private
   */


  LoadingScreenComponent.prototype._tick = function _tick() {
    this._renderLoadingIndicator();
    if (this._running) {
      (0, _globals.requestAnimationFrame)(this._tick);
    }
  };

  /**
   * (Re-)Renders the loading indicator
   * @private
   */


  LoadingScreenComponent.prototype._renderLoadingIndicator = function _renderLoadingIndicator() {
    var _canvas = this._canvas,
        width = _canvas.width,
        height = _canvas.height;

    var ctx = this._context;
    ctx.clearRect(0, 0, width, height);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(width / 2, height / 2);
    ctx.arc(width / 2, height / 2, width / 2, -Math.PI * 0.5, Math.PI * 2 * this.state.progress - Math.PI * 0.5, false);
    ctx.lineTo(width / 2, height / 2);
    ctx.clip();
    ctx.drawImage(this._preloaderImage, 0, 0, this._preloaderImage.width, this._preloaderImage.height, 0, 0, width, height);
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = 0.05;
    ctx.drawImage(this._preloaderImage, 0, 0, this._preloaderImage.width, this._preloaderImage.height, 0, 0, width, height);
    ctx.restore();
  };

  /**
   * Renders this screen
   * @return {ReactBEM.Element}
   * @private
   */


  LoadingScreenComponent.prototype._renderScreen = function _renderScreen() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:loadingScreen' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:container' },
        _globals.ReactBEM.createElement('canvas', { bem: 'e:canvas', ref: 'canvas' })
      )
    );
  };

  return LoadingScreenComponent;
}(_screenComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


exports.default = LoadingScreenComponent;


LoadingScreenComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LibraryComponent = function (_BaseComponent) {
  (0, _inherits3.default)(LibraryComponent, _BaseComponent);

  function LibraryComponent() {
    (0, _classCallCheck3.default)(this, LibraryComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onClick');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the library
   * @private
   */


  LibraryComponent.prototype._onClick = function _onClick() {
    this.props.onClick && this.props.onClick(this.props.library);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  LibraryComponent.prototype.renderWithBEM = function renderWithBEM() {
    var library = this.props.library;

    var style = {
      backgroundImage: 'url(' + library.coverImage + ')'
    };

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: 'b:photoRoll e:libraryList' },
      _globals.ReactBEM.createElement(
        'li',
        { bem: 'e:item', style: style, onClick: this._onClick },
        _globals.ReactBEM.createElement('div', { bem: 'e:overlay' }),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:name' },
          library.name
        )
      )
    );
  };

  return LibraryComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = LibraryComponent;


LibraryComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoComponent = function (_BaseComponent) {
  (0, _inherits3.default)(PhotoComponent, _BaseComponent);

  function PhotoComponent() {
    (0, _classCallCheck3.default)(this, PhotoComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  PhotoComponent.prototype.renderWithBEM = function renderWithBEM() {
    var photo = this.props.photo;

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: 'b:photoRoll e:photoList' },
      _globals.ReactBEM.createElement(
        'li',
        { bem: '$e:item', onClick: this.props.onClick },
        _globals.ReactBEM.createElement('div', { bem: 'e:overlay' }),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:title' },
          photo.title
        ),
        _globals.ReactBEM.createElement('img', { bem: 'e:image', src: photo.urls.thumb })
      )
    );
  };

  return PhotoComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = PhotoComponent;


PhotoComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _searchSuggestionComponent = __webpack_require__(65);

var _searchSuggestionComponent2 = _interopRequireDefault(_searchSuggestionComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var NoSearchResultsComponent = function (_BaseComponent) {
  (0, _inherits3.default)(NoSearchResultsComponent, _BaseComponent);

  function NoSearchResultsComponent() {
    (0, _classCallCheck3.default)(this, NoSearchResultsComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onSearchSuggestionClick');

    var PhotoRollProvider = _this.context.options.photoRoll.provider;
    _this._provider = new PhotoRollProvider();

    _this.state = {
      searchSuggestions: []
    };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when a search suggestion was clicked
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.SearchSuggestion} searchSuggestion
   * @private
   */


  NoSearchResultsComponent.prototype._onSearchSuggestionClick = function _onSearchSuggestionClick(searchSuggestion) {
    this.props.onSearchSuggestionClicked && this.props.onSearchSuggestionClicked(searchSuggestion);
  };

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  NoSearchResultsComponent.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    _BaseComponent.prototype.componentDidMount.call(this);

    this._provider.getSearchSuggestions().then(function (searchSuggestions) {
      _this2.setState({
        searchSuggestions: searchSuggestions
      });
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the message (which can include html)
   * @return {Object}
   * @private
   */


  NoSearchResultsComponent.prototype._renderMessage = function _renderMessage() {
    return { __html: this._t('photoRoll.search.noSearchResults', {
        query: this.props.query
      }) };
  };

  /**
   * Renders the search suggestions
   * @return {ReactBEM.Element}
   * @private
   */


  NoSearchResultsComponent.prototype._renderSearchSuggestions = function _renderSearchSuggestions() {
    var _this3 = this;

    if (!this.state.searchSuggestions.length) return null;

    var items = this.state.searchSuggestions.map(function (searchSuggestion) {
      return _globals.ReactBEM.createElement(_searchSuggestionComponent2.default, {
        onClick: _this3._onSearchSuggestionClick,
        searchSuggestion: searchSuggestion });
    });

    return _globals.ReactBEM.createElement(
      'div',
      null,
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:headline' },
        'Search suggestions'
      ),
      _globals.ReactBEM.createElement(
        'ul',
        { bem: '$e:libraryList' },
        items
      )
    );
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  NoSearchResultsComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:photoRoll e:row m:fullHeight' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:container' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:innerContainer' },
            _globals.ReactBEM.createElement('div', { bem: 'e:noSearchResults', dangerouslySetInnerHTML: this._renderMessage() }),
            this._renderSearchSuggestions()
          )
        )
      )
    );
  };

  return NoSearchResultsComponent;
}(_globals.BaseComponent);

exports.default = NoSearchResultsComponent;


NoSearchResultsComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(212);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _libraryComponent = __webpack_require__(159);

var _libraryComponent2 = _interopRequireDefault(_libraryComponent);

var _searchSuggestionComponent = __webpack_require__(65);

var _searchSuggestionComponent2 = _interopRequireDefault(_searchSuggestionComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OverviewComponent = function (_BaseComponent) {
  (0, _inherits3.default)(OverviewComponent, _BaseComponent);

  function OverviewComponent() {
    (0, _classCallCheck3.default)(this, OverviewComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this.state = {
      loading: true,
      libraries: [],
      searchSuggestions: []
    };

    _this._bindAll('_onLibraryClick', '_onSearchSuggestionClick');

    var PhotoRollProvider = _this.context.options.photoRoll.provider;
    _this._provider = new PhotoRollProvider();
    return _this;
  }

  /**
   * A method that is called whenever styles need to be fixed by the JavaScript.
   * This needs to be done thanks to older Internet Explorer browsers which have
   * a bunch of CSS bugs.
   */


  OverviewComponent.prototype.fixStyles = function fixStyles() {
    if (_globals.Utils.Browser.isIElte(11)) {
      var _refs = this.refs,
          cell = _refs.cell,
          container = _refs.container;

      if (!(cell && container)) {
        return;
      }
      var cellHeight = cell.offsetHeight;
      container.style.height = cellHeight + 'px';
    }
  };

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component has been mounted
   */


  OverviewComponent.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    _BaseComponent.prototype.componentDidMount.call(this);

    var modal = _modalManager2.default.instance.displayLoading(this._t('loading.loading'));
    this._load().then(function (_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
          libraries = _ref2[0],
          searchSuggestions = _ref2[1];

      modal.close();
      if (libraries.length === 1) {
        _this2._onLibraryClick(libraries[0], true);
      } else {
        _this2.setState({
          loading: false,
          libraries: libraries,
          searchSuggestions: searchSuggestions
        });
      }
    });
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when a library was clicked
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Library} library
   * @param  {Boolean} automatically = false
   * @private
   */


  OverviewComponent.prototype._onLibraryClick = function _onLibraryClick(library) {
    var automatically = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    this.props.onLibraryClicked && this.props.onLibraryClicked(library, automatically);
  };

  /**
   * Gets called when a search suggestion was clicked
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.SearchSuggestion} searchSuggestion
   * @private
   */


  OverviewComponent.prototype._onSearchSuggestionClick = function _onSearchSuggestionClick(searchSuggestion) {
    this.props.onSearchSuggestionClicked && this.props.onSearchSuggestionClicked(searchSuggestion);
  };

  // -------------------------------------------------------------------------- LOADING

  /**
   * Loads the libraries and search suggestions (if present)
   * @return {Promise}
   * @private
   */


  OverviewComponent.prototype._load = function _load() {
    var promises = [this._provider.getLibraries(), this._provider.getSearchSuggestions()];
    return _globals.Promise.all(promises);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the library items
   * @return {React.Component}
   * @private
   */


  OverviewComponent.prototype._renderLibraries = function _renderLibraries() {
    var _this3 = this;

    var items = this.state.libraries.map(function (library) {
      return _globals.ReactBEM.createElement(_libraryComponent2.default, {
        onClick: _this3._onLibraryClick,
        library: library });
    });
    return _globals.ReactBEM.createElement(
      'li',
      { bem: 'e:item' },
      _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:photoRoll' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:headline' },
          'Browse libraries'
        ),
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:libraryList' },
          items
        )
      )
    );
  };

  /**
   * Rnders the search suggestion items
   * @return {React.Component}
   * @private
   */


  OverviewComponent.prototype._renderSearchSuggestions = function _renderSearchSuggestions() {
    var _this4 = this;

    if (!this.state.searchSuggestions.length) return null;

    var items = this.state.searchSuggestions.map(function (searchSuggestion) {
      return _globals.ReactBEM.createElement(_searchSuggestionComponent2.default, {
        onClick: _this4._onSearchSuggestionClick,
        searchSuggestion: searchSuggestion });
    });

    return _globals.ReactBEM.createElement(
      'li',
      { bem: 'e:item' },
      _globals.ReactBEM.createElement(
        'bem',
        { specifier: 'b:photoRoll' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:headline' },
          'Search suggestions'
        ),
        _globals.ReactBEM.createElement(
          'ul',
          { bem: '$e:libraryList' },
          items
        )
      )
    );
  };

  /**
   * Renders the content for this component
   * @return {ReactBEM.Element}
   * @private
   */


  OverviewComponent.prototype._renderContent = function _renderContent() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:photoRoll e:row m:fullHeight' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell', ref: 'cell' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:container', ref: 'container' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:innerContainer' },
            _globals.ReactBEM.createElement(
              'ul',
              { bem: '$e:groupList' },
              this._renderLibraries(),
              this._renderSearchSuggestions()
            )
          )
        )
      )
    );
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  OverviewComponent.prototype.renderWithBEM = function renderWithBEM() {
    if (!this.state.loading) {
      return this._renderContent();
    } else {
      return _globals.ReactBEM.createElement('div', null);
    }
  };

  return OverviewComponent;
}(_globals.BaseComponent);

exports.default = OverviewComponent;


OverviewComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _screenComponent = __webpack_require__(21);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _topBarComponent = __webpack_require__(166);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _overviewComponent = __webpack_require__(162);

var _overviewComponent2 = _interopRequireDefault(_overviewComponent);

var _photoListComponent = __webpack_require__(66);

var _photoListComponent2 = _interopRequireDefault(_photoListComponent);

var _searchResultsComponent = __webpack_require__(164);

var _searchResultsComponent2 = _interopRequireDefault(_searchResultsComponent);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoRollScreenComponent = function (_ScreenComponent) {
  (0, _inherits3.default)(PhotoRollScreenComponent, _ScreenComponent);

  function PhotoRollScreenComponent() {
    (0, _classCallCheck3.default)(this, PhotoRollScreenComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ScreenComponent.call.apply(_ScreenComponent, [this].concat(args)));

    _this.state = {
      section: 'overview',
      sectionsHistory: []
    };

    _this._bindAll('_onLibraryClicked', '_onSearchSuggestionClicked', '_onPhotoClicked', '_onFileUpload', '_onWebcamClick', '_onBackClicked', '_onSearch');
    return _this;
  }

  // -------------------------------------------------------------------------- SECTIONS

  /**
   * Checks if the photo roll screen has a previous section
   * @return {Boolean} [description]
   */


  PhotoRollScreenComponent.prototype.hasPreviousSection = function hasPreviousSection() {
    return !!this.state.sectionsHistory.length;
  };

  /**
   * Switches to the given section
   * @param  {String} section
   * @param  {Boolean} allowScreenSwitch = true
   * @param  {Boolean} addToStack = true
   */


  PhotoRollScreenComponent.prototype.switchToSection = function switchToSection(section) {
    var allowScreenSwitch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var addToStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (section === 'back') {
      if (!this.hasPreviousSection()) {
        if (allowScreenSwitch) {
          return this.props.app.switchToScreen('back');
        } else {
          return this.switchToSection('overview');
        }
      }
      section = this.state.sectionsHistory.pop();
    } else if (this.state.section !== section && addToStack) {
      this.state.sectionsHistory.push(this.state.section);
    }

    this.setState({ section: section });
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when a library has been clicked
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Library} library
   * @param {Boolean} automatically = false
   * @private
   */


  PhotoRollScreenComponent.prototype._onLibraryClicked = function _onLibraryClicked(library) {
    var automatically = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    this.state.library = library;
    this.switchToSection('library', true, !automatically);
  };

  /**
   * Gets called when a search suggestion has been clicked
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.SearchSuggestion} searchSuggestion
   * @private
   */


  PhotoRollScreenComponent.prototype._onSearchSuggestionClicked = function _onSearchSuggestionClicked(searchSuggestion) {
    this.state.searchQuery = searchSuggestion.query;
    this.switchToSection('search');
  };

  /**
   * Gets called when the user has clicked and the PhotoRoll has loaded a photo
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Photo} photo
   * @private
   */


  PhotoRollScreenComponent.prototype._onPhotoClicked = function _onPhotoClicked(photo) {
    var _this2 = this;

    var loadingModal = _modalManager2.default.instance.displayLoading(this._t('loading.loading'));

    var image = new window.Image();
    image.addEventListener('load', function () {
      loadingModal.close();
      _this2.props.app.setImage(image, true);
    });
    image.addEventListener('error', function () {
      loadingModal.close();
      _modalManager2.default.instance.displayError(_this2._t('errors.imageLoadFail.title'), _this2._t('errors.imageLoadFail.text', { path: image.src }));
    });
    image.crossOrigin = 'Anonymous';
    image.src = photo.urls.raw;
  };

  /**
   * Gets called when the user clicks the back button
   * @private
   */


  PhotoRollScreenComponent.prototype._onBackClicked = function _onBackClicked() {
    this.switchToSection('back');
  };

  /**
   * Gets called when a search is triggered
   * @param  {String} query
   * @private
   */


  PhotoRollScreenComponent.prototype._onSearch = function _onSearch(query) {
    if (!query.trim().length) {
      this.state.searchQuery = null;
      return this.switchToSection('back', false);
    }

    this.state.searchQuery = query;
    this.switchToSection('search');
  };

  /**
   * Gets called when the user clicks the webcam button. Switches to the
   * webcam screen
   * @private
   */


  PhotoRollScreenComponent.prototype._onWebcamClick = function _onWebcamClick() {
    this.props.app.switchToScreen('webcam');
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user has selected a new file
   * @param {Image} image
   */


  PhotoRollScreenComponent.prototype._onFileUpload = function _onFileUpload(image) {
    this.props.app.setImage(image);
  };

  // -------------------------------------------------------------------------- BACK BUTTON

  /**
   * Checks if the back button should be visible
   * @return {Boolean}
   * @private
   */


  PhotoRollScreenComponent.prototype._isBackButtonVisible = function _isBackButtonVisible() {
    return this.state.sectionsHistory.length !== 0 || this.props.app.hasPreviousScreen();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the content component for this screen
   * @return {ReactBEM.Element}
   * @private
   */


  PhotoRollScreenComponent.prototype._renderContent = function _renderContent() {
    switch (this.state.section) {
      case 'search':
        return _globals.ReactBEM.createElement(_searchResultsComponent2.default, {
          query: this.state.searchQuery,
          onPhotoClicked: this._onPhotoClicked,
          onSearchSuggestionClicked: this._onSearchSuggestionClicked });
      case 'library':
        return _globals.ReactBEM.createElement(_photoListComponent2.default, {
          library: this.state.library,
          onPhotoClicked: this._onPhotoClicked });
      case 'overview':
        return _globals.ReactBEM.createElement(_overviewComponent2.default, {
          onLibraryClicked: this._onLibraryClicked,
          onSearchSuggestionClicked: this._onSearchSuggestionClicked
        });
    }
  };

  /**
   * Renders this screen
   * @return {ReactBEM.Element}
   * @private
   */


  PhotoRollScreenComponent.prototype._renderScreen = function _renderScreen() {
    var contentComponent = this._renderContent();

    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:photoRollScreen' },
      _globals.ReactBEM.createElement(_topBarComponent2.default, {
        onBackClicked: this._onBackClicked,
        onSearch: this._onSearch,
        searchQuery: this.state.searchQuery,
        onFileUpload: this._onFileUpload,
        onWebcamClick: this._onWebcamClick,
        backButton: this._isBackButtonVisible(),
        backButtonLabel: this._t('generic.back'),
        ref: 'topBarControls' }),
      contentComponent
    );
  };

  return PhotoRollScreenComponent;
}(_screenComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = PhotoRollScreenComponent;


PhotoRollScreenComponent.childContextTypes = {
  ui: _globals.React.PropTypes.object.isRequired,
  editor: _globals.React.PropTypes.object.isRequired,
  mediator: _globals.React.PropTypes.object.isRequired,
  options: _globals.React.PropTypes.object.isRequired,
  editorScreen: _globals.React.PropTypes.object.isRequired
};

PhotoRollScreenComponent.contextTypes = _screenComponent2.default.contextTypes;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _photoListComponent = __webpack_require__(66);

var _photoListComponent2 = _interopRequireDefault(_photoListComponent);

var _noSearchResultsComponent = __webpack_require__(161);

var _noSearchResultsComponent2 = _interopRequireDefault(_noSearchResultsComponent);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SearchResultsComponent = function (_PhotoListComponent) {
  (0, _inherits3.default)(SearchResultsComponent, _PhotoListComponent);

  function SearchResultsComponent() {
    (0, _classCallCheck3.default)(this, SearchResultsComponent);
    return (0, _possibleConstructorReturn3.default)(this, _PhotoListComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component receives new props
   * @param  {Object} props
   */
  SearchResultsComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
    if (props.query !== this.props.query) {
      this._loadPhotos(props.query);
    }
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Returns the headline for this view
   * @return {String}
   * @private
   */


  SearchResultsComponent.prototype._getHeadline = function _getHeadline() {
    return this._t('photoRoll.search.results.headline', {
      query: this.props.query
    });
  };

  /**
   * Loads the photos
   * @param {String} query
   * @private
   */


  SearchResultsComponent.prototype._loadPhotos = function _loadPhotos() {
    var _this2 = this;

    var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.query;

    this._totalPhotosHeight = 0;
    var modal = _modalManager2.default.instance.displayProgress(this._t('loading.loading'));
    var PhotoRollProvider = this.context.options.photoRoll.provider;
    var provider = new PhotoRollProvider();

    provider.searchPhotos(query).then(function (photos) {
      return _this2._preloadPhotos(photos, modal);
    }).then(function (photos) {
      _this2.setState({ photos: photos, loading: false });
      modal.close();
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the 'no results found' screen
   * @return {ReactBEM.Element}
   * @private
   */


  SearchResultsComponent.prototype._renderNotFound = function _renderNotFound() {
    return _globals.ReactBEM.createElement(_noSearchResultsComponent2.default, {
      query: this.props.query,
      onSearchSuggestionClicked: this.props.onSearchSuggestionClicked });
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  SearchResultsComponent.prototype.renderWithBEM = function renderWithBEM() {
    if (!this.state.loading) {
      if (this.state.photos.length === 0) {
        return this._renderNotFound();
      } else {
        return this._renderPhotos();
      }
    } else {
      return _globals.ReactBEM.createElement('div', null);
    }
  };

  return SearchResultsComponent;
}(_photoListComponent2.default);

exports.default = SearchResultsComponent;


SearchResultsComponent.contextTypes = _photoListComponent2.default.contextTypes;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TopBarButtonComponent = function (_BaseComponent) {
  (0, _inherits3.default)(TopBarButtonComponent, _BaseComponent);

  function TopBarButtonComponent() {
    (0, _classCallCheck3.default)(this, TopBarButtonComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  TopBarButtonComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:topBar' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:iconButton', onClick: this.props.onClick },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this.props.icon })
      )
    );
  };

  return TopBarButtonComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = TopBarButtonComponent;


TopBarButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _topBarComponent = __webpack_require__(32);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _topBarButtonComponent = __webpack_require__(165);

var _topBarButtonComponent2 = _interopRequireDefault(_topBarButtonComponent);

var _invisibleUploadComponent = __webpack_require__(41);

var _invisibleUploadComponent2 = _interopRequireDefault(_invisibleUploadComponent);

var _topBarSearchComponent = __webpack_require__(167);

var _topBarSearchComponent2 = _interopRequireDefault(_topBarSearchComponent);

var _backButtonComponent = __webpack_require__(174);

var _backButtonComponent2 = _interopRequireDefault(_backButtonComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var PhotoRollTopBarComponent = function (_TopBarComponent) {
  (0, _inherits3.default)(PhotoRollTopBarComponent, _TopBarComponent);

  function PhotoRollTopBarComponent() {
    (0, _classCallCheck3.default)(this, PhotoRollTopBarComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _TopBarComponent.call.apply(_TopBarComponent, [this].concat(args)));

    _this._bindAll('_onUploadButtonClicked', '_onWebcamButtonClicked', '_onBackClicked', '_onSearchValueChange', '_onNewFile');

    _this._onSearchValueChange = _globals.Utils.debounce(_this._onSearchValueChange, 250);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the user clicks the back button
   * @private
   */


  PhotoRollTopBarComponent.prototype._onBackClicked = function _onBackClicked() {
    this.props.onBackClicked && this.props.onBackClicked();
  };

  /**
   * Gets called when the search value has changed (this method is debounced)
   * @param {String} value
   * @private
   */


  PhotoRollTopBarComponent.prototype._onSearchValueChange = function _onSearchValueChange(value) {
    this.props.onSearch && this.props.onSearch(value);
  };

  /**
   * Gets called when the user clicks the upload button
   * @private
   */


  PhotoRollTopBarComponent.prototype._onUploadButtonClicked = function _onUploadButtonClicked() {
    this.refs.upload.open();
  };

  /**
   * Gets called when the user clicks the webcam button
   * @private
   */


  PhotoRollTopBarComponent.prototype._onWebcamButtonClicked = function _onWebcamButtonClicked() {
    this.props.onWebcamClick && this.props.onWebcamClick();
  };

  /**
   * Gets called when a new file has been selected
   * @param  {File} file
   * @private
   */


  PhotoRollTopBarComponent.prototype._onNewFile = function _onNewFile(file) {
    this.props.onFileUpload && this.props.onFileUpload(file);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Checks if the webcam is available
   * @return {Boolean}
   * @private
   */


  PhotoRollTopBarComponent.prototype._isWebcamAvailable = function _isWebcamAvailable() {
    return !_globals.Utils.isMobile() && this.context.options.enableWebcam !== false;
  };

  /**
   * Renders the buttons on the right
   * @return {Array.<React.Component>}
   * @private
   */


  PhotoRollTopBarComponent.prototype._renderRightButtons = function _renderRightButtons() {
    var options = this.context.options;

    var buttons = [];

    if (options.enableUpload) {
      buttons.push(_globals.ReactBEM.createElement(_topBarButtonComponent2.default, {
        icon: this._getAssetPath('photo-roll/upload.png', true),
        onClick: this._onUploadButtonClicked
      }));
    }

    if (this._isWebcamAvailable()) {
      buttons.push(_globals.ReactBEM.createElement(_topBarButtonComponent2.default, {
        icon: this._getAssetPath('photo-roll/webcam.png', true),
        onClick: this._onWebcamButtonClicked
      }));
    }

    return buttons;
  };

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  PhotoRollTopBarComponent.prototype.renderWithBEM = function renderWithBEM() {
    var backButton = void 0;
    if (this.props.backButton) {
      backButton = _globals.ReactBEM.createElement(_backButtonComponent2.default, {
        label: this.props.backButtonLabel,
        onClick: this._onBackClicked });
    }
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:topBar e:row' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:cell' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:table' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:left' },
            backButton
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:fullWidth' },
            _globals.ReactBEM.createElement(_topBarSearchComponent2.default, {
              searchQuery: this.props.searchQuery,
              onChange: this._onSearchValueChange }),
            _globals.ReactBEM.createElement(_invisibleUploadComponent2.default, { onNewFile: this._onNewFile, ref: 'upload' })
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cell m:right' },
            this._renderRightButtons()
          )
        )
      )
    );
  };

  return PhotoRollTopBarComponent;
}(_topBarComponent2.default);

exports.default = PhotoRollTopBarComponent;


PhotoRollTopBarComponent.contextTypes = _topBarComponent2.default.contextTypes;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TopBarSearchComponent = function (_BaseComponent) {
  (0, _inherits3.default)(TopBarSearchComponent, _BaseComponent);

  function TopBarSearchComponent() {
    (0, _classCallCheck3.default)(this, TopBarSearchComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call.apply(_BaseComponent, [this].concat(args)));

    _this._bindAll('_onFocus', '_onBlur', '_onChange', '_onBarClick');

    _this.state = {
      active: false,
      placeholder: _this._t('photoRoll.search.placeholder'),
      value: _this.props.searchQuery || ''
    };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Gets called when this component is about to receive new properties
   * @param  {Object} nextProps
   */


  TopBarSearchComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.searchQuery || this.state.value) {
      this.state.active = true;
    } else {
      this.state.active = false;
    }

    this.setState({
      value: nextProps.searchQuery || ''
    });
  };

  TopBarSearchComponent.prototype.componentDidUpdate = function componentDidUpdate() {
    this.refs.input.value = this.state.value;
  };

  /**
   * Gets called when this component has been mounted
   */


  TopBarSearchComponent.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    _BaseComponent.prototype.componentDidMount.call(this);
    this._hiddenInputDummy = document.createElement('div');

    var styleObject = _globals.Utils.getStyleObject(this.refs.input);
    var overrideKeys = ['font', 'lineHeight', 'textAlign', 'textIndent', 'textTransform', 'textDecoration', 'textRendering', 'textShadow', 'textOverflow', 'wordSpacing', 'letterSpacing', 'whiteSpace'];
    overrideKeys.forEach(function (key) {
      _this2._hiddenInputDummy.style[key] = styleObject[key];
    });

    this._hiddenInputDummy.style.position = 'absolute';
    this._hiddenInputDummy.style.top = '-9999px';
    this._hiddenInputDummy.style.left = '-9999px';

    this.refs.root.appendChild(this._hiddenInputDummy);

    this._updateInputWidth();
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Updates the input width to fit the text width
   * @private
   */


  TopBarSearchComponent.prototype._updateInputWidth = function _updateInputWidth() {
    var _this3 = this;

    this._hiddenInputDummy.innerHTML = this.state.value || this.state.placeholder;
    setTimeout(function () {
      _this3.setState({
        inputWidth: _this3._hiddenInputDummy.offsetWidth + 5
      });
    }, 0);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the search bar has been clicked
   * @private
   */


  TopBarSearchComponent.prototype._onBarClick = function _onBarClick() {
    this.refs.input.focus();
  };

  /**
   * Gets called when the input fields is focused
   * @private
   */


  TopBarSearchComponent.prototype._onFocus = function _onFocus() {
    this.setState({ active: true });
  };

  /**
   * Gets called when the input field loses focus
   * @private
   */


  TopBarSearchComponent.prototype._onBlur = function _onBlur() {
    if (this.state.value === '' && !this.props.searchQuery) {
      this.setState({ active: false });
    }
  };

  /**
   * Gets called when the input value has changed
   * @param  {Event} e
   * @private
   */


  TopBarSearchComponent.prototype._onChange = function _onChange(e) {
    this.state.value = e.target.value;
    this.forceUpdate();

    this.props.onChange && this.props.onChange(this.state.value);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  TopBarSearchComponent.prototype.renderWithBEM = function renderWithBEM() {
    var searchBarBEM = '$e:searchBar';
    var iconPath = 'photo-roll/search-light.png';
    if (this.state.active) {
      searchBarBEM += ' m:active';
      iconPath = 'photo-roll/search-dark.png';
    }
    iconPath = this._getAssetPath(iconPath, true);

    var inputStyle = {
      width: this.state.inputWidth + 'px'
    };

    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:photoRollScreen' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: searchBarBEM, ref: 'root', onClick: this._onBarClick },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:content' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: '$e:icon' },
            _globals.ReactBEM.createElement('img', { src: iconPath, bem: 'e:image' })
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:inputContainer' },
            _globals.ReactBEM.createElement('input', {
              bem: 'e:input',
              ref: 'input',
              placeholder: this.state.placeholder,
              onBlur: this._onBlur,
              onFocus: this._onFocus,
              onChange: this._onChange,
              defaultValue: this.state.value,
              style: inputStyle })
          )
        )
      )
    );
  };

  return TopBarSearchComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = TopBarSearchComponent;


TopBarSearchComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _rowComponent = __webpack_require__(40);

var _rowComponent2 = _interopRequireDefault(_rowComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var PhotoRollComponent = function (_RowComponent) {
  (0, _inherits3.default)(PhotoRollComponent, _RowComponent);

  function PhotoRollComponent() {
    (0, _classCallCheck3.default)(this, PhotoRollComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _RowComponent.call.apply(_RowComponent, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this._modifier = 'photoRoll';
    return _this;
  }

  /**
   * A method that is called whenever styles need to be fixed by the JavaScript.
   * This needs to be done thanks to older Internet Explorer browsers which have
   * a bunch of CSS bugs.
   */


  PhotoRollComponent.prototype.fixStyles = function fixStyles() {
    if (_globals.Utils.Browser.isIElte(11)) {
      var _refs = this.refs,
          cell = _refs.cell,
          overlay = _refs.overlay;

      var cellHeight = cell.offsetHeight;
      overlay.style.height = cellHeight + 'px';
    }
  };

  /**
   * Renders this row's content
   * @return {ReactBEM.Element}
   * @private
   */


  PhotoRollComponent.prototype._renderContent = function _renderContent() {
    var style = {
      backgroundImage: 'url(' + this._getAssetPath('splash/photo-roll.png', true, true) + ')'
    };

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:contentWrapper' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:contentRow' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:contentCell', onClick: this._onClick, style: style, ref: 'cell' },
          _globals.ReactBEM.createElement('div', { bem: 'e:overlay', ref: 'overlay' }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:headline' },
            this._t('splash.photoRoll.headline')
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:description' },
            this._t('splash.photoRoll.description')
          )
        )
      )
    );
  };

  return PhotoRollComponent;
}(_rowComponent2.default);

exports.default = PhotoRollComponent;


PhotoRollComponent.contextTypes = _rowComponent2.default.contextTypes;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _screenComponent = __webpack_require__(21);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _uploadComponent = __webpack_require__(170);

var _uploadComponent2 = _interopRequireDefault(_uploadComponent);

var _webcamComponent = __webpack_require__(171);

var _webcamComponent2 = _interopRequireDefault(_webcamComponent);

var _photoRollComponent = __webpack_require__(168);

var _photoRollComponent2 = _interopRequireDefault(_photoRollComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SplashScreenComponent = function (_ScreenComponent) {
  (0, _inherits3.default)(SplashScreenComponent, _ScreenComponent);

  function SplashScreenComponent() {
    (0, _classCallCheck3.default)(this, SplashScreenComponent);

    var _this = (0, _possibleConstructorReturn3.default)(this, _ScreenComponent.call(this));

    _this._bindAll('_onWebcamClick', '_onPhotoRollClick', '_onImage');
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the PhotoRollComponent has received a click
   * @private
   */


  SplashScreenComponent.prototype._onPhotoRollClick = function _onPhotoRollClick() {
    this.props.app.switchToScreen('photoRoll');
  };

  /**
   * Gets called when the WebcamComponent has received a click
   * @private
   */


  SplashScreenComponent.prototype._onWebcamClick = function _onWebcamClick() {
    this.props.app.switchToScreen('webcam');
  };

  /**
   * Gets called when the UploadComponent has received an image file
   * @param  {image} image
   * @private
   */


  SplashScreenComponent.prototype._onImage = function _onImage(image) {
    this.props.app.setImage(image);
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Checks if the webcam is available for the given device
   * @return {Boolean}
   * @private
   */


  SplashScreenComponent.prototype._isWebcamAvailable = function _isWebcamAvailable() {
    return !_globals.Utils.isMobile() && this.context.options.enableWebcam !== false;
  };

  /**
   * Checks if the photo roll is available
   * @return {Boolean}
   * @private
   */


  SplashScreenComponent.prototype._isPhotoRollAvailable = function _isPhotoRollAvailable() {
    return !!this.context.options.photoRoll.provider;
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this screen
   * @return {ReactBEM.Element}
   * @private
   */


  SplashScreenComponent.prototype._renderScreen = function _renderScreen() {
    var items = [];
    var totalRows = 0;

    var uploadAvailable = this.context.options.enableUpload;
    if (uploadAvailable) totalRows++;

    var webcamAvailable = this._isWebcamAvailable();
    if (webcamAvailable) totalRows++;

    var photoRollAvailable = this._isPhotoRollAvailable();
    if (photoRollAvailable) totalRows++;

    if (uploadAvailable) {
      items.push(_globals.ReactBEM.createElement(_uploadComponent2.default, {
        onImage: this._onImage,
        totalRows: totalRows }));
    }

    if (webcamAvailable) {
      items.push(_globals.ReactBEM.createElement(_webcamComponent2.default, {
        onClick: this._onWebcamClick,
        totalRows: totalRows }));
    }

    if (photoRollAvailable) {
      items.push(_globals.ReactBEM.createElement(_photoRollComponent2.default, {
        onClick: this._onPhotoRollClick,
        totalRows: totalRows }));
    }

    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:splashScreen' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:container' },
        items
      )
    );
  };

  return SplashScreenComponent;
}(_screenComponent2.default); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */


exports.default = SplashScreenComponent;


SplashScreenComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(24);

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _rowComponent = __webpack_require__(40);

var _rowComponent2 = _interopRequireDefault(_rowComponent);

var _buttonComponent = __webpack_require__(99);

var _buttonComponent2 = _interopRequireDefault(_buttonComponent);

var _invisibleUploadComponent = __webpack_require__(41);

var _invisibleUploadComponent2 = _interopRequireDefault(_invisibleUploadComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var UploadComponent = function (_RowComponent) {
  (0, _inherits3.default)(UploadComponent, _RowComponent);

  function UploadComponent() {
    (0, _classCallCheck3.default)(this, UploadComponent);

    var _this = (0, _possibleConstructorReturn3.default)(this, _RowComponent.call(this));

    _this._modifier = 'upload';

    _this._bindAll('_onImage', '_onDragEnter', '_onDragOver', '_onDragLeave', '_onDrop');

    _this._dragCounter = 0;
    _this.state = { dragAreaHovered: false };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the cell emits a `dragEnter` event. Highlights
   * the cell
   * @param {Event} e
   * @private
   */


  UploadComponent.prototype._onDragEnter = function _onDragEnter(e) {
    e.preventDefault();

    this._dragCounter++;
    this.setState({ dragAreaHovered: true });
  };

  /**
   * Gets called when the cell emits a `dragOver` event. We need to
   * override the default behavior to get a drop event.
   * @param  {Event} e
   * @private
   */


  UploadComponent.prototype._onDragOver = function _onDragOver(e) {
    e.preventDefault();
  };

  /**
   * Gets called when the cell emits a `dragLeave` event
   * @param  {Event} e
   * @private
   */


  UploadComponent.prototype._onDragLeave = function _onDragLeave(e) {
    e.preventDefault();

    this._dragCounter--;
    if (this._dragCounter === 0) {
      this.setState({ dragAreaHovered: false });
    }
  };

  /**
   * Gets called when the cell emits a `drop` Event
   * @param  {Event} e
   * @private
   */


  UploadComponent.prototype._onDrop = function _onDrop(e) {
    var _this2 = this;

    e.stopPropagation();
    e.preventDefault();
    e = e.nativeEvent;
    e.returnValue = false;

    this.setState({ dragAreaHovered: false }, function () {
      if (!e.dataTransfer) return;

      _this2._handleFile(e.dataTransfer.files[0]);
    });
  };

  /**
   * Gets called when the user clicks the button
   * @param  {Event} e
   * @private
   */


  UploadComponent.prototype._onClick = function _onClick(e) {
    this.refs.upload.open();
  };

  /**
   * Creates an image from the given file and passes it to the UI
   * @param  {File} file
   * @private
   */


  UploadComponent.prototype._handleFile = function _handleFile(file) {
    var _this3 = this;

    var reader = new window.FileReader();
    reader.onload = function () {
      return function (e) {
        var data = e.target.result;
        var image = new window.Image();

        image.addEventListener('load', function () {
          _this3._onImage(image);
        });

        image.src = data;
      };
    }(file);
    reader.readAsDataURL(file);
  };

  /**
   * Gets called when the image has been changed
   * @param  {Image} image
   * @private
   */


  UploadComponent.prototype._onImage = function _onImage(image) {
    this.props.onImage && this.props.onImage(image);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this row's content
   * @return {ReactBEM.Element}
   * @private
   */


  UploadComponent.prototype._renderContent = function _renderContent() {
    var cellProps = {
      onDragEnter: this._onDragEnter,
      onDragOver: this._onDragOver,
      onDragLeave: this._onDragLeave,
      onDrop: this._onDrop
    };

    if (this.state.dragAreaHovered) {
      cellProps.className = 'is-hovered';
    }

    var contentCellBEM = 'e:contentCell';
    // @TODO We need some class that implements webcamEnabled() and photoRollEnabled()
    if (this.context.options.enableWebcam !== false || this.context.options.photoRoll.provider !== null) {
      contentCellBEM += ' m:withBorder';
    }

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:contentWrapper' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:contentRow' },
        _globals.ReactBEM.createElement(
          'div',
          (0, _extends3.default)({ bem: contentCellBEM, onClick: this._onClick }, cellProps),
          _globals.ReactBEM.createElement(_invisibleUploadComponent2.default, { ref: 'upload', onNewFile: this._onImage }),
          _globals.ReactBEM.createElement(
            _buttonComponent2.default,
            { bem: 'e:button', uppercase: true },
            this._t('splash.upload.button')
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:description' },
            this._t('splash.upload.description')
          )
        )
      )
    );
  };

  return UploadComponent;
}(_rowComponent2.default);

exports.default = UploadComponent;


UploadComponent.propTypes = {
  onImage: _globals.React.PropTypes.func.isRequired
};

UploadComponent.contextTypes = _rowComponent2.default.contextTypes;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _rowComponent = __webpack_require__(40);

var _rowComponent2 = _interopRequireDefault(_rowComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var WebcamComponent = function (_RowComponent) {
  (0, _inherits3.default)(WebcamComponent, _RowComponent);

  function WebcamComponent() {
    (0, _classCallCheck3.default)(this, WebcamComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _RowComponent.call.apply(_RowComponent, [this].concat(args)));

    _this._needsStyleFixes = true;
    _this._modifier = 'webcam';
    return _this;
  }

  /**
   * A method that is called whenever styles need to be fixed by the JavaScript.
   * This needs to be done thanks to older Internet Explorer browsers which have
   * a bunch of CSS bugs.
   */


  WebcamComponent.prototype.fixStyles = function fixStyles() {
    if (_globals.Utils.Browser.isIElte(11)) {
      var _refs = this.refs,
          cell = _refs.cell,
          overlay = _refs.overlay;

      var cellHeight = cell.offsetHeight;
      overlay.style.height = cellHeight + 'px';
    }
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this row's content
   * @return {ReactBEM.Element}
   * @private
   */


  WebcamComponent.prototype._renderContent = function _renderContent() {
    var style = {
      backgroundImage: 'url(' + this._getAssetPath('splash/webcam.png', true, true) + ')'
    };

    return _globals.ReactBEM.createElement(
      'div',
      { bem: 'e:contentWrapper' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: 'e:contentRow' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:contentCell', onClick: this._onClick, style: style, ref: 'cell' },
          _globals.ReactBEM.createElement('div', { bem: 'e:overlay', ref: 'overlay' }),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:headline' },
            this._t('splash.webcam.headline')
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:description' },
            this._t('splash.webcam.description')
          )
        )
      )
    );
  };

  return WebcamComponent;
}(_rowComponent2.default);

exports.default = WebcamComponent;


WebcamComponent.contextTypes = _rowComponent2.default.contextTypes;

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var WebcamComponent = function (_BaseComponent) {
  (0, _inherits3.default)(WebcamComponent, _BaseComponent);

  function WebcamComponent() {
    (0, _classCallCheck3.default)(this, WebcamComponent);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseComponent.call(this));

    _this._bindAll('_onWebcamReady');

    _this.state = { webcamReady: false };
    return _this;
  }

  // -------------------------------------------------------------------------- LIFECYCLE

  /**
   * Checks whether this component needs an update
   * @param {Object} nextProps
   * @param {Object} nextState
   */


  WebcamComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
    // This component never updates
    return false;
  };

  /**
   * Gets called when the component is about to unmount. Stops the video
   * stream and kills the video
   */


  WebcamComponent.prototype.componentWillUnmount = function componentWillUnmount() {
    _BaseComponent.prototype.componentWillUnmount.call(this);

    var video = this.refs.video;

    if (this._stream) {
      var track = this._stream.getTracks()[0];
      track && track.stop();
      this._stream.stop && this._stream.stop();
    }
    video.pause();
  };

  /**
   * Gets called after the component has been mounted
   */


  WebcamComponent.prototype.componentDidMount = function componentDidMount() {
    this._resizeVideo();
    this._initVideoStream();
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the webcam is ready to serve a video
   * @private
   */


  WebcamComponent.prototype._onWebcamReady = function _onWebcamReady() {
    this.props.onReady && this.props.onReady();
    this.setState({ webcamReady: true });
  };

  /**
   * Public method that makes a photo from the current video stream
   * @return {Promise}
   */


  WebcamComponent.prototype.makePhoto = function makePhoto() {
    if (!this.state.webcamReady) {
      return _globals.Promise.reject(new Error('UserMedia stream not ready'));
    }

    var video = this.refs.video;


    return new _globals.Promise(function (resolve, reject) {
      var canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      var context = canvas.getContext('2d');
      context.drawImage(video, 0, 0);

      var image = new window.Image();
      image.addEventListener('load', function () {
        resolve(image);
      });
      image.src = canvas.toDataURL('image/png');
    });
  };

  /**
   * Resizes the video to fit the container
   * @private
   */


  WebcamComponent.prototype._resizeVideo = function _resizeVideo() {
    var _refs = this.refs,
        video = _refs.video,
        container = _refs.container;

    var innerDimensions = _globals.Utils.getInnerDimensionsForElement(container);

    video.width = innerDimensions.x;
    video.height = innerDimensions.y;
  };

  /**
   * Initializes the video stream
   * @private
   */


  WebcamComponent.prototype._initVideoStream = function _initVideoStream() {
    var _this2 = this;

    var video = this.refs.video;

    var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

    if (!getUserMedia) {
      var errorModal = _modalManager2.default.instance.displayError(this._t('errors.webcamNotSupported.title'), this._t('errors.webcamNotSupported.text'));
      errorModal.on('close', function () {
        return _this2.props.onBack();
      });
      return;
    }

    getUserMedia.call(navigator, { video: true }, function (stream) {
      _this2._stream = stream;
      video.onloadedmetadata = _this2._onWebcamReady;
      video.src = window.URL.createObjectURL(stream);
    }, function (err) {
      console.error && console.error(err);

      var errorModal = _modalManager2.default.instance.displayError(_this2._t('errors.webcamUnavailable.title'), _this2._t('errors.webcamUnavailable.text', { error: err.name }), true);

      errorModal.on('close', function () {
        return _this2.props.onBack();
      });
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */


  WebcamComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:webcam', ref: 'container' },
      _globals.ReactBEM.createElement('video', { bem: 'e:video', ref: 'video', autoPlay: true })
    );
  };

  return WebcamComponent;
}(_globals.BaseComponent);

exports.default = WebcamComponent;


WebcamComponent.propTypes = {
  onReady: _globals.React.PropTypes.func
};

WebcamComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _screenComponent = __webpack_require__(21);

var _screenComponent2 = _interopRequireDefault(_screenComponent);

var _topBarComponent = __webpack_require__(32);

var _topBarComponent2 = _interopRequireDefault(_topBarComponent);

var _webcamComponent = __webpack_require__(172);

var _webcamComponent2 = _interopRequireDefault(_webcamComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */
var WebcamScreenComponent = function (_ScreenComponent) {
  (0, _inherits3.default)(WebcamScreenComponent, _ScreenComponent);

  function WebcamScreenComponent() {
    (0, _classCallCheck3.default)(this, WebcamScreenComponent);

    var _this = (0, _possibleConstructorReturn3.default)(this, _ScreenComponent.call(this));

    _this._bindAll('_onCancel', '_onWebcamReady', '_onShutterClicked');
    _this.state = { webcamReady: false };
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when the webcam is ready
   * @private
   */


  WebcamScreenComponent.prototype._onWebcamReady = function _onWebcamReady() {
    this.setState({ webcamReady: true });
  };

  /**
   * Gets called when the user clicks the cancel button in the top bar
   * @private
   */


  WebcamScreenComponent.prototype._onCancel = function _onCancel() {
    this.props.app.switchToScreen('back');
  };

  /**
   * Gets called when the shutter button has been clicked
   * @private
   */


  WebcamScreenComponent.prototype._onShutterClicked = function _onShutterClicked() {
    var _this2 = this;

    var webcam = this.refs.webcam;
    webcam.makePhoto().then(function (image) {
      _this2.props.app.setImage(image);
    }).catch(function (e) {
      console.error && console.error(e);
    });
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders this screen
   * @return {ReactBEM.Element}
   * @private
   */


  WebcamScreenComponent.prototype._renderScreen = function _renderScreen() {
    return _globals.ReactBEM.createElement(
      'div',
      { bem: '$b:webcamScreen' },
      _globals.ReactBEM.createElement(
        _topBarComponent2.default,
        {
          label: this._t('webcam.headline') },
        _globals.ReactBEM.createElement(
          'bem',
          { specifier: '$b:topBar' },
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:cancelButton', onClick: this._onCancel },
            this._t('generic.cancel')
          ),
          _globals.ReactBEM.createElement(
            'div',
            { bem: 'e:label' },
            this._t('webcam.headline')
          )
        )
      ),
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:canvas e:container e:row' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:container e:cell' },
          _globals.ReactBEM.createElement(_webcamComponent2.default, {
            ref: 'webcam',
            onReady: this._onWebcamReady,
            onBack: this._onCancel })
        )
      ),
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$b:controls $e:container e:row' },
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:cell' },
          _globals.ReactBEM.createElement(
            'bem',
            { specifier: 'b:webcamScreen' },
            _globals.ReactBEM.createElement(
              'div',
              {
                bem: '$e:shutterButton',
                onClick: this._onShutterClicked,
                className: this.state.webcamReady ? 'is-active' : false },
              _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('controls/webcam/shutter.png', true) })
            )
          )
        )
      )
    );
  };

  return WebcamScreenComponent;
}(_screenComponent2.default);

exports.default = WebcamScreenComponent;


WebcamScreenComponent.contextTypes = _screenComponent2.default.contextTypes;

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TopBarBackButtonComponent = function (_BaseComponent) {
  (0, _inherits3.default)(TopBarBackButtonComponent, _BaseComponent);

  function TopBarBackButtonComponent() {
    (0, _classCallCheck3.default)(this, TopBarBackButtonComponent);
    return (0, _possibleConstructorReturn3.default)(this, _BaseComponent.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Renders this component
   * @return {ReactBEM.Element}
   */
  TopBarBackButtonComponent.prototype.renderWithBEM = function renderWithBEM() {
    return _globals.ReactBEM.createElement(
      'bem',
      { specifier: '$b:topBar' },
      _globals.ReactBEM.createElement(
        'div',
        { bem: '$e:backButton', onClick: this.props.onClick },
        _globals.ReactBEM.createElement('img', { bem: 'e:icon', src: this._getAssetPath('top-bar/back.png', true) }),
        _globals.ReactBEM.createElement(
          'div',
          { bem: 'e:label' },
          this.props.label
        )
      )
    );
  };

  return TopBarBackButtonComponent;
}(_globals.BaseComponent); /** @jsx ReactBEM.createElement **/
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = TopBarBackButtonComponent;


TopBarBackButtonComponent.contextTypes = _globals.BaseComponent.contextTypes;

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _photoeditorsdk = __webpack_require__(29);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  EVENTS: {
    RENDER: 'render',
    EXPORT: 'export',
    CLOSE: 'close',
    ZOOM_DONE: 'zoom:done',
    OPERATION_CREATED: 'operation:created',
    OPERATION_UPDATED: 'operation:updated',
    OPERATION_REMOVED: 'operation:removed',
    FEATURES_DISABLED: 'editor:features:disabled',
    FEATURES_ENABLED: 'editor:features:enabled',
    FEATURES_UPDATED: 'editor:features:updated',
    COLORPICKER_OPEN: 'colorpicker:open',
    HISTORY_UPDATED: 'history:update',
    HISTORY_BEFORE_UNDO: 'history:before_undo',
    HISTORY_UNDO: 'history:undo',
    WINDOW_RESIZE: 'window:resize',
    CONTROLS_SWITCHED: 'controls:switched',
    CROP_REAPPLY_RATIO: 'crop:reapply_ratio'
  },
  DEFAULTS: {
    TEXT: 'Double-click to edit',
    CROP_RATIOS: [[{ name: 'custom', ratio: '*', selected: true }, { name: 'square', ratio: 1 }, { name: '4-3', ratio: 1.33 }, { name: '16-9', ratio: 1.77 }], [{ name: 'social', dimensions: new _photoeditorsdk2.default.Math.Vector2(800, 800) }, { name: 'fb-ad', dimensions: new _photoeditorsdk2.default.Math.Vector2(1200, 627) }, { name: 'fb-post', dimensions: new _photoeditorsdk2.default.Math.Vector2(940, 788) }, { name: 'fb-cover', dimensions: new _photoeditorsdk2.default.Math.Vector2(851, 315) }]],
    FRAMES: [{
      name: 'dia',
      label: 'Dia',
      layoutMode: 'vertical-inside',
      icon: 'frames/dia/icon.png',
      imageGroups: {
        top: {
          mid: {
            image: 'frames/dia/dia_top.png',
            mode: 'repeat'
          }
        },
        left: {
          start: 'frames/dia/dia_top_left.png',
          mid: 'frames/dia/dia_left.png',
          end: 'frames/dia/dia_bottom_left.png'
        },
        right: {
          start: 'frames/dia/dia_top_right.png',
          mid: 'frames/dia/dia_right.png',
          end: 'frames/dia/dia_bottom_right.png'
        },
        bottom: {
          mid: {
            image: 'frames/dia/dia_bottom.png',
            mode: 'repeat'
          }
        }
      }
    },
    // {
    //   name: 'dotted',
    //   label: 'Dotted',
    //   layoutMode: 'vertical-inside',
    //   icon: 'frames/dotted/icon.png',
    //   imageGroups: {
    //     top: {
    //       start: 'frames/dotted/dotted_topleft.png',
    //       mid: {
    //         image: 'frames/dotted/dotted_top.png',
    //         mode: 'repeat'
    //       },
    //       end: 'frames/dotted/dotted_topright.png'
    //     },
    //     left: {
    //       mid: {
    //         image: 'frames/dotted/dotted_left.png',
    //         mode: 'repeat'
    //       }
    //     },
    //     right: {
    //       mid: {
    //         image: 'frames/dotted/dotted_right.png',
    //         mode: 'repeat'
    //       }
    //     },
    //     bottom: {
    //       start: 'frames/dotted/dotted_bottomleft.png',
    //       mid: {
    //         image: 'frames/dotted/dotted_bottom.png',
    //         mode: 'repeat'
    //       },
    //       end: 'frames/dotted/dotted_bottomright.png'
    //     }
    //   }
    // },
    {
      name: 'simple',
      label: 'Simple',
      tintable: true,
      layoutMode: 'vertical-inside',
      icon: 'frames/simple/icon.png',
      imageGroups: {
        top: {
          start: 'frames/simple/simple_corner.png',
          mid: {
            image: 'frames/simple/simple_horizontal.png',
            mode: 'repeat'
          },
          end: 'frames/simple/simple_corner.png'
        },
        left: {
          mid: {
            image: 'frames/simple/simple_vertical.png',
            mode: 'repeat'
          }
        },
        right: {
          mid: {
            image: 'frames/simple/simple_vertical.png',
            mode: 'repeat'
          }
        },
        bottom: {
          start: 'frames/simple/simple_corner.png',
          mid: {
            image: 'frames/simple/simple_horizontal.png',
            mode: 'repeat'
          },
          end: 'frames/simple/simple_corner.png'
        }
      }
    }, {
      name: 'white',
      label: 'White',
      tintable: true,
      layoutMode: 'vertical-inside',
      icon: 'frames/white/icon.png',
      imageGroups: {
        top: {
          start: 'frames/white/white_top_left.png',
          mid: {
            image: 'frames/white/white_top.png',
            mode: 'repeat'
          },
          end: 'frames/white/white_top_right.png'
        },
        left: {
          mid: {
            image: 'frames/white/white_left.png',
            mode: 'repeat'
          }
        },
        right: {
          mid: {
            image: 'frames/white/white_right.png',
            mode: 'repeat'
          }
        },
        bottom: {
          start: 'frames/white/white_bottom_left.png',
          mid: {
            image: 'frames/white/white_bottom.png',
            mode: 'repeat'
          },
          end: 'frames/white/white_bottom_right.png'
        }
      }
    }],
    FONTS: [{ name: 'helvetica', fontFamily: 'Helvetica', fontWeight: 'normal' }, { name: 'verdana', fontFamily: 'Verdana', fontWeight: 'normal' }, { name: 'timesnewroman', fontFamily: 'Times New Roman', fontWeight: 'normal' }, { name: 'impact', fontFamily: 'Impact', fontWeight: 'normal', default: true }],
    STICKER_CATEGORIES: [{
      'name': 'glasses',
      'label': 'Glasses',
      'stickers': [{
        'name': 'glasses-nerd',
        'label': 'Nerd glasses',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/glasses-nerd.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/glasses-nerd.png',
            'width': 221,
            'height': 91
          }
        }
      }, {
        'name': 'glasses-normal',
        'label': 'Normal glasses',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/glasses-normal.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/glasses-normal.png',
            'width': 249,
            'height': 87
          }
        }
      }, {
        'name': 'glasses-shutter-green',
        'label': 'Green shutter glasses',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/glasses-shutter-green.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/glasses-shutter-green.png',
            'width': 235,
            'height': 89
          }
        }
      }, {
        'name': 'glasses-shutter-yellow',
        'label': 'Yellow shutter glasses',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/glasses-shutter-yellow.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/glasses-shutter-yellow.png',
            'width': 236,
            'height': 89
          }
        }
      }, {
        'name': 'glasses-sun',
        'label': 'Sun glasses',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/glasses-sun.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/glasses-sun.png',
            'width': 250,
            'height': 87
          }
        }
      }]
    }, {
      'name': 'hats',
      'label': 'Hats',
      'stickers': [{
        'name': 'hat-cap',
        'label': 'Cap',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/hat-cap.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/hat-cap.png',
            'width': 237,
            'height': 189
          }
        }
      }, {
        'name': 'hat-cylinder',
        'label': 'Cylinder',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/hat-cylinder.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/hat-cylinder.png',
            'width': 225,
            'height': 176
          }
        }
      }, {
        'name': 'hat-party',
        'label': 'Party hat',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/hat-party.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/hat-party.png',
            'width': 140,
            'height': 226
          }
        }
      }, {
        'name': 'hat-sheriff',
        'label': 'Sheriff hat',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/hat-sheriff.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/hat-sheriff.png',
            'width': 251,
            'height': 129
          }
        }
      }]
    }, {
      'name': 'beards',
      'label': 'Beards',
      'stickers': [{
        'name': 'mustache-long',
        'label': 'Long mustache',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/mustache-long.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/mustache-long.png',
            'width': 199,
            'height': 182
          }
        }
      }, {
        'name': 'mustache1',
        'label': 'Brown mustache',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/mustache1.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/mustache1.png',
            'width': 238,
            'height': 106
          }
        }
      }, {
        'name': 'mustache2',
        'label': 'Black mustache',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/mustache2.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/mustache2.png',
            'width': 250,
            'height': 82
          }
        }
      }, {
        'name': 'mustache3',
        'label': 'Brown mustache',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/mustache3.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/mustache3.png',
            'width': 250,
            'height': 94
          }
        }
      }]
    }, {
      'name': 'misc',
      'label': 'Misc',
      'stickers': [{
        'name': 'heart',
        'label': 'Heart',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/heart.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/heart.png',
            'width': 185,
            'height': 174
          }
        }
      }, {
        'name': 'pipe',
        'label': 'Pipe',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/pipe.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/pipe.png',
            'width': 240,
            'height': 112
          }
        }
      }, {
        'name': 'snowflake',
        'label': 'Snow flake',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/snowflake.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/snowflake.png',
            'width': 204,
            'height': 171
          }
        }
      }, {
        'name': 'star',
        'label': 'Star',
        'images': {
          'mediaThumb': {
            'uri': 'stickers/thumb/star.png',
            'width': 100,
            'height': 100
          },
          'mediaBase': {
            'uri': 'stickers/base/star.png',
            'width': 201,
            'height': 191
          }
        }
      }]
    }]
  }
}; /*
    * This file is part of PhotoEditorSDK.
    *
    * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
    * All rights reserved.
    *
    * Redistribution and use in source and binary forms, without
    * modification, are permitted provided that the following license agreement
    * is approved and a legal/financial contract was signed by the user.
    * The license agreement can be found under following link:
    *
    * https://www.photoeditorsdk.com/LICENSE.txt
    */

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _controls = __webpack_require__(61);

var Controls = _interopRequireWildcard(_controls);

var _globals = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var EditorControls = function () {
  function EditorControls(editor, sdk, mediator) {
    (0, _classCallCheck3.default)(this, EditorControls);

    this._editor = editor;
    this._sdk = sdk;
    this._mediator = mediator;

    this._options = this._editor.getOptions();
    this._available = _globals.SDKUtils.extend({}, Controls, this._options.extensions.controls);
  }

  /**
   * Checks if the control with the given identifier is selectable
   * @param  {String}  identifier
   * @return {Boolean}
   */


  EditorControls.prototype.isEnabled = function isEnabled(identifier) {
    var control = this.get(identifier);

    if (!control) {
      _globals.Log.info('EditorControls#isEnabled: Unknown control: ' + identifier);
      return false;
    }

    return control.isAvailable && control.isAvailable(this._editor);
  };

  /**
   * Returns the control with the given identifier
   * @param  {String} identifier
   * @return {Control}
   */


  EditorControls.prototype.get = function get(identifier) {
    return this._available[identifier];
  };

  /**
   * Returns the available controls
   * @return {Object}
   */


  EditorControls.prototype.getAvailable = function getAvailable() {
    return this._available;
  };

  return EditorControls;
}();

exports.default = EditorControls;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EditorFeatures = function () {
  function EditorFeatures(editor, sdk, mediator) {
    (0, _classCallCheck3.default)(this, EditorFeatures);

    this._editor = editor;
    this._sdk = sdk;
    this._mediator = mediator;

    this._options = this._editor.getOptions();

    this._features = {
      drag: this._options.editor.enableDrag,
      zoom: this._options.editor.enableZoom
    };
  }

  /**
   * Checks if the feature with the given identifier is enabled
   * @param  {String}  identifier
   * @return {Boolean}
   */


  EditorFeatures.prototype.isEnabled = function isEnabled(identifier) {
    var capitalizedIdentifier = identifier.charAt(0).toUpperCase() + identifier.slice(1);
    var optionEnabled = this._options.editor['enable' + capitalizedIdentifier];
    return this._features[identifier] && optionEnabled;
  };

  /**
   * Enables the features with the given identifiers
   * @param  {String[]} identifiers
   */


  EditorFeatures.prototype.enable = function enable() {
    var _this = this;

    for (var _len = arguments.length, identifiers = Array(_len), _key = 0; _key < _len; _key++) {
      identifiers[_key] = arguments[_key];
    }

    identifiers.forEach(function (identifier) {
      _this._features[identifier] = true;
    });
    this._mediator.emit(_globals.Constants.EVENTS.FEATURES_ENABLED, identifiers);
    this._mediator.emit(_globals.Constants.EVENTS.FEATURES_UPDATED, identifiers);
  };

  /**
   * Disables the features with the given identifiers
   * @param  {String[]} identifiers
   */


  EditorFeatures.prototype.disable = function disable() {
    var _this2 = this;

    for (var _len2 = arguments.length, identifiers = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      identifiers[_key2] = arguments[_key2];
    }

    identifiers.forEach(function (identifier) {
      _this2._features[identifier] = false;
    });
    this._mediator.emit(_globals.Constants.EVENTS.FEATURES_DISABLED, identifiers);
    this._mediator.emit(_globals.Constants.EVENTS.FEATURES_UPDATED, identifiers);
  };

  return EditorFeatures;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = EditorFeatures;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EditorHistory = function (_EventEmitter) {
  (0, _inherits3.default)(EditorHistory, _EventEmitter);

  function EditorHistory(editor, sdk, mediator) {
    (0, _classCallCheck3.default)(this, EditorHistory);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._editor = editor;
    _this._sdk = sdk;
    _this._mediator = mediator;

    _this._history = [];
    return _this;
  }

  /**
   * Checks if there are any history items available
   * @return {Boolean}
   */


  EditorHistory.prototype.isAvailable = function isAvailable() {
    return this._history.length !== 0;
  };

  /**
   * Adds the given data to the history
   * @param {PhotoEditorSDK.Operation} operation
   * @param {Object} options
   * @param {Boolean} existent
   * @param {Function} [undo]
   * @return {Object}
   */


  EditorHistory.prototype.add = function add(operation, options, existent) {
    var _this2 = this;

    var undo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    var historyItem = void 0;
    if (operation instanceof Array) {
      var items = operation;
      this._history.push(items);
      items.forEach(function (item) {
        _this2._mediator.emit(_globals.Constants.EVENTS.HISTORY_UPDATED, item.operation);
      });

      historyItem = items;
    } else {
      historyItem = {
        operation: operation, options: options, existent: existent, undo: undo
      };
      this._history.push(historyItem);
      this._mediator.emit(_globals.Constants.EVENTS.HISTORY_UPDATED, operation);
    }
    return historyItem;
  };

  /**
   * Reverts the last change
   */


  EditorHistory.prototype.undo = function undo() {
    var _this3 = this;

    var operations = this._editor.operations;

    var lastItem = this._history.pop();
    if (lastItem) {
      var items = [].concat(lastItem);

      items.forEach(function (historyObject) {
        var operation = historyObject.operation,
            existent = historyObject.existent,
            options = historyObject.options,
            undo = historyObject.undo;

        _this3._mediator.emit(_globals.Constants.EVENTS.HISTORY_BEFORE_UNDO, historyObject);

        if (!existent) {
          operations.remove(operation);
        } else {
          operation = operations.getOrCreate(operation.constructor.identifier);
          operation.set(options);
          _this3._mediator.emit(_globals.Constants.EVENTS.OPERATION_UPDATED, operation);
        }

        if (typeof undo === 'function') {
          undo(operation, options);
        }

        _this3._mediator.emit(_globals.Constants.EVENTS.HISTORY_UPDATED, operation);
        _this3._mediator.emit(_globals.Constants.EVENTS.HISTORY_UNDO, operation);
      });

      this.emit('undo');
    }
  };

  /**
   * Resets the history
   */


  EditorHistory.prototype.reset = function reset() {
    this._history = [];
  };

  return EditorHistory;
}(_globals.EventEmitter); /*
                           * This file is part of PhotoEditorSDK.
                           *
                           * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                           * All rights reserved.
                           *
                           * Redistribution and use in source and binary forms, without
                           * modification, are permitted provided that the following license agreement
                           * is approved and a legal/financial contract was signed by the user.
                           * The license agreement can be found under following link:
                           *
                           * https://www.photoeditorsdk.com/LICENSE.txt
                           */

exports.default = EditorHistory;

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EditorOperations = function () {
  function EditorOperations(editor, sdk, mediator) {
    (0, _classCallCheck3.default)(this, EditorOperations);

    this._editor = editor;
    this._sdk = sdk;
    this._mediator = mediator;

    this._available = this._sdk.getOperations();
    this._map = {};
    this._stack = this._sdk.getOperationsStack();
    this._preferredOrder = this._editor.getOptions().editor.operationsOrder;

    this._fixStack();
  }

  /**
   * Checks whether an operation with the given identifier exists
   * @param {String} identifier
   * @return {Boolean}
   */


  EditorOperations.prototype.exists = function exists(identifier) {
    return !!this._map[identifier];
  };

  /**
   * Adds the given operation to the stack
   * @param {PhotoEditorSDK.Operation} operation
   */


  EditorOperations.prototype.add = function add(operation) {
    var _this = this;

    var identifier = operation.constructor.identifier;
    operation.on('updated', function () {
      _this._mediator.emit(_globals.Constants.EVENTS.OPERATION_UPDATED, operation);
    });
    var index = this._preferredOrder.indexOf(identifier);
    if (index === -1) {
      throw new Error('EditorOperations#add: `' + identifier + '` does not appear in `operationsOrder`');
    }
    this._stack.set(index, operation);
    this._map[identifier] = operation;

    this._mediator.emit(_globals.Constants.EVENTS.OPERATION_CREATED, operation);
  };

  /**
   * Removes the given operation from the stack
   * @param  {PhotoEditorSDK.Operation} operation
   */


  EditorOperations.prototype.remove = function remove(operation) {
    var identifier = operation.constructor.identifier;
    var stack = this._stack.getStack();

    // Remove operation from map
    delete this._map[identifier];

    // Remove operation from stack
    var index = stack.map(function (op) {
      return op.constructor.identifier;
    }).indexOf(operation.constructor.identifier);

    if (index !== -1) {
      this._stack.removeAt(index);

      // Set all following operations to dirty, since they might
      // have cached stuff drawn by the removed operation
      for (var i = index + 1; i < stack.length; i++) {
        var _operation = stack[i];
        if (!_operation) continue;
        _operation.setDirty(true);
      }

      this._mediator.emit(_globals.Constants.EVENTS.OPERATION_REMOVED, operation);
    }
  };

  /**
   * Returns the operation with the given identifier
   * @param  {String} identifier
   * @return {PhotoEditorSDK.Operation}
   */


  EditorOperations.prototype.get = function get(identifier) {
    return this._map[identifier];
  };

  /**
   * If the operation with the given identifier already exists, it returns
   * the existing operation. Otherwise, it creates and returns a new one.
   * @param  {String} identifier
   * @param  {Object} options
   * @return {PhotoEditorSDK.Operation}
   */


  EditorOperations.prototype.getOrCreate = function getOrCreate(identifier) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (this._map[identifier]) {
      var operation = this._map[identifier];
      return operation;
    } else {
      var Operation = this._available[identifier];
      var _operation2 = new Operation(this._sdk, options);
      this.add(_operation2);
      return _operation2;
    }
  };

  /**
   * Returns the operations stack
   * @return {PhotoEditorSDK.OperationsStack}
   */


  EditorOperations.prototype.getStack = function getStack() {
    return this._stack;
  };

  /**
   * Resets the operations
   */


  EditorOperations.prototype.reset = function reset() {
    this._map = {};
  };

  /**
   * Since the SDK might create some operations upfront (e.g. to fix the EXIF orientation),
   * we might have operations at array positions where they should not be. This method
   * moves them to their appropriate position
   * @private
   */


  EditorOperations.prototype._fixStack = function _fixStack() {
    var _this2 = this;

    var stack = this._stack.getStack().slice();
    this._stack.clear();

    stack.forEach(function (s) {
      _this2.add(s);
    });
  };

  return EditorOperations;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = EditorOperations;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MIN_ZOOM_DIMENSIONS = 300; /*
                                * This file is part of PhotoEditorSDK.
                                *
                                * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                * All rights reserved.
                                *
                                * Redistribution and use in source and binary forms, without
                                * modification, are permitted provided that the following license agreement
                                * is approved and a legal/financial contract was signed by the user.
                                * The license agreement can be found under following link:
                                *
                                * https://www.photoeditorsdk.com/LICENSE.txt
                                */

var EditorZoom = function (_EventEmitter) {
  (0, _inherits3.default)(EditorZoom, _EventEmitter);

  function EditorZoom(editor, sdk, mediator) {
    (0, _classCallCheck3.default)(this, EditorZoom);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._editor = editor;
    _this._sdk = sdk;
    _this._mediator = mediator;

    _this._isDefaultZoom = false;
    _this._zoom = _this._sdk.getZoom();
    _this._options = _this._editor.getOptions();

    _this._zoomLevels = [1, 2, 3, 4, 5, 6.25, 8.33, 12.5, 16.66, 25, 33.33, 50, 66.66, 100, 200, 300, 400, 500, 600, 700, 800, 1200, 1600, 3200].map(function (z) {
      return z / 100;
    });
    return _this;
  }

  /**
   * Zooms in the editor
   */


  EditorZoom.prototype.zoomIn = function zoomIn() {
    var newZoom = this._getClosestZoomLevel(this._zoom + 0.001, +1);
    if (!newZoom) return this._zoomLevels[this._zoomLevels.length - 1];
    this.set(newZoom);
  };

  /**
   * Zooms out the editor
   */


  EditorZoom.prototype.zoomOut = function zoomOut() {
    var newZoom = this._getClosestZoomLevel(this._zoom - 0.001, -1);
    if (!newZoom) return this._zoomLevels[0];
    this.set(newZoom);
  };

  /**
   * Returns the closest zoom level to the given one
   * @param  {Number} zoomLevel
   * @param  {Number} direction
   * @return {Number}
   * @private
   */


  EditorZoom.prototype._getClosestZoomLevel = function _getClosestZoomLevel(zoomLevel, direction) {
    if (direction === -1) {
      return this._zoomLevels.filter(function (l) {
        return l < zoomLevel;
      }).pop();
    } else if (direction === 1) {
      return this._zoomLevels.filter(function (l) {
        return l > zoomLevel;
      })[0];
    }
  };

  /**
   * Switches to the previous zoom
   */


  EditorZoom.prototype.undo = function undo() {
    if (!this._previousZoom) return;
    this.set(this._previousZoom);
    this._previousZoom = null;
  };

  /**
   * Sets the zoom to the given one
   * @param {Number} zoom
   * @param {Function} [callback]
   * @param {Boolean} [considerMinimum = true]
   */


  EditorZoom.prototype.set = function set(zoom, callback) {
    var considerMinimum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (!this._editor.isReady()) {
      return;
    }
    this._previousZoom = this._zoom;

    var newZoom = zoom;
    var defaultZoom = this.getDefault();
    if (zoom === 'auto' || newZoom === defaultZoom) {
      newZoom = defaultZoom;
      zoom = 'auto';

      this._isDefaultZoom = true;
    } else {
      this._isDefaultZoom = false;
    }

    var maxZoom = Math.max(1, defaultZoom * 2);
    var minZoom = considerMinimum ? this.getMinimum() : 0;
    newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));

    this._zoom = newZoom;
    this._sdk.setZoom(this._zoom);
    this._sdk.setTextureQuality(Math.min(this._zoom, 1));
    this.emit('set', this._zoom, callback);
  };

  /**
   * Returns the default zoom level
   * @return {Number}
   */


  EditorZoom.prototype.getDefault = function getDefault() {
    var finalDimensions = this._editor.getFinalDimensions(false);
    var canvasDimensions = this._editor.getCanvasDimensions();
    var defaultDimensions = _globals.SDKUtils.resizeVectorToFit(finalDimensions, canvasDimensions);

    return defaultDimensions.divide(finalDimensions).x;
  };

  /**
   * Returns the minimum zoom level
   * @return {Number}
   */


  EditorZoom.prototype.getMinimum = function getMinimum() {
    var finalDimensions = this._editor.getFinalDimensions();
    var minimumDimensions = _globals.SDKUtils.resizeVectorToFit(finalDimensions, new _globals.Vector2(MIN_ZOOM_DIMENSIONS, MIN_ZOOM_DIMENSIONS));

    return minimumDimensions.divide(finalDimensions).x;
  };

  /**
   * Checks if the editor is at the default zoom level
   * @return {Boolean}
   */


  EditorZoom.prototype.isDefault = function isDefault() {
    return this._isDefaultZoom;
  };

  /**
   * Returns the current zoom level
   * @return {Number}
   */


  EditorZoom.prototype.get = function get() {
    return this._zoom;
  };

  return EditorZoom;
}(_globals.EventEmitter);

exports.default = EditorZoom;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

var _fileDownloader = __webpack_require__(182);

var _fileDownloader2 = _interopRequireDefault(_fileDownloader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Exporter = function () {
  function Exporter(sdk, options, download) {
    (0, _classCallCheck3.default)(this, Exporter);

    this._sdk = sdk;
    this._options = options;
    this._download = download;
  }

  /**
   * Exports the image / data url
   * @return {Promise}
   */


  Exporter.prototype.export = function _export() {
    var _this = this;

    var renderType = this._getRenderType();

    return this._sdk.export(renderType, this._options.format, this._options.quality).then(function (data) {
      if (_this._download) {
        _this._downloadData(renderType, data);
      }
      return data;
    });
  };

  /**
   * Downloads the data using the given render type
   * @param  {RenderType} renderType
   * @param  {String} data
   * @private
   */


  Exporter.prototype._downloadData = function _downloadData(renderType, data) {
    switch (renderType) {
      case _globals.RenderType.DATAURL:
        _fileDownloader2.default.downloadDataURL(data, this._options.fileBasename);
        break;
      case _globals.RenderType.MSBLOB:
        _fileDownloader2.default.downloadMSBlob(data, this._options.fileBasename);
        break;
    }
  };

  /**
   * Returns the render type for this export
   * @return {RenderType}
   * @private
   */


  Exporter.prototype._getRenderType = function _getRenderType() {
    var options = this._options;
    if (options.type !== _globals.RenderType.IMAGE || !this._download) {
      return options.type;
    } else {
      if (_globals.Utils.supportsMSBlob()) {
        return _globals.RenderType.MSBLOB;
      } else {
        return _globals.RenderType.DATAURL;
      }
    }
  };

  return Exporter;
}();

exports.default = Exporter;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FileDownloader = function () {
  function FileDownloader() {
    (0, _classCallCheck3.default)(this, FileDownloader);
  }

  /**
   * Exports the given data url
   * @param  {String} data
   * @param  {String} baseName = 'photoeditorsdk-export'
   */
  FileDownloader.downloadDataURL = function downloadDataURL(data) {
    var baseName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'photoeditorsdk-export';

    var url = this.createBlobURLFromDataURL(data);
    var extension = this.getExtensionFromDataURL(data);

    var link = document.createElement('a');
    link.download = baseName + '.' + extension;
    link.href = url;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  /**
   * Exports the given data url using msBlob
   * @param  {String} data
   * @param  {String} baseName = 'photoeditorsdk-export'
   */


  FileDownloader.downloadMSBlob = function downloadMSBlob(data) {
    var baseName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'photoeditorsdk-export';

    navigator.msSaveBlob(data, baseName + '.png');
  };

  /**
   * Returns the file extension by reading the given data url
   * @param  {String} data
   * @return {String}
   */


  FileDownloader.getExtensionFromDataURL = function getExtensionFromDataURL(data) {
    var mimeString = data.split(',')[0].split(':')[1].split(';')[0];
    return mimeString.split('/').pop();
  };

  /**
   * Creates a Blob URI from the given Data URI
   * @param {String} data
   */


  FileDownloader.createBlobURLFromDataURL = function createBlobURLFromDataURL(data) {
    if (!window.Blob || !window.URL || !ArrayBuffer || !Uint8Array) {
      return data;
    }

    var rawData = _globals.Base64.decode(data.split(',')[1]);
    var mimeString = data.split(',')[0].split(':')[1].split(';')[0];

    // write the bytes of the string to an ArrayBuffer
    var arrayBuffer = new ArrayBuffer(rawData.length);
    var intArray = new Uint8Array(arrayBuffer);
    for (var i = 0; i < rawData.length; i++) {
      intArray[i] = rawData[i];
    }

    // write the ArrayBuffer to a blob, and you're done
    var blob = new window.Blob([arrayBuffer], {
      type: mimeString
    });
    return window.URL.createObjectURL(blob);
  };

  return FileDownloader;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = FileDownloader;

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FileLoader = function (_EventEmitter) {
  (0, _inherits3.default)(FileLoader, _EventEmitter);

  function FileLoader(input) {
    (0, _classCallCheck3.default)(this, FileLoader);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._input = input;
    _this._onFileChange = _this._onFileChange.bind(_this);
    _this._input.addEventListener('change', _this._onFileChange);
    return _this;
  }

  /**
   * Opens the file dialog
   */


  FileLoader.prototype.open = function open() {
    this._input.value = null;
    this._input.click();
  };

  /**
   * Loads the file into an image
   * @param  {File} file
   * @private
   */


  FileLoader.prototype._handleFile = function _handleFile(file) {
    var _this2 = this;

    var reader = new window.FileReader();
    reader.onload = function () {
      return function (e) {
        var data = e.target.result;
        var image = new window.Image();

        image.addEventListener('load', function () {
          _this2.emit('file', image);
        });

        image.src = data;
      };
    }(file);
    reader.readAsDataURL(file);
  };

  /**
   * Gets called when the file input value changes
   * @private
   */


  FileLoader.prototype._onFileChange = function _onFileChange() {
    var files = this._input.files;

    if (!files.length) return;

    this._handleFile(files[0]);
  };

  /**
   * Disposes all listeners
   */


  FileLoader.prototype.dispose = function dispose() {
    this._input.removeEventListener('change', this._onFileChange);
  };

  return FileLoader;
}(_globals.EventEmitter); /*
                           * This file is part of PhotoEditorSDK.
                           *
                           * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                           * All rights reserved.
                           *
                           * Redistribution and use in source and binary forms, without
                           * modification, are permitted provided that the following license agreement
                           * is approved and a legal/financial contract was signed by the user.
                           * The license agreement can be found under following link:
                           *
                           * https://www.photoeditorsdk.com/LICENSE.txt
                           */

exports.default = FileLoader;

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FontsLoader = function () {
  function FontsLoader() {
    (0, _classCallCheck3.default)(this, FontsLoader);

    this._fonts = [];
  }

  /**
   * Adds the given font to the list of fonts to load
   * @param {Object} font
   */


  FontsLoader.prototype.add = function add(font) {
    this._fonts.push(font);
  };

  /**
   * Loads the fonts
   */


  FontsLoader.prototype.load = function load() {};

  return FontsLoader;
}();

exports.default = FontsLoader;

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _fontsLoader = __webpack_require__(184);

var _fontsLoader2 = _interopRequireDefault(_fontsLoader);

var _fontRuler = __webpack_require__(186);

var _fontRuler2 = _interopRequireDefault(_fontRuler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var now = typeof window !== 'undefined' && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : __webpack_require__(89);

var FONT_STYLES = {
  italic: 'i'
};

var GoogleFontsLoader = function (_FontsLoader) {
  (0, _inherits3.default)(GoogleFontsLoader, _FontsLoader);

  function GoogleFontsLoader() {
    (0, _classCallCheck3.default)(this, GoogleFontsLoader);
    return (0, _possibleConstructorReturn3.default)(this, _FontsLoader.apply(this, arguments));
  }

  /**
   * Loads the fonts
   */
  GoogleFontsLoader.prototype.load = function load() {
    var _this2 = this;

    if (this._fonts.length === 0) {
      return Promise.resolve();
    }

    this._defaultFontRuler = new _fontRuler2.default();
    this._customFontRulers = [];

    this._addStylesheetTag();

    this._fonts.forEach(function (font) {
      var ruler = new _fontRuler2.default();
      ruler.setFont(font);
      _this2._customFontRulers.push(ruler);
    });

    return this._waitForLoadPromise();
  };

  /**
   * Checks for changed widths every 50ms, after 5 seconds it times out
   * @return {Promise}
   * @private
   */


  GoogleFontsLoader.prototype._waitForLoadPromise = function _waitForLoadPromise(promise) {
    var _this3 = this;

    this._startedAt = now();

    var promises = this._customFontRulers.map(function (ruler) {
      return _this3._waitForLoad(ruler).then(function () {
        ruler.dispose();
      });
    });

    return Promise.all(promises).then(function () {
      _this3.dispose();
    }).catch(function (e) {
      _this3.dispose();
      throw e;
    });
  };

  /**
   * Checks for changed widths every 50ms, after 5 seconds it times out
   * @return {Promise}
   * @private
   */


  GoogleFontsLoader.prototype._waitForLoad = function _waitForLoad(ruler) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      var fn = function fn() {
        var changed = _this4._checkWidthChanged(ruler);

        if (changed) {
          return resolve();
        } else {
          if (now() - _this4._startedAt >= 5000) {
            return reject(new Error('Font loading timed out.'));
          }
        }

        setTimeout(fn, 50);
      };
      fn();
    });
  };

  /**
   * Checks if the width has changed
   * @param {FontRuler} ruler
   * @return {Boolean}
   * @private
   */


  GoogleFontsLoader.prototype._checkWidthChanged = function _checkWidthChanged(ruler) {
    return this._defaultFontRuler.getWidth() !== ruler.getWidth();
  };

  /**
   * Appends the <link> tag to the head
   * @private
   */


  GoogleFontsLoader.prototype._addStylesheetTag = function _addStylesheetTag() {
    var families = this._getFamiliesString();
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://fonts.googleapis.com/css?family=' + families;

    var head = document.getElementsByTagName('head')[0];
    head.appendChild(link);
  };

  /**
   * Returns the string representation of all Google Fonts families that
   * should be loaded
   * @return {String}
   * @private
   */


  GoogleFontsLoader.prototype._getFamiliesString = function _getFamiliesString() {
    var families = {};
    this._fonts.forEach(function (font) {
      var fontFamily = font.getFontFamily();
      var fontStyle = font.getFontStyle();
      var fontWeight = font.getFontWeight();
      families[fontFamily] = families[fontFamily] || [];
      if (typeof fontWeight !== 'undefined') {
        families[fontFamily].push('' + fontWeight + (FONT_STYLES[fontStyle] || ''));
      } else {
        families[fontFamily].push(400); // default weight
      }
    });

    var familyStrings = [];
    for (var name in families) {
      var variants = families[name];
      var variantsString = variants.length ? ':' + variants.join(',') : '';
      var nameString = name.replace(' ', '+') + variantsString;
      familyStrings.push(nameString);
    }

    return familyStrings.join('|');
  };

  /**
   * Disposes the font rulers
   */


  GoogleFontsLoader.prototype.dispose = function dispose() {
    if (this._defaultFontRuler) this._defaultFontRuler.dispose();
    this._customFontRulers.forEach(function (ruler) {
      ruler.dispose();
    });
  };

  return GoogleFontsLoader;
}(_fontsLoader2.default);

exports.default = GoogleFontsLoader;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _font = __webpack_require__(69);

var _font2 = _interopRequireDefault(_font);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FONT_SIZE = 30; /*
                     * This file is part of PhotoEditorSDK.
                     *
                     * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                     * All rights reserved.
                     *
                     * Redistribution and use in source and binary forms, without
                     * modification, are permitted provided that the following license agreement
                     * is approved and a legal/financial contract was signed by the user.
                     * The license agreement can be found under following link:
                     *
                     * https://www.photoeditorsdk.com/LICENSE.txt
                     */

var CHARACTERS = 'abcdefghijklmnopqrstuvwxzy';

var FontRuler = function () {
  function FontRuler() {
    (0, _classCallCheck3.default)(this, FontRuler);

    this._font = new _font2.default({
      fontFamily: 'Times New Roman',
      fontWeight: 'normal',
      fontStyle: 'normal'
    });

    this._createRuler();
  }

  /**
   * Creates the ruler and attaches it to the DOM
   * @private
   */


  FontRuler.prototype._createRuler = function _createRuler() {
    this._ruler = document.createElement('div');
    this._ruler.innerText = CHARACTERS;
    document.body.appendChild(this._ruler);
    this._setRulerStyle();
  };

  /**
   * Styles the ruler
   * @private
   */


  FontRuler.prototype._setRulerStyle = function _setRulerStyle() {
    this._ruler.style.cssText = '\n      position: absolute;\n      top: -9999px;\n      left: -9999px;\n      display: inline-block;\n      font: ' + this._font.getFontStyle() + ' ' + this._font.getFontWeight() + ' ' + FONT_SIZE + 'px ' + this._font.getFontFamily() + ';\n    ';
  };

  /**
   * Sets the font to the given one
   * @param {PhotoEditorSDK.UI.ReactUI.Font} font
   */


  FontRuler.prototype.setFont = function setFont(font) {
    this._font = font;
    this._setRulerStyle();
  };

  /**
   * Returns the width of this ruler
   * @return {Number}
   */


  FontRuler.prototype.getWidth = function getWidth() {
    return this._ruler.offsetWidth;
  };

  /**
   * Removes this ruler from the DOM
   */


  FontRuler.prototype.dispose = function dispose() {
    if (this._ruler) {
      this._ruler.parentNode.removeChild(this._ruler);
      this._ruler = null;
    }
  };

  return FontRuler;
}();

exports.default = FontRuler;

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.SDK.OptionType; /*
                                           * This file is part of PhotoEditorSDK.
                                           *
                                           * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
                                           * All rights reserved.
                                           *
                                           * Redistribution and use in source and binary forms, without
                                           * modification, are permitted provided that the following license agreement
                                           * is approved and a legal/financial contract was signed by the user.
                                           * The license agreement can be found under following link:
                                           *
                                           * https://www.photoeditorsdk.com/LICENSE.txt
                                           */

var Frame = function (_SDK$Configurable) {
  (0, _inherits3.default)(Frame, _SDK$Configurable);

  function Frame(ui) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, Frame);

    var _this = (0, _possibleConstructorReturn3.default)(this, _SDK$Configurable.call(this, options));

    _this._loaded = false;
    _this._loading = false;
    _this._ui = ui;
    _this._frame = _globals.SDK.Utils.deepDefaults(_this._options, {});
    return _this;
  }

  /**
   * Loads the images of this frame
   * @return {Promise}
   */


  Frame.prototype.load = function load() {
    var _this2 = this;

    if (this._loaded) return Promise.resolve();
    if (this._loading) return Promise.reject(new Error('Called Frame#load while it\'s already loading'));

    this._loading = true;
    var imageGroups = this._options.imageGroups;


    var promises = [];
    ['top', 'left', 'right', 'bottom'].forEach(function (groupName) {
      if (!(groupName in imageGroups)) return;

      var group = imageGroups[groupName];
      ['start', 'mid', 'end'].forEach(function (partName) {
        if (!(partName in group)) return;

        promises.push(_this2._loadPart(groupName, partName));
      });
    });

    return Promise.all(promises).then(function () {
      _this2._loaded = true;
      _this2._loading = false;
    }).catch(function (e) {
      _this2._loaded = false;
      _this2._loading = false;
    });
  };

  /**
   * Loads the given part of the given group
   * @param  {String} groupName
   * @param  {String} partName
   * @return {Promise}
   * @private
   */


  Frame.prototype._loadPart = function _loadPart(groupName, partName) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var imageGroups = _this3._options.imageGroups;


      var part = imageGroups[groupName][partName];
      var imageUrl = part;
      // `part` can also be an object containing `mode` and `image`
      if (typeof part !== 'string' && 'image' in part) {
        imageUrl = part.image;
      }

      var image = new window.Image();
      image.addEventListener('load', function () {
        if (typeof part !== 'string') {
          _this3._frame.imageGroups[groupName][partName].image = image;
        } else {
          _this3._frame.imageGroups[groupName][partName] = image;
        }

        resolve(image);
      });
      image.addEventListener('error', function () {
        reject(new Error('Failed to load image at ' + imageUrl));
      });
      image.src = _this3._ui.getAssetPath(imageUrl);
    });
  };

  /**
   * Returns the frame
   * @return {Object}
   */


  Frame.prototype.getFrame = function getFrame() {
    return this._frame;
  };

  return Frame;
}(_globals.SDK.Configurable);

/**
 * Specifies the available options for the Frame class
 * @type {Object}
 * @ignore
 */


exports.default = Frame;
Frame.prototype.availableOptions = {
  name: { type: OptionType.STRING, required: true },
  label: { type: OptionType.STRING },
  icon: { type: OptionType.STRING },
  tintable: { type: OptionType.BOOLEAN, default: false },
  layoutMode: {
    type: OptionType.STRING,
    default: 'horizontal-inside',
    available: ['horizontal-inside', 'vertical-inside']
  },
  imageGroups: { type: OptionType.OBJECT, required: true }
};

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ImageResizer = function () {
  function ImageResizer(image, maxPixels, maxDimensions) {
    (0, _classCallCheck3.default)(this, ImageResizer);

    this._image = image;
    this._maxPixels = maxPixels;
    this._maxDimensions = maxDimensions;
  }

  /**
   * Checks if the image needs to be resized
   * @return {Boolean}
   */


  ImageResizer.prototype.needsResize = function needsResize() {
    var dimensions = new _globals.Vector2(this._image.width, this._image.height);
    var pixels = dimensions.x * dimensions.y;
    var exceedsMaxPixels = pixels > this._maxPixels;
    var exceedsMaxDimensions = this._maxDimensions !== null && (dimensions.x > this._maxDimensions || dimensions.y > this._maxDimensions);

    return exceedsMaxPixels || exceedsMaxDimensions;
  };

  /**
   * Resizes the image to match the maximum amount of pixels
   * @return {Promise}
   */


  ImageResizer.prototype.resize = function resize() {
    var _this = this;

    var reason = null;
    var canvas = null;
    var maxDimensions = this._maxDimensions;

    return new _globals.Promise(function (resolve, reject) {
      window.setTimeout(function () {
        var initialDimensions = new _globals.Vector2(_this._image.width, _this._image.height);
        var dimensions = initialDimensions.clone();

        // If max pixels is exceeded, resize to fit the max pixels
        if (dimensions.x * dimensions.y > _this._maxPixels) {
          dimensions.copy(_this._getDimensionsByMaxPixels());
          reason = 'maxMegaPixels';
        }

        // If max dimensions (maximum texture size) is exceeded,
        // make sure the shorter side equals the maximum texture
        // size
        if (maxDimensions !== null && (dimensions.x > maxDimensions || dimensions.y > maxDimensions)) {
          var scale = Math.min(maxDimensions / dimensions.x, maxDimensions / dimensions.y);
          dimensions.multiply(scale);
          reason = 'maxDimensions';
        }

        dimensions.floor();
        canvas = _this._createResizedImageCanvas(dimensions);

        resolve({ canvas: canvas, dimensions: dimensions, reason: reason });
      }, 1000);
    });
  };

  /**
   * Creates a resized canvas with the given dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} [imageDimensions] = dimensions
   * @return {Canvas}
   * @private
   */


  ImageResizer.prototype._createResizedImageCanvas = function _createResizedImageCanvas(dimensions) {
    var imageDimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : dimensions;

    var image = this._image;

    var canvas = document.createElement('canvas');
    canvas.width = dimensions.x;
    canvas.height = dimensions.y;

    var offset = dimensions.clone().subtract(imageDimensions).divide(2);

    var context = canvas.getContext('2d');
    context.drawImage(image, 0, 0, image.width, image.height, offset.x, offset.y, imageDimensions.x, imageDimensions.y);
    return canvas;
  };

  /**
   * Returns the dimensions that match the max pixel count
   * @return {Vector2}
   * @private
   */


  ImageResizer.prototype._getDimensionsByMaxPixels = function _getDimensionsByMaxPixels() {
    var image = this._image;
    var maxPixels = this._maxPixels;

    var ratioHV = image.width / image.height;
    var ratioVH = image.height / image.width;

    return new _globals.Vector2(Math.sqrt(maxPixels * ratioHV), Math.sqrt(maxPixels * ratioVH)).floor();
  };

  return ImageResizer;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = ImageResizer;

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

var _font = __webpack_require__(69);

var _font2 = _interopRequireDefault(_font);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FontsManager = function () {
  function FontsManager(options) {
    (0, _classCallCheck3.default)(this, FontsManager);

    this._options = options;
    this._fonts = [];

    this._initFonts();
  }

  /**
   * Initializes the fonts
   * @private
   */


  FontsManager.prototype._initFonts = function _initFonts() {
    var _options = this._options,
        additionalFonts = _options.additionalFonts,
        replaceFonts = _options.replaceFonts,
        selectableFonts = _options.selectableFonts;

    additionalFonts = additionalFonts || [];

    // Replace or append fonts
    var fonts = _globals.Constants.DEFAULTS.FONTS;
    if (replaceFonts) {
      fonts = additionalFonts;
    } else {
      fonts = fonts.concat(additionalFonts);
    }

    // Pick specific fonts using `selectableFonts` option
    if (selectableFonts && selectableFonts.length) {
      fonts = _globals.Utils.select(fonts, selectableFonts, function (r) {
        return r.name;
      });
    }

    // Turn fonts into actual Font objects
    fonts = fonts.map(function (font) {
      return new _font2.default(font);
    });

    // Font default font
    var defaultFont = null;
    fonts.forEach(function (font) {
      if (!defaultFont && font.default) {
        defaultFont = font;
      }
    });

    if (!defaultFont) {
      defaultFont = fonts[0];
    }

    this._defaultFont = defaultFont;
    this._fonts = fonts;
  };

  /**
   * Returns the default font
   * @return {PhotoEditorSDK.UI.ReactUI.Font[]}
   */


  FontsManager.prototype.getFonts = function getFonts() {
    return this._fonts;
  };

  /**
   * Returns the default font
   * @return {PhotoEditorSDK.UI.ReactUI.Font}
   */


  FontsManager.prototype.getDefaultFont = function getDefaultFont() {
    return this._defaultFont;
  };

  return FontsManager;
}();

exports.default = FontsManager;

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

var _frame = __webpack_require__(187);

var _frame2 = _interopRequireDefault(_frame);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FrameManager = function () {
  function FrameManager(ui, options) {
    (0, _classCallCheck3.default)(this, FrameManager);

    this._ui = ui;
    this._options = options;

    this._initFrames();
  }

  /**
   * Initializes the frames
   * @private
   */


  FrameManager.prototype._initFrames = function _initFrames() {
    var _this = this;

    var _options = this._options,
        additionalFrames = _options.additionalFrames,
        replaceFrames = _options.replaceFrames,
        selectableFrames = _options.selectableFrames;

    additionalFrames = additionalFrames || [];

    // Replace or append frames
    var frames = _globals.Constants.DEFAULTS.FRAMES;
    if (replaceFrames) {
      frames = additionalFrames;
    } else {
      frames = frames.concat(additionalFrames);
    }

    // Pick specific frames using `selectableFrames` option
    if (selectableFrames && selectableFrames.length) {
      frames = _globals.Utils.select(frames, selectableFrames, function (r) {
        return r.name;
      });
    }

    // Turn frames into actual Frame objects
    frames = frames.map(function (frame) {
      return new _frame2.default(_this._ui, frame);
    });

    // Default frame
    var defaultFrame = null;
    frames.forEach(function (frame) {
      if (!defaultFrame && frame.default) {
        defaultFrame = frame;
      }
    });

    if (!defaultFrame) {
      defaultFrame = frames[0];
    }

    this._defaultFrame = defaultFrame;
    this._frames = frames;
  };

  /**
   * Returns the default frame
   * @return {PhotoEditorSDK.UI.ReactUI.Frame[]}
   */


  FrameManager.prototype.getFrames = function getFrames() {
    return this._frames;
  };

  /**
   * Returns the default frame
   * @return {PhotoEditorSDK.UI.ReactUI.Frame}
   */


  FrameManager.prototype.getDefaultFrame = function getDefaultFrame() {
    return this._defaultFrame;
  };

  return FrameManager;
}();

exports.default = FrameManager;

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Library = function Library(data) {
  (0, _classCallCheck3.default)(this, Library);

  this.name = data.name;
  this.coverImage = data.coverImage;
};

exports.default = Library;

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Photo = function Photo(library, data) {
  (0, _classCallCheck3.default)(this, Photo);

  this.library = library;
  this.title = data.title;
  this.urls = data.urls;
};

exports.default = Photo;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Provider = function () {
  function Provider() {
    (0, _classCallCheck3.default)(this, Provider);
  }

  /**
   * Returns the libraries
   * @return {Promise}
   * @abstract
   */
  Provider.prototype.getLibraries = function getLibraries() {
    _globals.Log.warn(this.constructor.name, '`getLibraries` is abstract and not implemented.');
    return _globals.Promise.resolve([]);
  };

  /**
   * Returns search suggestions shown on the overview and "no results" page
   * @return {Promise}
   * @abstract
   */


  Provider.prototype.getSearchSuggestions = function getSearchSuggestions() {
    _globals.Log.warn(this.constructor.name, '`getSearchSuggestions` is abstract and not implemented.');
    return _globals.Promise.resolve([]);
  };

  /**
   * Returns the photos for the given library
   * @param {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Library} library
   * @return {Promise}
   * @abstract
   */


  Provider.prototype.getPhotosForLibrary = function getPhotosForLibrary(library) {
    _globals.Log.warn(this.constructor.name, '`getPhotosForLibrary` is abstract and not implemented.');
    return _globals.Promise.resolve([]);
  };

  /**
   * Searches for photos with the given query
   * @param {String} query
   * @return {Promise}
   */


  Provider.prototype.searchPhotos = function searchPhotos(query) {
    _globals.Log.warn(this.constructor.name, '`searchPhotos` is abstract and not implemented.');
    return _globals.Promise.resolve([]);
  };

  return Provider;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = Provider;

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SearchSuggestion = function SearchSuggestion(data) {
  (0, _classCallCheck3.default)(this, SearchSuggestion);

  this.query = data.query;
  this.name = this.query;
  this.coverImage = data.coverImage;
};

exports.default = SearchSuggestion;

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _editor = __webpack_require__(68);

var _editor2 = _interopRequireDefault(_editor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var LOAD_TIMEOUT = 5000;

var Preloader = function (_EventEmitter) {
  (0, _inherits3.default)(Preloader, _EventEmitter);

  function Preloader(ui, options, mediator) {
    (0, _classCallCheck3.default)(this, Preloader);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._ui = ui;
    _this._options = options;
    _this._mediator = mediator;

    // A shallow Editor instance that is only there to check for features etc.
    _this._editor = new _editor2.default(ui, options, mediator, true);

    // Generic assets that are pretty much always required
    _this._assets = ['controls/back.png', 'controls/minus.png', 'controls/plus.png', 'controls/tick.png', 'controls/webcam/shutter.png', 'controls/knobs/remove.png', 'controls/knobs/resize-diagonal-down.png', 'controls/knobs/resize-diagonal-up.png', 'controls/knobs/rotate.png', 'editor/export.png', 'editor/new.png', 'editor/undo.png', ['splash/photo-roll.png', false], ['splash/webcam.png', false], 'top-bar/back.png', 'close.png'];
    _this._appendControlsAssets();
    return _this;
  }

  /**
   * Adds the control-specific assets if necessary
   * @private
   */


  Preloader.prototype._appendControlsAssets = function _appendControlsAssets() {
    var controls = this._editor.controls.getAvailable();
    for (var key in controls) {
      var Control = controls[key];
      if (this._editor.controls.isEnabled(key)) {
        this._assets = this._assets.concat(Control.getPreloadAssets(this._editor));
        this._assets.push(Control.iconPath);
      }
    }
  };

  /**
   * Loads the assets, emits progress events
   */


  Preloader.prototype.load = function load() {
    var _this2 = this;

    var assets = this._assets.slice();
    var assetsCount = assets.length;
    var assetsLoaded = 0;

    /**
     * Called when an asset has been loaded. Increases the asset counter and emits a progress
     * event
     */
    var assetLoaded = function assetLoaded() {
      assetsLoaded++;
      _this2.emit('progress', assetsLoaded / assetsCount);
      if (assetsLoaded === assetsCount) {
        _this2.emit('done');
      }
    };

    /**
     * Logs a warning message that the given asset failed to load for the given reason
     * @param  {String} path
     * @param  {String} reason
     */
    var assetLoadFailed = function assetLoadFailed(path) {
      var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'timed out';

      _globals.Log.warn('Preloader', path + ' ' + reason + '.');
      assetLoaded();
    };

    /**
     * Creates a timeout for the given asset path. Assumes an asset failed to load when timeout
     * runs out
     * @param  {String} path
     * @return {Number}
     */
    var loadTimeout = function loadTimeout(path) {
      return window.setTimeout(function () {
        assetLoadFailed(path);
      }, LOAD_TIMEOUT);
    };

    assets.forEach(function (asset) {
      var retinaAsset = true;
      if (_globals.SDKUtils.isArray(asset)) {
        retinaAsset = asset[1];
        asset = asset[0];
      }

      var assetPath = _this2._ui.getAssetPath(asset, true, !retinaAsset);
      var image = new window.Image();
      var timeout = loadTimeout(assetPath);
      image.addEventListener('load', function () {
        window.clearTimeout(timeout);
        assetLoaded();
      });
      image.addEventListener('error', function () {
        window.clearTimeout(timeout);
        assetLoadFailed(assetPath, 'was not found');
      });
      image.crossOrigin = 'Anonymous';
      image.src = assetPath;
    });
  };

  return Preloader;
}(_globals.EventEmitter);

exports.default = Preloader;

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _serializer = __webpack_require__(73);

var _serializer2 = _interopRequireDefault(_serializer);

var _deserializer = __webpack_require__(72);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Serialization = function () {
  function Serialization(editor) {
    (0, _classCallCheck3.default)(this, Serialization);

    this._editor = editor;
  }

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  Serialization.prototype.serialize = function serialize() {
    var serializer = new _serializer2.default(this._editor);
    return serializer.serialize.apply(serializer, arguments);
  };

  /**
   * Deserializes the given data
   * @param  {Object} data
   * @return {Promise}
   */


  Serialization.prototype.deserialize = function deserialize(data) {
    var deserializer = new _deserializer2.default(this._editor, data);
    return deserializer.deserialize();
  };

  return Serialization;
}();

exports.default = Serialization;


Serialization.version = '1.0.0';

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _deserializer = __webpack_require__(72);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Deserializer = function (_BaseDeserializer) {
  (0, _inherits3.default)(Deserializer, _BaseDeserializer);

  function Deserializer() {
    (0, _classCallCheck3.default)(this, Deserializer);
    return (0, _possibleConstructorReturn3.default)(this, _BaseDeserializer.apply(this, arguments));
  }

  /**
   * Validates the version
   * @return {Promise}
   */
  Deserializer.prototype._validateVersion = function _validateVersion() {
    if (this._data.version !== '1.0.1') {
      return Promise.reject(new Error('Invalid version ' + this._data.version + ', expected 1.0.1'));
    }
    return Promise.resolve();
  };

  /**
   * Deserializes the operations
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeOperations = function _deserializeOperations() {
    var _this2 = this;

    // New in 1.0.1: `SelectiveBlurOperation`
    var promises = this._data.operations.map(function (operation) {
      switch (operation.type) {
        case 'crop':
          return _this2._deserializeCropOperation(operation);
        case 'orientation':
          return _this2._deserializeOrientationOperation(operation);
        case 'filter':
          return _this2._deserializeFilterOperation(operation);
        case 'adjustments':
          return _this2._deserializeAdjustmentsOperation(operation);
        case 'sprite':
          return _this2._deserializeSpriteOperation(operation);
        case 'focus':
          return _this2._deserializeFocusOperation(operation);
        case 'selective-blur':
          return _this2._deserializeSelectiveBlurOperation(operation);
      }
    });

    return Promise.all(promises);
  };

  /**
   * Deserializes the given crop operation
   * @param  {PhotoEditorSDK.Operation} operation
   * @return {Promise}
   * @private
   */


  Deserializer.prototype._deserializeCropOperation = function _deserializeCropOperation(operation) {
    // New in 1.0.1: `dimensions` option
    var options = operation.options;
    var scale = options.scale,
        rotation = options.rotation;

    var start = _globals.Vector2.fromObject(options.start);
    var end = _globals.Vector2.fromObject(options.end);

    // Normalize rotation
    if (rotation > Math.PI) {
      rotation -= Math.PI * 2;
    }

    this._editor.operations.getOrCreate('crop', {
      start: start, end: end, scale: scale, rotation: rotation
    });
    return Promise.resolve();
  };

  return Deserializer;
}(_deserializer2.default);

exports.default = Deserializer;

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _serializer = __webpack_require__(199);

var _serializer2 = _interopRequireDefault(_serializer);

var _deserializer = __webpack_require__(197);

var _deserializer2 = _interopRequireDefault(_deserializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Serialization = function () {
  function Serialization(editor) {
    (0, _classCallCheck3.default)(this, Serialization);

    this._editor = editor;
  }

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  Serialization.prototype.serialize = function serialize() {
    var serializer = new _serializer2.default(this._editor);
    return serializer.serialize.apply(serializer, arguments);
  };

  /**
   * Deserializes the given data
   * @param  {Object} data
   * @return {Promise}
   */


  Serialization.prototype.deserialize = function deserialize(data) {
    var deserializer = new _deserializer2.default(this._editor, data);
    return deserializer.deserialize();
  };

  return Serialization;
}();

exports.default = Serialization;


Serialization.version = '1.0.1';

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _serializer = __webpack_require__(73);

var _serializer2 = _interopRequireDefault(_serializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TWICE_PI = Math.PI * 2;

var Serializer = function (_BaseSerializer) {
  (0, _inherits3.default)(Serializer, _BaseSerializer);

  function Serializer() {
    (0, _classCallCheck3.default)(this, Serializer);
    return (0, _possibleConstructorReturn3.default)(this, _BaseSerializer.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- SERIALIZATION

  /**
   * Serializes the editor state
   * @param {Object} options = {}
   * @return {Promise}
   */
  Serializer.prototype.serialize = function serialize() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._options = _globals.SDKUtils.defaults(options, {
      image: true
    });

    var data = {
      version: '1.0.1'
    };

    return this._serializeInputImage(data).then(this._serializeOperations);
  };

  /**
   * Serializes the given operation
   * @param  {PhotoEditorSDK.Operation} operation
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeOperation = function _serializeOperation(operation) {
    switch (operation.constructor.identifier) {
      case 'crop':
        return this._serializeCropOperation(operation);
      case 'orientation':
        return this._serializeOrientationOperation(operation);
      case 'filter':
        return this._serializeFilterOperation(operation);
      case 'adjustments':
        return this._serializeAdjustmentsOperation(operation);
      case 'sprite':
        return this._serializeSpriteOperation(operation);
      case 'radial-focus':
        return this._serializeRadialFocusOperation(operation);
      case 'linear-focus':
        return this._serializeLinearFocusOperation(operation);
      case 'selective-blur':
        return this._serializeSelectiveBlurOperation(operation);
      default:
        throw new Error('Unable to serialize operation of type ' + operation.constructor.identifier);
    }
  };

  /**
   * Serializes the given crop operation
   * @param  {PhotoEditorSDK.Operation.CropOperation} operation
   * @return {Object}
   * @private
   */


  Serializer.prototype._serializeCropOperation = function _serializeCropOperation(operation) {
    var options = operation.serializeOptions(['start', 'end', 'rotation', 'scale', 'textureScale'], true);
    options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;

    delete options.textureScale;
    return {
      type: 'crop',
      options: options
    };
  };

  return Serializer;
}(_serializer2.default);

exports.default = Serializer;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(33);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _photoeditorsdk = __webpack_require__(29);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EventEmitter = _photoeditorsdk2.default.EventEmitter,
    Utils = _photoeditorsdk2.default.Utils; /*
                                             * This file is part of PhotoEditorSDK.
                                             *
                                             * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                             * All rights reserved.
                                             *
                                             * Redistribution and use in source and binary forms, without
                                             * modification, are permitted provided that the following license agreement
                                             * is approved and a legal/financial contract was signed by the user.
                                             * The license agreement can be found under following link:
                                             *
                                             * https://www.photoeditorsdk.com/LICENSE.txt
                                             */

var SharedState = function (_EventEmitter) {
  (0, _inherits3.default)(SharedState, _EventEmitter);

  function SharedState() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SharedState);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._state = state;
    return _this;
  }

  /**
   * Sets the given state
   * @param {Object} newState
   * @param {Boolean} update = true
   */


  SharedState.prototype.set = function set() {
    var newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if ((typeof newState === 'undefined' ? 'undefined' : (0, _typeof3.default)(newState)) !== 'object') {
      console && console.trace('SharedState#set expects an object as first parameter');
    }

    var oldState = Utils.extend({}, this._state);
    this._state = Utils.extend(this._state, newState);

    if (update) {
      this.broadcastUpdate(oldState, this._state);
    }
  };

  /**
   * Returns the state for the given property
   * @param {String} prop
   */


  SharedState.prototype.get = function get(prop) {
    return this._state[prop];
  };

  /**
   * Broadcasts an update
   * @param {Object} oldState
   * @param {Object} newState
   */


  SharedState.prototype.broadcastUpdate = function broadcastUpdate(oldState) {
    var newState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this.emit('update', oldState, newState);
  };

  /**
   * Clears the state
   */


  SharedState.prototype.clear = function clear() {
    this._state = {};
  };

  return SharedState;
}(EventEmitter);

exports.default = SharedState;

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _photoeditorsdk = __webpack_require__(29);

var _photoeditorsdk2 = _interopRequireDefault(_photoeditorsdk);

var _log = __webpack_require__(74);

var _log2 = _interopRequireDefault(_log);

var _browser = __webpack_require__(202);

var _browser2 = _interopRequireDefault(_browser);

var _jsonLoader = __webpack_require__(37);

var _jsonLoader2 = _interopRequireDefault(_jsonLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Vector2 = _photoeditorsdk2.default.Math.Vector2; /*
                                                      * This file is part of PhotoEditorSDK.
                                                      *
                                                      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                      * All rights reserved.
                                                      *
                                                      * Redistribution and use in source and binary forms, without
                                                      * modification, are permitted provided that the following license agreement
                                                      * is approved and a legal/financial contract was signed by the user.
                                                      * The license agreement can be found under following link:
                                                      *
                                                      * https://www.photoeditorsdk.com/LICENSE.txt
                                                      */

var UIUtils = {
  /**
   * Returns the inner dimensions (size - padding) of the given
   * DOM element
   * @param  {DOMElement} element
   * @return {Vector2}
   */
  getInnerDimensionsForElement: function getInnerDimensionsForElement(element) {
    var size = new Vector2(element.offsetWidth, element.offsetHeight);
    var computedStyle = window.getComputedStyle(element, null);
    size.x -= parseInt(computedStyle.getPropertyValue('padding-left'), 10);
    size.x -= parseInt(computedStyle.getPropertyValue('padding-right'), 10);
    size.y -= parseInt(computedStyle.getPropertyValue('padding-top'), 10);
    size.y -= parseInt(computedStyle.getPropertyValue('padding-bottom'), 10);
    return size;
  },


  /**
   * Gets the x and y position for the given event.
   * @param {Event} e
   * @return {Vector2}
   */
  getEventPosition: function getEventPosition(e) {
    var x = e.clientX;
    var y = e.clientY;
    if (e.type.indexOf('touch') !== -1) {
      if (!e.touches.length) return;

      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }
    return new Vector2(x, y);
  },


  /**
   * Creates a canvas with a transparency pattern
   * @return {Canvas}
   */
  createTransparentPatternCanvas: function createTransparentPatternCanvas() {
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    canvas.width = 10;
    canvas.height = 10;

    context.fillStyle = 'white';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = '#cccccc';
    context.fillRect(0, 0, canvas.width / 2, canvas.height / 2);
    context.fillRect(canvas.width / 2, canvas.height / 2, canvas.width, canvas.height);

    return canvas;
  },


  /**
   * Checks if the browser supports canvas.msToBlob
   * @return {Boolean}
   */
  supportsMSBlob: function supportsMSBlob() {
    var canvas = document.createElement('canvas');
    return typeof canvas.msToBlob !== 'undefined';
  },


  /**
   * Translates the given key using the given options
   * @param  {Object} phrases
   * @param  {String} key
   * @param  {Object} interpolationOptions = {}
   * @return {String}
   */
  translate: function translate(phrases, key) {
    var interpolationOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var response = this.fetch(phrases, key);
    if (!response) {
      _log2.default.warn('Utils#translate', 'Unable to translate `' + key + '`');
      return key;
    }
    for (var _key in interpolationOptions) {
      response = response.replace('${' + _key + '}', interpolationOptions[_key]);
    }
    return response;
  },


  /**
   * Gets the property value at `path` of `object`
   * @param  {Object} object
   * @param  {String} path
   * @param  {?} [defaultValue]
   * @return {?}
   */
  fetch: function fetch(object, path, defaultValue) {
    // Replace indexes with property accessors
    path = path.replace(/\[(\w+)]/g, '.$1');
    // Strip leading dot (when path begins with [0] for example)
    path = path.replace(/^\./, '');

    var pathSegments = path.split('.');
    for (var i = 0; i < pathSegments.length; i++) {
      var segment = pathSegments[i];
      object = object[segment];
      if (!object) {
        break;
      }
    }

    if (typeof object === 'undefined') {
      return false;
    }

    return object;
  },


  /**
   * Checks whether the user agent represents a mobile device
   * @return {Boolean}
   */
  isMobile: function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    /* eslint-disable */
    return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))
    );
    /* eslint-enable */
  },


  /**
   * Selects the `selectedItems` from `items`. `selector` is called for every item, return value
   * is matched against `selectedItems`
   * @param  {Array} items
   * @param  {Array} selectedItems
   * @param  {Function} [selector = null]
   * @return {Array}
   */
  select: function select(items, selectedItems) {
    var selector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (!selector) selector = function selector(i) {
      return i;
    };

    var newItems = [];
    selectedItems.forEach(function (selectedItem) {
      items.forEach(function (item) {
        var itemIdentifier = selector(item);
        if (itemIdentifier === selectedItem) {
          newItems.push(item);
        }
      });
    });
    return newItems;
  },


  /**
   * Gets the given URL using JSON(P)
   * @param  {String} url
   * @return {Promise}
   */
  getJSONP: function getJSONP(url) {
    var loader = new _jsonLoader2.default(url);
    return loader.load();
  },


  /**
   * Merges the given `newCategories` into the given `categories`
   * @param  {Array.<Object>} categories
   * @param  {Array.<Object>} newCategories
   * @param  {String} itemsProperty
   * @private
   */
  mergeCategories: function mergeCategories(categories, newCategories, itemsProperty) {
    categories = categories.slice(0);

    var existingCategory = null;
    newCategories.forEach(function (newCategory) {
      categories.forEach(function (category) {
        if (newCategory.name === category.name) {
          existingCategory = category;
        }
      });

      if (!existingCategory) {
        categories.push(newCategory);
      } else {
        existingCategory[itemsProperty] = existingCategory[itemsProperty].concat(newCategory[itemsProperty]);
      }
    });

    return categories;
  },


  /**
   * Returns a camelized style object for the given DOMElement
   * @param  {DOMElement} el
   * @return {Object}
   */
  getStyleObject: function getStyleObject(el) {
    var styleProperties = window.getComputedStyle(el);
    var styleObject = {};
    for (var property in styleProperties) {
      var value = styleProperties.getPropertyValue(property);
      var camelizedAttr = property.replace(/-([a-z])/g, function (a, b) {
        return b.toUpperCase();
      });
      if (value !== '') {
        styleObject[camelizedAttr] = value;
      }
    }
    return styleObject;
  },


  /**
   * Debounces the given function to trigger only every so often
   * @param  {Function} fn
   * @param  {Number}   wait
   * @param  {Boolean}
   * @return {Function}
   */
  debounce: function debounce(fn, wait, immediate) {
    var timeout;
    return function () {
      var _this = this;

      var args = arguments;
      var later = function later() {
        timeout = null;
        if (!immediate) fn.apply(_this, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) fn.apply(this, args);
    };
  },


  /**
   * Finds the native scrollbar width for the current browser
   * @return {Number}
   */
  getScrollbarWidth: function getScrollbarWidth() {
    var outer = document.createElement('div');
    outer.style.visibility = 'hidden';
    outer.style.width = '100px';
    outer.style.msOverflowStyle = 'scrollbar';
    document.body.appendChild(outer);

    var widthNoScroll = outer.offsetWidth;
    outer.style.overflow = 'scroll';

    var inner = document.createElement('div');
    inner.style.width = '100%';
    outer.appendChild(inner);

    var widthWithScroll = inner.offsetWidth;
    outer.parentNode.removeChild(outer);

    return widthNoScroll - widthWithScroll;
  },


  Browser: _browser2.default
};

exports.default = UIUtils;

/***/ },
/* 202 */
/***/ function(module, exports) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = {
  getIEVersion: function getIEVersion() {
    var _navigator = navigator,
        userAgent = _navigator.userAgent,
        appVersion = _navigator.appVersion;

    if (appVersion.indexOf('MSIE') !== -1) {
      return appVersion.match(/MSIE\s+?([0-9]+)/i)[1];
    } else if (userAgent.indexOf('Trident') !== -1) {
      return userAgent.match(/rv:([0-9]+)/i)[1];
    } else {
      return false;
    }
  },
  isIE10: function isIE10() {
    var version = this.getIEVersion();
    return version !== false && version === 10;
  },
  isIE11: function isIE11() {
    var version = this.getIEVersion();
    return version !== false && version === 11;
  },
  isIElte: function isIElte(version) {
    var browserVersion = this.getIEVersion();
    if (browserVersion === false) return false;
    return browserVersion <= version;
  }
};

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 * requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
 * MIT license
 * @license
 */
var root = typeof window === 'undefined' ? global : window;
var rAF = root.requestAnimationFrame;
var cAF = root.cancelAnimationFrame;

var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
for (var x = 0; x < vendors.length && !rAF; ++x) {
  exports.requestAnimationFrame = rAF = root[vendors[x] + 'RequestAnimationFrame'];
  exports.cancelAnimationFrame = cAF = root[vendors[x] + 'CancelAnimationFrame'] || root[vendors[x] + 'CancelRequestAnimationFrame'];
}

/* istanbul ignore next */
if (!rAF) {
  exports.requestAnimationFrame = rAF = function rAF(callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}

/* istanbul ignore next */
if (!cAF) {
  exports.cancelAnimationFrame = cAF = function cAF(id) {
    clearTimeout(id);
  };
}

exports.requestAnimationFrame = rAF;
exports.cancelAnimationFrame = cAF;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(90)))

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(214), __esModule: true };

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(215), __esModule: true };

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(216), __esModule: true };

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(217), __esModule: true };

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(218), __esModule: true };

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(220), __esModule: true };

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(221), __esModule: true };

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(222), __esModule: true };

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _isIterable2 = __webpack_require__(206);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(205);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _from = __webpack_require__(204);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(36);
__webpack_require__(246);
module.exports = __webpack_require__(9).Array.from;

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(59);
__webpack_require__(36);
module.exports = __webpack_require__(244);

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(59);
__webpack_require__(36);
module.exports = __webpack_require__(245);

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(248);
module.exports = __webpack_require__(9).Object.assign;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(249);
var $Object = __webpack_require__(9).Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(250);
var $Object = __webpack_require__(9).Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(251);
module.exports = __webpack_require__(9).Object.setPrototypeOf;

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(253);
__webpack_require__(252);
__webpack_require__(254);
__webpack_require__(255);
module.exports = __webpack_require__(9).Symbol;

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(36);
__webpack_require__(59);
module.exports = __webpack_require__(58).f('iterator');

/***/ },
/* 223 */
/***/ function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ },
/* 224 */
/***/ function(module, exports) {

module.exports = function(){ /* empty */ };

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(19)
  , toLength  = __webpack_require__(86)
  , toIndex   = __webpack_require__(243);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var $defineProperty = __webpack_require__(14)
  , createDesc      = __webpack_require__(28);

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(27)
  , gOPS    = __webpack_require__(50)
  , pIE     = __webpack_require__(34);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(13).document && document.documentElement;

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators  = __webpack_require__(23)
  , ITERATOR   = __webpack_require__(10)('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(44);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(15);
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var create         = __webpack_require__(49)
  , descriptor     = __webpack_require__(28)
  , setToStringTag = __webpack_require__(51)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(22)(IteratorPrototype, __webpack_require__(10)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

var ITERATOR     = __webpack_require__(10)('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};

/***/ },
/* 234 */
/***/ function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(27)
  , toIObject = __webpack_require__(19);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

var META     = __webpack_require__(35)('meta')
  , isObject = __webpack_require__(26)
  , has      = __webpack_require__(18)
  , setDesc  = __webpack_require__(14).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(25)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = __webpack_require__(27)
  , gOPS     = __webpack_require__(50)
  , pIE      = __webpack_require__(34)
  , toObject = __webpack_require__(55)
  , IObject  = __webpack_require__(80)
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(25)(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(14)
  , anObject = __webpack_require__(15)
  , getKeys  = __webpack_require__(27);

module.exports = __webpack_require__(16) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(19)
  , gOPN      = __webpack_require__(83).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(18)
  , toObject    = __webpack_require__(55)
  , IE_PROTO    = __webpack_require__(52)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(26)
  , anObject = __webpack_require__(15);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(45)(Function.call, __webpack_require__(82).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(54)
  , defined   = __webpack_require__(46);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(54)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(15)
  , get      = __webpack_require__(87);
module.exports = __webpack_require__(9).getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(77)
  , ITERATOR  = __webpack_require__(10)('iterator')
  , Iterators = __webpack_require__(23);
module.exports = __webpack_require__(9).isIterable = function(it){
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var ctx            = __webpack_require__(45)
  , $export        = __webpack_require__(17)
  , toObject       = __webpack_require__(55)
  , call           = __webpack_require__(231)
  , isArrayIter    = __webpack_require__(229)
  , toLength       = __webpack_require__(86)
  , createProperty = __webpack_require__(226)
  , getIterFn      = __webpack_require__(87);

$export($export.S + $export.F * !__webpack_require__(233)(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var addToUnscopables = __webpack_require__(224)
  , step             = __webpack_require__(234)
  , Iterators        = __webpack_require__(23)
  , toIObject        = __webpack_require__(19);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(81)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(17);

$export($export.S + $export.F, 'Object', {assign: __webpack_require__(237)});

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

var $export = __webpack_require__(17)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(49)});

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

var $export = __webpack_require__(17);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(16), 'Object', {defineProperty: __webpack_require__(14).f});

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(17);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(241).set});

/***/ },
/* 252 */
/***/ function(module, exports) {



/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
// ECMAScript 6 symbols shim
var global         = __webpack_require__(13)
  , has            = __webpack_require__(18)
  , DESCRIPTORS    = __webpack_require__(16)
  , $export        = __webpack_require__(17)
  , redefine       = __webpack_require__(85)
  , META           = __webpack_require__(236).KEY
  , $fails         = __webpack_require__(25)
  , shared         = __webpack_require__(53)
  , setToStringTag = __webpack_require__(51)
  , uid            = __webpack_require__(35)
  , wks            = __webpack_require__(10)
  , wksExt         = __webpack_require__(58)
  , wksDefine      = __webpack_require__(57)
  , keyOf          = __webpack_require__(235)
  , enumKeys       = __webpack_require__(227)
  , isArray        = __webpack_require__(230)
  , anObject       = __webpack_require__(15)
  , toIObject      = __webpack_require__(19)
  , toPrimitive    = __webpack_require__(56)
  , createDesc     = __webpack_require__(28)
  , _create        = __webpack_require__(49)
  , gOPNExt        = __webpack_require__(239)
  , $GOPD          = __webpack_require__(82)
  , $DP            = __webpack_require__(14)
  , $keys          = __webpack_require__(27)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(83).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(34).f  = $propertyIsEnumerable;
  __webpack_require__(50).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(48)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(22)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(57)('asyncIterator');

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(57)('observable');

/***/ },
/* 256 */
/***/ function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			configurable: false,
			get: function() { return module.l; }
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			configurable: false,
			get: function() { return module.i; }
		});
		module.webpackPolyfill = 1;
	}
	return module;
}


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(256)(module), __webpack_require__(90)))

/***/ },
/* 258 */
/***/ function(module, exports) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ },
/* 259 */
/***/ function(module, exports) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

exports.decode = exports.parse = __webpack_require__(258);
exports.encode = exports.stringify = __webpack_require__(259);


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = __webpack_require__(257);
var util = __webpack_require__(262);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(260);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ },
/* 262 */
/***/ function(module, exports) {

"use strict";
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ },
/* 263 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_263__;

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(3);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(2);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(1);

var _appComponent = __webpack_require__(92);

var _appComponent2 = _interopRequireDefault(_appComponent);

var _scrollbarComponent = __webpack_require__(5);

var _scrollbarComponent2 = _interopRequireDefault(_scrollbarComponent);

var _controlsComponent = __webpack_require__(7);

var _controlsComponent2 = _interopRequireDefault(_controlsComponent);

var _modalManager = __webpack_require__(6);

var _modalManager2 = _interopRequireDefault(_modalManager);

var _jsonLoader = __webpack_require__(37);

var _jsonLoader2 = _interopRequireDefault(_jsonLoader);

var _photoRoll = __webpack_require__(94);

var PhotoRoll = _interopRequireWildcard(_photoRoll);

var _controls = __webpack_require__(8);

var _controls2 = _interopRequireDefault(_controls);

var _controls3 = __webpack_require__(61);

var Controls = _interopRequireWildcard(_controls3);

var _sliderComponent = __webpack_require__(30);

var _sliderComponent2 = _interopRequireDefault(_sliderComponent);

var _sliderOverlayComponent = __webpack_require__(12);

var _sliderOverlayComponent2 = _interopRequireDefault(_sliderOverlayComponent);

var _fontLoader = __webpack_require__(93);

var _fontLoader2 = _interopRequireDefault(_fontLoader);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var bd = function bd(str) {
  return _globals.SDKUtils.byteArrayToString(_globals.Base64.decode(str));
}; /*
    * This file is part of PhotoEditorSDK.
    *
    * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
    * All rights reserved.
    *
    * Redistribution and use in source and binary forms, without
    * modification, are permitted provided that the following license agreement
    * is approved and a legal/financial contract was signed by the user.
    * The license agreement can be found under following link:
    *
    * https://www.photoeditorsdk.com/LICENSE.txt
    * @license
    */

/**
 * The React UI
 * @class
 * @alias ReactUI
 * @extends PhotoEditorSDK.EventEmitter
 * @memberof PhotoEditorSDK.UI
 */
var ReactUI = function (_EventEmitter) {
  (0, _inherits3.default)(ReactUI, _EventEmitter);

  /**
   * Creates an UI instance
   * @param  {Object} options
   * @param  {String} options.apiKey - Your API key
   * @param  {DOMElement} options.container - The container that the UI should be rendered to
   * @param  {String} [options.title = 'PhotoEditor SDK'] - Only available for licensees
   * @param  {String} [options.language = 'en'] - Currently `en` and `de` are supported
   * @param  {String} [options.logLevel] - `trace`, `info`, `warn`, `error` or `log`
   * @param  {Boolean} [options.responsive = false] - Should the editor re-render on window resize?
   *
   * @param  {Boolean} [options.enableUpload = true] - Should the user be able to upload their own photos?
   * @param  {Boolean} [options.enableWebcam = true] - Enables webcam support. Disabled on mobile devices.
   *
   * @param  {Boolean} [options.showCloseButton = false] - Should the close button be displayed?
   * @param  {Boolean} [options.showHeader = true] - Should the header (with title text) be displayed?
   *                                                 Should only be set to `false` by licensees.
   * @param  {Boolean} [options.showTopBar = true] - Should the top bar (new / zoom / undo / export) be displayed?
   *
   * @param  {Object} [options.photoRoll]
   * @param  {PhotoEditorSDK.UI.ReactUI.PhotoRoll.Provider} provider - The class providing all data
   *                                                                 for the photo roll
   *
   * @param  {Boolean} [options.preloader = true] - Enables the preloader
   * @param  {Object} [options.editor]
   * @param  {Image} [options.editor.image] - The image that the user can edit
   * @param  {Image} [options.editor.watermarkImage] - An image that should be placed on top as a watermark
   * @param  {String} [options.editor.preferredRenderer = 'webgl'] - `webgl` or `canvas`
   * @param  {Number} [options.editor.pixelRatio = 1] - If none is given, PhotoEditorSDK automatically
   *   detects the current device's pixel ratio
   * @param  {Boolean} [options.editor.enableDrag = true] - Should dragging the canvas be enabled?
   * @param  {Boolean} [options.editor.enableZoom = true] - Should zooming be enabled?
   * @param  {Boolean} [options.editor.smoothDownscaling = false] - Toggles smooth downscaling
   * @param  {Boolean} [options.editor.smoothUpscaling = false] - Toggles smooth upscaling
   * @param  {Boolean} [options.editor.displayResizeMessage = true] - Should a message be displayed
   *                                                       when the image has been scaled down
   *                                                       for performance?
   * @param  {String[]} [options.editor.tools] - The enabled tools. Available are: `crop`, `rotation`,
   *                                    `flip`, `filter`, `brightness`, `saturation`, `gamma`, `contrast`,
   *                                    `clarity`, `exposure`, `shadows`, `highlights`, `text`,
   *                                    `sticker`, `brush`, `selective-blur`, `radial-focus`,
   *                                    `linear-focus`, `frame` and `frame`
   * @param  {(String[]|Array[])} [options.editor.controlsOrder] - The order in which the controls are displayed.
   *                                           Available are `crop`, `filter`,
   *                                           `adjustments`, `text`, `sticker`, `brush`, `focus`,
   *                                           `frame`. Can be grouped in arrays which will be
   *                                           displayed with separators.
   * @param  {String[]} [options.editor.operationsOrder] - The order in which operations are added to
   *                                              the stack. Changing this may affect the
   *                                              performance.
   * @param  {Object} [options.editor.controlsOptions] - Options that are passed to specific controls. See
   *                                            the documentation for each control to learn more
   *                                            about available values.
   * @param {Object[]} [options.editor.forceControls] - An array of objects specifying the controls
   *                                                  the user needs to use before being able to
   *                                                  use the actual editor.
   *
   * @param  {Object} [options.editor.maxMegaPixels] - Maximum amount of megapixels per device type
   * @param  {Number} [options.editor.maxMegaPixels.desktop = 10]
   * @param  {Number} [options.editor.maxMegaPixels.mobile = 5]
   *
   * @param  {Object} [options.editor.export]
   * @param  {Boolean} [options.editor.export.showButton = true] - Should the `export` button be displayed?
   * @param  {String} [options.editor.export.format = 'image/png'] - The export format. Available formats
   * @param  {PhotoEditorSDK.RenderType} [options.editor.export.type] - The export type (image or data url)
   * @param  {Boolean} [options.editor.export.download] - Should the result be presented as a download?
   * @param  {String} [options.editor.export.fileBasename = 'photoeditorsdk-export'] - The basename
   *                                                      of the exported file (file extension will
   *                                                      be added automatically)
   * @param {Number} [options.editor.export.quality = 0.8] - The export quality (0...1, only supported
   *                                                for JPG images)
   *
   * @param  {Object} [options.assets]
   * @param  {String} [options.assets.baseUrl = '/assets'] - Path that is prepended to all asset paths
   * @param  {Function} [options.assets.resolver] - A function resolving a path to another path.
   */
  function ReactUI() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, ReactUI);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._mediator = new _globals.EventEmitter();
    _this._fontLoader = new _fontLoader2.default();
    _this._options = options;
    _this._initOptions();
    _this._initLanguage();
    _this._initEvents();
    _this._disposed = false;

    _globals.Log.setLevel(_this._options.logLevel);

    if (_this._v()) {
      _this.run();
    }
    return _this;
  }

  /**
   * Main entry point for the UI
   * @private
   */


  ReactUI.prototype.run = function run() {
    this._registerWebFonts();

    // Container has to be position: relative
    this._options.container.style.position = 'relative';
    this._render();
  };

  /**
   * Renders the UI
   * @private
   */


  ReactUI.prototype._render = function _render() {
    var component = _globals.React.createElement(_appComponent2.default, {
      ui: this,
      mediator: this._mediator,
      options: this._options });

    if (this._options.renderReturnsComponent) {
      return component;
    } else {
      this._component = _globals.ReactDOM.render(component, this._options.container);
    }
  };

  /**
   * Exports an image
   * @param {Boolean} download = false
   * @return {Promise}
   */


  ReactUI.prototype.export = function _export() {
    var _component;

    return (_component = this._component).export.apply(_component, arguments);
  };

  /**
   * Serializes the editor state
   * @return {Promise}
   */


  ReactUI.prototype.serialize = function serialize() {
    var _component2;

    return (_component2 = this._component).serialize.apply(_component2, arguments);
  };

  /**
   * Deserializes the given data
   * @param  {Object} data
   * @return {Promise}
   */


  ReactUI.prototype.deserialize = function deserialize(data) {
    return this._component.deserialize(data);
  };

  /**
   * Returns the editor
   * @return {PhotoEditorSDK.UI.ReactUI.Editor}
   */


  ReactUI.prototype.getEditor = function getEditor() {
    return this._component.getEditor();
  };

  // -------------------------------------------------------------------------- INITIALIZATION

  /**
   * Initializes the default options
   * @private
   */


  ReactUI.prototype._initOptions = function _initOptions() {
    this._options = _globals.SDKUtils.defaults(this._options, {
      language: 'en',
      title: 'PhotoEditor SDK',
      logLevel: 'warn',

      preloader: true,

      editor: {},
      assets: {},
      photoRoll: {},

      enableUpload: true,
      enableWebcam: true,

      showCloseButton: false,
      showHeader: true,
      showTopBar: true,
      responsive: false
    });

    this._options.editor = _globals.SDKUtils.defaults(this._options.editor || {}, {
      pixelRatio: typeof window !== 'undefined' && window.devicePixelRatio || 1,
      preferredRenderer: 'webgl',
      enableZoom: true,
      enableDrag: true,
      smoothDownscaling: false,
      smoothUpscaling: false,
      displayResizeMessage: true,
      maxMegaPixels: {},
      forceControls: [],
      watermarkImage: null,
      tools: ['crop', 'filter', 'brightness', 'saturation', 'contrast', 'clarity', 'exposure', 'shadows', 'highlights', 'text', 'sticker', 'brush', 'radial-focus', 'linear-focus', 'frame'],
      controlsOrder: ['crop', ['filter', 'adjustments'], ['text', 'sticker', 'brush'], ['selectiveBlur', 'focus', 'frame']],
      operationsOrder: [
      // First, all operations that affect the image dimensions
      'exif-orientation', // Automatically created by SDK
      'orientation', 'crop',

      // Then color operations (first filter, then fine-tuning)
      'filter', 'adjustments',

      // Then post-processing
      'radial-focus', 'linear-focus', 'selective-blur', 'sprite', 'frame', 'watermark'],
      controlsOptions: {}
    });

    this._options.editor.maxMegaPixels = _globals.SDKUtils.defaults(this._options.editor.maxMegaPixels, {
      mobile: 5,
      desktop: 10
    });

    this._options.editor.export = _globals.SDKUtils.defaults(this._options.editor.export || {}, {
      showButton: true,
      format: 'image/png',
      type: _globals.RenderType.IMAGE,
      download: true,
      fileBasename: 'photoeditorsdk-export',
      quality: 0.8
    });

    this._options.photoRoll = _globals.SDKUtils.defaults(this._options.photoRoll || {}, {
      provider: null
    });

    this._options.extensions = _globals.SDKUtils.defaults(this._options.extensions || {}, {
      languages: {},
      operations: [],
      controls: []
    });

    this._options.assets = _globals.SDKUtils.defaults(this._options.assets || {}, {
      baseUrl: 'assets',
      resolver: null
    });
  };

  /**
   * Validates presence of the API key
   * @return {Boolean}
   * @private
   */


  ReactUI.prototype._v = function _v() {
    if (!this[bd('X29wdGlvbnM=')][bd('YXBpS2V5')]) {
      _globals.Log.error(bd('YXBpS2V5'), bd('Tm8gYGFwaUtleWAgb3B0aW9uIGdpdmVuLg=='));
      _globals.Log.error(bd('YXBpS2V5'), bd('SW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhbiBBUEkga2V5IHlldCwgcGxlYXNlIGNvbnRhY3Qgb3VyIHNhbGVzIHN0YWZmIGF0IHNhbGVzQHBob3RvZWRpdG9yc2RrLmNvbSB0byBvYnRhaW4gYSBsaWNlbnNlIG9yIGxvZyBpbiB0byB5b3VyIGN1c3RvbWVyIGRhc2hib2FyZC4='));
      return false;
    }
    return true;
  };

  /**
   * Creates a <style> block in <head> that specifies the web fonts
   * that we use in this UI. We're doing this in JS because the assets
   * path is dynamic.
   * @private
   */


  ReactUI.prototype._registerWebFonts = function _registerWebFonts() {
    var regularFontPath = this.getAssetPath('fonts/montserrat-regular.woff', true, true);
    var lightFontPath = this.getAssetPath('fonts/montserrat-light.woff', true, true);

    var css = '\n      // Injected by PhotoEditorSDK\n      @font-face {\n        font-family: "__pesdk_Montserrat";\n        src: url(\'' + regularFontPath + '\') format(\'woff\');\n        font-weight: normal;\n        font-style: normal;\n      }\n\n      @font-face {\n        font-family: "__pesdk_Montserrat";\n        src: url(\'' + lightFontPath + '\') format(\'woff\');\n        font-weight: 100;\n        font-style: normal;\n      }\n    ';

    this._webFontsStyle = document.createElement('style');
    this._webFontsStyle.innerHTML = css;

    var head = document.getElementsByTagName('head')[0];
    head.appendChild(this._webFontsStyle);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Catches mediator events and emits them here
   * @private
   */


  ReactUI.prototype._initEvents = function _initEvents() {
    this._mediator.pipeEvents(this);
  };

  /**
   * Unpipes the vents
   * @private
   */


  ReactUI.prototype._disposeEvents = function _disposeEvents() {
    this._mediator.unpipeEvents(this);
  };

  // -------------------------------------------------------------------------- I18N

  /**
   * Initializes the internationalization
   * @private
   */


  ReactUI.prototype._initLanguage = function _initLanguage() {
    this._languages = _globals.SDKUtils.deepDefaults(this._options.extensions.languages, {
      de: __webpack_require__(95),
      en: __webpack_require__(96)
    });
    this._language = this._languages[this._options.language];
    if (!this._language) {
      _globals.Log.error(this.constructor.name, 'Language `' + this._options.language + '` not found!');
    }
  };

  /**
   * Returns the translation for `key`
   * @param  {String} key
   * @param  {Object} [interpolationOptions]
   * @return {String}
   */


  ReactUI.prototype.translate = function translate(key, interpolationOptions) {
    return _globals.Utils.translate(this._language, key, interpolationOptions);
  };

  /**
   * Sets the image to the given one
   * @param {Image} image
   */


  ReactUI.prototype.setImage = function setImage(image) {
    if (!this._component) return;
    this._component.setImage(image);
  };

  /**
   * Returns the resolved asset path for the given asset name
   * @param  {String} asset
   * @param  {Boolean} uiAsset = false
   * @param  {Boolean} disableRetina = false
   * @return {String}
   */


  ReactUI.prototype.getAssetPath = function getAssetPath(asset) {
    var uiAsset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var disableRetina = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var _options$assets = this._options.assets,
        baseUrl = _options$assets.baseUrl,
        resolver = _options$assets.resolver;

    var path = baseUrl + '/' + asset;

    // Don't prepend baseUrl to absolute urls
    if (asset.match(/(ftp|http|https):\/\//)) {
      path = asset;
    }

    if (uiAsset) {
      if (!disableRetina) {
        // Append @2x if device's pixel ratio > 1
        var pixelRatio = typeof window !== 'undefined' && window.devicePixelRatio || 1;
        if (pixelRatio > 1) {
          var regex = /\.[\w?=]+$/;
          asset = asset.replace(regex, function (match) {
            return '@2x' + match;
          });
        }
      }

      path = baseUrl + '/ui/react/' + asset;
    }

    if (typeof resolver !== 'undefined' && resolver !== null) {
      path = resolver(path);
    }

    return path;
  };

  /**
   * Returns the font loader
   * @return {FontLoader}
   */


  ReactUI.prototype.getFontLoader = function getFontLoader() {
    return this._fontLoader;
  };

  /**
   * Disposes the UI
   */


  ReactUI.prototype.dispose = function dispose() {
    if (this._disposed) {
      throw new Error('This instance of PhotoEditorSDK is already disposed.');
    }
    this._disposed = true;

    // Remove web fonts style
    this._webFontsStyle.parentNode.removeChild(this._webFontsStyle);

    // Unmount AppComponent
    _globals.ReactDOM.unmountComponentAtNode(this._options.container);

    this._disposeEvents();
  };

  return ReactUI;
}(_globals.EventEmitter);

/**
 * Export event
 *
 * @event PhotoEditorSDK.UI.ReactUI#export
 * @type {Image|String|Blob}
 */

/**
 * Operation created event
 *
 * @event PhotoEditorSDK.UI.ReactUI#operation:created
 * @type {PhotoEditorSDK.Operation}
 */

/**
 * Operation removed event
 *
 * @event PhotoEditorSDK.UI.ReactUI#operation:removed
 * @type {PhotoEditorSDK.Operation}
 */

/**
 * History undo event
 *
 * @event PhotoEditorSDK.UI.ReactUI#history:undo
 */

/**
 * Controls switched event
 *
 * @event PhotoEditorSDK.UI.ReactUI#controls:switched
 * @type {PhotoEditorSDK.UI.ReactUI.Controls}
 */

/**
 * A unique string that represents this UI
 * @type {String}
 */


ReactUI.prototype.identifier = 'react';

// Export extendable stuff
ReactUI.BaseComponent = _globals.BaseComponent;
ReactUI.BaseControls = _controls2.default;
ReactUI.ControlsComponent = _controlsComponent2.default;
ReactUI.React = _globals.React;
ReactUI.ReactBEM = _globals.ReactBEM;
ReactUI.SharedState = _globals.SharedState;
ReactUI.Constants = _globals.Constants;
ReactUI.Utils = _globals.Utils;
ReactUI.ScrollbarComponent = _scrollbarComponent2.default;
ReactUI.ModalManager = _modalManager2.default;
ReactUI.JSONLoader = _jsonLoader2.default;
ReactUI.PhotoRoll = PhotoRoll;
ReactUI.Controls = Controls;
ReactUI.SliderComponent = _sliderComponent2.default;
ReactUI.SliderOverlayComponent = _sliderOverlayComponent2.default;

/**
 * The PhotoEditorSDK UI can also be integrated as a React.js component
 * @class
 * @extends React.Component
 * @memberof PhotoEditorSDK.UI.ReactUI
 */

var ReactComponent = function (_React$Component) {
  (0, _inherits3.default)(ReactComponent, _React$Component);

  function ReactComponent() {
    (0, _classCallCheck3.default)(this, ReactComponent);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this2._ui = new ReactUI(_this2.props);
    return _this2;
  }

  /**
   * Renders this component
   * @return {React.Element}
   */


  ReactComponent.prototype.render = function render() {
    return this._ui.render();
  };

  return ReactComponent;
}(_globals.React.Component);

ReactUI.ReactComponent = ReactComponent;

// Extend PhotoEditorSDK object
_globals.SDK.UI = _globals.SDK.UI || {};
_globals.SDK.UI.ReactUI = ReactUI;

module.exports = ReactUI;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBjZTFiNzg1YTIyN2E1ZWJiODU4NSIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3Njcm9sbGJhci1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2xpYi9tb2RhbC1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2NvbnRyb2xzLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvZHJhZ2dhYmxlLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9zbGlkZXItb3ZlcmxheS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2NhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9zY3JlZW4tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJwaG90b2VkaXRvcnNka1wiLFwiY29tbW9uanMyXCI6XCJwaG90b2VkaXRvcnNka1wiLFwiYW1kXCI6XCJwaG90b2VkaXRvcnNka1wiLFwicm9vdFwiOlwiUGhvdG9FZGl0b3JTREtcIn0iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zbGlkZXItY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3Nwcml0ZXMvc3ByaXRlcy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NoYXJlZC90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2pzb24tbG9hZGVyLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL2NvbG9yLXBpY2tlci1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvc3ByaXRlcy9pdGVtcy9pdGVtLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3NwbGFzaC9yb3ctY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NoYXJlZC9pbnZpc2libGUtdXBsb2FkLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zaGFyZWQvdG9wLWJhci9idXR0b24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9saWIvbWFuYWdlcnMvZmlsdGVyLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXRlZ29yeS1kcm9wZG93bi9jYXRlZ29yeS1kcm9wZG93bi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvb3ZlcnZpZXctY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3RleHQvZm9udC1wcmV2aWV3LWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvaXRlbXMvc2VhcmNoLXN1Z2dlc3Rpb24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9waG90by1saXN0LWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vbGliL2JlbS5qc3giLCJ3ZWJwYWNrOi8vLy4vbGliL2VkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZm9udC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvbWFuYWdlcnMvc3RpY2tlci1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2xpYi9yZWFjdC1iZW0uanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3NlcmlhbGl6YXRpb24vMS4wLjAvZGVzZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL2xpYi9zZXJpYWxpemF0aW9uLzEuMC4wL3NlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3NoYXJlZC9sb2cuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9jbGFzc25hbWVzL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2FwcC1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2xpYi9mb250LWxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcGhvdG8tcm9sbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9sYW5nL2RlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbGFuZy9lbi5qc29uIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYmFjay1idXR0b24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2Jhc2UtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2J1dHRvbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2F0ZWdvcnktZHJvcGRvd24vb3ZlcmxheS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL2FscGhhLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb2xvci1waWNrZXIvaHVlLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb2xvci1waWNrZXIvb3ZlcmxheS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL3NhdHVyYXRpb24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2FkanVzdG1lbnRzL2FkanVzdG1lbnRzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9hZGp1c3RtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2JydXNoL2JydXNoLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvYnJ1c2gvYnJ1c2gtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2JydXNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvYnJ1c2gvcHJlc2V0LXByZXZpZXctaXRlbS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvY3JvcC9jcm9wLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvY3JvcC9jcm9wLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9jcm9wL2Nyb3AtdG9wLWJhci1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvY3JvcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZpbHRlci9maWx0ZXItY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZpbHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZvY3VzL2ZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvZm9jdXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZvY3VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvbGluZWFyLWZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvcmFkaWFsLWZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvZnJhbWUvZnJhbWUtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZyYW1lL2ZyYW1lLWl0ZW0tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZyYW1lL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvbWluaS1zbGlkZXItY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L2luZGV4LmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvb3ZlcnZpZXctY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy90b3AtYmFyL2V4cG9ydC1idXR0b24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L3RvcC1iYXIvbmV3LWZpbGUtYnV0dG9uLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L3RvcC1iYXIvdW5kby1idXR0b24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L3RvcC1iYXIvem9vbS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvc2VsZWN0aXZlLWJsdXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9zZWxlY3RpdmUtYmx1ci9zZWxlY3RpdmUtYmx1ci1jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3NlbGVjdGl2ZS1ibHVyL3NlbGVjdGl2ZS1ibHVyLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9zcHJpdGVzL2l0ZW1zL2JydXNoLWl0ZW0tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3Nwcml0ZXMvaXRlbXMvc3RpY2tlci1pdGVtLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy9zcHJpdGVzL2l0ZW1zL3RleHQtaXRlbS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvc3RpY2tlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3N0aWNrZXIvc3RpY2tlci1jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3N0aWNrZXIvc3RpY2tlci1jb250cm9scy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY29udHJvbHMvc3RpY2tlci9zdGlja2VyLWNvbnRyb2xzLW92ZXJsYXktY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3N0aWNrZXIvc3RpY2tlci1pdGVtLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy90ZXh0L2ZvbnQtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3RleHQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy90ZXh0L3RleHQtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jb250cm9scy90ZXh0L3RleHQtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRyb2xzL3RleHQvdGV4dC1jb250cm9scy1vdmVybGF5LWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9kb25lLWJ1dHRvbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvaGVhZGVyLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9tb2RhbC1jb250YWluZXItY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21vZGFscy9lcnJvci1tb2RhbC1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvbW9kYWxzL2xvYWRpbmctbW9kYWwtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21vZGFscy9wcm9ncmVzcy1tb2RhbC1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvbW9kYWxzL3dhcm5pbmctbW9kYWwtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvZWRpdG9yL2NhbnZhcy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9lZGl0b3IvZWRpdG9yLXNjcmVlbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9sb2FkaW5nL2xvYWRpbmctc2NyZWVuLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvaXRlbXMvbGlicmFyeS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL2l0ZW1zL3Bob3RvLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvbm8tc2VhcmNoLXJlc3VsdHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9vdmVydmlldy1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL3Bob3RvLXJvbGwtc2NyZWVuLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvc2VhcmNoLXJlc3VsdHMtY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC90b3AtYmFyL3RvcC1iYXItYnV0dG9uLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvdG9wLWJhci90b3AtYmFyLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvdG9wLWJhci90b3AtYmFyLXNlYXJjaC1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9zcGxhc2gvcGhvdG8tcm9sbC1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9zcGxhc2gvc3BsYXNoLXNjcmVlbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy9zcGxhc2gvdXBsb2FkLWNvbXBvbmVudC5qc3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9zY3JlZW5zL3NwbGFzaC93ZWJjYW0tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3NjcmVlbnMvd2ViY2FtL3dlYmNhbS1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2NyZWVucy93ZWJjYW0vd2ViY2FtLXNjcmVlbi1jb21wb25lbnQuanN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvc2hhcmVkL3RvcC1iYXIvYmFjay1idXR0b24tY29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly8vLi9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL2xpYi9lZGl0b3IvY29udHJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2VkaXRvci9mZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZWRpdG9yL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2VkaXRvci9vcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL2xpYi9lZGl0b3Ivem9vbS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZXhwb3J0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2ZpbGUtZG93bmxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlsZS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2ZvbnQtbG9hZGVycy9mb250cy1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2ZvbnQtbG9hZGVycy9nb29nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2ZvbnQtcnVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2ZyYW1lLmpzIiwid2VicGFjazovLy8uL2xpYi9pbWFnZS1yZXNpemVyLmpzIiwid2VicGFjazovLy8uL2xpYi9tYW5hZ2Vycy9mb250LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL21hbmFnZXJzL2ZyYW1lLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3Bob3RvLXJvbGwvbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcGhvdG8tcm9sbC9waG90by5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcGhvdG8tcm9sbC9wcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcGhvdG8tcm9sbC9zZWFyY2gtc3VnZ2VzdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcHJlbG9hZGVyLmpzIiwid2VicGFjazovLy8uL2xpYi9zZXJpYWxpemF0aW9uLzEuMC4wL2luZGV4LmpzIiwid2VicGFjazovLy8uL2xpYi9zZXJpYWxpemF0aW9uLzEuMC4xL2Rlc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvc2VyaWFsaXphdGlvbi8xLjAuMS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvc2VyaWFsaXphdGlvbi8xLjAuMS9zZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL2xpYi9zaGFyZWQtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL2xpYi91dGlscy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9zaGFyZWQvYW5pbWF0aW9uLWZyYW1lLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0RE9NXCIsXCJjb21tb25qczJcIjpcInJlYWN0LWRvbVwiLFwiY29tbW9uanNcIjpcInJlYWN0LWRvbVwiLFwiYW1kXCI6XCJyZWFjdC1kb21cIn0iLCJ3ZWJwYWNrOi8vLy4vdWkuanMiXSwibmFtZXMiOlsiQmFzZTY0IiwiQ29sb3IiLCJDb2xvck1hdHJpeCIsIk1hdGgiLCJFdmVudEVtaXR0ZXIiLCJFWElGIiwiT3B0aW9uVHlwZSIsIlByb21pc2UiLCJTREtVdGlscyIsIlV0aWxzIiwiUmVuZGVyVHlwZSIsIkltYWdlRm9ybWF0IiwiU0RLIiwiVW5pZm9ybVR5cGUiLCJWZWN0b3IyIiwibm93Iiwid2luZG93IiwicGVyZm9ybWFuY2UiLCJiaW5kIiwicmVxdWlyZSIsIlJlYWN0IiwiQkVNIiwiQ2xhc3NuYW1lcyIsIkJhc2VDb21wb25lbnQiLCJSZWFjdEJFTSIsIkNvbnN0YW50cyIsIlNoYXJlZFN0YXRlIiwiUmVhY3RET00iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIkxvZyIsIlNDUk9MTEJBUl9XSURUSCIsIlNjcm9sbGJhckNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwiTkFUSVZFX1NDUk9MTEJBUl9XSURUSCIsImdldFNjcm9sbGJhcldpZHRoIiwiX25lZWRzU3R5bGVGaXhlcyIsIl9pc0RyYWdnaW5nIiwiX2JpbmRBbGwiLCJzdGF0ZSIsImJ1dHRvblNpemUiLCJidXR0b25Qb3NpdGlvbiIsImJ1dHRvblZpc2libGUiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZSIsImZpeFN0eWxlcyIsImlzTW9iaWxlIiwiX3VwZGF0ZUxpc3RTaXplIiwiX29uTGlzdFNjcm9sbCIsImRpcmVjdGlvbiIsIl9nZXREaXJlY3Rpb24iLCJsaXN0U2Nyb2xsU2l6ZSIsImxpc3RTY3JvbGxQb3NpdGlvbiIsImJhY2tncm91bmRTY3JvbGxTaXplIiwiSE9SSVpPTlRBTCIsIl9saXN0Iiwic2Nyb2xsV2lkdGgiLCJvZmZzZXRXaWR0aCIsInNjcm9sbExlZnQiLCJfbm9kZSIsIlZFUlRJQ0FMIiwic2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsVG9wIiwicHJvZ3Jlc3MiLCJzZXRTdGF0ZSIsIl9vbkJ1dHRvbkRyYWdTdGFydCIsImUiLCJfaW5pdGlhbEJ1dHRvblBvc2l0aW9uIiwiX29uQnV0dG9uRHJhZyIsImRpZmYiLCJ4IiwieSIsIl9zZXRCdXR0b25Qb3NpdGlvbiIsIl9vbkJ1dHRvbkRyYWdTdG9wIiwiX29uQmFyRHJhZ1N0YXJ0IiwibW91c2VQb3NpdGlvbiIsImdldEV2ZW50UG9zaXRpb24iLCJfaW5pdGlhbFBvc2l0aW9uIiwiY2xvbmUiLCJib3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJlbGVtZW50T2Zmc2V0IiwibGVmdCIsInRvcCIsInJlbGF0aXZlUG9zaXRpb24iLCJzdWJ0cmFjdCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9vbkJhckRyYWciLCJfb25CYXJEcmFnU3RvcCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzY3JvbGxhYmxlQnV0dG9uU2l6ZSIsInNjcm9sbGFibGVMaXN0U2l6ZSIsIm1heCIsIm1pbiIsInNjcm9sbFBvc2l0aW9uIiwiX3VwZGF0ZUJ1dHRvblNpemUiLCJjYiIsInBhcmVudFNpemUiLCJwYXJlbnRTY3JvbGxTaXplIiwiY2xpZW50V2lkdGgiLCJzdHlsZSIsImhlaWdodCIsImZ1bGxEaW1lbnNpb25zIiwiX2dldEZ1bGxMaXN0RGltZW5zaW9ucyIsIl9saXN0U2l6ZSIsIl9saXN0Q29udGVudFNpemUiLCJ3aWR0aCIsInJlY3QiLCJyZWZzIiwicm9vdCIsImxpc3QiLCJuZXdMaXN0U2l6ZSIsInByb3BzIiwiX2dldEJ1dHRvblN0eWxlIiwiZ2V0TGlzdCIsImdldFJvb3QiLCJyZW5kZXJXaXRoQkVNIiwiY2hpbGRyZW4iLCJidXR0b25TdHlsZSIsInNjcm9sbGJhclN0eWxlIiwiZGlzcGxheSIsImNoaWxkIiwiY2xvbmVFbGVtZW50IiwicmVmIiwiX29uQnV0dG9uRG93biIsImNvbnRleHRUeXBlcyIsIk1vZGFsIiwidHlwZSIsInRpdGxlIiwidGV4dCIsIm92ZXJsYXkiLCJkYXRhIiwic2V0RGF0YSIsImVtaXQiLCJjbG9zZSIsIk1vZGFsTWFuYWdlciIsIl9tb2RhbHMiLCJkaXNwbGF5TG9hZGluZyIsIm1vZGFsIiwiYWRkTW9kYWwiLCJkaXNwbGF5UHJvZ3Jlc3MiLCJkaXNwbGF5V2FybmluZyIsImRpc3BsYXlFcnJvciIsInB1c2giLCJvbiIsInJlbW92ZU1vZGFsIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiZ2V0TW9kYWxzIiwiX2luc3RhbmNlIiwiQ29udHJvbHNDb21wb25lbnQiLCJhcmdzIiwiX2hhc0JhY2tCdXR0b24iLCJfaGFzRG9uZUJ1dHRvbiIsIl9iYWNrQnV0dG9uQ2xpY2tlZCIsIl9vbkJhY2tDbGljayIsIm9uU3dpdGNoQ29udHJvbHMiLCJfb25Eb25lQ2xpY2siLCJyZW5kZXJDb250cm9scyIsInJlbmRlck92ZXJsYXlDb250cm9scyIsImZvcmNlZENvbnRyb2wiLCJvcHRpb25zIiwiYmFja0J1dHRvbiIsImRvbmVCdXR0b24iLCJDb250cm9sIiwiZ2V0SW5pdGlhbFNoYXJlZFN0YXRlIiwiaXNBdmFpbGFibGUiLCJlZGl0b3IiLCJnZXRQcmVsb2FkQXNzZXRzIiwidG9wQmFyQ29udHJvbHNDb21wb25lbnQiLCJjb250cm9sc0NvbXBvbmVudCIsImNhbnZhc0NvbnRyb2xzQ29tcG9uZW50IiwiaWRlbnRpZmllciIsImljb25QYXRoIiwibGFuZ3VhZ2VLZXkiLCJkZWZhdWx0T3B0aW9ucyIsIkRyYWdnYWJsZUNvbXBvbmVudCIsIl9vbkRyYWdTdGFydCIsImRpc2FibGVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJfaW5pdGlhbE1vdXNlUG9zaXRpb24iLCJfb25EcmFnTW92ZSIsIl9vbkRyYWdFbmQiLCJlbGVtZW50Iiwib25TdGFydCIsIm1vdXNlRGlmZiIsIm9uRHJhZyIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIm9uU3RvcCIsInJlbmRlciIsIkFycmF5IiwiRXJyb3IiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsIlNsaWRlck92ZXJsYXlDb21wb25lbnQiLCJ2YWx1ZSIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJfb25TbGlkZXJWYWx1ZUNoYW5nZSIsIm9uQ2hhbmdlIiwiX3JlbmRlclNsaWRlciIsImRlZmF1bHRzIiwibWlkZGxlRG90IiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsImxhYmVsIiwiQ2FudmFzQ29udHJvbHNDb21wb25lbnQiLCJfcGVyZm9ybUhpdFRlc3QiLCJjbGlja1Bvc2l0aW9uIiwiY29udGFpbmVyIiwiY29udGFpbmVyUmVjdCIsImNvbnRhaW5lclBvc2l0aW9uIiwicG9zaXRpb25PbkNhbnZhcyIsImNvbnRleHQiLCJjb250cm9scyIsImdldEF2YWlsYWJsZSIsImNvbnRyb2wiLCJjbGlja1Jlc3BvbnNlIiwiY2xpY2tBdFBvc2l0aW9uIiwic2VsZWN0ZWRTcHJpdGUiLCJnZXRTaGFyZWRTdGF0ZSIsIl9vbkNhbnZhc1pvb21Eb25lIiwiZm9yY2VVcGRhdGUiLCJfYmluZEV2ZW50cyIsIm1lZGlhdG9yIiwiRVZFTlRTIiwiWk9PTV9ET05FIiwiX3VuYmluZEV2ZW50cyIsIm9mZiIsIlNjcmVlbkNvbXBvbmVudCIsIl9yZW5kZXJIZWFkZXIiLCJzaG93SGVhZGVyIiwiX3JlbmRlclNjcmVlbiIsInNjcmVlbkJFTVNwZWNpZmllciIsInZpc2libGUiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJhbnkiLCJTbGlkZXJDb21wb25lbnQiLCJzbGlkZXJQb3NpdGlvbiIsImZvcmVncm91bmRMZWZ0IiwiZm9yZWdyb3VuZFdpZHRoIiwiX3NldFZhbHVlIiwiX29uTWlkZGxlRG90Q2xpY2siLCJfcHJldmlvdXNWYWx1ZSIsIm5ld1ZhbHVlIiwiX29uS25vYkRyYWdTdGFydCIsInBvc2l0aW9uIiwiX2luaXRpYWxTbGlkZXJQb3NpdGlvbiIsIl9vbktub2JEcmFnIiwiYmFyIiwiYmFyV2lkdGgiLCJuZXdTbGlkZXJQb3NpdGlvbiIsIl9vbktub2JEcmFnU3RvcCIsImFkZCIsIl9nZXRLbm9iU3R5bGUiLCJfZ2V0Rm9yZWdyb3VuZFN0eWxlIiwiX2Rpc3BsYXlNaWRkbGVEb3QiLCJlbWl0Q2hhbmdlIiwiZW1pdFJlbGVhc2UiLCJyb3VuZCIsImFicyIsIl9idWlsZFZhbHVlIiwidG9GaXhlZCIsInBvc2l0aXZlVmFsdWVQcmVmaXgiLCJ2YWx1ZVVuaXQiLCJmb3JlZ3JvdW5kUHJvcHMiLCJjb21wb25lbnRCZW0iLCJPcGVyYXRpb25zIiwiU3ByaXRlT3BlcmF0aW9uIiwiU3RpY2tlciIsIlRleHQiLCJCcnVzaCIsIlNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudCIsIl9jYW52YXNDbGlja0Rpc2FibGVkIiwiX2V2ZW50cyIsIk9QRVJBVElPTl9VUERBVEVEIiwiX29uT3BlcmF0aW9uVXBkYXRlZCIsIk9QRVJBVElPTl9SRU1PVkVEIiwiX29uT3BlcmF0aW9uUmVtb3ZlZCIsIm9wZXJhdGlvbiIsIm5ld09wZXJhdGlvbiIsIm9wZXJhdGlvbnMiLCJnZXRPckNyZWF0ZSIsInNwcml0ZXMiLCJlbmFibGVkIiwic2V0U2hhcmVkU3RhdGUiLCJvcGVyYXRpb25FeGlzdGVkQmVmb3JlIiwiaW5pdGlhbE9wdGlvbnMiLCJnZXRTcHJpdGVzIiwiX29uSXRlbUJsdXIiLCJfb25DYW52YXNDbGljayIsImhpdFRlc3QiLCJfb25TcHJpdGVGbGlwIiwic2V0RmxpcEhvcml6b250YWxseSIsImdldEZsaXBIb3Jpem9udGFsbHkiLCJzZXRGbGlwVmVydGljYWxseSIsImdldEZsaXBWZXJ0aWNhbGx5IiwiX29uU3ByaXRlVGFrZVRvRnJvbnQiLCJ0YWtlU3ByaXRlVG9Gcm9udCIsImZvcmNlU2hhcmVkVXBkYXRlIiwiX29uU3ByaXRlUmVtb3ZlIiwicmVtb3ZlU3ByaXRlIiwiZGlzcG9zZSIsIl9vblNwcml0ZURyYWdTdGFydCIsIl9vblNwcml0ZURyYWdTdG9wIiwic2V0VGltZW91dCIsIl9nZXRDb250YWluZXJTdHlsZSIsImNhbnZhc0RpbWVuc2lvbnMiLCJnZXRDYW52YXNEaW1lbnNpb25zIiwib3V0cHV0RGltZW5zaW9ucyIsImdldE91dHB1dERpbWVuc2lvbnMiLCJkaXZpZGUiLCJfZ2V0Q29udGFpbmVyUHJvcHMiLCJfZ2V0SW5uZXJDb250YWluZXJQcm9wcyIsIm9uQ2xpY2siLCJfcmVuZGVyU3ByaXRlSXRlbXMiLCJtYXAiLCJzIiwiaXNTZWxlY3RlZCIsIkNvbXBvbmVudENsYXNzIiwic2hhcmVkU3RhdGUiLCJnZXRJZCIsIl9yZW5kZXJPdmVybGF5Q29udHJvbHMiLCJUb3BCYXJDb21wb25lbnQiLCJyZW5kZXJDb250ZW50IiwiVElNRU9VVCIsIkpTT05Mb2FkZXIiLCJ1cmwiLCJfdXJsIiwiX3BhcnNlZFVybCIsInBhcnNlIiwiX2lzSlNPTlBSZXF1ZXN0IiwicXVlcnkiLCJrZXkiLCJsb2FkIiwiX2xvYWRKU09OUCIsIl9sb2FkSlNPTiIsInJlc29sdmUiLCJyZWplY3QiLCJ4aHIiLCJYRG9tYWluUmVxdWVzdCIsIm9ubG9hZCIsImpzb24iLCJKU09OIiwicmVzcG9uc2VUZXh0Iiwib25lcnJvciIsIlhNTEh0dHBSZXF1ZXN0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwib0V2ZW50IiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsIm9wZW4iLCJzZW5kIiwiZmFpbGVkIiwic3VjY2VlZGVkIiwiZm5OYW1lIiwicmFuZG9tIiwibm9kZSIsIl9jcmVhdGVKU09OUE5vZGUiLCJyZXN1bHQiLCJfcmVtb3ZlSlNPTlBOb2RlIiwiSlNPTlBVcmwiLCJfYnVpbGRKU09OUFVybCIsImhlYWROb2RlIiwicXVlcnlTZWxlY3RvciIsInNjcmlwdE5vZGUiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJwYXJhbWV0ZXIiLCJwYXJhbSIsInNlYXJjaCIsImZvcm1hdCIsIkNvbG9yUGlja2VyQ29tcG9uZW50IiwiX3ZhbHVlIiwiaW5pdGlhbFZhbHVlIiwiQ09MT1JQSUNLRVJfT1BFTiIsIl9vbkNvbG9yUGlja2VyT3BlbiIsIm92ZXJsYXlWaXNpYmxlIiwiX3RyYW5zcGFyZW50UGF0dGVybkNhbnZhcyIsImNyZWF0ZVRyYW5zcGFyZW50UGF0dGVybkNhbnZhcyIsIl9yZW5kZXJDb2xvciIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbG9yUGlja2VyIiwiX29uQ29sb3JQaWNrZXJDbG9zZSIsIl9vbkJ1dHRvbkNsaWNrIiwiX2VtaXRFdmVudCIsIl9vblZhbHVlQ2hhbmdlIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsInBhdHRlcm4iLCJjcmVhdGVQYXR0ZXJuIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0b1JHQkEiLCJPdmVybGF5IiwiYWxwaGEiLCJjbGFzc05hbWUiLCJfdCIsIkl0ZW1Db21wb25lbnQiLCJfZ2V0QWJzb2x1dGVTcHJpdGVQb3NpdGlvbiIsInNwcml0ZSIsImdldFBvc2l0aW9uIiwibXVsdGlwbHkiLCJfb25TcHJpdGVVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIm5leHRQcm9wcyIsIl9vbkl0ZW1EcmFnU3RhcnQiLCJvbkRyYWdTdGFydCIsIl9vbkl0ZW1EcmFnIiwib2Zmc2V0IiwibmV3UG9zaXRpb24iLCJzZXRQb3NpdGlvbiIsIl9vbkl0ZW1EcmFnU3RvcCIsIm9uRHJhZ1N0b3AiLCJSb3dDb21wb25lbnQiLCJfb25DbGljayIsIl9yZW5kZXJDb250ZW50Iiwicm93QkVNIiwiX21vZGlmaWVyIiwidG90YWxSb3dzIiwiZnVuYyIsIkludmlzaWJsZVVwbG9hZENvbXBvbmVudCIsIl9maWxlTG9hZGVyIiwiZmlsZUlucHV0IiwiX29uTmV3RmlsZSIsImZpbGUiLCJvbk5ld0ZpbGUiLCJUb3BCYXJCdXR0b25Db21wb25lbnQiLCJiZW0iLCJpY29uIiwiX2dldEFzc2V0UGF0aCIsIkZpbHRlck1hbmFnZXIiLCJfb3B0aW9ucyIsIl9jYXRlZ29yaWVzQnlJZCIsIl9jYXRlZ29yaWVzIiwibmFtZSIsImZpbHRlcnMiLCJGaWx0ZXJzIiwiQ2Vsc2l1c0ZpbHRlciIsIkNoZXN0RmlsdGVyIiwiRml4aWVGaWx0ZXIiLCJMZW5pbkZpbHRlciIsIlBvbGFGaWx0ZXIiLCJQb2xhNjY5RmlsdGVyIiwiSzFGaWx0ZXIiLCJLMkZpbHRlciIsIks2RmlsdGVyIiwiS0R5bmFtaWNGaWx0ZXIiLCJCV0ZpbHRlciIsIkJXSGFyZEZpbHRlciIsIlg0MDBGaWx0ZXIiLCJGcm9udEZpbHRlciIsIk1lbGxvd0ZpbHRlciIsIlNlbWlyZWRGaWx0ZXIiLCJTdW5ueUZpbHRlciIsIlRleGFzRmlsdGVyIiwiTWV0YWxGaWx0ZXIiLCJBMTVGaWx0ZXIiLCJCcmVlemVGaWx0ZXIiLCJGcmlkZ2VGaWx0ZXIiLCJPcmNoaWRGaWx0ZXIiLCJRdW96aUZpbHRlciIsIkZvb2RGaWx0ZXIiLCJHbGFtRmlsdGVyIiwiTG9tb0ZpbHRlciIsIkdvYmJsaW5GaWx0ZXIiLCJfaW5pdENhdGVnb3JpZXMiLCJjYXRlZ29yaWVzIiwicmVwbGFjZUNhdGVnb3JpZXMiLCJtZXJnZUNhdGVnb3JpZXMiLCJzZWxlY3RhYmxlRmlsdGVycyIsIm5ld0NhdGVnb3JpZXMiLCJmb3JFYWNoIiwiY2F0ZWdvcnkiLCJmaWx0ZXIiLCJmIiwibGVuZ3RoIiwiYWxsQ2F0ZWdvcnkiLCJjIiwicmVkdWNlIiwiYSIsImIiLCJjb25jYXQiLCJ1bnNoaWZ0IiwiZ2V0RmlsdGVyc0ZvckNhdGVnb3J5IiwiY2F0ZWdvcnlOYW1lIiwiZ2V0Q2F0ZWdvcmllcyIsImRlZmF1bHQiLCJDYXRlZ29yeURyb3Bkb3duQ29tcG9uZW50IiwiaXRlbXMiLCJzZWxlY3RlZEl0ZW0iLCJPdmVydmlld0NvbnRyb2xzQ29tcG9uZW50IiwiX29uSXRlbUNsaWNrIiwiX3JlbmRlckxpc3RJdGVtcyIsIm1ha2VJdGVtIiwiZ2V0IiwiY29udHJvbHNPcmRlciIsImdyb3VwT3JJZGVudGlmaWVyIiwiaXNBcnJheSIsImdyb3VwIiwiZ3JvdXBJdGVtcyIsImlzRW5hYmxlZCIsImZpbmFsSXRlbXMiLCJpdGVtT3JHcm91cCIsImxpc3RJdGVtcyIsIkZvbnRQcmV2aWV3Q29tcG9uZW50IiwiX3JlbmRlckNhbnZhcyIsInNkayIsImdldFNESyIsInBpeGVsUmF0aW8iLCJnZXRQaXhlbFJhdGlvIiwiY2xlYXJSZWN0IiwiZm9udCIsImZvbnRTdHlsZSIsImZvbnRXZWlnaHQiLCJmb250RmFtaWx5IiwidGV4dEJhc2VsaW5lIiwidGV4dEFsaWduIiwiZmlsbFRleHQiLCJTZWFyY2hTdWdnZXN0aW9uQ29tcG9uZW50Iiwic2VhcmNoU3VnZ2VzdGlvbiIsImJhY2tncm91bmRJbWFnZSIsImNvdmVySW1hZ2UiLCJDT0xVTU5fV0lEVEgiLCJQaG90b0xpc3RDb21wb25lbnQiLCJfdG90YWxQaG90b3NIZWlnaHQiLCJsb2FkaW5nIiwicGhvdG9zIiwiX2xvYWRQaG90b3MiLCJzY3JvbGxiYXIiLCJfb25QaG90b0NsaWNrZWQiLCJwaG90byIsIm9uUGhvdG9DbGlja2VkIiwiX2dldEhlYWRsaW5lIiwibGlicmFyeSIsIkJyb3dzZXIiLCJpc0lFbHRlIiwiY2VsbCIsImNlbGxIZWlnaHQiLCJfcmVuZGVyQ29sdW1ucyIsImNvbHVtbkNvdW50IiwiY29sdW1uSGVpZ2h0cyIsImNvbHVtbnMiLCJpIiwiZGltZW5zaW9ucyIsInNob3J0ZXN0Q29sdW1uSW5kZXgiLCJzaG9ydGVzdENvbHVtbkhlaWdodCIsIkluZmluaXR5Iiwib2JqIiwiX3JlbmRlclBob3RvcyIsImNvbHVtbiIsImluc3RhbmNlIiwiUGhvdG9Sb2xsUHJvdmlkZXIiLCJwaG90b1JvbGwiLCJwcm92aWRlciIsImdldFBob3Rvc0ZvckxpYnJhcnkiLCJ0aGVuIiwiX3ByZWxvYWRQaG90b3MiLCJjYXRjaCIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsIm1lc3NhZ2UiLCJ0b3RhbFBob3RvcyIsImxvYWRlZFBob3RvcyIsImFsbCIsIl9wcmVsb2FkUGhvdG8iLCJpbWFnZSIsInBob3RvRGltZW5zaW9ucyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJ1cmxzIiwidGh1bWIiLCJlbGVtZW50U2VwYXJhdG9yIiwibW9kaWZpZXJTZXBhcmF0b3IiLCJibG9ja1ByZWZpeCIsIkJFTU9iamVjdCIsInBhcmVudCIsIl9wYXJlbnQiLCJfdHlwZSIsIl9uYW1lIiwibW9kaWZpZXIiLCJyZXNwb25zZSIsInN0ciIsImJsb2NrIiwiRWRpdG9yIiwidWkiLCJzaGFsbG93IiwiX3VpIiwiX21lZGlhdG9yIiwiX3JlYWR5IiwiX3BhZGRpbmciLCJfaW5pdFNESyIsIl9vblpvb20iLCJfb25VbmRvIiwiX3NkayIsImhpc3RvcnkiLCJ6b29tIiwiX2luaXRTZXJpYWxpemVycyIsImZlYXR1cmVzIiwiX3J1bm5pbmciLCJfcmVuZGVyUmVxdWVzdGVkIiwiX3JlbmRlckNhbGxiYWNrcyIsIl9hbmltYXRpb25GcmFtZVJlcXVlc3QiLCJfdGljayIsInNldEltYWdlIiwicmVzZXRFZGl0b3IiLCJyZW5kZXJlciIsImdldFJlbmRlcmVyIiwiaW5pdGlhbERpbWVuc2lvbnMiLCJtYXhQaXhlbHMiLCJnZXRNYXhNZWdhcGl4ZWxzIiwibWF4RGltZW5zaW9ucyIsImdldE1heERpbWVuc2lvbnMiLCJyZXNldCIsImltYWdlUmVzaXplciIsImV4aWYiLCJkb25lIiwicmVzaXplUmVhc29uIiwiX3NldEltYWdlIiwiX2luaXRXYXRlcm1hcmsiLCJuZWVkc1Jlc2l6ZSIsInBhcnNlRXhpZiIsInJlc2l6ZSIsInJlYXNvbiIsIndhdGVybWFya0ltYWdlIiwiX3dhdGVybWFya09wZXJhdGlvbiIsImxvZ0xldmVsIiwiZGlzcGxheVdlbGNvbWVNZXNzYWdlIiwiZGVidWciLCJhcGlLZXkiLCJzbW9vdGhEb3duc2NhbGluZyIsInNtb290aFVwc2NhbGluZyIsInByZWZlcnJlZFJlbmRlcmVyIiwicmVuZGVyZXJPcHRpb25zIiwidHJhbnNwYXJlbnQiLCJjYWxsYmFjayIsImZpeE9mZnNldCIsImdldFJvdGF0aW9uIiwic2V0Um90YXRpb24iLCJyb3RhdGlvbiIsImdldFNwcml0ZVNjYWxlIiwic2V0U3ByaXRlU2NhbGUiLCJzcHJpdGVTY2FsZSIsImlzVG9vbEVuYWJsZWQiLCJ0b29scyIsIm1heE1lZ2FQaXhlbHMiLCJtb2JpbGUiLCJkZXNrdG9wIiwiaW5jb3Jwb3JhdGVTcHJpdGVTY2FsZSIsImdldE91dHB1dFRleHR1cmVEaW1lbnNpb25zIiwiZ2V0RmluYWxEaW1lbnNpb25zIiwic3VidHJhY3RQYWRkaW5nIiwiZ2V0Q2FudmFzIiwic2V0QWxsT3BlcmF0aW9uc1RvRGlydHkiLCJzZXQiLCJleHBvcnQiLCJkb3dubG9hZCIsInNldEVuYWJsZWQiLCJleHBvcnRlciIsIm91dHB1dCIsIkVYUE9SVCIsIl9zZXJpYWxpemVycyIsInNlcmlhbGl6ZSIsInZlcnNpb24iLCJTZXJpYWxpemVyIiwic2VyaWFsaXplciIsImRlc2VyaWFsaXplIiwiX2FwcGx5T2Zmc2V0IiwiX29mZnNldCIsInNldE9mZnNldCIsInN0YXJ0Iiwic3RvcCIsIl9jbGFtcE9mZnNldCIsImdldE9mZnNldCIsInJlbmRlcmVyRGltZW5zaW9ucyIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwibWluT2Zmc2V0IiwiY2xhbXAiLCJtYXhPZmZzZXQiLCJuZXdPZmZzZXQiLCJjYWxsYmFja3MiLCJzbGljZSIsIl9yZW5kZXIiLCJyIiwicHJpbnRFcnJvciIsIl9sYXN0T3V0cHV0Qm91bmRzIiwiZ2V0U3ByaXRlIiwiZ2V0Qm91bmRzIiwiaXNSZWFkeSIsImdldElucHV0RGltZW5zaW9ucyIsImdldFBhZGRpbmciLCJzZXRQYWRkaW5nIiwicGFkZGluZyIsImdldEltYWdlIiwiZ2V0T3B0aW9ucyIsImdldFVJIiwiYnJvYWRjYXN0Q3JvcCIsImNyb3BPcGVyYXRpb24iLCJjcm9wcGFibGVPcGVyYXRpb25zIiwiY3JvcCIsImJyb2FkY2FzdEZsaXAiLCJmbGlwcGFibGVPcGVyYXRpb25zIiwiZmxpcCIsImJyb2FkY2FzdFJvdGF0ZSIsImRlZ3JlZXMiLCJyb3RhdGUiLCJGb250IiwiQ29uZmlndXJhYmxlIiwicHJvdG90eXBlIiwiYXZhaWxhYmxlT3B0aW9ucyIsIlNUUklORyIsInJlcXVpcmVkIiwiQUxMIiwiYXZhaWxhYmxlIiwiQk9PTEVBTiIsIlN0aWNrZXJNYW5hZ2VyIiwiREVGQVVMVFMiLCJTVElDS0VSX0NBVEVHT1JJRVMiLCJfYWRkQ2F0ZWdvcmllcyIsIl91cGRhdGVBbGxDYXRlZ29yeSIsImxvYWRFeHRlcm5hbCIsImxvYWRlciIsIl9hbGxDYXRlZ29yeSIsImFsbENhdGVnb3J5TGFiZWwiLCJzdGlja2VycyIsImdldFN0aWNrZXJzRm9yQ2F0ZWdvcnkiLCJnZXRDYXRlZ29yeSIsImlkIiwiZmxhdHRlbiIsImFyciIsIkJFTV9UWVBFUyIsIm0iLCJfcGFyc2VCZW1TcGVjaWZpZXIiLCJzcGVjaWZpZXIiLCJwYXJ0cyIsInNwbGl0IiwicGFydCIsIm1hdGNoIiwicGFzcyIsIl9nZXRCZW1JbmZvRm9yTm9kZSIsImlzQmVtTm9kZSIsIl9pc05vZGVCRU1hYmxlIiwiaXNWYWxpZEVsZW1lbnQiLCJfYXBwbHlCRU1DbGFzc2VzIiwiY2xhc3NOYW1lcyIsImJlbUluZm8iLCJvd25CZW1PYmplY3QiLCJfX2JlbU9iamVjdCIsImNoaWxkcmVuQmVtT2JqZWN0IiwiX3RyYW5zZm9ybVRvUmVhY3QiLCJ0cmFuc2Zvcm0iLCJEZXNlcmlhbGl6ZXIiLCJfZWRpdG9yIiwiX2RhdGEiLCJfZmlsdGVyTWFuYWdlciIsIl9zdGlja2VyTWFuYWdlciIsIl92YWxpZGF0ZVZlcnNpb24iLCJfZGVzZXJpYWxpemVJbnB1dEltYWdlIiwiX2Rlc2VyaWFsaXplT3BlcmF0aW9ucyIsImlucHV0SW1hZ2UiLCJwcm9taXNlcyIsIl9kZXNlcmlhbGl6ZUNyb3BPcGVyYXRpb24iLCJfZGVzZXJpYWxpemVPcmllbnRhdGlvbk9wZXJhdGlvbiIsIl9kZXNlcmlhbGl6ZUZpbHRlck9wZXJhdGlvbiIsIl9kZXNlcmlhbGl6ZUFkanVzdG1lbnRzT3BlcmF0aW9uIiwiX2Rlc2VyaWFsaXplU3ByaXRlT3BlcmF0aW9uIiwiX2Rlc2VyaWFsaXplRm9jdXNPcGVyYXRpb24iLCJzY2FsZSIsImZyb21PYmplY3QiLCJlbmQiLCJQSSIsIkZpbHRlckNsYXNzIiwiRmlsdGVyIiwiaW50ZW5zaXR5IiwiQWRqdXN0bWVudHNPcGVyYXRpb24iLCJvcGVyYXRpb25PcHRpb25zIiwiZGVmYXVsdFZhbHVlIiwic3ByaXRlT3BlcmF0aW9uIiwiX2Rlc2VyaWFsaXplU3RpY2tlciIsIl9kZXNlcmlhbGl6ZVRleHQiLCJfZGVzZXJpYWxpemVCcnVzaCIsInNldFNwcml0ZXMiLCJzdGlja2VyIiwiYWRqdXN0bWVudHMiLCJzdHJ1Y3R1cmUiLCJmbGlwSG9yaXpvbnRhbGx5IiwiZmxpcFZlcnRpY2FsbHkiLCJjcmVhdGVTdGlja2VyIiwiYnJpZ2h0bmVzcyIsInNhdHVyYXRpb24iLCJjb250cmFzdCIsImdldEFzc2V0UGF0aCIsImltYWdlcyIsIm1lZGlhQmFzZSIsInVyaSIsImZvbnRTaXplIiwibGluZUhlaWdodCIsImFsaWdubWVudCIsIm1heFdpZHRoIiwiY29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjcmVhdGVUZXh0IiwiZnJvbUFycmF5IiwiYnJ1c2giLCJwYXRocyIsImJydXNoT2JqZWN0IiwiY3JlYXRlQnJ1c2giLCJwYXRoIiwic2l6ZSIsInBvaW50cyIsImNvbG9yT2JqZWN0IiwicGF0aE9iamVjdCIsImNyZWF0ZVBhdGgiLCJwb2ludCIsImFkZENvbnRyb2xQb2ludCIsInJhZGl1cyIsImdyYWRpZW50UmFkaXVzIiwiYmx1clJhZGl1cyIsImdyYWRpZW50U2l6ZSIsIl9nZXRJbnB1dERpbWVuc2lvbnNGb3JPcGVyYXRpb24iLCJvcGVyYXRpb25Gb3VuZCIsImlucHV0RGltZW5zaW9ucyIsImdldFN0YWNrIiwib3AiLCJnZXROZXdEaW1lbnNpb25zIiwiVFdJQ0VfUEkiLCJfc2VyaWFsaXplT3BlcmF0aW9ucyIsIl9zZXJpYWxpemVJbnB1dEltYWdlIiwiREFUQV9VUkwiLCJQTkciLCJkYXRhVXJsIiwicmVwbGFjZSIsInN0YWNrIiwiX3NlcmlhbGl6ZU9wZXJhdGlvbiIsIl9zZXJpYWxpemVDcm9wT3BlcmF0aW9uIiwiX3NlcmlhbGl6ZU9yaWVudGF0aW9uT3BlcmF0aW9uIiwiX3NlcmlhbGl6ZUZpbHRlck9wZXJhdGlvbiIsIl9zZXJpYWxpemVBZGp1c3RtZW50c09wZXJhdGlvbiIsIl9zZXJpYWxpemVTcHJpdGVPcGVyYXRpb24iLCJfc2VyaWFsaXplUmFkaWFsRm9jdXNPcGVyYXRpb24iLCJfc2VyaWFsaXplTGluZWFyRm9jdXNPcGVyYXRpb24iLCJzZXJpYWxpemVPcHRpb25zIiwiZ2V0SW50ZW5zaXR5IiwiZ2V0RmlsdGVyIiwib3B0aW9uTmFtZSIsIm9wdGlvbiIsImdldE9wdGlvbiIsIl9zZXJpYWxpemVTdGlja2VyIiwiX3NlcmlhbGl6ZVRleHQiLCJfc2VyaWFsaXplQnJ1c2giLCJnZXRBZGp1c3RtZW50cyIsImFkanVzdG1lbnRzT3B0aW9ucyIsImdldEJyaWdodG5lc3MiLCJnZXRTYXR1cmF0aW9uIiwiZ2V0Q29udHJhc3QiLCJnZXRQYXRocyIsIl9zZXJpYWxpemVQYXRoIiwidGhpY2tuZXNzIiwiZ2V0Q29udHJvbFBvaW50cyIsInRvT2JqZWN0IiwibWF4TG9nTGV2ZWwiLCJMRVZFTFMiLCJiYWNrZ3JvdW5kIiwiTEVWRUxfVFlQRVMiLCJsIiwic2V0TGV2ZWwiLCJfbGV2ZWwiLCJjYW5Mb2ciLCJjdXJyZW50TGV2ZWxJbmRleCIsIm1heExldmVsSW5kZXgiLCJoYXNDb2xvcmZ1bE91dHB1dCIsInByb2Nlc3MiLCJicm93c2VyIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibGluZXMiLCJsaW5lIiwibGV2ZWwiLCJ0YWciLCJ0b1N0cmluZyIsImpvaW4iLCJBcHBDb21wb25lbnQiLCJfc2NyZWVucyIsInNwbGFzaCIsIndlYmNhbSIsImVtcHR5IiwiaW5pdGlhbFNjcmVlbiIsInByZWxvYWRlciIsIl9zY3JlZW5BZnRlckxvYWRpbmciLCJfcHJldmlvdXNTY3JlZW5zU3RhY2siLCJhY3RpdmVTY3JlZW4iLCJhY3RpdmVTY3JlZW5OYW1lIiwic2NyZWVucyIsImhhc1ByZXZpb3VzU2NyZWVuIiwiZ2V0UHJldmlvdXNTY3JlZW4iLCJzd2l0Y2hUb1NjcmVlbiIsIlNjcmVlbiIsInBvcCIsImZpcnN0RWRpdG9yTGF1bmNoIiwiZWRpdG9yU2NyZWVuIiwiZ2V0RWRpdG9yIiwiZ2V0Q2hpbGRDb250ZXh0IiwiX3JlbmRlclNjcmVlbnMiLCJyZW5kZXJlZFNjcmVlbnMiLCJDb21wb25lbnQiLCJjaGlsZENvbnRleHRUeXBlcyIsIm9iamVjdCIsImlzUmVxdWlyZWQiLCJGb250TG9hZGVyIiwiZm9udHMiLCJfZm9udHMiLCJfbG9hZGVkRm9udHMiLCJzZXRGb250cyIsIm5lZWRzVG9Mb2FkIiwiZ2V0UHJvdmlkZXIiLCJfZ2V0Rm9udElkZW50aWZpZXIiLCJnZXROYW1lIiwiZ2V0Rm9udFdlaWdodCIsImdldEZvbnRGYW1pbHkiLCJnZXRGb250U3R5bGUiLCJmb250TG9hZGVkIiwic2V0Rm9udExvYWRlZCIsImxvYWRlcnMiLCJnb29nbGUiLCJCYWNrQnV0dG9uQ29tcG9uZW50IiwiX29uU2hhcmVkU3RhdGVVcGRhdGUiLCJyZXNwb25zaXZlIiwiZm5OYW1lcyIsImludGVycG9sYXRpb25PcHRpb25zIiwidHJhbnNsYXRlIiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsInNoYXJlZFN0YXRlRGlkQ2hhbmdlIiwic2hvdWxkU2hhcmVkQ29tcG9uZW50VXBkYXRlIiwicHJvcCIsImJyb2FkY2FzdFVwZGF0ZSIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJCdXR0b25Db21wb25lbnQiLCJiZW1TcGVjaWZpZXIiLCJ1cHBlcmNhc2UiLCJzdHJpbmciLCJDYXRlZ29yeURyb3Bkb3duT3ZlcmxheUNvbXBvbmVudCIsIml0ZW0iLCJhY3RpdmUiLCJBbHBoYUNvbXBvbmVudCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsIm5ld1Byb3BzIiwidGFyZ2V0Iiwia25vYiIsIl9pbml0aWFsQWxwaGEiLCJfc2V0QWxwaGFGcm9tUG9zaXRpb24iLCJjYW52YXNXaWR0aCIsImFscGhhQ2hhbmdlIiwiX3NldEFscGhhIiwiZ3JhZGllbnQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsInRvSGV4IiwiSHVlQ29tcG9uZW50IiwiaHN2QXJyIiwidG9IU1YiLCJoIiwidiIsIl9oc3ZDb2xvciIsIl9pbml0aWFsSHVlIiwiX3NldFZhbHVlRnJvbVBvc2l0aW9uIiwiY2FudmFzSGVpZ2h0IiwiaHVlQ2hhbmdlIiwiX3NldEh1ZSIsImZyb21IU1YiLCJyYXRpbyIsInN0cm9rZVN0eWxlIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiQ29sb3JQaWNrZXJPdmVybGF5Q29tcG9uZW50IiwiX2hzdiIsIl9vbkRvY3VtZW50Q2xpY2siLCJvbkNsb3NlIiwiX29uRWxlbWVudENsaWNrIiwiX29uQ29sb3JDaGFuZ2UiLCJhbHBoYUNvbXBvbmVudCIsIlNhdHVyYXRpb25Db21wb25lbnQiLCJfaW5pdGlhbFZhbHVlIiwiX2luaXRpYWxTYXR1cmF0aW9uIiwiX3NldFZhbHVlc0Zyb21Qb3NpdGlvbiIsInNhdHVyYXRpb25DaGFuZ2UiLCJ2YWx1ZUNoYW5nZSIsIl9zZXRIU1YiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJnIiwicHV0SW1hZ2VEYXRhIiwiSVRFTVMiLCJtaWRWYWx1ZSIsIkFkanVzdG1lbnRzQ29udHJvbHNDb21wb25lbnQiLCJfb3BlcmF0aW9uIiwic2VsZWN0ZWRDb250cm9scyIsIm9wdGlvbnNFcXVhbCIsImdldERlZmF1bHRPcHRpb25zIiwicmVtb3ZlIiwic2V0T3B0aW9uIiwiY29udHJvbHNJdGVtIiwiX2J1aWxkU2xpZGVyUHJvcHMiLCJzbGlkZXJWYWx1ZSIsInNsaWRlclByb3BzIiwibWluaVNsaWRlciIsIlRPT0xTIiwiQWRqdXN0bWVudHNDb250cm9scyIsIm9uRW50ZXIiLCJleGlzdHMiLCJ0b29sIiwiQnJ1c2hDYW52YXNDb250cm9sc0NvbXBvbmVudCIsIl93aW5kb3dSZXNpemVkIiwiX2RyYXdpbmciLCJfbGFzdERyYXdQb3NpdGlvbiIsImV4dGVuZCIsIldJTkRPV19SRVNJWkUiLCJfb25XaW5kb3dSZXNpemUiLCJjdXJzb3JWaXNpYmxlIiwiY3Vyc29yUG9zaXRpb24iLCJfdXBkYXRlQ29udGFpbmVyUmVjdCIsIl9vbk1vdXNlRG93biIsIl9vcHRpb25zQmVmb3JlRHJhdyIsIl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlRHJhdyIsIl9nZXRDdXJzb3JQb3NpdGlvbiIsImhhcmRuZXNzIiwiX2N1cnJlbnRQYXRoIiwiX29uTW91c2VNb3ZlIiwiX29uTW91c2VVcCIsInNldENsb3NlZCIsIm91dHB1dFRleHR1cmVEaW1lbnNpb25zIiwiX29uTW91c2VFbnRlciIsIl9vbk1vdXNlTGVhdmUiLCJzaG91bGREcmF3IiwiYnJ1c2hTaXplIiwiZGlzdGFuY2UiLCJsZW4iLCJfb25Nb3VzZU1vdmVPbkNhbnZhcyIsIl9nZXRDdXJzb3JTdHlsZSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5Ub3AiLCJfY29udGFpbmVyQm91bmRpbmdSZWN0IiwiaW5uZXJDb250YWluZXIiLCJldmVudCIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsIm9uTW91c2VNb3ZlIiwiY3Vyc29yQ2xhc3MiLCJCcnVzaENvbnRyb2xzQ29tcG9uZW50IiwiX2JydXNoT3B0aW9ucyIsIl9oYXNQcmVzZXRzIiwidGhpY2tuZXNzUHJlc2V0cyIsIl9oYXNTbGlkZXIiLCJ0aGlja25lc3NDb250cm9sc0VuYWJsZWQiLCJkaXNhYmxlIiwiX29uVGhpY2tuZXNzQ2xpY2siLCJfb25UaGlja25lc3NVcGRhdGVkIiwiYWRkU3ByaXRlIiwicHJldmlvdXNCcnVzaCIsIl9vbkNvbG9yVXBkYXRlZCIsIl9yZW5kZXJUaGlja25lc3NJdGVtcyIsIm1heFRoaWNrbmVzcyIsImFwcGx5IiwiaXNBY3RpdmUiLCJmaW5hbERpbWVuc2lvbnMiLCJtaW5UaGlja25lc3MiLCJjdXJyZW50V2lkdGgiLCJCcnVzaENvbnRyb2xzIiwib25FeGl0IiwidW5kbyIsImVuYWJsZSIsIlByZXNldFByZXZpZXdJdGVtQ29tcG9uZW50IiwiZGlhbWV0ZXIiLCJhcmMiLCJmaWxsIiwiTUlOX0RJTUVOU0lPTlMiLCJDcm9wQ2FudmFzQ29udHJvbHNDb21wb25lbnQiLCJfdXBkYXRlRGltZW5zaW9ucyIsImNyb3BTaXplIiwiZmxvb3IiLCJfb25DZW50ZXJEcmFnU3RhcnQiLCJfaW5pdGlhbFZhbHVlcyIsIl9vbkNlbnRlckRyYWciLCJjcm9wRGlmZmVyZW5jZSIsIm1pblN0YXJ0IiwibWF4U3RhcnQiLCJuZXdTdGFydCIsIm5ld0VuZCIsIl9jdXJyZW50RHJhZ09wdGlvbiIsIm5ld1NpemUiLCJtYXhTaXplIiwiX2NhbGN1bGF0ZURpbWVuc2lvbnMiLCJfZ2V0QXJlYVN0eWxlcyIsImNlaWwiLCJ0b3BMZWZ0IiwiX2dldERpbWVuc2lvbnNTdHlsZXMiLCJ0b3BDZW50ZXIiLCJjZW50ZXJMZWZ0IiwiY2VudGVyIiwiY2FudmFzQ29udGVudCIsImFyZWFTdHlsZXMiLCJDcm9wQ29udHJvbHNDb21wb25lbnQiLCJfcmF0aW9zIiwiZ2V0UmF0aW9zIiwiQ1JPUF9SRUFQUExZX1JBVElPIiwiX3JlYXBwbHlSYXRpbyIsIl9zZWxlY3RJbml0aWFsUmF0aW8iLCJyYXRpb3MiLCJyZXBsYWNlUmF0aW9zIiwic2VsZWN0YWJsZVJhdGlvcyIsImF2YWlsYWJsZVJhdGlvcyIsIkNST1BfUkFUSU9TIiwic2VsZWN0IiwiX29uUm90YXRpb25DaGFuZ2UiLCJfdXBkYXRlU3ByaXRlU2NhbGUiLCJyb3RhdGVkU3ByaXRlRGltZW5zaW9ucyIsIl9nZXRSb3RhdGVkU3ByaXRlRGltZW5zaW9ucyIsImRpc3RhbmNlVG9Db3JuZXIiLCJjb3MiLCJzaW4iLCJfY2FsY3VsYXRlVGV4dHVyZVNjYWxlIiwiY3JvcERpbWVuc2lvbnMiLCJfZ2V0SGlzdG9yeUl0ZW1zIiwiaGlzdG9yeUl0ZW1zIiwiY3JvcEhpc3RvcnlJdGVtIiwiX2dldENyb3BIaXN0b3J5SXRlbSIsIm9yaWVudGF0aW9uSGlzdG9yeUl0ZW0iLCJfZ2V0T3JpZW50YXRpb25IaXN0b3J5SXRlbSIsImluaXRpYWxDcm9wT3B0aW9ucyIsImNyb3BPcGVyYXRpb25FeGlzdGVkQmVmb3JlIiwiZXhpc3RlbnQiLCJuZXdPcHRpb25zIiwib3JpZW50YXRpb25PcGVyYXRpb24iLCJpbml0aWFsT3JpZW50YXRpb25PcHRpb25zIiwib3JpZW50YXRpb25PcGVyYXRpb25FeGlzdGVkQmVmb3JlIiwiaW52ZXJzZUZsaXAiLCJfc2VsZWN0UmF0aW8iLCJlcXVhbHMiLCJ0ZXh0dXJlU2NhbGUiLCJzZXREZWZhdWx0T3B0aW9ucyIsInNlbGVjdGVkUmF0aW8iLCJvcGVyYXRpb25SYXRpbyIsIl9yYXRpbyIsIm1hdGNoaW5nUmF0aW9zIiwic2VsZWN0ZWRSYXRpb3MiLCJzZWxlY3RlZCIsIl9zZXREZWZhdWx0T3B0aW9uc0ZvclJhdGlvIiwibmV3U2hhcmVkU3RhdGUiLCJjYW52YXNSYXRpbyIsImdyb3VwT3JSYXRpbyIsIm5vQ3JvcEl0ZW0iLCJDcm9wVG9wQmFyQ29tcG9uZW50IiwiX29uUm90YXRlQ2xpY2siLCJuZXdSb3RhdGlvbiIsIm9yaWVudGF0aW9uUm90YXRpb24iLCJ0ZW1wU3RhcnQiLCJfb25GbGlwQ2xpY2siLCJuZXdGbGlwIiwidG1wU3RhcnQiLCJDcm9wQ29udHJvbHMiLCJhY3RpdmVQYWRkaW5nIiwiY3JvcE9wdGlvbnMiLCJjb250cm9sc09wdGlvbnMiLCJhc3NldHMiLCJGaWx0ZXJDb250cm9sc0NvbXBvbmVudCIsIl9pbml0RmlsdGVyTWFuYWdlciIsInNldEludGVuc2l0eSIsIl9vbkNhdGVnb3J5Q2hhbmdlIiwiY3VycmVudEZpbHRlciIsImlzSWRlbnRpdHkiLCJJZGVudGl0eUZpbHRlciIsImRpc3BsYXlOYW1lIiwiX3JlbmRlckNhdGVnb3J5RHJvcGRvd24iLCJjYXRlZ29yeURyb3Bkb3duVmlzaWJsZSIsImhpZGVDYXRlZ29yaWVzIiwiY2F0ZWdvcnlJdGVtcyIsInNlbGVjdGVkQ2F0ZWdvcnkiLCJjYXRlZ29yeURyb3Bkb3duIiwiRmlsdGVyc0NvbnRyb2xzIiwiRmlsdGVyQ29uc3RydWN0b3IiLCJJbml0aWFsRmlsdGVyQ29uc3RydWN0b3IiLCJmaWx0ZXJPcHRpb25zIiwiZmlsdGVyTWFuYWdlciIsIkZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQiLCJfZ2V0Q29udHJvbHNGb3JPcGVyYXRpb24iLCJDb250cm9scyIsInRvb2xOYW1lIiwiaWNvbk5hbWUiLCJGb2N1c0NvbnRyb2xzQ29tcG9uZW50IiwiX3JlbW92ZWRPcGVyYXRpb24iLCJfb25CbHVyUmFkaXVzQ2hhbmdlIiwic2V0Qmx1clJhZGl1cyIsInByZXZpb3VzT3BlcmF0aW9uIiwiY3VycmVudE9wZXJhdGlvbiIsImZvY3VzT3BlcmF0aW9uIiwic2hvcnRlc3RTaWRlIiwiZ2V0Qmx1clJhZGl1cyIsIm5vRm9jdXNJdGVtIiwiRm9jdXNDb250cm9scyIsImluaXRpYWxPcGVyYXRpb24iLCJMaW5lYXJGb2N1c0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IiwiYXJlYVBvc2l0aW9uIiwiYXJlYURpbWVuc2lvbnMiLCJrbm9iUG9zaXRpb24iLCJfc2V0U3R5bGVzRnJvbU9wdGlvbnMiLCJfaW5pdGlhbFN0YXJ0IiwiZ2V0U3RhcnQiLCJfaW5pdGlhbEVuZCIsImdldEVuZCIsIl9pbml0aWFsRGlzdCIsInJlbGF0aXZlT2Zmc2V0IiwiX2luaXRpYWxLbm9iUG9zaXRpb24iLCJuZXdLbm9iUG9zaXRpb24iLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJfZ2V0QXJlYVN0eWxlIiwiZGlzdCIsImF0YW4yIiwiTW96VHJhbnNmb3JtIiwibXNUcmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJnZXRTaXplIiwibWlkZGxlIiwiYXJlYVNpemUiLCJ0b3RhbERpc3QiLCJmYWN0b3IiLCJSYWRpYWxGb2N1c0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IiwiX2tub2JDaGFuZ2VkTWFudWFsbHkiLCJnZXRSYWRpdXMiLCJGcmFtZU92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnQiLCJfaW5pdEZyYW1lTWFuYWdlciIsIl9mcmFtZU1hbmFnZXIiLCJmcmFtZSIsIl9vblNjYWxlQ2hhbmdlIiwic2V0U2NhbGUiLCJzZXRUaW50Q29sb3IiLCJfb25GcmFtZUNsaWNrIiwic2V0RnJhbWUiLCJsb2FkaW5nTW9kYWwiLCJsb2FkVGltZW91dCIsImNsZWFyVGltZW91dCIsImZyYW1lT2JqZWN0IiwiZ2V0RnJhbWUiLCJjdXJyZW50U2NhbGUiLCJnZXRTY2FsZSIsImZyYW1lcyIsImdldEZyYW1lcyIsImN1cnJlbnRGcmFtZSIsIm5vRnJhbWVJdGVtIiwidGludGFibGUiLCJnZXRUaW50Q29sb3IiLCJGcmFtZUl0ZW1Db21wb25lbnQiLCJfcmVuZGVyRnJhbWUiLCJyZXNvbHZlZEZyYW1lUGF0aCIsImdldEljb24iLCJkcmF3U2l6ZSIsImRyYXdQb3NpdGlvbiIsImRyYXdJbWFnZSIsImdldExhYmVsIiwiRnJhbWVDb250cm9scyIsIk1pbmlTbGlkZXJDb21wb25lbnQiLCJPdmVydmlld0NvbnRyb2xzIiwiT3ZlcnZpZXdDYW52YXNDb250cm9sc0NvbXBvbmVudCIsIkV4cG9ydEJ1dHRvbkNvbXBvbmVudCIsImV4cG9ydE9wdGlvbnMiLCJzd2l0Y2hUb0NvbnRyb2xzIiwic2hvd0J1dHRvbiIsIk5ld0ZpbGVCdXR0b25Db21wb25lbnQiLCJ3ZWJjYW1FbmFibGVkIiwiZW5hYmxlV2ViY2FtIiwicGhvdG9Sb2xsRW5hYmxlZCIsInVwbG9hZCIsImFwcCIsImJ1dHRvbkxhYmVsIiwiT3ZlcnZpZXdUb3BCYXJDb21wb25lbnQiLCJuZXdGaWxlQnV0dG9uIiwiZW5hYmxlVXBsb2FkIiwiem9vbUNvbXBvbmVudCIsImVuYWJsZVpvb20iLCJVbmRvQnV0dG9uQ29tcG9uZW50IiwiSElTVE9SWV9VUERBVEVEIiwiX29uSGlzdG9yeVVwZGF0ZWQiLCJGRUFUVVJFU19VUERBVEVEIiwiX29uRmVhdHVyZXNVcGRhdGVkIiwiWm9vbUNvbXBvbmVudCIsIl9vblpvb21Eb25lIiwiX29uWm9vbU91dENsaWNrIiwiem9vbU91dCIsIl9vblpvb21JbkNsaWNrIiwiem9vbUluIiwiU2VsZWN0aXZlQmx1ckNvbnRyb2xzIiwiZ2V0QnJ1c2giLCJfYnJ1c2hUaGlja25lc3MiLCJwcmV2aW91c1ZhbHVlIiwicmVsZWFzZWQiLCJCcnVzaEl0ZW1Db21wb25lbnQiLCJfYXBwZW5kQ2FudmFzIiwibmV3Q2FudmFzIiwiX2lzU2VsZWN0ZWQiLCJicnVzaENsYXNzTmFtZSIsIlN0aWNrZXJJdGVtQ29tcG9uZW50IiwiX2lkIiwiZ2V0VVVJRCIsInNpZGUiLCJfZ2V0Qm90dG9tRHJhZ0tub2JQb3NpdGlvbiIsIl9nZXRUb3BEcmFnS25vYlBvc2l0aW9uIiwiX2luaXRpYWxEaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsInN0aWNrZXJQb3NpdGlvbiIsImtub2JEaXN0YW5jZUZyb21DZW50ZXIiLCJpbml0aWFsS25vYkRpc3RhbmNlRnJvbUNlbnRlciIsImZpeGVkUmF0aW8iLCJoYWxmRGltZW5zaW9ucyIsIl9nZXRTdGlja2VyRGltZW5zaW9ucyIsImluaXRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCJyYWRpYW5zIiwibmV3RGltZW5zaW9ucyIsImxvY2FsRGlzdGFuY2VUb0NlbnRlciIsInByZXZpb3VzTG9jYWxEaXN0YW5jZVRvQ2VudGVyIiwiZGlzdGFuY2VUb0NlbnRlckRpZmYiLCJfb25Sb3RhdGVLbm9iRHJhZ1N0YXJ0IiwiX2dldFJvdGF0ZUtub2JQb3NpdGlvbiIsIl9vblJvdGF0ZUtub2JEcmFnU3RvcCIsIl9vblJvdGF0ZUtub2JEcmFnIiwiX2dldEJvdHRvbURyYWdLbm9iU3R5bGUiLCJfZ2V0VG9wRHJhZ0tub2JTdHlsZSIsIl9nZXRSb3RhdGVLbm9iU3R5bGUiLCJfZ2V0U3RpY2tlclN0eWxlIiwicHJvY2Vzc2VkRGltZW5zaW9ucyIsInNwcml0ZVBvc2l0aW9uIiwic3ByaXRlRGltZW5zaW9ucyIsIk9UcmFuc2Zvcm0iLCJzdGlja2VyUm90YXRpb24iLCJfcmVuZGVyS25vYnMiLCJrbm9icyIsIl9yZW5kZXJTVkdGaWx0ZXIiLCJmaWx0ZXJzU1ZHIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJfcmVuZGVySXRlbSIsInN0aWNrZXJTdHlsZSIsImJhc2VVUkwiLCJsb2NhdGlvbiIsImhyZWYiLCJoYXNoIiwic3RpY2tlckltYWdlU3R5bGUiLCJ4bGlua0hyZWYiLCJUZXh0SXRlbUNvbXBvbmVudCIsImVkaXRNb2RlIiwiX29uVGV4dENoYW5nZSIsInNldFRleHQiLCJfb25JdGVtRG91YmxlQ2xpY2siLCJlbnRlckVkaXRNb2RlIiwiX2VkaXRlZCIsInRleHRhcmVhIiwiZm9jdXMiLCJfb25JdGVtVG91Y2hTdGFydCIsIl9pbml0aWFsVG91Y2hQb3NpdGlvbiIsIl90YXBTdGFydEF0IiwiX29uSXRlbVRvdWNoRW5kIiwiX2xhc3RUYXBBdCIsIl9vblJvdGF0aW9uS25vYkRyYWdTdGFydCIsIl9kcmFnZ2luZyIsIl9nZXRSb3RhdGlvbktub2JQb3NpdGlvbiIsIl9vblJvdGF0aW9uS25vYkRyYWciLCJib3VuZGluZ0JveCIsImdldEJvdW5kaW5nQm94IiwiX29uUm90YXRpb25Lbm9iRHJhZ1N0b3AiLCJfb25SZXNpemVLbm9iRHJhZ1N0YXJ0IiwiX2dldFJlc2l6ZUtub2JQb3NpdGlvbiIsIl9vblJlc2l6ZUtub2JEcmFnIiwidGV4dFJvdGF0aW9uIiwiZGlzdGFuY2VUb1Bvc2l0aW9uIiwibmV3TWF4V2lkdGgiLCJzZXRNYXhXaWR0aCIsIl9vblJlc2l6ZUtub2JEcmFnU3RvcCIsIl9nZXRSb3RhdGlvbktub2JTdHlsZSIsIl9nZXRSZXNpemVLbm9iU3R5bGUiLCJfZ2V0VGV4dFN0eWxlIiwiZ2V0RE9NU3R5bGUiLCJfZ2V0SXRlbUNvbnRhaW5lclN0eWxlIiwidGV4dFBvc2l0aW9uIiwidHJhbnNmb3JtT3JpZ2luIiwiZ2V0TWF4V2lkdGgiLCJNb3pUcmFuc2Zvcm1PcmlnaW4iLCJtc1RyYW5zZm9ybU9yaWdpbiIsIldlYmtpdFRyYW5zZm9ybU9yaWdpbiIsImNvbnRlbnQiLCJnZXRUZXh0IiwiU3RpY2tlckNvbnRyb2xzIiwiZ2V0U3ByaXRlc09mVHlwZSIsImdldFNwcml0ZXNBdFBvc2l0aW9uIiwic2VsZWN0YWJsZVN0aWNrZXJzIiwidG9vbHRpcHMiLCJTdGlja2VyQ2FudmFzQ29udHJvbHNDb21wb25lbnQiLCJTdGlja2VyT3ZlcnZpZXdDb250cm9sc0NvbXBvbmVudCIsIkhJU1RPUllfQkVGT1JFX1VORE8iLCJfb25CZWZvcmVIaXN0b3J5VW5kbyIsIl9zcHJpdGVzIiwiX3N0aWNrZXJzIiwiX2luaXRTdGlja2VyTWFuYWdlciIsImhpc3RvcnlPYmplY3QiLCJza2lwSGlzdG9yeSIsInN0aWNrZXJzSlNPTlBhdGgiLCJfbG9hZEV4dGVybmFsU3RpY2tlcnMiLCJkb25lTG9hZGluZyIsImVycm9yTW9kYWwiLCJvbkJhY2siLCJfcmVuZGVyVG9vbHRpcENhbnZhcyIsImhvdmVyZWRTdGlja2VyIiwidG9vbHRpcFZpc2libGUiLCJ0b29sdGlwQ2FudmFzIiwicmVzb2x2ZWRTdGlja2VyUGF0aCIsIm1lZGlhTWVkaXVtIiwiX29uU3RpY2tlckNsaWNrIiwiX2NhbGN1bGF0ZUluaXRpYWxTdGlja2VyU2NhbGUiLCJpbWFnZURpbWVuc2lvbnMiLCJvdmVybGFwIiwiX29uU3RpY2tlck1vdXNlRW50ZXIiLCJzdGlja2VyUGF0aCIsImhvdmVyZWRTdGlja2VyRWxlbWVudCIsImN1cnJlbnRUYXJnZXQiLCJfdXBkYXRlVG9vbHRpcFBvc2l0aW9uIiwiZWwiLCJwYXJlbnRCb3VuZGluZ1JlY3QiLCJ0b29sdGlwUG9zaXRpb24iLCJfb25TdGlja2VyTW91c2VMZWF2ZSIsIml0ZW1FdmVudHMiLCJfcmVuZGVyVG9vbHRpcCIsInRvb2x0aXAiLCJTdGlja2VyQ29udHJvbHNPdmVybGF5Q29tcG9uZW50Iiwib25GbGlwIiwiX29uVGFrZVRvRnJvbnRDbGljayIsIm9uVGFrZVRvRnJvbnQiLCJfb25SZW1vdmVDbGljayIsIm9uUmVtb3ZlIiwiX3JlbmRlckl0ZW1zIiwiX3JlbmRlclN0aWNrZXIiLCJtZWRpYVRodW1iIiwiRm9udENvbXBvbmVudCIsIl9vbkxpc3RJdGVtQ2xpY2siLCJUZXh0Q29udHJvbHMiLCJmb250TWFuYWdlciIsImRlZmF1bHRGb250IiwiZ2V0RGVmYXVsdEZvbnQiLCJnZXRGb250cyIsImFkZGl0aW9uYWxGb250cyIsInJlcGxhY2VGb250cyIsInNlbGVjdGFibGVGb250cyIsImRlZmF1bHRUZXh0IiwiVGV4dENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IiwiVEVYVCIsIl9vblRleHRFZGl0IiwiQUxJR05NRU5UUyIsIlRleHRDb250cm9sc0NvbXBvbmVudCIsIl9mb250TG9hZGVyIiwiZ2V0Rm9udExvYWRlciIsIm1vZGUiLCJmb250c0xvYWRlZCIsIl9jcmVhdGVUZXh0IiwiX2xvYWRGb250cyIsIm1heFRleHR1cmVTaXplIiwiZ2V0TWF4VGV4dHVyZVNpemUiLCJtYXhIZWlnaHQiLCJfb25Gb250U2l6ZUNoYW5nZSIsInNlbGVjdGVkVGV4dCIsInNldEZvbnRTaXplIiwiX29uRm9udENoYW5nZSIsInNldEZvbnRGYW1pbHkiLCJzZXRGb250V2VpZ2h0Iiwic2V0Rm9udFN0eWxlIiwiX29uQWxpZ25tZW50Q2xpY2siLCJnZXRBbGlnbm1lbnQiLCJjdXJyZW50SW5kZXgiLCJuZXh0SW5kZXgiLCJuZXdBbGlnbm1lbnQiLCJzZXRBbGlnbm1lbnQiLCJfb25Gb3JlZ3JvdW5kQ29sb3JDaGFuZ2UiLCJzZXRDb2xvciIsIl9vbkJhY2tncm91bmRDb2xvckNoYW5nZSIsInNldEJhY2tncm91bmRDb2xvciIsIl9zd2l0Y2hUb01vZGUiLCJfcmVuZGVyRm9udFNpemVPdmVybGF5Q29udHJvbCIsIl9yZW5kZXJGb250RmFtaWx5T3ZlcmxheUNvbnRyb2wiLCJtYXhGb250U2l6ZSIsImdldEZvbnRTaXplIiwiX3JlbmRlclNpemVJdGVtIiwiX3JlbmRlckZvbnRJdGVtIiwiX3JlbmRlckFsaWdubWVudEl0ZW0iLCJfcmVuZGVyVGFrZVRvRnJvbnRJdGVtIiwiZm9yZWdyb3VuZENvbG9yIiwiZ2V0Q29sb3IiLCJnZXRCYWNrZ3JvdW5kQ29sb3IiLCJUZXh0Q29udHJvbHNPdmVybGF5Q29tcG9uZW50IiwiX29uRWRpdENsaWNrIiwib25FZGl0IiwiRG9uZUJ1dHRvbkNvbXBvbmVudCIsIkhlYWRlckNvbXBvbmVudCIsIl9vbkNsb3NlQ2xpY2siLCJDTE9TRSIsImNsb3NlQnV0dG9uIiwic2hvd0Nsb3NlQnV0dG9uIiwiTW9kYWxDb250YWluZXJDb21wb25lbnQiLCJfbW9kYWxNYW5hZ2VyIiwibW9kYWxNYW5hZ2VyIiwiX29uTW9kYWxNYW5hZ2VyVXBkYXRlIiwiX29uTW9kYWxDbG9zZWQiLCJfcmVuZGVyTW9kYWxzIiwibW9kYWxzIiwiTW9kYWxDb21wb25lbnQiLCJFcnJvck1vZGFsQ29tcG9uZW50IiwiX29uQ2xvc2UiLCJtb2RhbEVsZW1lbnQiLCJMb2FkaW5nTW9kYWxDb21wb25lbnQiLCJQcm9ncmVzc01vZGFsQ29tcG9uZW50IiwicHJvZ3Jlc3NTdHlsZSIsIldhcm5pbmdNb2RhbENvbXBvbmVudCIsIkNhbnZhc0NvbXBvbmVudCIsIl9pbml0aWFsUmVuZGVyRG9uZSIsImNhbnZhc1Bvc2l0aW9uIiwiY2FudmFzT2Zmc2V0IiwicmVzaXplVG8iLCJfZ2V0Q29udGFpbmVyRGltZW5zaW9ucyIsImlkZW50aWZpZXJzIiwiY2FudmFzQ2VsbCIsInNldENhbnZhcyIsIl9vblpvb21DaGFuZ2UiLCJfZHJhZ1N0YXJ0UG9zaXRpb24iLCJuYXRpdmVFdmVudCIsIl9kcmFnSW5pdGlhbE9mZnNldCIsImV2ZW50UG9zaXRpb24iLCJkaWZmRnJvbVN0YXJ0IiwibGFzdE9mZnNldCIsIl9nZXREcmFnZ2FibGVTdHlsZSIsImNvbnRhaW5lckNvbnRlbnQiLCJsYXJnZUNvbnRyb2xzIiwiem9vbUFsbG93c0RyYWciLCJnZXREZWZhdWx0IiwiZHJhZ0VuYWJsZWQiLCJXSU5ET1dfUkVTSVpFX0RFTEFZIiwiRWRpdG9yU2NyZWVuQ29tcG9uZW50IiwiX292ZXJ2aWV3Q29udHJvbHMiLCJfcHJldmlvdXNDb250cm9sc1N0YWNrIiwiX29uTmV3SW1hZ2UiLCJfc3RhcnRFZGl0b3IiLCJfb25JbWFnZVJlc2l6ZSIsIl9vblJlbmRlckVycm9yIiwiX2ZvcmNlQ29udHJvbHMiLCJmb3JjZUNvbnRyb2xzIiwiX2ZvcmNlQ29udHJvbEluZGV4IiwiX3N3aXRjaFRvTmV4dEZvcmNlQ29udHJvbCIsImF2YWlsYWJsZUNvbnRyb2xzIiwiY29udHJvbE9iamVjdCIsImZpeGVkT3B0aW9ucyIsIm9uY2UiLCJkaXNwbGF5UmVzaXplTWVzc2FnZSIsIl9yZXNpemVUaW1lb3V0IiwiX29uV2luZG93UmVzaXplRG9uZSIsImluaXRpYWxTdGF0ZSIsImNvbnRyb2xPcHRpb25zIiwibmV3Q29udHJvbHMiLCJjb250cm9sc0NoYW5nZWQiLCJjYWxsIiwiY2xlYXIiLCJnZXRab29tIiwiX3Nob3dVbmRvQnV0dG9uIiwiVG9wQmFyQ29udHJvbHNDb21wb25lbnQiLCJjYW52YXNDb250cm9scyIsInRvcEJhckNvbnRyb2xzIiwic2hvd1RvcEJhciIsImxhcmdlQ2FudmFzQ29udHJvbHMiLCJMb2FkaW5nU2NyZWVuQ29tcG9uZW50IiwiX3ByZWxvYWRlciIsImRldmljZVBpeGVsUmF0aW8iLCJfY2FudmFzIiwiX2NvbnRleHQiLCJfcHJlbG9hZGVySW1hZ2UiLCJfcmVuZGVyTG9hZGluZ0luZGljYXRvciIsImN0eCIsInNhdmUiLCJjbGlwIiwicmVzdG9yZSIsImdsb2JhbEFscGhhIiwiTGlicmFyeUNvbXBvbmVudCIsIlBob3RvQ29tcG9uZW50IiwiTm9TZWFyY2hSZXN1bHRzQ29tcG9uZW50IiwiX3Byb3ZpZGVyIiwic2VhcmNoU3VnZ2VzdGlvbnMiLCJfb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2siLCJvblNlYXJjaFN1Z2dlc3Rpb25DbGlja2VkIiwiZ2V0U2VhcmNoU3VnZ2VzdGlvbnMiLCJfcmVuZGVyTWVzc2FnZSIsIl9yZW5kZXJTZWFyY2hTdWdnZXN0aW9ucyIsIk92ZXJ2aWV3Q29tcG9uZW50IiwibGlicmFyaWVzIiwiX2xvYWQiLCJfb25MaWJyYXJ5Q2xpY2siLCJhdXRvbWF0aWNhbGx5Iiwib25MaWJyYXJ5Q2xpY2tlZCIsImdldExpYnJhcmllcyIsIl9yZW5kZXJMaWJyYXJpZXMiLCJQaG90b1JvbGxTY3JlZW5Db21wb25lbnQiLCJzZWN0aW9uIiwic2VjdGlvbnNIaXN0b3J5IiwiaGFzUHJldmlvdXNTZWN0aW9uIiwic3dpdGNoVG9TZWN0aW9uIiwiYWxsb3dTY3JlZW5Td2l0Y2giLCJhZGRUb1N0YWNrIiwiX29uTGlicmFyeUNsaWNrZWQiLCJfb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZCIsInNlYXJjaFF1ZXJ5IiwicmF3IiwiX29uQmFja0NsaWNrZWQiLCJfb25TZWFyY2giLCJ0cmltIiwiX29uV2ViY2FtQ2xpY2siLCJfb25GaWxlVXBsb2FkIiwiX2lzQmFja0J1dHRvblZpc2libGUiLCJjb250ZW50Q29tcG9uZW50IiwiU2VhcmNoUmVzdWx0c0NvbXBvbmVudCIsInNlYXJjaFBob3RvcyIsIl9yZW5kZXJOb3RGb3VuZCIsIlBob3RvUm9sbFRvcEJhckNvbXBvbmVudCIsIl9vblNlYXJjaFZhbHVlQ2hhbmdlIiwiZGVib3VuY2UiLCJvbkJhY2tDbGlja2VkIiwib25TZWFyY2giLCJfb25VcGxvYWRCdXR0b25DbGlja2VkIiwiX29uV2ViY2FtQnV0dG9uQ2xpY2tlZCIsIm9uV2ViY2FtQ2xpY2siLCJvbkZpbGVVcGxvYWQiLCJfaXNXZWJjYW1BdmFpbGFibGUiLCJfcmVuZGVyUmlnaHRCdXR0b25zIiwiYnV0dG9ucyIsImJhY2tCdXR0b25MYWJlbCIsIlRvcEJhclNlYXJjaENvbXBvbmVudCIsInBsYWNlaG9sZGVyIiwiaW5wdXQiLCJfaGlkZGVuSW5wdXREdW1teSIsInN0eWxlT2JqZWN0IiwiZ2V0U3R5bGVPYmplY3QiLCJvdmVycmlkZUtleXMiLCJfdXBkYXRlSW5wdXRXaWR0aCIsImlubmVySFRNTCIsImlucHV0V2lkdGgiLCJfb25CYXJDbGljayIsIl9vbkZvY3VzIiwiX29uQmx1ciIsIl9vbkNoYW5nZSIsInNlYXJjaEJhckJFTSIsImlucHV0U3R5bGUiLCJQaG90b1JvbGxDb21wb25lbnQiLCJTcGxhc2hTY3JlZW5Db21wb25lbnQiLCJfb25QaG90b1JvbGxDbGljayIsIl9vbkltYWdlIiwiX2lzUGhvdG9Sb2xsQXZhaWxhYmxlIiwidXBsb2FkQXZhaWxhYmxlIiwid2ViY2FtQXZhaWxhYmxlIiwicGhvdG9Sb2xsQXZhaWxhYmxlIiwiVXBsb2FkQ29tcG9uZW50IiwiX2RyYWdDb3VudGVyIiwiZHJhZ0FyZWFIb3ZlcmVkIiwiX29uRHJhZ0VudGVyIiwiX29uRHJhZ092ZXIiLCJfb25EcmFnTGVhdmUiLCJfb25Ecm9wIiwicmV0dXJuVmFsdWUiLCJkYXRhVHJhbnNmZXIiLCJfaGFuZGxlRmlsZSIsImZpbGVzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0RhdGFVUkwiLCJvbkltYWdlIiwiY2VsbFByb3BzIiwib25EcmFnRW50ZXIiLCJvbkRyYWdPdmVyIiwib25EcmFnTGVhdmUiLCJvbkRyb3AiLCJjb250ZW50Q2VsbEJFTSIsIldlYmNhbUNvbXBvbmVudCIsIndlYmNhbVJlYWR5IiwibmV4dFN0YXRlIiwidmlkZW8iLCJfc3RyZWFtIiwidHJhY2siLCJnZXRUcmFja3MiLCJwYXVzZSIsIl9yZXNpemVWaWRlbyIsIl9pbml0VmlkZW9TdHJlYW0iLCJfb25XZWJjYW1SZWFkeSIsIm9uUmVhZHkiLCJtYWtlUGhvdG8iLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJ0b0RhdGFVUkwiLCJpbm5lckRpbWVuc2lvbnMiLCJnZXRJbm5lckRpbWVuc2lvbnNGb3JFbGVtZW50IiwiZ2V0VXNlck1lZGlhIiwid2Via2l0R2V0VXNlck1lZGlhIiwibW96R2V0VXNlck1lZGlhIiwibXNHZXRVc2VyTWVkaWEiLCJzdHJlYW0iLCJvbmxvYWRlZG1ldGFkYXRhIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiZXJyIiwiV2ViY2FtU2NyZWVuQ29tcG9uZW50IiwiX29uQ2FuY2VsIiwiX29uU2h1dHRlckNsaWNrZWQiLCJUb3BCYXJCYWNrQnV0dG9uQ29tcG9uZW50IiwiUkVOREVSIiwiT1BFUkFUSU9OX0NSRUFURUQiLCJGRUFUVVJFU19ESVNBQkxFRCIsIkZFQVRVUkVTX0VOQUJMRUQiLCJISVNUT1JZX1VORE8iLCJDT05UUk9MU19TV0lUQ0hFRCIsIkZSQU1FUyIsImxheW91dE1vZGUiLCJpbWFnZUdyb3VwcyIsIm1pZCIsInJpZ2h0IiwiYm90dG9tIiwiRk9OVFMiLCJFZGl0b3JDb250cm9scyIsIl9hdmFpbGFibGUiLCJleHRlbnNpb25zIiwiaW5mbyIsIkVkaXRvckZlYXR1cmVzIiwiX2ZlYXR1cmVzIiwiZHJhZyIsImVuYWJsZURyYWciLCJjYXBpdGFsaXplZElkZW50aWZpZXIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsIm9wdGlvbkVuYWJsZWQiLCJFZGl0b3JIaXN0b3J5IiwiX2hpc3RvcnkiLCJoaXN0b3J5SXRlbSIsImxhc3RJdGVtIiwiRWRpdG9yT3BlcmF0aW9ucyIsImdldE9wZXJhdGlvbnMiLCJfbWFwIiwiX3N0YWNrIiwiZ2V0T3BlcmF0aW9uc1N0YWNrIiwiX3ByZWZlcnJlZE9yZGVyIiwib3BlcmF0aW9uc09yZGVyIiwiX2ZpeFN0YWNrIiwicmVtb3ZlQXQiLCJzZXREaXJ0eSIsIk9wZXJhdGlvbiIsIk1JTl9aT09NX0RJTUVOU0lPTlMiLCJFZGl0b3Jab29tIiwiX2lzRGVmYXVsdFpvb20iLCJfem9vbSIsIl96b29tTGV2ZWxzIiwieiIsIm5ld1pvb20iLCJfZ2V0Q2xvc2VzdFpvb21MZXZlbCIsInpvb21MZXZlbCIsIl9wcmV2aW91c1pvb20iLCJjb25zaWRlck1pbmltdW0iLCJkZWZhdWx0Wm9vbSIsIm1heFpvb20iLCJtaW5ab29tIiwiZ2V0TWluaW11bSIsInNldFpvb20iLCJzZXRUZXh0dXJlUXVhbGl0eSIsImRlZmF1bHREaW1lbnNpb25zIiwicmVzaXplVmVjdG9yVG9GaXQiLCJtaW5pbXVtRGltZW5zaW9ucyIsImlzRGVmYXVsdCIsIkV4cG9ydGVyIiwiX2Rvd25sb2FkIiwicmVuZGVyVHlwZSIsIl9nZXRSZW5kZXJUeXBlIiwicXVhbGl0eSIsIl9kb3dubG9hZERhdGEiLCJEQVRBVVJMIiwiZG93bmxvYWREYXRhVVJMIiwiZmlsZUJhc2VuYW1lIiwiTVNCTE9CIiwiZG93bmxvYWRNU0Jsb2IiLCJJTUFHRSIsInN1cHBvcnRzTVNCbG9iIiwiRmlsZURvd25sb2FkZXIiLCJiYXNlTmFtZSIsImNyZWF0ZUJsb2JVUkxGcm9tRGF0YVVSTCIsImV4dGVuc2lvbiIsImdldEV4dGVuc2lvbkZyb21EYXRhVVJMIiwibGluayIsImJvZHkiLCJjbGljayIsIm1zU2F2ZUJsb2IiLCJtaW1lU3RyaW5nIiwiQmxvYiIsIkFycmF5QnVmZmVyIiwiVWludDhBcnJheSIsInJhd0RhdGEiLCJkZWNvZGUiLCJhcnJheUJ1ZmZlciIsImludEFycmF5IiwiYmxvYiIsIkZpbGVMb2FkZXIiLCJfaW5wdXQiLCJfb25GaWxlQ2hhbmdlIiwiRm9udHNMb2FkZXIiLCJGT05UX1NUWUxFUyIsIml0YWxpYyIsIkdvb2dsZUZvbnRzTG9hZGVyIiwiX2RlZmF1bHRGb250UnVsZXIiLCJfY3VzdG9tRm9udFJ1bGVycyIsIl9hZGRTdHlsZXNoZWV0VGFnIiwicnVsZXIiLCJzZXRGb250IiwiX3dhaXRGb3JMb2FkUHJvbWlzZSIsInByb21pc2UiLCJfc3RhcnRlZEF0IiwiX3dhaXRGb3JMb2FkIiwiZm4iLCJjaGFuZ2VkIiwiX2NoZWNrV2lkdGhDaGFuZ2VkIiwiZmFtaWxpZXMiLCJfZ2V0RmFtaWxpZXNTdHJpbmciLCJyZWwiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJmYW1pbHlTdHJpbmdzIiwidmFyaWFudHMiLCJ2YXJpYW50c1N0cmluZyIsIm5hbWVTdHJpbmciLCJGT05UX1NJWkUiLCJDSEFSQUNURVJTIiwiRm9udFJ1bGVyIiwiX2ZvbnQiLCJfY3JlYXRlUnVsZXIiLCJfcnVsZXIiLCJpbm5lclRleHQiLCJfc2V0UnVsZXJTdHlsZSIsImNzc1RleHQiLCJGcmFtZSIsIl9sb2FkZWQiLCJfbG9hZGluZyIsIl9mcmFtZSIsImRlZXBEZWZhdWx0cyIsImdyb3VwTmFtZSIsInBhcnROYW1lIiwiX2xvYWRQYXJ0IiwiaW1hZ2VVcmwiLCJPQkpFQ1QiLCJJbWFnZVJlc2l6ZXIiLCJfaW1hZ2UiLCJfbWF4UGl4ZWxzIiwiX21heERpbWVuc2lvbnMiLCJwaXhlbHMiLCJleGNlZWRzTWF4UGl4ZWxzIiwiZXhjZWVkc01heERpbWVuc2lvbnMiLCJjb3B5IiwiX2dldERpbWVuc2lvbnNCeU1heFBpeGVscyIsIl9jcmVhdGVSZXNpemVkSW1hZ2VDYW52YXMiLCJyYXRpb0hWIiwicmF0aW9WSCIsInNxcnQiLCJGb250c01hbmFnZXIiLCJfaW5pdEZvbnRzIiwiX2RlZmF1bHRGb250IiwiRnJhbWVNYW5hZ2VyIiwiX2luaXRGcmFtZXMiLCJhZGRpdGlvbmFsRnJhbWVzIiwicmVwbGFjZUZyYW1lcyIsInNlbGVjdGFibGVGcmFtZXMiLCJkZWZhdWx0RnJhbWUiLCJfZGVmYXVsdEZyYW1lIiwiX2ZyYW1lcyIsImdldERlZmF1bHRGcmFtZSIsIkxpYnJhcnkiLCJQaG90byIsIlByb3ZpZGVyIiwid2FybiIsIlNlYXJjaFN1Z2dlc3Rpb24iLCJMT0FEX1RJTUVPVVQiLCJQcmVsb2FkZXIiLCJfYXNzZXRzIiwiX2FwcGVuZENvbnRyb2xzQXNzZXRzIiwiYXNzZXRzQ291bnQiLCJhc3NldHNMb2FkZWQiLCJhc3NldExvYWRlZCIsImFzc2V0TG9hZEZhaWxlZCIsImFzc2V0IiwicmV0aW5hQXNzZXQiLCJhc3NldFBhdGgiLCJ0aW1lb3V0IiwiU2VyaWFsaXphdGlvbiIsImRlc2VyaWFsaXplciIsIl9kZXNlcmlhbGl6ZVNlbGVjdGl2ZUJsdXJPcGVyYXRpb24iLCJfc2VyaWFsaXplU2VsZWN0aXZlQmx1ck9wZXJhdGlvbiIsIl9zdGF0ZSIsInRyYWNlIiwiVUlVdGlscyIsImNvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwicGFyc2VJbnQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiY2xpZW50WCIsImNsaWVudFkiLCJ0b3VjaGVzIiwibXNUb0Jsb2IiLCJwaHJhc2VzIiwiZmV0Y2giLCJwYXRoU2VnbWVudHMiLCJzZWdtZW50IiwidmVuZG9yIiwib3BlcmEiLCJ0ZXN0Iiwic3Vic3RyIiwic2VsZWN0ZWRJdGVtcyIsInNlbGVjdG9yIiwibmV3SXRlbXMiLCJpdGVtSWRlbnRpZmllciIsImdldEpTT05QIiwiaXRlbXNQcm9wZXJ0eSIsImV4aXN0aW5nQ2F0ZWdvcnkiLCJuZXdDYXRlZ29yeSIsInN0eWxlUHJvcGVydGllcyIsInByb3BlcnR5IiwiY2FtZWxpemVkQXR0ciIsIndhaXQiLCJpbW1lZGlhdGUiLCJhcmd1bWVudHMiLCJsYXRlciIsImNhbGxOb3ciLCJvdXRlciIsInZpc2liaWxpdHkiLCJtc092ZXJmbG93U3R5bGUiLCJ3aWR0aE5vU2Nyb2xsIiwib3ZlcmZsb3ciLCJpbm5lciIsIndpZHRoV2l0aFNjcm9sbCIsImdldElFVmVyc2lvbiIsImFwcFZlcnNpb24iLCJpc0lFMTAiLCJpc0lFMTEiLCJicm93c2VyVmVyc2lvbiIsImdsb2JhbCIsInJBRiIsImNBRiIsImxhc3RUaW1lIiwidmVuZG9ycyIsImN1cnJUaW1lIiwiRGF0ZSIsImdldFRpbWUiLCJ0aW1lVG9DYWxsIiwiUGhvdG9Sb2xsIiwiYmQiLCJieXRlQXJyYXlUb1N0cmluZyIsIlJlYWN0VUkiLCJfaW5pdE9wdGlvbnMiLCJfaW5pdExhbmd1YWdlIiwiX2luaXRFdmVudHMiLCJfZGlzcG9zZWQiLCJfdiIsInJ1biIsIl9yZWdpc3RlcldlYkZvbnRzIiwiY29tcG9uZW50IiwicmVuZGVyUmV0dXJuc0NvbXBvbmVudCIsIl9jb21wb25lbnQiLCJsYW5ndWFnZSIsImxhbmd1YWdlcyIsImJhc2VVcmwiLCJyZXNvbHZlciIsInJlZ3VsYXJGb250UGF0aCIsImxpZ2h0Rm9udFBhdGgiLCJjc3MiLCJfd2ViRm9udHNTdHlsZSIsInBpcGVFdmVudHMiLCJfZGlzcG9zZUV2ZW50cyIsInVucGlwZUV2ZW50cyIsIl9sYW5ndWFnZXMiLCJkZSIsImVuIiwiX2xhbmd1YWdlIiwidWlBc3NldCIsImRpc2FibGVSZXRpbmEiLCJyZWdleCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJCYXNlQ29udHJvbHMiLCJSZWFjdENvbXBvbmVudCIsIlVJIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDOURBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7QUNNQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7QUEzQkE7Ozs7Ozs7Ozs7Ozs7O0FBNkJBLElBQU1BLFNBQVMseUJBQWVBLE1BQTlCO0FB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Q0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7O0FDbEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE1BQU07QUFDOUU7QUFDQSx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjLDBDQUEwQyxNQUFNLEdBQUcsT0FBTztBQUMxSCxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNFQUFzRSxNQUFNLEdBQUcsT0FBTztBQUN0RjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBEQUEwRCxNQUFNO0FBQ2hFLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRTs7Ozs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsTUFBTTtBQUNwRjtBQUNBLHdD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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BGQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQUs7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzdEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQSxpRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDY0E7O0FBTUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztJQUFZ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YWN0VUkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJwaG90b2VkaXRvcnNka1wiKSwgcmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInBob3RvZWRpdG9yc2RrXCIsIFwicmVhY3RcIiwgXCJyZWFjdC1kb21cIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUGhvdG9FZGl0b3JSZWFjdFVJXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicGhvdG9lZGl0b3JzZGtcIiksIHJlcXVpcmUoXCJyZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUGhvdG9FZGl0b3JSZWFjdFVJXCJdID0gZmFjdG9yeShyb290W1wiUGhvdG9FZGl0b3JTREtcIl0sIHJvb3RbXCJSZWFjdFwiXSwgcm9vdFtcIlJlYWN0RE9NXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMjlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV82MF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzI2M19fKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb3J5IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vcnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyNjQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGNlMWI3ODVhMjI3YTVlYmI4NTg1IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBQaG90b0VkaXRvclNESyBmcm9tICdwaG90b2VkaXRvcnNkaydcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCBDbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnXG5cbmltcG9ydCBCRU0gZnJvbSAnLi9saWIvYmVtJ1xuaW1wb3J0IFJlYWN0QkVNIGZyb20gJy4vbGliL3JlYWN0LWJlbSdcbmltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50cy9iYXNlLWNvbXBvbmVudCdcbmltcG9ydCBVdGlscyBmcm9tICcuL2xpYi91dGlscydcbmltcG9ydCBDb25zdGFudHMgZnJvbSAnLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IFNoYXJlZFN0YXRlIGZyb20gJy4vbGliL3NoYXJlZC1zdGF0ZSdcbmltcG9ydCB7IHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUgfSBmcm9tICcuLi9zaGFyZWQvYW5pbWF0aW9uLWZyYW1lJ1xuaW1wb3J0IExvZyBmcm9tICcuLi9zaGFyZWQvbG9nJ1xuXG5jb25zdCBCYXNlNjQgPSBQaG90b0VkaXRvclNESy5CYXNlNjRcbmNvbnN0IENvbG9yID0gUGhvdG9FZGl0b3JTREsuQ29sb3JcbmNvbnN0IENvbG9yTWF0cml4ID0gUGhvdG9FZGl0b3JTREsuTWF0aC5Db2xvck1hdHJpeFxuY29uc3QgRXZlbnRFbWl0dGVyID0gUGhvdG9FZGl0b3JTREsuRXZlbnRFbWl0dGVyXG5jb25zdCBFWElGID0gUGhvdG9FZGl0b3JTREsuRVhJRlxuY29uc3QgT3B0aW9uVHlwZSA9IFBob3RvRWRpdG9yU0RLLk9wdGlvblR5cGVcbmNvbnN0IFByb21pc2UgPSBQaG90b0VkaXRvclNESy5Qcm9taXNlXG5jb25zdCBTREtVdGlscyA9IFBob3RvRWRpdG9yU0RLLlV0aWxzXG5jb25zdCBSZW5kZXJUeXBlID0gUGhvdG9FZGl0b3JTREsuUmVuZGVyVHlwZVxuY29uc3QgSW1hZ2VGb3JtYXQgPSBQaG90b0VkaXRvclNESy5JbWFnZUZvcm1hdFxuY29uc3QgU0RLID0gUGhvdG9FZGl0b3JTREtcbmNvbnN0IFVuaWZvcm1UeXBlID0gUGhvdG9FZGl0b3JTREsuVW5pZm9ybVR5cGVcbmNvbnN0IFZlY3RvcjIgPSBQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJcblxuY29uc3Qgbm93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSlcbiAgOiByZXF1aXJlKCdwZXJmb3JtYW5jZS1ub3cnKSlcblxuZXhwb3J0IHtcbiAgUHJvbWlzZSwgVXRpbHMsIFJlYWN0LCBCRU0sIENsYXNzbmFtZXMsIEJhc2VDb21wb25lbnQsIFJlYWN0QkVNLCBWZWN0b3IyLFxuICBTREtVdGlscywgRXZlbnRFbWl0dGVyLCBDb25zdGFudHMsIFNoYXJlZFN0YXRlLCBDb2xvciwgQmFzZTY0LCBSZW5kZXJUeXBlLCBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSxcbiAgUmVhY3RET00sIEVYSUYsIFNESywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSwgTG9nLCBub3csIENvbG9yTWF0cml4LFxuICBJbWFnZUZvcm1hdFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZ2xvYmFscy5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3NldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9jcmVhdGVcIik7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdCwgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQsIFV0aWxzLCBWZWN0b3IyIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi9kcmFnZ2FibGUtY29tcG9uZW50J1xuY29uc3QgU0NST0xMQkFSX1dJRFRIID0gMTJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsYmFyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuTkFUSVZFX1NDUk9MTEJBUl9XSURUSCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5OQVRJVkVfU0NST0xMQkFSX1dJRFRIID0gVXRpbHMuZ2V0U2Nyb2xsYmFyV2lkdGgoKVxuICAgIH1cblxuICAgIHRoaXMuX25lZWRzU3R5bGVGaXhlcyA9IHRydWVcbiAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2VcbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkJ1dHRvbkRyYWdTdGFydCcsXG4gICAgICAnX29uQnV0dG9uRHJhZycsXG4gICAgICAnX29uQnV0dG9uRHJhZ1N0b3AnLFxuICAgICAgJ19vbkJhckRyYWdTdGFydCcsXG4gICAgICAnX29uQmFyRHJhZycsXG4gICAgICAnX29uQmFyRHJhZ1N0b3AnLFxuICAgICAgJ19vbkxpc3RTY3JvbGwnXG4gICAgKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBidXR0b25TaXplOiAwLFxuICAgICAgYnV0dG9uUG9zaXRpb246IDAsXG4gICAgICBidXR0b25WaXNpYmxlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG4gICAgdGhpcy51cGRhdGUoKVxuICB9XG5cbiAgZml4U3R5bGVzICgpIHtcbiAgICBpZiAoIVV0aWxzLmlzTW9iaWxlKCkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUxpc3RTaXplKClcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzY3JvbGxzIHRoZSBsaXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25MaXN0U2Nyb2xsICgpIHtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2luZykgcmV0dXJuXG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLl9nZXREaXJlY3Rpb24oKVxuXG4gICAgbGV0IGxpc3RTY3JvbGxTaXplLCBsaXN0U2Nyb2xsUG9zaXRpb24sIGJhY2tncm91bmRTY3JvbGxTaXplXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LkhPUklaT05UQUwpIHtcbiAgICAgIGxpc3RTY3JvbGxTaXplID0gdGhpcy5fbGlzdC5zY3JvbGxXaWR0aCAtIHRoaXMuX2xpc3Qub2Zmc2V0V2lkdGhcbiAgICAgIGxpc3RTY3JvbGxQb3NpdGlvbiA9IHRoaXMuX2xpc3Quc2Nyb2xsTGVmdFxuICAgICAgYmFja2dyb3VuZFNjcm9sbFNpemUgPSB0aGlzLl9ub2RlLm9mZnNldFdpZHRoIC0gdGhpcy5zdGF0ZS5idXR0b25TaXplXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFNjcm9sbGJhckNvbXBvbmVudC5WRVJUSUNBTCkge1xuICAgICAgbGlzdFNjcm9sbFNpemUgPSB0aGlzLl9saXN0LnNjcm9sbEhlaWdodCAtIHRoaXMuX2xpc3Qub2Zmc2V0SGVpZ2h0XG4gICAgICBsaXN0U2Nyb2xsUG9zaXRpb24gPSB0aGlzLl9saXN0LnNjcm9sbFRvcFxuICAgICAgYmFja2dyb3VuZFNjcm9sbFNpemUgPSB0aGlzLl9ub2RlLm9mZnNldEhlaWdodCAtIHRoaXMuc3RhdGUuYnV0dG9uU2l6ZVxuICAgIH1cblxuICAgIGNvbnN0IHByb2dyZXNzID0gbGlzdFNjcm9sbFBvc2l0aW9uIC8gbGlzdFNjcm9sbFNpemVcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGJ1dHRvblBvc2l0aW9uOiBiYWNrZ3JvdW5kU2Nyb2xsU2l6ZSAqIHByb2dyZXNzXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBtb3VzZSBidXR0b24gb24gdGhlIGJhclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQnV0dG9uRHJhZ1N0YXJ0IChlKSB7XG4gICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWVcbiAgICB0aGlzLl9pbml0aWFsQnV0dG9uUG9zaXRpb24gPSB0aGlzLnN0YXRlLmJ1dHRvblBvc2l0aW9uIHx8IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gZGlmZlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQnV0dG9uRHJhZyAoZGlmZikge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuX2dldERpcmVjdGlvbigpXG5cbiAgICBsZXQgYnV0dG9uUG9zaXRpb25cbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgYnV0dG9uUG9zaXRpb24gPSB0aGlzLl9pbml0aWFsQnV0dG9uUG9zaXRpb24gKyBkaWZmLnhcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICBidXR0b25Qb3NpdGlvbiA9IHRoaXMuX2luaXRpYWxCdXR0b25Qb3NpdGlvbiArIGRpZmYueVxuICAgIH1cbiAgICB0aGlzLl9zZXRCdXR0b25Qb3NpdGlvbihidXR0b25Qb3NpdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBidXR0b25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJ1dHRvbkRyYWdTdG9wICgpIHtcbiAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgYmFyXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CYXJEcmFnU3RhcnQgKGUpIHtcbiAgICBjb25zdCBtb3VzZVBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKVxuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IG1vdXNlUG9zaXRpb24uY2xvbmUoKVxuICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IHRoaXMuX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBlbGVtZW50T2Zmc2V0ID0gbmV3IFZlY3RvcjIoXG4gICAgICBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgIGJvdW5kaW5nUmVjdC50b3BcbiAgICApXG5cbiAgICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0gbW91c2VQb3NpdGlvblxuICAgICAgLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChlbGVtZW50T2Zmc2V0KVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5fZ2V0RGlyZWN0aW9uKClcbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgdGhpcy5fc2V0QnV0dG9uUG9zaXRpb24ocmVsYXRpdmVQb3NpdGlvbi54IC0gdGhpcy5zdGF0ZS5idXR0b25TaXplIC8gMilcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICB0aGlzLl9zZXRCdXR0b25Qb3NpdGlvbihyZWxhdGl2ZVBvc2l0aW9uLnkgLSB0aGlzLnN0YXRlLmJ1dHRvblNpemUgLyAyKVxuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uQmFyRHJhZylcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkJhckRyYWcpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQmFyRHJhZ1N0b3ApXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkJhckRyYWdTdG9wKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBiYXJcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhckRyYWcgKGUpIHtcbiAgICBjb25zdCBtb3VzZVBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKVxuXG4gICAgY29uc3QgYm91bmRpbmdSZWN0ID0gdGhpcy5fbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IGVsZW1lbnRPZmZzZXQgPSBuZXcgVmVjdG9yMihcbiAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0LFxuICAgICAgYm91bmRpbmdSZWN0LnRvcFxuICAgIClcblxuICAgIGNvbnN0IHJlbGF0aXZlUG9zaXRpb24gPSBtb3VzZVBvc2l0aW9uXG4gICAgICAuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KGVsZW1lbnRPZmZzZXQpXG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5fZ2V0RGlyZWN0aW9uKClcbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgdGhpcy5fc2V0QnV0dG9uUG9zaXRpb24ocmVsYXRpdmVQb3NpdGlvbi54IC0gdGhpcy5zdGF0ZS5idXR0b25TaXplIC8gMilcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICB0aGlzLl9zZXRCdXR0b25Qb3NpdGlvbihyZWxhdGl2ZVBvc2l0aW9uLnkgLSB0aGlzLnN0YXRlLmJ1dHRvblNpemUgLyAyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBiYXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhckRyYWdTdG9wICgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkJhckRyYWcpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25CYXJEcmFnKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkJhckRyYWdTdG9wKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25CYXJEcmFnU3RvcClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogU2V0cyB0aGUgYnV0dG9uIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYnV0dG9uUG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCdXR0b25Qb3NpdGlvbiAoYnV0dG9uUG9zaXRpb24pIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLl9nZXREaXJlY3Rpb24oKVxuXG4gICAgbGV0IHNjcm9sbGFibGVCdXR0b25TaXplLCBzY3JvbGxhYmxlTGlzdFNpemVcbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgc2Nyb2xsYWJsZUJ1dHRvblNpemUgPSB0aGlzLl9ub2RlLm9mZnNldFdpZHRoIC0gdGhpcy5zdGF0ZS5idXR0b25TaXplXG4gICAgICBzY3JvbGxhYmxlTGlzdFNpemUgPSB0aGlzLl9saXN0LnNjcm9sbFdpZHRoIC0gdGhpcy5fbGlzdC5vZmZzZXRXaWR0aFxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuVkVSVElDQUwpIHtcbiAgICAgIHNjcm9sbGFibGVCdXR0b25TaXplID0gdGhpcy5fbm9kZS5vZmZzZXRIZWlnaHQgLSB0aGlzLnN0YXRlLmJ1dHRvblNpemVcbiAgICAgIHNjcm9sbGFibGVMaXN0U2l6ZSA9IHRoaXMuX2xpc3Quc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fbGlzdC5vZmZzZXRIZWlnaHRcbiAgICB9XG5cbiAgICAvLyBDbGFtcCBidXR0b24gcG9zaXRpb25cbiAgICBidXR0b25Qb3NpdGlvbiA9IE1hdGgubWF4KDAsIGJ1dHRvblBvc2l0aW9uKVxuICAgIGJ1dHRvblBvc2l0aW9uID0gTWF0aC5taW4oYnV0dG9uUG9zaXRpb24sIHNjcm9sbGFibGVCdXR0b25TaXplKVxuXG4gICAgLy8gU2V0IGJ1dHRvbiBwb3NpdGlvblxuICAgIHRoaXMuc2V0U3RhdGUoeyBidXR0b25Qb3NpdGlvbiB9KVxuXG4gICAgLy8gVXBkYXRlIGxpc3Qgc2Nyb2xsIHBvc2l0aW9uXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBidXR0b25Qb3NpdGlvbiAvIHNjcm9sbGFibGVCdXR0b25TaXplXG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxhYmxlTGlzdFNpemUgKiBwcm9ncmVzc1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LkhPUklaT05UQUwpIHtcbiAgICAgIHRoaXMuX2xpc3Quc2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFNjcm9sbGJhckNvbXBvbmVudC5WRVJUSUNBTCkge1xuICAgICAgdGhpcy5fbGlzdC5zY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBidXR0b24gcG9zaXRpb24gYW5kIHNpemVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVCdXR0b25TaXplIChjYikge1xuICAgIGxldCBidXR0b25TaXplID0gMFxuICAgIGxldCBidXR0b25WaXNpYmxlID0gZmFsc2VcbiAgICBsZXQgcGFyZW50U2l6ZSwgcGFyZW50U2Nyb2xsU2l6ZVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5fZ2V0RGlyZWN0aW9uKClcbiAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgcGFyZW50U2l6ZSA9IHRoaXMuX2xpc3QuY2xpZW50V2lkdGhcbiAgICAgIHBhcmVudFNjcm9sbFNpemUgPSB0aGlzLl9saXN0LnNjcm9sbFdpZHRoXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFNjcm9sbGJhckNvbXBvbmVudC5WRVJUSUNBTCkge1xuICAgICAgcGFyZW50U2l6ZSA9IHRoaXMuX2xpc3Qub2Zmc2V0SGVpZ2h0XG4gICAgICBwYXJlbnRTY3JvbGxTaXplID0gdGhpcy5fbGlzdC5zY3JvbGxIZWlnaHRcbiAgICB9XG5cbiAgICBidXR0b25TaXplID0gcGFyZW50U2l6ZSAvIHBhcmVudFNjcm9sbFNpemUgKiBwYXJlbnRTaXplXG4gICAgYnV0dG9uVmlzaWJsZSA9IHBhcmVudFNjcm9sbFNpemUgPiBwYXJlbnRTaXplXG5cbiAgICB0aGlzLnNldFN0YXRlKHsgYnV0dG9uU2l6ZSwgYnV0dG9uVmlzaWJsZSB9LCBjYilcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBsaXN0IHNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVMaXN0U2l6ZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0KSByZXR1cm5cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuX2dldERpcmVjdGlvbigpXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LkhPUklaT05UQUwpIHtcbiAgICAgIHRoaXMuX2xpc3Quc3R5bGUuaGVpZ2h0ID0gJydcbiAgICAgIGNvbnN0IGZ1bGxEaW1lbnNpb25zID0gdGhpcy5fZ2V0RnVsbExpc3REaW1lbnNpb25zKClcbiAgICAgIHRoaXMuX2xpc3RTaXplID0gZnVsbERpbWVuc2lvbnMueVxuICAgICAgdGhpcy5fbGlzdENvbnRlbnRTaXplID0gdGhpcy5fbGlzdC5vZmZzZXRIZWlnaHRcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICB0aGlzLl9saXN0LnN0eWxlLndpZHRoID0gJydcbiAgICAgIGNvbnN0IGZ1bGxEaW1lbnNpb25zID0gdGhpcy5fZ2V0RnVsbExpc3REaW1lbnNpb25zKClcbiAgICAgIHRoaXMuX2xpc3RTaXplID0gZnVsbERpbWVuc2lvbnMueFxuICAgICAgdGhpcy5fbGlzdENvbnRlbnRTaXplID0gdGhpcy5fbGlzdC5vZmZzZXRXaWR0aFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBvcmRlciB0byBnZXQgdGhlIGFic29sdXRlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGxpc3QsIGluY2x1ZGluZyB0aGUgc2Nyb2xsYmFyLFxuICAgKiB3ZSBuZWVkIHRvIG1ha2UgdXNlIG9mIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGdWxsTGlzdERpbWVuc2lvbnMgKCkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLl9saXN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFVCTElDIEFQSVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaW1lbnNpb25zIGFuZCBzdHVmZlxuICAgKi9cbiAgdXBkYXRlICgpIHtcbiAgICBpZiAoVXRpbHMuaXNNb2JpbGUoKSkgeyByZXR1cm4gfVxuXG4gICAgY29uc3QgeyByb290LCBsaXN0IH0gPSB0aGlzLnJlZnNcbiAgICB0aGlzLl9ub2RlID0gcm9vdFxuICAgIHRoaXMuX2xpc3QgPSBsaXN0XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLl9nZXREaXJlY3Rpb24oKVxuICAgIHRoaXMuX3VwZGF0ZUJ1dHRvblNpemUoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9saXN0U2l6ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVMaXN0U2l6ZSgpXG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdMaXN0U2l6ZSA9IHRoaXMuX2xpc3RTaXplXG4gICAgICBpZiAodGhpcy5zdGF0ZS5idXR0b25WaXNpYmxlKSB7XG4gICAgICAgIG5ld0xpc3RTaXplICs9IHRoaXMuY29uc3RydWN0b3IuTkFUSVZFX1NDUk9MTEJBUl9XSURUSFxuICAgICAgfVxuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBTY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCkge1xuICAgICAgICB0aGlzLl9saXN0LnN0eWxlLmhlaWdodCA9IGAke25ld0xpc3RTaXplfXB4YFxuICAgICAgICB0aGlzLl9ub2RlLnN0eWxlLnRvcCA9IGAke3RoaXMuX2xpc3RDb250ZW50U2l6ZSAtIFNDUk9MTEJBUl9XSURUSH1weGBcbiAgICAgICAgdGhpcy5fbm9kZS5zdHlsZS53aWR0aCA9IGAke3RoaXMuX2xpc3Qub2Zmc2V0V2lkdGh9cHhgXG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMKSB7XG4gICAgICAgIHRoaXMuX2xpc3Quc3R5bGUud2lkdGggPSBgJHtuZXdMaXN0U2l6ZX1weGBcbiAgICAgICAgdGhpcy5fbm9kZS5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5fbGlzdENvbnRlbnRTaXplIC0gU0NST0xMQkFSX1dJRFRIfXB4YFxuICAgICAgICB0aGlzLl9ub2RlLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuX2xpc3Qub2Zmc2V0SGVpZ2h0fXB4YFxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9saXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX29uTGlzdFNjcm9sbClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIHNjcm9sbGJhcidzIGRpcmVjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0RGlyZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5kaXJlY3Rpb24gfHwgJ2hvcml6b250YWwnXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTVFlMSU5HXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJ1dHRvbidzIHN0eWxlIG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0QnV0dG9uU3R5bGUgKCkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuX2dldERpcmVjdGlvbigpXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiB0aGlzLnN0YXRlLmJ1dHRvblBvc2l0aW9uLFxuICAgICAgICB3aWR0aDogdGhpcy5zdGF0ZS5idXR0b25TaXplXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdGhpcy5zdGF0ZS5idXR0b25Qb3NpdGlvbixcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnN0YXRlLmJ1dHRvblNpemVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBHRVRURVJTXG5cbiAgZ2V0TGlzdCAoKSB7IHJldHVybiB0aGlzLnJlZnMubGlzdCB9XG4gIGdldFJvb3QgKCkgeyByZXR1cm4gdGhpcy5yZWZzLnJvb3QgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBpZiAoVXRpbHMuaXNNb2JpbGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9XG5cbiAgICBjb25zdCBidXR0b25TdHlsZSA9IHRoaXMuX2dldEJ1dHRvblN0eWxlKClcbiAgICBjb25zdCBzY3JvbGxiYXJTdHlsZSA9IHtcbiAgICAgIGRpc3BsYXk6IHRoaXMuc3RhdGUuYnV0dG9uVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSdcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZCA9IFJlYWN0LmNsb25lRWxlbWVudCh0aGlzLnByb3BzLmNoaWxkcmVuLCB7XG4gICAgICByZWY6ICdsaXN0J1xuICAgIH0pXG5cbiAgICByZXR1cm4gKDxkaXY+XG4gICAgICB7Y2hpbGR9XG4gICAgICA8ZGl2XG4gICAgICAgIGJlbT17YCRiOnNjcm9sbGJhciBtOiR7dGhpcy5wcm9wcy5kaXJlY3Rpb24gfHwgJ2hvcml6b250YWwnfSBtOiR7dGhpcy5zdGF0ZS5idXR0b25WaXNpYmxlID8gJ3Zpc2libGUnIDogJ2ludmlzaWJsZSd9YH1cbiAgICAgICAgcmVmPSdyb290J1xuICAgICAgICBzdHlsZT17c2Nyb2xsYmFyU3R5bGV9XG4gICAgICAgIG9uTW91c2VEb3duPXt0aGlzLl9vbkJhckRyYWdTdGFydH1cbiAgICAgICAgb25Ub3VjaFN0YXJ0PXt0aGlzLl9vbkJhckRyYWdTdGFydH0+XG4gICAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbkJ1dHRvbkRyYWdTdGFydH1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uQnV0dG9uRHJhZ31cbiAgICAgICAgICBvblN0b3A9e3RoaXMuX29uQnV0dG9uRHJhZ1N0b3B9PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGJlbT0nZTpiYXInXG4gICAgICAgICAgICBzdHlsZT17YnV0dG9uU3R5bGV9XG4gICAgICAgICAgICBvbk1vdXNlRG93bj17dGhpcy5fb25CdXR0b25Eb3dufSAvPlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5TY3JvbGxiYXJDb21wb25lbnQuSE9SSVpPTlRBTCA9ICdob3Jpem9udGFsJ1xuU2Nyb2xsYmFyQ29tcG9uZW50LlZFUlRJQ0FMID0gJ3ZlcnRpY2FsJ1xuXG5TY3JvbGxiYXJDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2Nyb2xsYmFyLWNvbXBvbmVudC5qc3giLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL2dsb2JhbHMnXG5cbmNsYXNzIE1vZGFsIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIHRpdGxlLCB0ZXh0LCBvdmVybGF5ID0gZmFsc2UpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMudGl0bGUgPSB0aXRsZVxuICAgIHRoaXMudGV4dCA9IHRleHRcbiAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5XG4gICAgdGhpcy5kYXRhID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRhdGEgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgc2V0RGF0YSAoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoaXMgbW9kYWxcbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fbW9kYWxzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbG9hZGluZyBtb2RhbFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7TW9kYWx9XG4gICAqL1xuICBkaXNwbGF5TG9hZGluZyAodGV4dCkge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKCdsb2FkaW5nJywgbnVsbCwgdGV4dClcbiAgICB0aGlzLmFkZE1vZGFsKG1vZGFsKVxuICAgIHJldHVybiBtb2RhbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwcm9ncmVzcyBtb2RhbFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7TW9kYWx9XG4gICAqL1xuICBkaXNwbGF5UHJvZ3Jlc3MgKHRleHQsIHByb2dyZXNzID0gMCkge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKCdwcm9ncmVzcycsIG51bGwsIHRleHQpXG4gICAgbW9kYWwuc2V0RGF0YSh7IHByb2dyZXNzIH0pXG4gICAgdGhpcy5hZGRNb2RhbChtb2RhbClcbiAgICByZXR1cm4gbW9kYWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdHMgYSB3YXJuaW5nIG1vZGFsXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge01vZGFsfVxuICAgKi9cbiAgZGlzcGxheVdhcm5pbmcgKHRpdGxlLCB0ZXh0KSB7XG4gICAgY29uc3QgbW9kYWwgPSBuZXcgTW9kYWwoJ3dhcm5pbmcnLCB0aXRsZSwgdGV4dClcbiAgICB0aGlzLmFkZE1vZGFsKG1vZGFsKVxuICAgIHJldHVybiBtb2RhbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXJyb3IgbW9kYWxcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0aXRsZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3ZlcmxheSA9IHRydWVcbiAgICogQHJldHVybiB7TW9kYWx9XG4gICAqL1xuICBkaXNwbGF5RXJyb3IgKHRpdGxlLCB0ZXh0LCBvdmVybGF5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1vZGFsID0gbmV3IE1vZGFsKCdlcnJvcicsIHRpdGxlLCB0ZXh0LCBvdmVybGF5KVxuICAgIHRoaXMuYWRkTW9kYWwobW9kYWwpXG4gICAgcmV0dXJuIG1vZGFsXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbW9kYWwgdG8gdGhlIGxpc3Qgb2YgbW9kYWxzXG4gICAqIEBwYXJhbSB7TW9kYWx9IG1vZGFsXG4gICAqL1xuICBhZGRNb2RhbCAobW9kYWwpIHtcbiAgICB0aGlzLl9tb2RhbHMucHVzaChtb2RhbClcbiAgICBtb2RhbC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU1vZGFsKG1vZGFsKVxuICAgIH0pXG4gICAgbW9kYWwub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJylcbiAgICB9KVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBtb2RhbCBmcm9tIHRoZSBsaXN0IG9mIG1vZGFsc1xuICAgKiBAcGFyYW0gIHtNb2RhbH0gbW9kYWxcbiAgICovXG4gIHJlbW92ZU1vZGFsIChtb2RhbCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbW9kYWxzLmluZGV4T2YobW9kYWwpXG4gICAgdGhpcy5fbW9kYWxzLnNwbGljZShpbmRleCwgMSlcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbW9kYWxzXG4gICAqIEByZXR1cm4ge0FycmF5LjxNb2RhbD59XG4gICAqL1xuICBnZXRNb2RhbHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RhbHNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvbmUgYW5kIG9ubHkgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKiBAcmV0dXJuIHtNb2RhbE1hbmFnZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGluc3RhbmNlICgpIHtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBNb2RhbE1hbmFnZXIoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VcbiAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvbW9kYWwtbWFuYWdlci5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBCYWNrQnV0dG9uQ29tcG9uZW50IGZyb20gJy4uL2JhY2stYnV0dG9uLWNvbXBvbmVudCdcbmltcG9ydCBEb25lQnV0dG9uQ29tcG9uZW50IGZyb20gJy4uL2RvbmUtYnV0dG9uLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5faGFzQmFja0J1dHRvbiA9IHRydWVcbiAgICB0aGlzLl9oYXNEb25lQnV0dG9uID0gZmFsc2VcbiAgICB0aGlzLl9iYWNrQnV0dG9uQ2xpY2tlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkJhY2tDbGljaycsXG4gICAgICAnX29uRG9uZUNsaWNrJ1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja0NsaWNrIChlKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkNsaWNrZWQgPSB0cnVlXG4gICAgdGhpcy5wcm9wcy5vblN3aXRjaENvbnRyb2xzKCdiYWNrJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgZG9uZSBidXR0b25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRG9uZUNsaWNrIChlKSB7XG4gICAgdGhpcy5fb25CYWNrQ2xpY2soKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvdmVybGF5IGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJPdmVybGF5Q29udHJvbHMgKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgZm9yY2VkQ29udHJvbCA9IHRoaXMucHJvcHMub3B0aW9ucyAmJiB0aGlzLnByb3BzLm9wdGlvbnMuZm9yY2VkQ29udHJvbFxuICAgIGNvbnN0IGJhY2tCdXR0b24gPSB0aGlzLl9oYXNCYWNrQnV0dG9uICYmICFmb3JjZWRDb250cm9sXG4gICAgICA/IDxCYWNrQnV0dG9uQ29tcG9uZW50IG9uQ2xpY2s9e3RoaXMuX29uQmFja0NsaWNrfSAvPlxuICAgICAgOiBudWxsXG5cbiAgICBjb25zdCBkb25lQnV0dG9uID0gdGhpcy5faGFzRG9uZUJ1dHRvbiB8fCBmb3JjZWRDb250cm9sXG4gICAgICA/IDxEb25lQnV0dG9uQ29tcG9uZW50IG9uQ2xpY2s9e3RoaXMuX29uRG9uZUNsaWNrfSAvPlxuICAgICAgOiBudWxsXG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpjb250cm9scycgcmVmPSdyb290Jz5cbiAgICAgIHt0aGlzLnJlbmRlck92ZXJsYXlDb250cm9scygpfVxuICAgICAgPGRpdiBiZW09J2U6dGFibGUnPlxuICAgICAgICB7YmFja0J1dHRvbn1cbiAgICAgICAge3RoaXMucmVuZGVyQ29udHJvbHMoKX1cbiAgICAgICAge2RvbmVCdXR0b259XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIGNvbnRyb2xzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJXG4gKi9cbmNsYXNzIENvbnRyb2wge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5pdGlhbCBzaGFyZWQgc3RhdGUgZm9yIHRoaXMgY29udHJvbFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEBwYXJhbSAge09iamVjdH0gYWRkaXRpb25hbFN0YXRlID0ge31cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEluaXRpYWxTaGFyZWRTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY29udHJvbCBpcyBhdmFpbGFibGUgdG8gdGhlIHVzZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGlzQXZhaWxhYmxlIChlZGl0b3IpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NldHMgdGhhdCBzaG91bGQgYmUgcHJlbG9hZGVkIGZvciB0aGlzIGNvbnRyb2xcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRQcmVsb2FkQXNzZXRzICgpIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIHRvcCBiYXIgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgdXBwZXIgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuVG9wQmFyQ29udHJvbHNDb21wb25lbnR9XG4gKi9cbkNvbnRyb2wudG9wQmFyQ29udHJvbHNDb21wb25lbnQgPSBudWxsXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKi9cbkNvbnRyb2wuY29udHJvbHNDb21wb25lbnQgPSBudWxsXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKi9cbkNvbnRyb2wuY2FudmFzQ29udHJvbHNDb21wb25lbnQgPSBudWxsXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkNvbnRyb2wuaWRlbnRpZmllciA9IG51bGxcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpY29uIHBhdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkNvbnRyb2wuaWNvblBhdGggPSBudWxsXG5cbi8qKlxuICogVGhlIGxhbmd1YWdlIGtleSB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGlzIGZpbHRlclxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuQ29udHJvbC5sYW5ndWFnZUtleSA9IG51bGxcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkNvbnRyb2wuZGVmYXVsdE9wdGlvbnMgPSB7fVxuXG5leHBvcnQgZGVmYXVsdCBDb250cm9sXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2NvbnRyb2xzLmpzIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cbmltcG9ydCB7IFJlYWN0LCBCYXNlQ29tcG9uZW50LCBVdGlscywgVmVjdG9yMiB9IGZyb20gJy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyYWdnYWJsZUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkRyYWdTdGFydCcsXG4gICAgICAnX29uRHJhZ01vdmUnLFxuICAgICAgJ19vbkRyYWdFbmQnXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnMgZHJhZ2dpbmcgdGhlIGNoaWxkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRyYWdTdGFydCAoZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkKSByZXR1cm5cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIHRoaXMuX2luaXRpYWxNb3VzZVBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25EcmFnTW92ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkRyYWdNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkRyYWdFbmQpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkRyYWdFbmQpXG5cbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBlbGVtZW50T2Zmc2V0ID0gbmV3IFZlY3RvcjIoXG4gICAgICBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgIGJvdW5kaW5nUmVjdC50b3BcbiAgICApXG5cbiAgICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0gdGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QoZWxlbWVudE9mZnNldClcbiAgICB0aGlzLnByb3BzLm9uU3RhcnQgJiYgdGhpcy5wcm9wcy5vblN0YXJ0KHJlbGF0aXZlUG9zaXRpb24sIGUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIGNoaWxkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRyYWdNb3ZlIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgY29uc3QgbW91c2VQb3NpdGlvbiA9IFV0aWxzLmdldEV2ZW50UG9zaXRpb24oZSlcbiAgICBpZiAoIW1vdXNlUG9zaXRpb24pIHJldHVyblxuICAgIGNvbnN0IG1vdXNlRGlmZiA9IG1vdXNlUG9zaXRpb24uY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLl9pbml0aWFsTW91c2VQb3NpdGlvbilcblxuICAgIHRoaXMucHJvcHMub25EcmFnICYmIHRoaXMucHJvcHMub25EcmFnKG1vdXNlRGlmZiwgZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBjaGlsZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25EcmFnRW5kIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblxuICAgIHRoaXMuX29uRHJhZ01vdmUoZSlcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uRHJhZ01vdmUpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25EcmFnTW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25EcmFnRW5kKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25EcmFnRW5kKVxuXG4gICAgdGhpcy5wcm9wcy5vblN0b3AgJiYgdGhpcy5wcm9wcy5vblN0b3AoZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0LkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXIgKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy5jaGlsZHJlbiB8fCB0aGlzLnByb3BzLmNoaWxkcmVuIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ2dhYmxlQ29tcG9uZW50IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQuJylcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuY2hpbGRyZW4sIHtcbiAgICAgIG9uTW91c2VEb3duOiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICByZWY6ICdlbGVtZW50J1xuICAgIH0pXG4gIH1cbn1cblxuRHJhZ2dhYmxlQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2RyYWdnYWJsZS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLVXRpbHMsIFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTbGlkZXJDb21wb25lbnQgZnJvbSAnLi4vc2xpZGVyLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpZGVyT3ZlcmxheUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vblNsaWRlclZhbHVlQ2hhbmdlJ1xuICAgIClcblxuICAgIHRoaXMuc3RhdGUgPSB7IHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChwcm9wcykge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdGhpcy5zdGF0ZS52YWx1ZSkge1xuICAgICAgdGhpcy5zdGF0ZS52YWx1ZSA9IHByb3BzLnZhbHVlXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNsaWRlciB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TbGlkZXJWYWx1ZUNoYW5nZSAodmFsdWUpIHtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlICYmXG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKVxuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZSB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIFNsaWRlckNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtTbGlkZXJDb21wb25lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2xpZGVyICgpIHtcbiAgICBjb25zdCBwcm9wcyA9IFNES1V0aWxzLmRlZmF1bHRzKHRoaXMucHJvcHMsIHtcbiAgICAgIHN0eWxlOiAnJyxcbiAgICAgIG1pZGRsZURvdDogZmFsc2UsXG4gICAgICBtaW5WYWx1ZTogMSxcbiAgICAgIG1heFZhbHVlOiAxMDAsXG4gICAgICBsYWJlbDogJ0xhYmVsJyxcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLl9vblNsaWRlclZhbHVlQ2hhbmdlLFxuICAgICAgdmFsdWU6IHRoaXMuc3RhdGUudmFsdWVcbiAgICB9KVxuICAgIHJldHVybiA8U2xpZGVyQ29tcG9uZW50IHsuLi5wcm9wc30gLz5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpjb250cm9scyBlOm92ZXJsYXkgbTpzbGlkZXIgbTpkYXJrJz5cbiAgICAgIHt0aGlzLl9yZW5kZXJTbGlkZXIoKX1cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuU2xpZGVyT3ZlcmxheUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zbGlkZXItb3ZlcmxheS1jb21wb25lbnQuanN4IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBCYXNlQ29tcG9uZW50LCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkNhbnZhc1pvb21Eb25lJ1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEhJVCBURVNUXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhbnkgb3RoZXIgY29udHJvbCByZWFjdHMgdG8gYSBjbGljayBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICogQHBhcmFtICB7VmVjdG9yMn0gY2xpY2tQb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1IaXRUZXN0IChjbGlja1Bvc2l0aW9uKSB7XG4gICAgY29uc3QgeyBjb250YWluZXIgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBjb250YWluZXJQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKFxuICAgICAgY29udGFpbmVyUmVjdC5sZWZ0LFxuICAgICAgY29udGFpbmVyUmVjdC50b3BcbiAgICApXG5cbiAgICBjb25zdCBwb3NpdGlvbk9uQ2FudmFzID0gY2xpY2tQb3NpdGlvblxuICAgICAgLnN1YnRyYWN0KGNvbnRhaW5lclBvc2l0aW9uKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IGNvbnRyb2xzID0gZWRpdG9yLmNvbnRyb2xzLmdldEF2YWlsYWJsZSgpXG5cbiAgICAvLyBDaGVjayBpZiBhbnkgb2YgdGhlIGNvbnRyb2xzIHJlc3BvbmRzIHRvIGEgY2xpY2tcbiAgICAvLyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICBmb3IgKGxldCBpZGVudGlmaWVyIGluIGNvbnRyb2xzKSB7XG4gICAgICBjb25zdCBjb250cm9sID0gY29udHJvbHNbaWRlbnRpZmllcl1cbiAgICAgIGNvbnN0IGNsaWNrUmVzcG9uc2UgPSBjb250cm9sLmNsaWNrQXRQb3NpdGlvbiAmJlxuICAgICAgICBjb250cm9sLmNsaWNrQXRQb3NpdGlvbihwb3NpdGlvbk9uQ2FudmFzLCBlZGl0b3IpXG5cbiAgICAgIGlmIChjbGlja1Jlc3BvbnNlKSB7XG4gICAgICAgIC8vIERvbid0IHJlLXNlbGVjdCBhbiBhbHJlYWR5IHNlbGVjdGVkIGl0ZW1cbiAgICAgICAgaWYgKGNsaWNrUmVzcG9uc2Uuc2VsZWN0ZWRTcHJpdGUgPT09IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzcG9uZHMgdG8gY2xpY2ssIHN3aXRjaCB0byB0aGUgY29udHJvbHNcbiAgICAgICAgdGhpcy5wcm9wcy5vblN3aXRjaENvbnRyb2xzKGNvbnRyb2wsIGNsaWNrUmVzcG9uc2UpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGNhbnZhcyBoYXMgYmVlbiB6b29tZWQgaW4gb3Igb3V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DYW52YXNab29tRG9uZSAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogQmluZHMgdGhlIGV2ZW50cyBpbiBfZXZlbnRzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9iaW5kRXZlbnRzICgpIHtcbiAgICBzdXBlci5fYmluZEV2ZW50cygpXG4gICAgdGhpcy5jb250ZXh0Lm1lZGlhdG9yLm9uKFxuICAgICAgQ29uc3RhbnRzLkVWRU5UUy5aT09NX0RPTkUsXG4gICAgICB0aGlzLl9vbkNhbnZhc1pvb21Eb25lXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuYmluZHMgdGhlIGV2ZW50cyBpbiBfZXZlbnRzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF91bmJpbmRFdmVudHMgKCkge1xuICAgIHN1cGVyLl91bmJpbmRFdmVudHMoKVxuICAgIHRoaXMuY29udGV4dC5tZWRpYXRvci5vZmYoXG4gICAgICBDb25zdGFudHMuRVZFTlRTLlpPT01fRE9ORSxcbiAgICAgIHRoaXMuX29uQ2FudmFzWm9vbURvbmVcbiAgICApXG4gIH1cbn1cblxuQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdCwgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IEhlYWRlckNvbXBvbmVudCBmcm9tICcuLi9oZWFkZXItY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY3JlZW5Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGhlYWRlciAoaWYgZW5hYmxlZClcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJIZWFkZXIgKCkge1xuICAgIGlmICghdGhpcy5jb250ZXh0Lm9wdGlvbnMuc2hvd0hlYWRlcikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuICg8SGVhZGVyQ29tcG9uZW50IC8+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBzY3JlZW5cbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJTY3JlZW4gKCkge1xuICAgIHJldHVybiA8ZGl2IC8+XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgbGV0IHNjcmVlbkJFTVNwZWNpZmllciA9ICdiOnNjcmVlbidcbiAgICBpZiAoIXRoaXMuY29udGV4dC5vcHRpb25zLnNob3dIZWFkZXIpIHtcbiAgICAgIHNjcmVlbkJFTVNwZWNpZmllciArPSAnIG06bm9IZWFkZXInXG4gICAgfVxuXG4gICAgcmV0dXJuICg8ZGl2IGJlbT17c2NyZWVuQkVNU3BlY2lmaWVyfSBjbGFzc05hbWU9eyF0aGlzLnByb3BzLnZpc2libGUgPyAnaXMtaGlkZGVuJyA6IG51bGx9PlxuICAgICAge3RoaXMuX3JlbmRlckhlYWRlcigpfVxuICAgICAge3RoaXMuX3JlbmRlclNjcmVlbigpfVxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5TY3JlZW5Db21wb25lbnQucHJvcFR5cGVzID0ge1xuICBlZGl0b3I6IFJlYWN0LlByb3BUeXBlcy5hbnlcbn1cblxuU2NyZWVuQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvc2NyZWVuLWNvbXBvbmVudC5qc3giLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvYXNzaWduXCIpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfYXNzaWduMi5kZWZhdWx0IHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMjlfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwicGhvdG9lZGl0b3JzZGtcIixcImNvbW1vbmpzMlwiOlwicGhvdG9lZGl0b3JzZGtcIixcImFtZFwiOlwicGhvdG9lZGl0b3JzZGtcIixcInJvb3RcIjpcIlBob3RvRWRpdG9yU0RLXCJ9XG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IERyYWdnYWJsZUNvbXBvbmVudCBmcm9tICcuL2RyYWdnYWJsZS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNsaWRlckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbktub2JEcmFnU3RhcnQnLFxuICAgICAgJ19vbktub2JEcmFnJyxcbiAgICAgICdfb25Lbm9iRHJhZ1N0b3AnLFxuICAgICAgJ19vbkJhckRyYWdTdGFydCcsXG4gICAgICAnX29uQmFyRHJhZycsXG4gICAgICAnX29uQmFyRHJhZ1N0b3AnLFxuICAgICAgJ19vbk1pZGRsZURvdENsaWNrJ1xuICAgIClcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy52YWx1ZSB8fCAwLFxuICAgICAgc2xpZGVyUG9zaXRpb246IDAsXG4gICAgICBmb3JlZ3JvdW5kTGVmdDogMCxcbiAgICAgIGZvcmVncm91bmRXaWR0aDogMFxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICAvLyBUcmlnZ2VyIGEgcmUtcmVuZGVyIHRvIHBvc2l0aW9uIHRoZSBrbm9iXG4gICAgdGhpcy5fc2V0VmFsdWUodGhpcy5zdGF0ZS52YWx1ZSwgZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wc1xuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAocHJvcHMpIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHRoaXMuc3RhdGUudmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFZhbHVlKHByb3BzLnZhbHVlLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEgbW91c2UgYnV0dG9uIG9uIHRoZSBtaWRkbGUgZG90XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25NaWRkbGVEb3RDbGljayAoKSB7XG4gICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWVcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMucHJvcHMubWluVmFsdWUgKyAodGhpcy5wcm9wcy5tYXhWYWx1ZSAtIHRoaXMucHJvcHMubWluVmFsdWUpIC8gMlxuICAgIHRoaXMuX3NldFZhbHVlKG5ld1ZhbHVlLCB0cnVlLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBrbm9iXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZ1N0YXJ0IChwb3NpdGlvbikge1xuICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlXG4gICAgdGhpcy5faW5pdGlhbFNsaWRlclBvc2l0aW9uID0gdGhpcy5zdGF0ZS5zbGlkZXJQb3NpdGlvblxuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHBvc2l0aW9uXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIGtub2JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gZGlmZlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWcgKGRpZmYpIHtcbiAgICBjb25zdCB7IGJhciB9ID0gdGhpcy5yZWZzXG4gICAgY29uc3QgYmFyV2lkdGggPSBiYXIub2Zmc2V0V2lkdGhcblxuICAgIGxldCBuZXdTbGlkZXJQb3NpdGlvbiA9IHRoaXMuX2luaXRpYWxTbGlkZXJQb3NpdGlvbiArIGRpZmYueFxuICAgIG5ld1NsaWRlclBvc2l0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3U2xpZGVyUG9zaXRpb24sIGJhcldpZHRoKSlcbiAgICBjb25zdCBwcm9ncmVzcyA9IG5ld1NsaWRlclBvc2l0aW9uIC8gYmFyV2lkdGhcbiAgICBsZXQgbmV3VmFsdWUgPSB0aGlzLnByb3BzLm1pblZhbHVlICsgKHRoaXMucHJvcHMubWF4VmFsdWUgLSB0aGlzLnByb3BzLm1pblZhbHVlKSAqIHByb2dyZXNzXG5cbiAgICB0aGlzLl9zZXRWYWx1ZShuZXdWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBrbm9iXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZ1N0b3AgKCkge1xuICAgIHRoaXMuX3NldFZhbHVlKHRoaXMuc3RhdGUudmFsdWUsIHRydWUsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIGJhclxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFyRHJhZ1N0YXJ0IChwb3NpdGlvbikge1xuICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlXG4gICAgdGhpcy5faW5pdGlhbFBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKVxuXG4gICAgY29uc3QgeyBiYXIgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGJhcldpZHRoID0gYmFyLm9mZnNldFdpZHRoXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBwb3NpdGlvbi54IC8gYmFyV2lkdGhcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMucHJvcHMubWluVmFsdWUgKyAodGhpcy5wcm9wcy5tYXhWYWx1ZSAtIHRoaXMucHJvcHMubWluVmFsdWUpICogcHJvZ3Jlc3NcbiAgICB0aGlzLl9zZXRWYWx1ZShuZXdWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgYmFyXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IGRpZmZcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhckRyYWcgKGRpZmYpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX2luaXRpYWxQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAuYWRkKGRpZmYpXG5cbiAgICBjb25zdCB7IGJhciB9ID0gdGhpcy5yZWZzXG4gICAgY29uc3QgYmFyV2lkdGggPSBiYXIub2Zmc2V0V2lkdGhcbiAgICBjb25zdCBwcm9ncmVzcyA9IHBvc2l0aW9uLnggLyBiYXJXaWR0aFxuICAgIGxldCBuZXdWYWx1ZSA9IHRoaXMucHJvcHMubWluVmFsdWUgKyAodGhpcy5wcm9wcy5tYXhWYWx1ZSAtIHRoaXMucHJvcHMubWluVmFsdWUpICogcHJvZ3Jlc3NcbiAgICBuZXdWYWx1ZSA9IE1hdGgubWF4KHRoaXMucHJvcHMubWluVmFsdWUsIE1hdGgubWluKHRoaXMucHJvcHMubWF4VmFsdWUsIG5ld1ZhbHVlKSlcbiAgICB0aGlzLl9zZXRWYWx1ZShuZXdWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBiYXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhckRyYWdTdG9wICgpIHtcbiAgICB0aGlzLl9zZXRWYWx1ZSh0aGlzLnN0YXRlLnZhbHVlLCB0cnVlLCB0cnVlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBmb3IgdGhlIGtub2IgKHBvc2l0aW9uKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0S25vYlN0eWxlICgpIHtcbiAgICByZXR1cm4geyBsZWZ0OiB0aGlzLnN0YXRlLnNsaWRlclBvc2l0aW9uIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBmb3IgdGhlIGZvcmVncm91bmQgYmFyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGb3JlZ3JvdW5kU3R5bGUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnN0YXRlLmZvcmVncm91bmRMZWZ0LFxuICAgICAgd2lkdGg6IHRoaXMuc3RhdGUuZm9yZWdyb3VuZFdpZHRoXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBEZWNpZGVzIHdoZXRoZXIgb3Igbm90IHRoaXMgc2xpZGVyIHNob3VsZCBoYXZlIGEgbWlkZGxlIGRvdCBvbiB0aGUgYmFyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGlzcGxheU1pZGRsZURvdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMubWlkZGxlRG90ICE9PSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZSwgdXBkYXRlcyB0aGUgc2xpZGVyIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVtaXRDaGFuZ2UgPSB0cnVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW1pdFJlbGVhc2UgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFZhbHVlICh2YWx1ZSwgZW1pdENoYW5nZSA9IHRydWUsIGVtaXRSZWxlYXNlID0gZmFsc2UpIHtcbiAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpXG4gICAgY29uc3QgeyBtaW5WYWx1ZSwgbWF4VmFsdWUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBwcm9ncmVzcyA9ICh2YWx1ZSAtIG1pblZhbHVlKSAvIChtYXhWYWx1ZSAtIG1pblZhbHVlKVxuXG4gICAgLy8gQ2FsY3VsYXRlIHNsaWRlciBwb3NpdGlvblxuICAgIGNvbnN0IHsgYmFyIH0gPSB0aGlzLnJlZnNcbiAgICBjb25zdCBiYXJXaWR0aCA9IGJhci5vZmZzZXRXaWR0aFxuICAgIGNvbnN0IHNsaWRlclBvc2l0aW9uID0gYmFyV2lkdGggKiBwcm9ncmVzc1xuXG4gICAgLy8gQ2FsY3VsYXRlIGZvcmVncm91bmQgcG9zaXRpb24gYW5kIHdpZHRoXG4gICAgbGV0IGZvcmVncm91bmRXaWR0aCA9IHByb2dyZXNzICogYmFyV2lkdGhcbiAgICBsZXQgZm9yZWdyb3VuZExlZnQgPSAwXG4gICAgaWYgKHRoaXMuX2Rpc3BsYXlNaWRkbGVEb3QoKSkge1xuICAgICAgZm9yZWdyb3VuZFdpZHRoID0gTWF0aC5hYnMocHJvZ3Jlc3MgLSAwLjUpICogYmFyV2lkdGhcbiAgICAgIGZvcmVncm91bmRMZWZ0ID0gcHJvZ3Jlc3MgPCAwLjVcbiAgICAgICAgPyAoYmFyV2lkdGggKiAwLjUgLSBmb3JlZ3JvdW5kV2lkdGgpXG4gICAgICAgIDogJzUwJSdcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsdWUsIHNsaWRlclBvc2l0aW9uLCBmb3JlZ3JvdW5kV2lkdGgsIGZvcmVncm91bmRMZWZ0IH0pXG5cbiAgICBpZiAoZW1pdENoYW5nZSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJiB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlLCB0aGlzLl9wcmV2aW91c1ZhbHVlLCBlbWl0UmVsZWFzZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZGlzcGxheSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBwcm9wc1xuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkVmFsdWUgKHZhbHVlKSB7XG4gICAgLy8gTGltaXQgZGVjaW1hbHMgdG8gdHdvIGRpZ2l0cywgaWYgcHJlc2VudFxuICAgIGlmICh2YWx1ZSAlIDEgIT09IDApIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9GaXhlZCgyKVxuICAgIH1cblxuICAgIC8vIEFkZCBwb3NpdGl2ZSB2YWx1ZSBwcmVmaXggKCspIGlmIHZhbHVlIGlzID4gMFxuICAgIGlmICh0aGlzLnByb3BzLnBvc2l0aXZlVmFsdWVQcmVmaXggJiYgdmFsdWUgPj0gMCkge1xuICAgICAgdmFsdWUgPSBgJHt0aGlzLnByb3BzLnBvc2l0aXZlVmFsdWVQcmVmaXh9JHt2YWx1ZX1gXG4gICAgfVxuXG4gICAgLy8gQWRkIHVuaXQgaWYgcHJlc2VudFxuICAgIGlmICh0aGlzLnByb3BzLnZhbHVlVW5pdCkge1xuICAgICAgdmFsdWUgKz0gdGhpcy5wcm9wcy52YWx1ZVVuaXRcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBsZXQgbWlkZGxlRG90ID0gbnVsbFxuICAgIGlmICh0aGlzLl9kaXNwbGF5TWlkZGxlRG90KCkpIHtcbiAgICAgIG1pZGRsZURvdCA9IChcbiAgICAgICAgPGRpdiBiZW09J2U6bWlkZGxlRG90JyBvbkNsaWNrPXt0aGlzLl9vbk1pZGRsZURvdENsaWNrfSAvPlxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGZvcmVncm91bmRQcm9wcyA9IHtcbiAgICAgIHN0eWxlOiB0aGlzLl9nZXRGb3JlZ3JvdW5kU3R5bGUoKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudEJlbSA9ICckYjpzbGlkZXInICsgKHRoaXMucHJvcHMuc3R5bGUgPyAnIG06JyArIHRoaXMucHJvcHMuc3R5bGUgOiAnJylcbiAgICByZXR1cm4gKDxkaXYgYmVtPXtjb21wb25lbnRCZW19PlxuICAgICAgPGRpdiBiZW09JyRlOmJhcicgcmVmPSdiYXInPlxuICAgICAgICA8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgb25TdGFydD17dGhpcy5fb25CYXJEcmFnU3RhcnR9XG4gICAgICAgICAgb25EcmFnPXt0aGlzLl9vbkJhckRyYWd9XG4gICAgICAgICAgb25TdG9wPXt0aGlzLl9vbkJhckRyYWdTdG9wfT5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBiZW09JyRlOmJhY2tncm91bmQnIC8+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nJGU6Zm9yZWdyb3VuZCcgey4uLmZvcmVncm91bmRQcm9wc30gLz5cbiAgICAgICAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICAgICAgb25TdGFydD17dGhpcy5fb25Lbm9iRHJhZ1N0YXJ0fVxuICAgICAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uS25vYkRyYWd9XG4gICAgICAgICAgICAgIG9uU3RvcD17dGhpcy5fb25Lbm9iRHJhZ1N0b3B9PlxuICAgICAgICAgICAgICA8ZGl2IGJlbT0nZTprbm9iIGI6a25vYiBtOnNsaWRlcicgc3R5bGU9e3RoaXMuX2dldEtub2JTdHlsZSgpfSAvPlxuICAgICAgICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgICAgICB7bWlkZGxlRG90fVxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGJlbT0nJGU6bGFiZWxzJz5cbiAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwgbTpsb3dlckJvdW5kYXJ5Jz57dGhpcy5fYnVpbGRWYWx1ZSh0aGlzLnByb3BzLm1pblZhbHVlKX08L2Rpdj5cbiAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwgbTp2YWx1ZSc+e3RoaXMucHJvcHMubGFiZWx9IHt0aGlzLl9idWlsZFZhbHVlKHRoaXMuc3RhdGUudmFsdWUpfTwvZGl2PlxuICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCBtOnVwcGVyQm91bmRhcnknPnt0aGlzLl9idWlsZFZhbHVlKHRoaXMucHJvcHMubWF4VmFsdWUpfTwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblNsaWRlckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zbGlkZXItY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cywgVXRpbHMsIFNESywgUmVhY3RCRU0gfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFRleHRJdGVtQ29tcG9uZW50IGZyb20gJy4vaXRlbXMvdGV4dC1pdGVtLWNvbXBvbmVudCdcbmltcG9ydCBTdGlja2VySXRlbUNvbXBvbmVudCBmcm9tICcuL2l0ZW1zL3N0aWNrZXItaXRlbS1jb21wb25lbnQnXG5pbXBvcnQgQnJ1c2hJdGVtQ29tcG9uZW50IGZyb20gJy4vaXRlbXMvYnJ1c2gtaXRlbS1jb21wb25lbnQnXG5pbXBvcnQgQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudCdcbmNvbnN0IHsgU3RpY2tlciwgVGV4dCwgQnJ1c2ggfSA9IFNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGVzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQ2FudmFzQ2xpY2snLFxuICAgICAgJ19vblNwcml0ZURyYWdTdGFydCcsXG4gICAgICAnX29uU3ByaXRlRHJhZ1N0b3AnLFxuICAgICAgJ19vbk9wZXJhdGlvblVwZGF0ZWQnLFxuICAgICAgJ19vbk9wZXJhdGlvblJlbW92ZWQnLFxuICAgICAgJ19vblNwcml0ZUZsaXAnLFxuICAgICAgJ19vblNwcml0ZVRha2VUb0Zyb250JyxcbiAgICAgICdfb25TcHJpdGVSZW1vdmUnXG4gICAgKVxuXG4gICAgdGhpcy5fY2FudmFzQ2xpY2tEaXNhYmxlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9ldmVudHMgPSB7XG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5PUEVSQVRJT05fVVBEQVRFRF06IHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlZCxcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9SRU1PVkVEXTogdGhpcy5fb25PcGVyYXRpb25SZW1vdmVkXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBiZWVuIHJlbW92ZWRcbiAgICogQHBhcmFtICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblJlbW92ZWQgKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHNlbGVjdGVkU3ByaXRlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIGlmIChvcGVyYXRpb24gIT09IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpIHx8ICFzZWxlY3RlZFNwcml0ZSkgcmV0dXJuXG5cbiAgICAvLyBPcGVyYXRpb24gY2FuIGJlIHJlbW92ZWQgYnkgdGhlIHVuZG8gYnV0dG9uLiBXZSBuZWVkXG4gICAgLy8gdG8gbWFrZSBzdXJlIHdlIHJlLWNyZWF0ZSB0aGUgb3BlcmF0aW9uIGZvciB0aGUgbGlmZXRpbWVcbiAgICAvLyBvZiB0aGlzIGNvbnRyb2xcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgbmV3T3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3Nwcml0ZScsIHtcbiAgICAgIHNwcml0ZXM6IFtzZWxlY3RlZFNwcml0ZV0sXG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH0pXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb246IG5ld09wZXJhdGlvbixcbiAgICAgIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmU6IGZhbHNlLFxuICAgICAgaW5pdGlhbE9wdGlvbnM6IHt9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25VcGRhdGVkIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCBzZWxlY3RlZFNwcml0ZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBpZiAob3BlcmF0aW9uICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSB8fCAhc2VsZWN0ZWRTcHJpdGUpIHJldHVyblxuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzcHJpdGUgaXMgbm8gbG9uZ2VyIGV4aXN0ZW50LFxuICAgIC8vIHJlLWFkZCBpdFxuICAgIGNvbnN0IHNwcml0ZXMgPSBvcGVyYXRpb24uZ2V0U3ByaXRlcygpXG4gICAgaWYgKHNwcml0ZXMuaW5kZXhPZihzZWxlY3RlZFNwcml0ZSkgPT09IC0xKSB7XG4gICAgICBzcHJpdGVzLnB1c2goc2VsZWN0ZWRTcHJpdGUpXG4gICAgfVxuXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2VsZWN0ZWQgaXRlbSBpcyBkZXNlbGVjdGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtQmx1ciAoKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBzb21ld2hlcmUgb24gdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2FudmFzQ2xpY2sgKGUpIHtcbiAgICBpZiAodGhpcy5fY2FudmFzQ2xpY2tEaXNhYmxlZCkgcmV0dXJuXG5cbiAgICBjb25zdCBoaXRUZXN0ID0gdGhpcy5fcGVyZm9ybUhpdFRlc3QoVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKSlcbiAgICBpZiAoIWhpdFRlc3QpIHtcbiAgICAgIGlmICh0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpKSB7XG4gICAgICAgIHRoaXMuX29uSXRlbUJsdXIoKVxuICAgICAgfVxuICAgICAgdGhpcy5wcm9wcy5vblN3aXRjaENvbnRyb2xzKCdob21lJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBmbGlwcyB0aGUgc2VsZWN0ZWQgc3ByaXRlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZGlyZWN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TcHJpdGVGbGlwIChkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBzZWxlY3RlZFNwcml0ZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAnaCc6XG4gICAgICAgIHNlbGVjdGVkU3ByaXRlLnNldEZsaXBIb3Jpem9udGFsbHkoIXNlbGVjdGVkU3ByaXRlLmdldEZsaXBIb3Jpem9udGFsbHkoKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3YnOlxuICAgICAgICBzZWxlY3RlZFNwcml0ZS5zZXRGbGlwVmVydGljYWxseSghc2VsZWN0ZWRTcHJpdGUuZ2V0RmxpcFZlcnRpY2FsbHkoKSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciB0YWtlcyB0aGUgc2VsZWN0ZWQgc3ByaXRlIHRvIGZyb250XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TcHJpdGVUYWtlVG9Gcm9udCAoZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBvcGVyYXRpb24udGFrZVNwcml0ZVRvRnJvbnQodGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKSlcbiAgICB0aGlzLmZvcmNlU2hhcmVkVXBkYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHJlbW92ZXMgdGhlIHNlbGVjdGVkIHNwcml0ZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU3ByaXRlUmVtb3ZlICgpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGNvbnN0IHNlbGVjdGVkU3ByaXRlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIG9wZXJhdGlvbi5yZW1vdmVTcHJpdGUoc2VsZWN0ZWRTcHJpdGUpXG4gICAgc2VsZWN0ZWRTcHJpdGUuZGlzcG9zZSgpXG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgIHNlbGVjdGVkU3ByaXRlOiBudWxsXG4gICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIERSQUdHSU5HXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBzcHJpdGUgaGFzIHJlY2VpdmVkIGEgZHJhZ2dpbmcgZXZlbnQuIEJsb2NrcyB0aGUgYF9vbkNhbnZhc0NsaWNrYFxuICAgKiBoYW5kbGVyIHVudGlsIGBfb25TcHJpdGVEcmFnU3RvcGBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNwcml0ZURyYWdTdGFydCAoKSB7XG4gICAgdGhpcy5fY2FudmFzQ2xpY2tEaXNhYmxlZCA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW5jZSBgX29uQ2FudmFzQ2xpY2tgIGlzIHRyaWdnZXJlZCByaWdodCBhZnRlciB0aGUgZHJhZyBlbmQgZXZlbnQgZm9yIGtub2JzIGlzIHRyaWdnZXJlZCxcbiAgICogd2UgbmVlZCB0byB3YWl0IGEgc2hvcnQgYW1vdW50IG9mIHRpbWUgdW50aWwgd2UgcmUtZW5hYmFsZSB0aGUgY2FudmFzIGNsaWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TcHJpdGVEcmFnU3RvcCAoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9jYW52YXNDbGlja0Rpc2FibGVkID0gZmFsc2VcbiAgICB9LCAxMDApXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTVFlMSU5HXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRhaW5lciBzdHlsZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q29udGFpbmVyU3R5bGUgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBjYW52YXNEaW1lbnNpb25zID0gZWRpdG9yLmdldENhbnZhc0RpbWVuc2lvbnMoKVxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCB7IHgsIHkgfSA9IGNhbnZhc0RpbWVuc2lvbnMuY2xvbmUoKVxuICAgICAgLmRpdmlkZSgyKVxuICAgICAgLnN1YnRyYWN0KFxuICAgICAgICBvdXRwdXREaW1lbnNpb25zLmNsb25lKCkuZGl2aWRlKDIpXG4gICAgICApXG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHdpZHRoOiBvdXRwdXREaW1lbnNpb25zLngsXG4gICAgICBoZWlnaHQ6IG91dHB1dERpbWVuc2lvbnMueVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvcGVydGllcyBmb3IgdGhlIG91dGVyIGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q29udGFpbmVyUHJvcHMgKCkge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb3BlcnRpZXMgZm9yIHRoZSBjYW52YXMgY29udGFpbmVyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRJbm5lckNvbnRhaW5lclByb3BzICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IHRoaXMuX2dldENvbnRhaW5lclN0eWxlKCksXG4gICAgICBvbkNsaWNrOiB0aGlzLl9vbkNhbnZhc0NsaWNrXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNwcml0ZSBpdGVtc1xuICAgKiBAcmV0dXJuIHtBcnJheS48U3ByaXRlSXRlbUNvbXBvbmVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU3ByaXRlSXRlbXMgKCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgY29uc3Qgc3ByaXRlcyA9IG9wZXJhdGlvbi5nZXRTcHJpdGVzKClcbiAgICBjb25zdCBzZWxlY3RlZFNwcml0ZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcblxuICAgIHJldHVybiBzcHJpdGVzXG4gICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzID09PSBzZWxlY3RlZFNwcml0ZVxuICAgICAgICBsZXQgQ29tcG9uZW50Q2xhc3MgPSBudWxsXG4gICAgICAgIGlmIChzIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgIENvbXBvbmVudENsYXNzID0gVGV4dEl0ZW1Db21wb25lbnRcbiAgICAgICAgfSBlbHNlIGlmIChzIGluc3RhbmNlb2YgU3RpY2tlcikge1xuICAgICAgICAgIENvbXBvbmVudENsYXNzID0gU3RpY2tlckl0ZW1Db21wb25lbnRcbiAgICAgICAgfSBlbHNlIGlmIChzIGluc3RhbmNlb2YgQnJ1c2gpIHtcbiAgICAgICAgICBDb21wb25lbnRDbGFzcyA9IEJydXNoSXRlbUNvbXBvbmVudFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICg8Q29tcG9uZW50Q2xhc3NcbiAgICAgICAgICBvcGVyYXRpb249e29wZXJhdGlvbn1cbiAgICAgICAgICBzaGFyZWRTdGF0ZT17dGhpcy5wcm9wcy5zaGFyZWRTdGF0ZX1cbiAgICAgICAgICBzcHJpdGU9e3N9XG4gICAgICAgICAgc2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICAgICAgb25EcmFnU3RhcnQ9e3RoaXMuX29uU3ByaXRlRHJhZ1N0YXJ0fVxuICAgICAgICAgIG9uRHJhZ1N0b3A9e3RoaXMuX29uU3ByaXRlRHJhZ1N0b3B9XG4gICAgICAgICAgb25SZW1vdmU9e3RoaXMuX29uU3ByaXRlUmVtb3ZlLmJpbmQodGhpcywgcyl9XG4gICAgICAgICAgb3B0aW9ucz17dGhpcy5wcm9wcy5vcHRpb25zfVxuICAgICAgICAgIHJlZj17YHNwcml0ZS0ke3MuZ2V0SWQoKX1gfSAvPilcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVGhpcyByZW5kZXJzIGNvbnRyb2xzIG9uIHRvcCBvZiB0aGUgc3ByaXRlc1xuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxkaXZcbiAgICAgIGJlbT0nJGI6Y2FudmFzQ29udHJvbHMgZTpjb250YWluZXIgbTpmdWxsJ1xuICAgICAgcmVmPSdjb250YWluZXInXG4gICAgICB7Li4udGhpcy5fZ2V0Q29udGFpbmVyUHJvcHMoKX0+XG4gICAgICA8ZGl2XG4gICAgICAgIGJlbT0nYjpjYW52YXNDb250cm9scyBlOmlubmVyQ29udGFpbmVyJ1xuICAgICAgICByZWY9J2lubmVyQ29udGFpbmVyJ1xuICAgICAgICB7Li4udGhpcy5fZ2V0SW5uZXJDb250YWluZXJQcm9wcygpfT5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGJlbT0nJGI6c3ByaXRlc0NhbnZhc0NvbnRyb2xzJ1xuICAgICAgICAgIHJlZj0nY29udGFpbmVyJz5cbiAgICAgICAgICB7dGhpcy5fcmVuZGVyU3ByaXRlSXRlbXMoKX1cbiAgICAgICAgICB7dGhpcy5fcmVuZGVyT3ZlcmxheUNvbnRyb2xzKCl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc3ByaXRlcy9zcHJpdGVzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3BCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRlbnQgb2YgdGhpcyBUb3BCYXJDb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlckNvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nJGI6dG9wQmFyIGU6cm93Jz5cbiAgICAgIDxkaXYgYmVtPSdlOmNlbGwnPlxuICAgICAgICB7dGhpcy5yZW5kZXJDb250ZW50KCl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuVG9wQmFyQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NoYXJlZC90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50LmpzeCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbCBYTUxIdHRwUmVxdWVzdCAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5jb25zdCBUSU1FT1VUID0gNTAwMFxuaW1wb3J0IFBob3RvRWRpdG9yU0RLIGZyb20gJ3Bob3RvZWRpdG9yc2RrJ1xuY29uc3QgeyBQcm9taXNlIH0gPSBQaG90b0VkaXRvclNES1xuaW1wb3J0IFVSTCBmcm9tICd1cmwnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpTT05Mb2FkZXIge1xuICBjb25zdHJ1Y3RvciAodXJsKSB7XG4gICAgdGhpcy5fdXJsID0gdXJsXG4gICAgdGhpcy5fcGFyc2VkVXJsID0gVVJMLnBhcnNlKHRoaXMuX3VybCwgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyByZXF1ZXN0IGlzIGEgSlNPTlAgcmVxdWVzdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2lzSlNPTlBSZXF1ZXN0ICgpIHtcbiAgICBjb25zdCB7IHF1ZXJ5IH0gPSB0aGlzLl9wYXJzZWRVcmxcbiAgICBmb3IgKGxldCBrZXkgaW4gcXVlcnkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XVxuICAgICAgaWYgKHZhbHVlID09PSAnPycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIEpTT04oUCkgZnJvbSB0aGUgZ2l2ZW4gVVJMXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBsb2FkICgpIHtcbiAgICBpZiAodGhpcy5faXNKU09OUFJlcXVlc3QoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRKU09OUCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkSlNPTigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBVUkwgYXMgSlNPTlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgX2xvYWRKU09OICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHhoclxuICAgICAgaWYgKHdpbmRvdy5YRG9tYWluUmVxdWVzdCkge1xuICAgICAgICB4aHIgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KClcblxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpXG4gICAgICAgICAgcmVzb2x2ZShqc29uKVxuICAgICAgICB9XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZWplY3QoZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKG9FdmVudCkge1xuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KVxuICAgICAgICAgICAgICByZXNvbHZlKGpzb24pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBIVFRQIFN0YXR1cyAke3hoci5zdGF0dXN9YCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB0aGlzLl91cmwsIHRydWUpXG4gICAgICB4aHIuc2VuZCgpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgVVJMIGFzIEpTT05QXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBfbG9hZEpTT05QICgpIHtcbiAgICBsZXQgZmFpbGVkID0gZmFsc2VcbiAgICBsZXQgc3VjY2VlZGVkID0gZmFsc2VcblxuICAgIGNvbnN0IGZuTmFtZSA9ICdwZXNkaycgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiA5OTk5OTk5OTk5OTk5OSlcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2NyZWF0ZUpTT05QTm9kZShmbk5hbWUpXG4gICAgICB3aW5kb3dbZm5OYW1lXSA9IChyZXN1bHQpID0+IHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlSlNPTlBOb2RlKG5vZGUpXG4gICAgICAgIGlmICghZmFpbGVkKSB7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFzdWNjZWVkZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVKU09OUE5vZGUobm9kZSlcbiAgICAgICAgICBmYWlsZWQgPSB0cnVlXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCBvZiA1IHNlY29uZHMgZXhjZWVkZWQuJykpXG4gICAgICAgIH1cbiAgICAgIH0sIFRJTUVPVVQpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgSlNPTlAgPHNjcmlwdD4gbm9kZSBpbnNpZGUgdGhlIDxoZWFkPiBlbGVtZW50XG4gICAqIEBwYXJhbSAge1N0cmluZ30gZm5OYW1lXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlSlNPTlBOb2RlIChmbk5hbWUpIHtcbiAgICBjb25zdCBKU09OUFVybCA9IHRoaXMuX2J1aWxkSlNPTlBVcmwoZm5OYW1lKVxuICAgIGNvbnN0IGhlYWROb2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpXG4gICAgY29uc3Qgc2NyaXB0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgc2NyaXB0Tm9kZS5zcmMgPSBKU09OUFVybFxuICAgIGhlYWROb2RlLmFwcGVuZENoaWxkKHNjcmlwdE5vZGUpXG4gICAgcmV0dXJuIHNjcmlwdE5vZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBKU09OUCA8c2NyaXB0PiBub2RlIGZyb20gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW1vdmVKU09OUE5vZGUgKG5vZGUpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBKU09OUCB1cmwgZm9yIHRoZSBnaXZlbiBmdW5jdGlvbiBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZm5OYW1lXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF9idWlsZEpTT05QVXJsIChmbk5hbWUpIHtcbiAgICAvLyBGaW5kIEpTT05QIHBhcmFtZXRlclxuICAgIGNvbnN0IHsgcXVlcnkgfSA9IHRoaXMuX3BhcnNlZFVybFxuICAgIGxldCBwYXJhbWV0ZXIgPSBudWxsXG4gICAgZm9yIChsZXQgcGFyYW0gaW4gcXVlcnkpIHtcbiAgICAgIGlmIChxdWVyeVtwYXJhbV0gPT09ICc/Jykge1xuICAgICAgICBwYXJhbWV0ZXIgPSBwYXJhbVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9wYXJzZWRVcmwuc2VhcmNoXG4gICAgcXVlcnlbcGFyYW1ldGVyXSA9IGZuTmFtZVxuXG4gICAgcmV0dXJuIFVSTC5mb3JtYXQodGhpcy5fcGFyc2VkVXJsKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvanNvbi1sb2FkZXIuanMiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCwgVXRpbHMsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29sb3JQaWNrZXJPdmVybGF5Q29tcG9uZW50IGZyb20gJy4vb3ZlcmxheS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yUGlja2VyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5wcm9wcy5pbml0aWFsVmFsdWUuY2xvbmUoKVxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQnV0dG9uQ2xpY2snLFxuICAgICAgJ19vblZhbHVlQ2hhbmdlJyxcbiAgICAgICdfb25Db2xvclBpY2tlck9wZW4nLFxuICAgICAgJ19vbkNvbG9yUGlja2VyQ2xvc2UnXG4gICAgKVxuXG4gICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuQ09MT1JQSUNLRVJfT1BFTl06IHRoaXMuX29uQ29sb3JQaWNrZXJPcGVuXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG92ZXJsYXlWaXNpYmxlOiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuX3RyYW5zcGFyZW50UGF0dGVybkNhbnZhcyA9IFV0aWxzLmNyZWF0ZVRyYW5zcGFyZW50UGF0dGVybkNhbnZhcygpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIHRoaXMuX3JlbmRlckNvbG9yKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIHRoaXMuX3JlbmRlckNvbG9yKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgY29sb3JwaWNrZXIgaGFzIGJlZW4gb3BlbmVkLiBJZiBpdCBpcyBub3QgdGhlIHNhbWVcbiAgICogY29sb3IgcGlja2VyIGFzIHRoaXMsIHRoaXMgb25lIGdldHMgY2xvc2VkLiBUaGlzIG1ha2VzIHN1cmUgdGhhdCB0aGVyZVxuICAgKiBpcyBvbmx5IG9uZSBjb2xvciBwaWNrZXIgb3BlbiBhdCBhIHRpbWVcbiAgICogQHBhcmFtICB7Q29sb3JQaWNrZXJDb21wb25lbnR9IGNvbG9yUGlja2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db2xvclBpY2tlck9wZW4gKGNvbG9yUGlja2VyKSB7XG4gICAgaWYgKGNvbG9yUGlja2VyID09PSB0aGlzKSByZXR1cm5cbiAgICB0aGlzLnNldFN0YXRlKHsgb3ZlcmxheVZpc2libGU6IGZhbHNlIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgY29sb3IgcGlja2VyIG92ZXJsYXkgdHJpZXMgdG8gY2xvc2UgaXRzZWxmXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db2xvclBpY2tlckNsb3NlICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgb3ZlcmxheVZpc2libGU6IGZhbHNlIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgY29sb3IgcGlja2VyIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CdXR0b25DbGljayAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICghdGhpcy5zdGF0ZS5vdmVybGF5VmlzaWJsZSkge1xuICAgICAgdGhpcy5fZW1pdEV2ZW50KENvbnN0YW50cy5FVkVOVFMuQ09MT1JQSUNLRVJfT1BFTiwgdGhpcylcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgb3ZlcmxheVZpc2libGU6ICF0aGlzLnN0YXRlLm92ZXJsYXlWaXNpYmxlIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdmFsdWUgY2hhbmdlc1xuICAgKiBAcGFyYW0gIHtDb2xvcn0gdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblZhbHVlQ2hhbmdlICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl9yZW5kZXJDb2xvcigpXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG5cbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlICYmIHRoaXMucHJvcHMub25DaGFuZ2UodmFsdWUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY3VycmVudCBjb2xvciBvbiB0aGUgcHJldmlldyBjYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDb2xvciAoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5yZWZzLmNhbnZhc1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHRcblxuICAgIGNvbnN0IHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4odGhpcy5fdHJhbnNwYXJlbnRQYXR0ZXJuQ2FudmFzLCAncmVwZWF0JylcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBhdHRlcm5cbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fdmFsdWUudG9SR0JBKClcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBsZXQgT3ZlcmxheSA9IG51bGxcbiAgICBpZiAodGhpcy5zdGF0ZS5vdmVybGF5VmlzaWJsZSkge1xuICAgICAgT3ZlcmxheSA9ICg8Q29sb3JQaWNrZXJPdmVybGF5Q29tcG9uZW50XG4gICAgICAgIGluaXRpYWxWYWx1ZT17dGhpcy5fdmFsdWV9XG4gICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vblZhbHVlQ2hhbmdlfVxuICAgICAgICBvbkNsb3NlPXt0aGlzLl9vbkNvbG9yUGlja2VyQ2xvc2V9XG4gICAgICAgIGFscGhhPXt0aGlzLnByb3BzLmFscGhhfSAvPilcbiAgICB9XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLnN0YXRlLm92ZXJsYXlWaXNpYmxlID8gJ2lzLWFjdGl2ZScgOiBudWxsXG5cbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICA8ZGl2IGJlbT0nJGI6Y29sb3JQaWNrZXInIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBvbkNsaWNrPXt0aGlzLl9vbkJ1dHRvbkNsaWNrfT5cbiAgICAgICAgPGNhbnZhcyBiZW09J2U6cHJldmlldycgcmVmPSdjYW52YXMnIC8+XG4gICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57dGhpcy5wcm9wcy5sYWJlbCB8fCB0aGlzLl90KCdnZW5lcmljLmNvbG9yJyl9PC9kaXY+XG4gICAgICAgIHtPdmVybGF5fVxuICAgICAgPC9kaXY+XG4gICAgPC9iZW0+KVxuICB9XG59XG5cbkNvbG9yUGlja2VyQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbG9yLXBpY2tlci9jb2xvci1waWNrZXItY29tcG9uZW50LmpzeCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEl0ZW1Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25JdGVtRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25JdGVtRHJhZ1N0b3AnLFxuICAgICAgJ19vbkl0ZW1EcmFnJyxcbiAgICAgICdfb25TcHJpdGVVcGRhdGUnXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ0FMQ1VMQVRJT05TXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBzcHJpdGVcbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRBYnNvbHV0ZVNwcml0ZVBvc2l0aW9uICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcblxuICAgIHJldHVybiB0aGlzLnByb3BzLnNwcml0ZS5nZXRQb3NpdGlvbigpXG4gICAgICAuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIHRoaXMucHJvcHMuc3ByaXRlLm9uKCd1cGRhdGUnLCB0aGlzLl9vblNwcml0ZVVwZGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHVubW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KClcbiAgICB0aGlzLnByb3BzLnNwcml0ZS5vZmYoJ3VwZGF0ZScsIHRoaXMuX29uU3ByaXRlVXBkYXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgd2lsbCByZWNlaXZlIG5ldyBwcm9wc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5leHRQcm9wc1xuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAobmV4dFByb3BzKSB7XG4gICAgdGhpcy5wcm9wcy5zcHJpdGUub2ZmKCd1cGRhdGUnLCB0aGlzLl9vblNwcml0ZVVwZGF0ZSlcbiAgICBuZXh0UHJvcHMuc3ByaXRlLm9uKCd1cGRhdGUnLCB0aGlzLl9vblNwcml0ZVVwZGF0ZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50J3Mgc3ByaXRlIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNwcml0ZVVwZGF0ZSAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhpcyBpdGVtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtRHJhZ1N0YXJ0ICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHNwcml0ZS5nZXRQb3NpdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0ICYmIHRoaXMucHJvcHMub25EcmFnU3RhcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoaXMgaXRlbVxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkl0ZW1EcmFnIChvZmZzZXQpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLl9pbml0aWFsUG9zaXRpb24uY2xvbmUoKVxuICAgICAgLmFkZChvZmZzZXQuZGl2aWRlKG91dHB1dERpbWVuc2lvbnMpKVxuXG4gICAgc3ByaXRlLnNldFBvc2l0aW9uKG5ld1Bvc2l0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhpcyBpdGVtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtRHJhZ1N0b3AgKCkge1xuICAgIHRoaXMucHJvcHMub25EcmFnU3RvcCAmJiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoKVxuICB9XG59XG5cbkl0ZW1Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc3ByaXRlcy9pdGVtcy9pdGVtLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdCwgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3dDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbCgnX29uQ2xpY2snKVxuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DbGljayAoZSkge1xuICAgIHRoaXMucHJvcHMub25DbGljayAmJiB0aGlzLnByb3BzLm9uQ2xpY2soKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyByb3cncyBjb250ZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQ29udGVudCAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBsZXQgcm93QkVNID0gYCRlOnJvdyBtOiR7dGhpcy5fbW9kaWZpZXJ9YFxuICAgIGlmICh0aGlzLnByb3BzLnRvdGFsUm93cykge1xuICAgICAgcm93QkVNICs9IGAgbTpyb3ctJHt0aGlzLnByb3BzLnRvdGFsUm93c31gXG4gICAgfVxuXG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nYjpzcGxhc2hTY3JlZW4nPlxuICAgICAgPGRpdiBiZW09e3Jvd0JFTX0+XG4gICAgICAgIHt0aGlzLl9yZW5kZXJDb250ZW50KCl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuUm93Q29tcG9uZW50LnByb3BUeXBlcyA9IHtcbiAgb25DbGljazogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbn1cblxuUm93Q29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvc3BsYXNoL3Jvdy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IEZpbGVMb2FkZXIgZnJvbSAnLi4vLi4vbGliL2ZpbGUtbG9hZGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZpc2libGVVcGxvYWRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25OZXdGaWxlJ1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLl9maWxlTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5yZWZzLmZpbGVJbnB1dClcbiAgICB0aGlzLl9maWxlTG9hZGVyLm9uKCdmaWxlJywgdGhpcy5fb25OZXdGaWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgdW5tb3VudGVkXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgdGhpcy5fZmlsZUxvYWRlci5vZmYoJ2ZpbGUnLCB0aGlzLl9vbk5ld0ZpbGUpXG4gICAgdGhpcy5fZmlsZUxvYWRlci5kaXNwb3NlKClcbiAgICB0aGlzLl9maWxlTG9hZGVyID0gbnVsbFxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIEZpbGVMb2FkZXIgZW1pdHMgYSBuZXcgZmlsZVxuICAgKiBAcGFyYW0gIHtGaWxlfSBmaWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25OZXdGaWxlIChmaWxlKSB7XG4gICAgdGhpcy5wcm9wcy5vbk5ld0ZpbGUgJiZcbiAgICAgIHRoaXMucHJvcHMub25OZXdGaWxlKGZpbGUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQVUJMSUMgQVBJXG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2QgZm9yIG9wZW5pbmcgdGhlIGZpbGUgbG9hZGVyXG4gICAqL1xuICBvcGVuICgpIHtcbiAgICB0aGlzLl9maWxlTG9hZGVyLm9wZW4oKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiA8aW5wdXQgdHlwZT0nZmlsZScgYmVtPSdiOmhpZGRlbkZpbGVJbnB1dCcgcmVmPSdmaWxlSW5wdXQnIC8+XG4gIH1cbn1cblxuSW52aXNpYmxlVXBsb2FkQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NoYXJlZC9pbnZpc2libGUtdXBsb2FkLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvcEJhckJ1dHRvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgLy8gQnVpbGQgQkVNIHNwZWNpZmllclxuICAgIGxldCBiZW0gPSAnJGU6YnV0dG9uJ1xuICAgIGlmICh0aGlzLnByb3BzLnN0eWxlKSB7XG4gICAgICBiZW0gKz0gYCBtOiR7dGhpcy5wcm9wcy5zdHlsZX1gXG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLmljb24pIHtcbiAgICAgIGJlbSArPSAnIG06d2l0aEljb24nXG4gICAgfVxuXG4gICAgLy8gQnVpbGQgaWNvblxuICAgIGxldCBpY29uID0gbnVsbFxuICAgIGlmICh0aGlzLnByb3BzLmljb24pIHtcbiAgICAgIGljb24gPSAoPGltZ1xuICAgICAgICBiZW09J2U6aWNvbidcbiAgICAgICAgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgodGhpcy5wcm9wcy5pY29uLCB0cnVlKX0gLz4pXG4gICAgfVxuXG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nJGI6dG9wQmFyJz5cbiAgICAgIDxkaXYgYmVtPXtiZW19IG9uQ2xpY2s9e3RoaXMucHJvcHMub25DbGlja30+XG4gICAgICAgIHtpY29ufVxuICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMucHJvcHMubGFiZWwgfHwgJ0J1dHRvbid9PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuVG9wQmFyQnV0dG9uQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NoYXJlZC90b3AtYmFyL2J1dHRvbi1jb21wb25lbnQuanN4IiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBTREssIFV0aWxzIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsdGVyTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLl9jYXRlZ29yaWVzQnlJZCA9IHt9XG4gICAgdGhpcy5fY2F0ZWdvcmllcyA9IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3JldHJvJyxcbiAgICAgICAgZmlsdGVyczogW1xuICAgICAgICAgIFNESy5GaWx0ZXJzLkNlbHNpdXNGaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuQ2hlc3RGaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuRml4aWVGaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuTGVuaW5GaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuUG9sYUZpbHRlcixcbiAgICAgICAgICBTREsuRmlsdGVycy5Qb2xhNjY5RmlsdGVyLFxuICAgICAgICAgIFNESy5GaWx0ZXJzLksxRmlsdGVyLFxuICAgICAgICAgIFNESy5GaWx0ZXJzLksyRmlsdGVyLFxuICAgICAgICAgIFNESy5GaWx0ZXJzLks2RmlsdGVyLFxuICAgICAgICAgIFNESy5GaWx0ZXJzLktEeW5hbWljRmlsdGVyXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdidycsXG4gICAgICAgIGZpbHRlcnM6IFtcbiAgICAgICAgICBTREsuRmlsdGVycy5CV0ZpbHRlcixcbiAgICAgICAgICBTREsuRmlsdGVycy5CV0hhcmRGaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuWDQwMEZpbHRlclxuICAgICAgICBdXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdzdW1tZXInLFxuICAgICAgICBmaWx0ZXJzOiBbXG4gICAgICAgICAgU0RLLkZpbHRlcnMuRnJvbnRGaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuTWVsbG93RmlsdGVyLFxuICAgICAgICAgIFNESy5GaWx0ZXJzLlNlbWlyZWRGaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuU3VubnlGaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuVGV4YXNGaWx0ZXJcbiAgICAgICAgXVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnd2ludGVyJyxcbiAgICAgICAgZmlsdGVyczogW1xuICAgICAgICAgIFNESy5GaWx0ZXJzLk1ldGFsRmlsdGVyLFxuICAgICAgICAgIFNESy5GaWx0ZXJzLkExNUZpbHRlcixcbiAgICAgICAgICBTREsuRmlsdGVycy5CcmVlemVGaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuRnJpZGdlRmlsdGVyLFxuICAgICAgICAgIFNESy5GaWx0ZXJzLk9yY2hpZEZpbHRlcixcbiAgICAgICAgICBTREsuRmlsdGVycy5RdW96aUZpbHRlclxuICAgICAgICBdXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdzcGVjaWFsJyxcbiAgICAgICAgZmlsdGVyczogW1xuICAgICAgICAgIFNESy5GaWx0ZXJzLkZvb2RGaWx0ZXIsXG4gICAgICAgICAgU0RLLkZpbHRlcnMuR2xhbUZpbHRlcixcbiAgICAgICAgICBTREsuRmlsdGVycy5Mb21vRmlsdGVyLFxuICAgICAgICAgIFNESy5GaWx0ZXJzLkdvYmJsaW5GaWx0ZXJcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cblxuICAgIHRoaXMuX2luaXRDYXRlZ29yaWVzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2F0ZWdvcmllc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRDYXRlZ29yaWVzICgpIHtcbiAgICAvLyBTaG91bGQgdGhlIGNhdGVnb3JpZXMgcGFzc2VkIGluIGJ5IHRoZSB1c2VyIHJlcGxhY2UgdGhlIGV4aXN0aW5nIG9uZXM/XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2F0ZWdvcmllcykge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMucmVwbGFjZUNhdGVnb3JpZXMpIHtcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IHRoaXMuX29wdGlvbnMuY2F0ZWdvcmllc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IFV0aWxzLm1lcmdlQ2F0ZWdvcmllcyhcbiAgICAgICAgICB0aGlzLl9jYXRlZ29yaWVzLFxuICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2F0ZWdvcmllcyxcbiAgICAgICAgICAnZmlsdGVycydcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBmaWx0ZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBzZWxlY3RhYmxlXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZUZpbHRlcnMpIHtcbiAgICAgIGNvbnN0IG5ld0NhdGVnb3JpZXMgPSBbXVxuICAgICAgdGhpcy5fY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSkgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJzID0gY2F0ZWdvcnkuZmlsdGVycy5maWx0ZXIoKGYpID0+XG4gICAgICAgICAgdGhpcy5fb3B0aW9ucy5zZWxlY3RhYmxlRmlsdGVycy5pbmRleE9mKGYuaWRlbnRpZmllcikgIT09IC0xXG4gICAgICAgIClcbiAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5ld0NhdGVnb3JpZXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBjYXRlZ29yeS5uYW1lLFxuICAgICAgICAgICAgZmlsdGVyc1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLl9jYXRlZ29yaWVzID0gbmV3Q2F0ZWdvcmllc1xuICAgIH1cblxuICAgIGNvbnN0IGFsbENhdGVnb3J5ID0ge1xuICAgICAgbmFtZTogJ2FsbCcsXG4gICAgICBmaWx0ZXJzOiB0aGlzLl9jYXRlZ29yaWVzXG4gICAgICAgIC5tYXAoKGMpID0+IGMuZmlsdGVycylcbiAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpXG4gICAgfVxuICAgIHRoaXMuX2NhdGVnb3JpZXMudW5zaGlmdChhbGxDYXRlZ29yeSlcbiAgICB0aGlzLl9jYXRlZ29yaWVzLmZvckVhY2goKGMpID0+IHsgdGhpcy5fY2F0ZWdvcmllc0J5SWRbYy5uYW1lXSA9IGMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXJzIGZvciB0aGUgY2F0ZWdvcnkgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNhdGVnb3J5TmFtZVxuICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICovXG4gIGdldEZpbHRlcnNGb3JDYXRlZ29yeSAoY2F0ZWdvcnlOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9jYXRlZ29yaWVzQnlJZFtjYXRlZ29yeU5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsdGVyIGNhdGVnb3J5ICcke2NhdGVnb3J5TmFtZX0nYClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhdGVnb3JpZXNCeUlkW2NhdGVnb3J5TmFtZV0uZmlsdGVyc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNhdGVnb3JpZXNcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRDYXRlZ29yaWVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcmllc1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvbWFuYWdlcnMvZmlsdGVyLW1hbmFnZXIuanMiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNjBfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9XG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzXG4gKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgYWRqdXN0bWVudHMgfSBmcm9tICcuL2FkanVzdG1lbnRzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjcm9wIH0gZnJvbSAnLi9jcm9wJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZm9jdXMgfSBmcm9tICcuL2ZvY3VzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdGlja2VyIH0gZnJvbSAnLi9zdGlja2VyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0ZXh0IH0gZnJvbSAnLi90ZXh0J1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBicnVzaCB9IGZyb20gJy4vYnJ1c2gnXG5leHBvcnQgeyBkZWZhdWx0IGFzIHNlbGVjdGl2ZUJsdXIgfSBmcm9tICcuL3NlbGVjdGl2ZS1ibHVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmcmFtZSB9IGZyb20gJy4vZnJhbWUnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2luZGV4LmpzIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENhdGVnb3J5RHJvcGRvd25PdmVybGF5Q29tcG9uZW50IGZyb20gJy4vb3ZlcmxheS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhdGVnb3J5RHJvcGRvd25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQnV0dG9uQ2xpY2snXG4gICAgKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG92ZXJsYXlWaXNpYmxlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBjb2xvciBwaWNrZXIgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJ1dHRvbkNsaWNrIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IG92ZXJsYXlWaXNpYmxlOiAhdGhpcy5zdGF0ZS5vdmVybGF5VmlzaWJsZSB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGxldCBPdmVybGF5ID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuc3RhdGUub3ZlcmxheVZpc2libGUpIHtcbiAgICAgIE92ZXJsYXkgPSAoPENhdGVnb3J5RHJvcGRvd25PdmVybGF5Q29tcG9uZW50XG4gICAgICAgIGl0ZW1zPXt0aGlzLnByb3BzLml0ZW1zfVxuICAgICAgICBzZWxlY3RlZEl0ZW09e3RoaXMucHJvcHMuc2VsZWN0ZWRJdGVtfVxuICAgICAgICBvbkNoYW5nZT17dGhpcy5wcm9wcy5vbkNoYW5nZX0gLz4pXG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5zdGF0ZS5vdmVybGF5VmlzaWJsZSA/ICdpcy1hY3RpdmUnIDogbnVsbFxuXG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgPGRpdiBiZW09JyRlOmNhdGVnb3J5RHJvcGRvd24nIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBvbkNsaWNrPXt0aGlzLl9vbkJ1dHRvbkNsaWNrfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLnByb3BzLnNlbGVjdGVkSXRlbS5pY29ufSAvPlxuICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMucHJvcHMuc2VsZWN0ZWRJdGVtLmxhYmVsfTwvZGl2PlxuICAgICAgICB7T3ZlcmxheX1cbiAgICAgIDwvZGl2PlxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5DYXRlZ29yeURyb3Bkb3duQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NhdGVnb3J5LWRyb3Bkb3duL2NhdGVnb3J5LWRyb3Bkb3duLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFNjcm9sbGJhckNvbXBvbmVudCBmcm9tICcuLi8uLi9zY3JvbGxiYXItY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdmVydmlld0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5faGFzQmFja0J1dHRvbiA9IGZhbHNlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBpdGVtIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkl0ZW1DbGljayAoY29udHJvbHMpIHtcbiAgICB0aGlzLnByb3BzLm9uU3dpdGNoQ29udHJvbHMoY29udHJvbHMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBpdGVtcyBmb3IgdGhpcyBjb250cm9sXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaXN0SXRlbXMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGxldCBpdGVtcyA9IFtdXG4gICAgY29uc3QgbWFrZUl0ZW0gPSAoaWRlbnRpZmllcikgPT4ge1xuICAgICAgY29uc3QgY29udHJvbCA9IGVkaXRvci5jb250cm9scy5nZXQoaWRlbnRpZmllcilcbiAgICAgIHJldHVybiAoPGxpXG4gICAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAgICBrZXk9e2NvbnRyb2wuaWRlbnRpZmllcn1cbiAgICAgICAgZGF0YS1pZGVudGlmaWVyPXtjb250cm9sLmlkZW50aWZpZXJ9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uSXRlbUNsaWNrLmJpbmQodGhpcywgY29udHJvbCl9PlxuICAgICAgICA8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgICAgIDxkaXYgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnPlxuICAgICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoY29udHJvbC5pY29uUGF0aCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoY29udHJvbC5sYW5ndWFnZUtleSl9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvYmVtPlxuICAgICAgPC9saT4pXG4gICAgfVxuXG4gICAgY29uc3QgeyBjb250cm9sc09yZGVyIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucy5lZGl0b3JcbiAgICBjb250cm9sc09yZGVyLmZvckVhY2goKGdyb3VwT3JJZGVudGlmaWVyKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShncm91cE9ySWRlbnRpZmllcikpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cE9ySWRlbnRpZmllclxuXG4gICAgICAgIGxldCBncm91cEl0ZW1zID0gW11cbiAgICAgICAgZ3JvdXAuZm9yRWFjaCgoaWRlbnRpZmllcikgPT4ge1xuICAgICAgICAgIGlmICghZWRpdG9yLmNvbnRyb2xzLmlzRW5hYmxlZChpZGVudGlmaWVyKSkgcmV0dXJuXG4gICAgICAgICAgZ3JvdXBJdGVtcy5wdXNoKG1ha2VJdGVtKGlkZW50aWZpZXIpKVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChncm91cEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goZ3JvdXBJdGVtcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGdyb3VwT3JJZGVudGlmaWVyXG4gICAgICAgIGlmICghZWRpdG9yLmNvbnRyb2xzLmlzRW5hYmxlZChpZGVudGlmaWVyKSkgcmV0dXJuXG4gICAgICAgIGl0ZW1zLnB1c2gobWFrZUl0ZW0oaWRlbnRpZmllcikpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGxldCBmaW5hbEl0ZW1zID0gW11cbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtT3JHcm91cCkgPT4ge1xuICAgICAgZmluYWxJdGVtcyA9IGZpbmFsSXRlbXMuY29uY2F0KGl0ZW1Pckdyb3VwKVxuICAgICAgaWYgKGl0ZW1Pckdyb3VwICE9PSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSkge1xuICAgICAgICBmaW5hbEl0ZW1zLnB1c2goPGxpIGJlbT0nZTpzZXBhcmF0b3InIC8+KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gZmluYWxJdGVtc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlckNvbnRyb2xzICgpIHtcbiAgICBjb25zdCBsaXN0SXRlbXMgPSB0aGlzLl9yZW5kZXJMaXN0SXRlbXMoKVxuXG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nZTpjZWxsIG06bGlzdCc+XG4gICAgICA8U2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgICAgICA8dWwgYmVtPSckZTpsaXN0Jz5cbiAgICAgICAgICB7bGlzdEl0ZW1zfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9TY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cbk92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L292ZXJ2aWV3LWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbnRQcmV2aWV3Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG4gICAgdGhpcy5fcmVuZGVyQ2FudmFzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIHRoaXMuX3JlbmRlckNhbnZhcygpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDQU5WQVMgUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgZm9udCBmYW1pbHkgb250byB0aGUgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQ2FudmFzICgpIHtcbiAgICBjb25zdCB7IGNhbnZhcyB9ID0gdGhpcy5yZWZzXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHNkayA9IGVkaXRvci5nZXRTREsoKVxuXG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHNkay5nZXRQaXhlbFJhdGlvKClcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGggKiBwaXhlbFJhdGlvXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHQgKiBwaXhlbFJhdGlvXG5cbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjYW52YXMub2Zmc2V0V2lkdGh9cHhgXG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NhbnZhcy5vZmZzZXRIZWlnaHR9cHhgXG5cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JlZCdcbiAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgICBjb250ZXh0LmZvbnQgPSBgJHt0aGlzLnByb3BzLmZvbnRTdHlsZSB8fCAnJ30gJHt0aGlzLnByb3BzLmZvbnRXZWlnaHQgfHwgJyd9ICR7MjQgKiBwaXhlbFJhdGlvfXB4ICR7dGhpcy5wcm9wcy5mb250RmFtaWx5fWBcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnXG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJ1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJ1xuXG4gICAgY29udGV4dC5maWxsVGV4dCgnQWJjJywgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8Y2FudmFzIGJlbT0nYjpmb250RmFtaWx5IGU6Y2FudmFzJyByZWY9J2NhbnZhcycgLz4pXG4gIH1cbn1cblxuRm9udFByZXZpZXdDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvdGV4dC9mb250LXByZXZpZXctY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoU3VnZ2VzdGlvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkNsaWNrJ1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgc2VhcmNoIHN1Z2dlc3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNsaWNrICgpIHtcbiAgICB0aGlzLnByb3BzLm9uQ2xpY2sgJiZcbiAgICAgIHRoaXMucHJvcHMub25DbGljayh0aGlzLnByb3BzLnNlYXJjaFN1Z2dlc3Rpb24pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgeyBzZWFyY2hTdWdnZXN0aW9uIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJHtzZWFyY2hTdWdnZXN0aW9uLmNvdmVySW1hZ2V9KWBcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGJlbSBzcGVjaWZpZXI9J2I6cGhvdG9Sb2xsIGU6bGlicmFyeUxpc3QnPlxuICAgICAgICA8bGkgYmVtPSdlOml0ZW0nIHN0eWxlPXtzdHlsZX0gb25DbGljaz17dGhpcy5fb25DbGlja30+XG4gICAgICAgICAgPGRpdiBiZW09J2U6b3ZlcmxheScgLz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpuYW1lJz57c2VhcmNoU3VnZ2VzdGlvbi5xdWVyeX08L2Rpdj5cbiAgICAgICAgPC9saT5cbiAgICAgIDwvYmVtPlxuICAgIClcbiAgfVxufVxuXG5TZWFyY2hTdWdnZXN0aW9uQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9pdGVtcy9zZWFyY2gtc3VnZ2VzdGlvbi1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cbmltcG9ydCB7IFZlY3RvcjIsIFV0aWxzLCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgTW9kYWxNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2xpYi9tb2RhbC1tYW5hZ2VyJ1xuaW1wb3J0IFBob3RvQ29tcG9uZW50IGZyb20gJy4vaXRlbXMvcGhvdG8tY29tcG9uZW50J1xuaW1wb3J0IFNjcm9sbGJhckNvbXBvbmVudCBmcm9tICcuLi8uLi9zY3JvbGxiYXItY29tcG9uZW50J1xuXG5jb25zdCBDT0xVTU5fV0lEVEggPSAyNDBcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGhvdG9MaXN0Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX25lZWRzU3R5bGVGaXhlcyA9IHRydWVcbiAgICB0aGlzLl90b3RhbFBob3Rvc0hlaWdodCA9IDBcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICBwaG90b3M6IFtdXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIHRoaXMuX2xvYWRQaG90b3MoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlICguLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMucmVmcy5zY3JvbGxiYXIpIHtcbiAgICAgIHRoaXMucmVmcy5zY3JvbGxiYXIudXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYSBwaG90b1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlBob3RvUm9sbC5QaG90b30gcGhvdG9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblBob3RvQ2xpY2tlZCAocGhvdG8pIHtcbiAgICB0aGlzLnByb3BzLm9uUGhvdG9DbGlja2VkICYmXG4gICAgICB0aGlzLnByb3BzLm9uUGhvdG9DbGlja2VkKHBob3RvKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWFkbGluZSBmb3IgdGhpcyB2aWV3XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRIZWFkbGluZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMubGlicmFyeS5uYW1lXG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgc3R5bGVzIG5lZWQgdG8gYmUgZml4ZWQgYnkgdGhlIEphdmFTY3JpcHQuXG4gICAqIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSB0aGFua3MgdG8gb2xkZXIgSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlcnMgd2hpY2ggaGF2ZVxuICAgKiBhIGJ1bmNoIG9mIENTUyBidWdzLlxuICAgKi9cbiAgZml4U3R5bGVzICgpIHtcbiAgICBpZiAoVXRpbHMuQnJvd3Nlci5pc0lFbHRlKDExKSkge1xuICAgICAgY29uc3QgeyBjZWxsIH0gPSB0aGlzLnJlZnNcbiAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLnJlZnMuc2Nyb2xsYmFyLmdldExpc3QoKVxuICAgICAgaWYgKCEoY2VsbCAmJiBsaXN0KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbGxIZWlnaHQgPSBjZWxsLm9mZnNldEhlaWdodFxuICAgICAgbGlzdC5zdHlsZS5oZWlnaHQgPSBgJHtjZWxsSGVpZ2h0fXB4YFxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlZnMuc2Nyb2xsYmFyKSB7XG4gICAgICB0aGlzLnJlZnMuc2Nyb2xsYmFyLnVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTE9BRElOR1xuXG4gIF9yZW5kZXJDb2x1bW5zICgpIHtcbiAgICBjb25zdCB7IHBob3RvcyB9ID0gdGhpcy5zdGF0ZVxuICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gM1xuICAgIGNvbnN0IGNvbHVtbkhlaWdodHMgPSBbXVxuXG4gICAgY29uc3QgY29sdW1ucyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICBjb2x1bW5zLnB1c2goW10pXG4gICAgICBjb2x1bW5IZWlnaHRzLnB1c2goMClcbiAgICB9XG5cbiAgICBwaG90b3MuZm9yRWFjaCgocGhvdG8pID0+IHtcbiAgICAgIGNvbnN0IHsgZGltZW5zaW9ucyB9ID0gcGhvdG9cblxuICAgICAgLy8gRmluZCBzaG9ydGVzdCBjb2x1bW5cbiAgICAgIGxldCBzaG9ydGVzdENvbHVtbkluZGV4ID0gbnVsbFxuICAgICAgbGV0IHNob3J0ZXN0Q29sdW1uSGVpZ2h0ID0gSW5maW5pdHlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICBpZiAoY29sdW1uSGVpZ2h0c1tpXSA8IHNob3J0ZXN0Q29sdW1uSGVpZ2h0KSB7XG4gICAgICAgICAgc2hvcnRlc3RDb2x1bW5JbmRleCA9IGlcbiAgICAgICAgICBzaG9ydGVzdENvbHVtbkhlaWdodCA9IGNvbHVtbkhlaWdodHNbaV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb2x1bW5zW3Nob3J0ZXN0Q29sdW1uSW5kZXhdLnB1c2goPFBob3RvQ29tcG9uZW50XG4gICAgICAgIHBob3RvPXtwaG90by5vYmp9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uUGhvdG9DbGlja2VkLmJpbmQodGhpcywgcGhvdG8ub2JqKX0gLz4pXG4gICAgICBjb2x1bW5IZWlnaHRzW3Nob3J0ZXN0Q29sdW1uSW5kZXhdICs9IGRpbWVuc2lvbnMueVxuICAgIH0pXG5cbiAgICByZXR1cm4gY29sdW1uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRlbnQgZm9yIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyUGhvdG9zICgpIHtcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5fcmVuZGVyQ29sdW1ucygpXG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nJGI6cGhvdG9Sb2xsIGU6cm93IG06ZnVsbEhlaWdodCc+XG4gICAgICA8ZGl2IGJlbT0nZTpjZWxsJyByZWY9J2NlbGwnPlxuICAgICAgICA8U2Nyb2xsYmFyQ29tcG9uZW50IGRpcmVjdGlvbj0ndmVydGljYWwnIHJlZj0nc2Nyb2xsYmFyJz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpjb250YWluZXInIHJlZj0nY29udGFpbmVyJz5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOmlubmVyQ29udGFpbmVyJz5cbiAgICAgICAgICAgICAgPGRpdiBiZW09J2U6aGVhZGxpbmUnPnt0aGlzLl9nZXRIZWFkbGluZSgpfTwvZGl2PlxuICAgICAgICAgICAgICA8YmVtIHNwZWNpZmllcj0nZTpwaG90b0xpc3QnPlxuICAgICAgICAgICAgICAgIHtjb2x1bW5zLm1hcCgoY29sdW1uKSA9PlxuICAgICAgICAgICAgICAgICAgPHVsIGJlbT0nJGU6bGlzdCc+e2NvbHVtbn08L3VsPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvYmVtPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvU2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBwaG90b3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkUGhvdG9zICgpIHtcbiAgICB0aGlzLl90b3RhbFBob3Rvc0hlaWdodCA9IDBcblxuICAgIGNvbnN0IG1vZGFsID0gTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlQcm9ncmVzcyh0aGlzLl90KCdsb2FkaW5nLmxvYWRpbmcnKSlcbiAgICBjb25zdCBQaG90b1JvbGxQcm92aWRlciA9IHRoaXMuY29udGV4dC5vcHRpb25zLnBob3RvUm9sbC5wcm92aWRlclxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFBob3RvUm9sbFByb3ZpZGVyKClcblxuICAgIHByb3ZpZGVyLmdldFBob3Rvc0ZvckxpYnJhcnkodGhpcy5wcm9wcy5saWJyYXJ5KVxuICAgICAgLnRoZW4oKHBob3RvcykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlbG9hZFBob3RvcyhwaG90b3MsIG1vZGFsKVxuICAgICAgfSlcbiAgICAgIC50aGVuKChwaG90b3MpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHBob3RvcywgbG9hZGluZzogZmFsc2UgfSlcbiAgICAgICAgbW9kYWwuY2xvc2UoKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgICBtb2RhbC5jbG9zZSgpXG4gICAgICAgIE1vZGFsTWFuYWdlci5pbnN0YW5jZS5kaXNwbGF5RXJyb3IodGhpcy5fdCgnZXJyb3JzLnBob3RvUm9sbExvYWRGYWlsLnRpdGxlJyksIHRoaXMuX3QoJ2Vycm9ycy5waG90b1JvbGxMb2FkRmFpbC50ZXh0JywgeyBlcnJvcjogZS5tZXNzYWdlIH0pKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVsb2FkcyB0aGUgcGhvdG9zXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5QaG90b1JvbGwuUGhvdG9bXX0gcGhvdG9zXG4gICAqIEBwYXJhbSB7TW9kYWx9IG1vZGFsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJlbG9hZFBob3RvcyAocGhvdG9zLCBtb2RhbCkge1xuICAgIGNvbnN0IHRvdGFsUGhvdG9zID0gcGhvdG9zLmxlbmd0aFxuICAgIGxldCBsb2FkZWRQaG90b3MgPSAwXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBob3Rvcy5tYXAoKHBob3RvKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJlbG9hZFBob3RvKHBob3RvKVxuICAgICAgICAudGhlbigoaW1hZ2UpID0+IHtcbiAgICAgICAgICBjb25zdCBwaG90b0RpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KVxuICAgICAgICAgIHBob3RvRGltZW5zaW9ucy5tdWx0aXBseShDT0xVTU5fV0lEVEggLyBpbWFnZS53aWR0aClcbiAgICAgICAgICB0aGlzLl90b3RhbFBob3Rvc0hlaWdodCArPSBwaG90b0RpbWVuc2lvbnMueVxuXG4gICAgICAgICAgbG9hZGVkUGhvdG9zKytcbiAgICAgICAgICBtb2RhbC5zZXREYXRhKHsgcHJvZ3Jlc3M6IGxvYWRlZFBob3RvcyAvIHRvdGFsUGhvdG9zIH0pXG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2JqOiBwaG90byxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHBob3RvRGltZW5zaW9uc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVsb2FkcyB0aGUgZ2l2ZW4gcGhvdG9cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5QaG90b1JvbGwuUGhvdG99IHBob3RvXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJlbG9hZFBob3RvIChwaG90bykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShpbWFnZSlcbiAgICAgIH0pXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShpbWFnZSlcbiAgICAgIH0pXG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnXG4gICAgICBpbWFnZS5zcmMgPSBwaG90by51cmxzLnRodW1iXG4gICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUubG9hZGluZykge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBob3RvcygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiA8ZGl2IC8+XG4gICAgfVxuICB9XG59XG5cblBob3RvTGlzdENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvcGhvdG8tbGlzdC1jb21wb25lbnQuanN4IiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5jb25zdCBlbGVtZW50U2VwYXJhdG9yID0gJ19fJ1xuY29uc3QgbW9kaWZpZXJTZXBhcmF0b3IgPSAnLS0nXG5jb25zdCBibG9ja1ByZWZpeCA9ICdwZXNkay1yZWFjdC0nXG5cbmNsYXNzIEJFTU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yIChwYXJlbnQsIHR5cGUsIG5hbWUpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgICB0aGlzLl90eXBlID0gdHlwZVxuICAgIHRoaXMuX25hbWUgPSBuYW1lXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJFTU9iamVjdCBvZiB0eXBlIFwiZWxlbWVudFwiIHRoYXQgaGFzIHRoaXMgZWxlbWVudCBhcyBwYXJlbnRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge0JFTU9iamVjdH1cbiAgICovXG4gIGVsZW1lbnQgKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEJFTU9iamVjdCh0aGlzLCAnZWxlbWVudCcsIG5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJFTU9iamVjdCBvZiB0eXBlIFwibW9kaWZpZXJcIiB0aGF0IGhhcyB0aGlzIGVsZW1lbnQgYXMgcGFyZW50XG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtCRU1PYmplY3R9XG4gICAqL1xuICBtb2RpZmllciAobmFtZSkge1xuICAgIHJldHVybiBuZXcgQkVNT2JqZWN0KHRoaXMsICdtb2RpZmllcicsIG5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBjbGFzcyBuYW1lIGZvciB0aGlzIEJFTU9iamVjdFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgc3RyICgpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuc3RyIDogJydcbiAgICBzd2l0Y2ggKHRoaXMuX3R5cGUpIHtcbiAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgcmVzcG9uc2UgKz0gYCR7YmxvY2tQcmVmaXh9JHt0aGlzLl9uYW1lfWBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2VsZW1lbnQnOlxuICAgICAgICByZXNwb25zZSArPSBgJHtlbGVtZW50U2VwYXJhdG9yfSR7dGhpcy5fbmFtZX1gXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIHJlc3BvbnNlICs9IGAke21vZGlmaWVyU2VwYXJhdG9yfSR7dGhpcy5fbmFtZX1gXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCRU1PYmplY3Qgb2YgdHlwZSBcImJsb2NrXCIgdGhhdCBoYXMgdGhpcyBlbGVtZW50IGFzIHBhcmVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7QkVNT2JqZWN0fVxuICAgKi9cbiAgYmxvY2sgKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEJFTU9iamVjdChudWxsLCAnYmxvY2snLCBuYW1lKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvYmVtLmpzeCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHtcbiAgRXZlbnRFbWl0dGVyLCBTREssIENvbnN0YW50cywgVmVjdG9yMiwgVXRpbHMsXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUsIFByb21pc2UsIExvZ1xufSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IEV4cG9ydGVyIGZyb20gJy4vZXhwb3J0ZXInXG5pbXBvcnQgSW1hZ2VSZXNpemVyIGZyb20gJy4vaW1hZ2UtcmVzaXplcidcblxuaW1wb3J0IEVkaXRvck9wZXJhdGlvbnMgZnJvbSAnLi9lZGl0b3Ivb3BlcmF0aW9ucydcbmltcG9ydCBFZGl0b3JDb250cm9scyBmcm9tICcuL2VkaXRvci9jb250cm9scydcbmltcG9ydCBFZGl0b3JGZWF0dXJlcyBmcm9tICcuL2VkaXRvci9mZWF0dXJlcydcbmltcG9ydCBFZGl0b3Jab29tIGZyb20gJy4vZWRpdG9yL3pvb20nXG5pbXBvcnQgRWRpdG9ySGlzdG9yeSBmcm9tICcuL2VkaXRvci9oaXN0b3J5J1xuXG4vKipcbiAqIFRoZSBFZGl0b3IgY2xhc3MgaXMgYW4gaW50ZXJmYWNlIHRvIHRoZSBTREssIG1hbmFnaW5nIG9wZXJhdGlvbnMsIHJlbmRlcmluZyxcbiAqIGhpc3RvcnksIHpvb20gZXRjLlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSVxuICovXG5jbGFzcyBFZGl0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAodWksIG9wdGlvbnMsIG1lZGlhdG9yLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fdWkgPSB1aVxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5fbWVkaWF0b3IgPSBtZWRpYXRvclxuICAgIHRoaXMuX3JlYWR5ID0gZmFsc2VcbiAgICB0aGlzLl9wYWRkaW5nID0gWzAsIDAsIDAsIDBdXG5cbiAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgIHRoaXMuX2luaXRTREsoKVxuXG4gICAgICB0aGlzLl9vblpvb20gPSB0aGlzLl9vblpvb20uYmluZCh0aGlzKVxuICAgICAgdGhpcy5fb25VbmRvID0gdGhpcy5fb25VbmRvLmJpbmQodGhpcylcbiAgICAgIHRoaXMub3BlcmF0aW9ucyA9IG5ldyBFZGl0b3JPcGVyYXRpb25zKHRoaXMsIHRoaXMuX3NkaywgdGhpcy5fbWVkaWF0b3IpXG5cbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBFZGl0b3JIaXN0b3J5KHRoaXMsIHRoaXMuX3NkaywgdGhpcy5fbWVkaWF0b3IpXG4gICAgICB0aGlzLmhpc3Rvcnkub24oJ3VuZG8nLCB0aGlzLl9vblVuZG8pXG4gICAgICB0aGlzLnpvb20gPSBuZXcgRWRpdG9yWm9vbSh0aGlzLCB0aGlzLl9zZGssIHRoaXMuX21lZGlhdG9yKVxuICAgICAgdGhpcy56b29tLm9uKCdzZXQnLCB0aGlzLl9vblpvb20pXG5cbiAgICAgIHRoaXMuX2luaXRTZXJpYWxpemVycygpXG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9scyA9IG5ldyBFZGl0b3JDb250cm9scyh0aGlzLCB0aGlzLl9zZGssIHRoaXMuX21lZGlhdG9yKVxuICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgRWRpdG9yRmVhdHVyZXModGhpcywgdGhpcy5fc2RrLCB0aGlzLl9tZWRpYXRvcilcblxuICAgIC8vIFJlbmRlcmluZ1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZVxuICAgIHRoaXMuX3JlbmRlclJlcXVlc3RlZCA9IHRydWVcbiAgICB0aGlzLl9yZW5kZXJDYWxsYmFja3MgPSBbXVxuICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lUmVxdWVzdCA9IG51bGxcblxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuX3RpY2sgPSB0aGlzLl90aWNrLmJpbmQodGhpcylcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIElOSVRJQUxJWkFUSU9OXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIGltYWdlIHRvIGJlIHJlbmRlcmVkLiBJZiB0aGUgaW1hZ2UgbmVlZHMgdG8gYmUgcmVzaXplZCB0byBmaXQgaW50byBhXG4gICAqIFdlYkdMIHRleHR1cmUgb3IgdG8gbWF0Y2ggdGhlIGBtYXhNZWdhUGl4ZWxzYCBvcHRpb24sIHJlc2l6aW5nIGlzIGRvbmUgYmVmb3JlIHNldHRpbmdcbiAgICogdGhlIGltYWdlLlxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlc2V0RWRpdG9yIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIHNldEltYWdlIChpbWFnZSA9IHRoaXMuX29wdGlvbnMuZWRpdG9yLmltYWdlLCByZXNldEVkaXRvciA9IHRydWUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3Nkay5nZXRSZW5kZXJlcigpXG4gICAgY29uc3QgaW5pdGlhbERpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KVxuICAgIGNvbnN0IG1heFBpeGVscyA9IHRoaXMuZ2V0TWF4TWVnYXBpeGVscygpICogMTAwMDAwMFxuICAgIGNvbnN0IG1heERpbWVuc2lvbnMgPSByZW5kZXJlci5nZXRNYXhEaW1lbnNpb25zKClcblxuICAgIGlmIChyZXNldEVkaXRvcikge1xuICAgICAgdGhpcy5yZXNldCgpXG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2VSZXNpemVyID0gbmV3IEltYWdlUmVzaXplcihcbiAgICAgIGltYWdlLFxuICAgICAgbWF4UGl4ZWxzLFxuICAgICAgbWF4RGltZW5zaW9uc1xuICAgIClcbiAgICBsZXQgZXhpZiA9IG51bGxcblxuICAgIGNvbnN0IGRvbmUgPSAoaW1hZ2UsIGRpbWVuc2lvbnMgPSBpbml0aWFsRGltZW5zaW9ucywgcmVzaXplUmVhc29uID0gbnVsbCkgPT4ge1xuICAgICAgdGhpcy5fc2V0SW1hZ2UoaW1hZ2UsIGV4aWYsIGRpbWVuc2lvbnMpXG5cbiAgICAgIHRoaXMuX2luaXRXYXRlcm1hcmsoKVxuXG4gICAgICB0aGlzLl9yZWFkeSA9IHRydWVcbiAgICAgIHRoaXMuZW1pdCgncmVhZHknKVxuICAgIH1cblxuICAgIGlmICghaW1hZ2VSZXNpemVyLm5lZWRzUmVzaXplKCkpIHtcbiAgICAgIGRvbmUoaW1hZ2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgncmVzaXplJylcbiAgICAgIGV4aWYgPSB0aGlzLl9zZGsucGFyc2VFeGlmKGltYWdlKVxuICAgICAgaW1hZ2VSZXNpemVyLnJlc2l6ZSgpXG4gICAgICAgIC50aGVuKCh7IGNhbnZhcywgZGltZW5zaW9ucywgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAvLyBGbGFnIGNhbnZhcyBhcyBKUEVHIHNvIHRoYXQgZXhwb3J0IHdpbGwgcmVjb2duaXplIHRoYXRcbiAgICAgICAgICAvLyBpdCBuZWVkcyB0byByZXN0b3JlIEVYSUYgZGF0YVxuICAgICAgICAgIGNhbnZhcy5zcmMgPSAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnXG5cbiAgICAgICAgICB0aGlzLmVtaXQoJ3Jlc2l6ZWQnLCB7IGRpbWVuc2lvbnMsIHJlYXNvbiB9KVxuICAgICAgICAgIGRvbmUoY2FudmFzLCBkaW1lbnNpb25zLCByZWFzb24pXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSB3YXRlcm1hcmsgb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFdhdGVybWFyayAoKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZWRpdG9yLndhdGVybWFya0ltYWdlKSB7XG4gICAgICB0aGlzLl93YXRlcm1hcmtPcGVyYXRpb24gPSB0aGlzLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3dhdGVybWFyaycsIHtcbiAgICAgICAgaW1hZ2U6IHRoaXMuX29wdGlvbnMuZWRpdG9yLndhdGVybWFya0ltYWdlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgU0RLXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFNESyAoKSB7XG4gICAgY29uc3QgeyBsb2dMZXZlbCwgZGlzcGxheVdlbGNvbWVNZXNzYWdlLCBkZWJ1ZywgYXBpS2V5IH0gPSB0aGlzLl9vcHRpb25zXG4gICAgY29uc3QgeyBzbW9vdGhEb3duc2NhbGluZywgc21vb3RoVXBzY2FsaW5nLCBwcmVmZXJyZWRSZW5kZXJlciwgcGl4ZWxSYXRpbyB9ID0gdGhpcy5fb3B0aW9ucy5lZGl0b3JcbiAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICBsb2dMZXZlbCxcbiAgICAgIGRlYnVnLFxuICAgICAgZGlzcGxheVdlbGNvbWVNZXNzYWdlLFxuICAgICAgcGl4ZWxSYXRpbyxcbiAgICAgIHNtb290aERvd25zY2FsaW5nLFxuICAgICAgc21vb3RoVXBzY2FsaW5nLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBhcGlLZXlcbiAgICB9XG4gICAgdGhpcy5fc2RrID0gbmV3IFNESyhwcmVmZXJyZWRSZW5kZXJlciwgcmVuZGVyZXJPcHRpb25zKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gWk9PTUlOR1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciBhIG5ldyB6b29tIGxldmVsIGhhcyBiZWVuIHNldC4gUmUtcmVuZGVycyB0aGUgZWRpdG9yLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHpvb21cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblpvb20gKHpvb20sIGNhbGxiYWNrID0gbnVsbCkge1xuICAgIHRoaXMuZml4T2Zmc2V0KClcbiAgICB0aGlzLnJlbmRlcigoKSA9PiB7XG4gICAgICB0aGlzLl9tZWRpYXRvci5lbWl0KENvbnN0YW50cy5FVkVOVFMuWk9PTV9ET05FKVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgYW4gdW5kbyBoYXBwZW5lZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uVW5kbyAoKSB7XG4gICAgdGhpcy5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcm90YXRpb25cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0Um90YXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zZGsuZ2V0Um90YXRpb24oKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJvdGF0aW9uIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cbiAgICovXG4gIHNldFJvdGF0aW9uIChyb3RhdGlvbikge1xuICAgIHRoaXMuX3Nkay5zZXRSb3RhdGlvbihyb3RhdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNwcml0ZSBzY2FsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRTcHJpdGVTY2FsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nkay5nZXRTcHJpdGVTY2FsZSgpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3ByaXRlIHNjYWxlIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3ByaXRlU2NhbGVcbiAgICovXG4gIHNldFNwcml0ZVNjYWxlIChzcHJpdGVTY2FsZSkge1xuICAgIHRoaXMuX3Nkay5zZXRTcHJpdGVTY2FsZShzcHJpdGVTY2FsZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0MgUFJJVkFURSBBUElcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjb250cm9sIHdpdGggdGhlIHRvb2wgaWRlbnRpZmllciBpcyBlbmFibGVkXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIGlkZW50aWZpZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzVG9vbEVuYWJsZWQgKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5lZGl0b3IudG9vbHMuaW5kZXhPZihpZGVudGlmaWVyKSAhPT0gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG1lZ2EgcGl4ZWxzXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1heE1lZ2FwaXhlbHMgKCkge1xuICAgIGNvbnN0IHsgbWF4TWVnYVBpeGVscyB9ID0gdGhpcy5fb3B0aW9ucy5lZGl0b3JcbiAgICByZXR1cm4gVXRpbHMuaXNNb2JpbGUoKSA/IG1heE1lZ2FQaXhlbHMubW9iaWxlIDogbWF4TWVnYVBpeGVscy5kZXNrdG9wXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDIFBVQkxJQyBBUElcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3V0cHV0IHNwcml0ZSdzIGN1cnJlbnQgZGltZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluY29ycG9yYXRlU3ByaXRlU2NhbGUgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRPdXRwdXREaW1lbnNpb25zIChpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fc2RrLmdldE91dHB1dERpbWVuc2lvbnMoaW5jb3Jwb3JhdGVTcHJpdGVTY2FsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdXRwdXQgdGV4dHVyZSdzIGN1cnJlbnQgZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlID0gZmFsc2VcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0T3V0cHV0VGV4dHVyZURpbWVuc2lvbnMgKGluY29ycG9yYXRlU3ByaXRlU2NhbGUgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLl9zZGsuZ2V0T3V0cHV0VGV4dHVyZURpbWVuc2lvbnMoaW5jb3Jwb3JhdGVTcHJpdGVTY2FsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaW5hbCBkaW1lbnNpb25zIHRoYXQgdGhlIGlucHV0IGltYWdlIHdvdWxkIGhhdmVcbiAgICogYWZ0ZXIgYWxsIGV4aXN0aW5nIG9wZXJhdGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlID0gZmFsc2VcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0RmluYWxEaW1lbnNpb25zIChpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fc2RrLmdldEZpbmFsRGltZW5zaW9ucyhpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNhbnZhcyBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHN1YnRyYWN0UGFkZGluZyA9IHRydWVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0Q2FudmFzRGltZW5zaW9ucyAoc3VidHJhY3RQYWRkaW5nID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX3Nkay5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihjYW52YXMub2Zmc2V0V2lkdGgsIGNhbnZhcy5vZmZzZXRIZWlnaHQpXG4gICAgaWYgKHN1YnRyYWN0UGFkZGluZykge1xuICAgICAgZGltZW5zaW9ucy5zdWJ0cmFjdChcbiAgICAgICAgdGhpcy5fcGFkZGluZ1sxXSArIHRoaXMuX3BhZGRpbmdbM10sXG4gICAgICAgIHRoaXMuX3BhZGRpbmdbMF0gKyB0aGlzLl9wYWRkaW5nWzJdXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb25zXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gaW1hZ2VcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FWElGfSBbZXhpZl1cbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IFtkaW1lbnNpb25zXVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEltYWdlIChpbWFnZSA9IHRoaXMuX29wdGlvbnMuZWRpdG9yLmltYWdlLCBleGlmID0gbnVsbCwgZGltZW5zaW9ucyA9IG51bGwpIHtcbiAgICAvLyBJbnZhbGlkYXRlIGNhY2hlc1xuICAgIHRoaXMuX3Nkay5zZXRBbGxPcGVyYXRpb25zVG9EaXJ0eSgpXG5cbiAgICB0aGlzLl9vcHRpb25zLmVkaXRvci5pbWFnZSA9IGltYWdlXG4gICAgdGhpcy5fc2RrLnNldEltYWdlKGltYWdlLCBleGlmLCBkaW1lbnNpb25zKVxuXG4gICAgdGhpcy56b29tLnNldCgnYXV0bycpXG5cbiAgICB0aGlzLmVtaXQoJ25ldy1pbWFnZScpXG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0cyBhbiBpbWFnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRvd25sb2FkID0gZmFsc2VcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGV4cG9ydCAoZG93bmxvYWQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl93YXRlcm1hcmtPcGVyYXRpb24pIHtcbiAgICAgIHRoaXMuX3dhdGVybWFya09wZXJhdGlvbi5zZXRFbmFibGVkKGZhbHNlKVxuICAgIH1cblxuICAgIC8vIEludmFsaWRhdGUgY2FjaGVzXG4gICAgdGhpcy5fc2RrLnNldEFsbE9wZXJhdGlvbnNUb0RpcnR5KClcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zLmVkaXRvci5leHBvcnRcbiAgICBjb25zdCBleHBvcnRlciA9IG5ldyBFeHBvcnRlcih0aGlzLl9zZGssIG9wdGlvbnMsIGRvd25sb2FkKVxuICAgIHJldHVybiBleHBvcnRlci5leHBvcnQoKVxuICAgICAgLnRoZW4oKG91dHB1dCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoJ2V4cG9ydCcsIG91dHB1dClcbiAgICAgICAgdGhpcy5fbWVkaWF0b3IuZW1pdChDb25zdGFudHMuRVZFTlRTLkVYUE9SVCwgb3V0cHV0LCB0aGlzKVxuXG4gICAgICAgIGlmICh0aGlzLl93YXRlcm1hcmtPcGVyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLl93YXRlcm1hcmtPcGVyYXRpb24uc2V0RW5hYmxlZCh0cnVlKVxuICAgICAgICAgIHRoaXMuX3Nkay5yZW5kZXIoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW52YWxpZGF0ZSBjYWNoZXNcbiAgICAgICAgdGhpcy5fc2RrLnNldEFsbE9wZXJhdGlvbnNUb0RpcnR5KClcblxuICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU0VSSUFMSVpBVElPTlxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgc2VyaWFsaXplcnMgYW5kIGRlc2VyaWFsaXplcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0U2VyaWFsaXplcnMgKCkge1xuICAgIHRoaXMuX3NlcmlhbGl6ZXJzID0ge1xuICAgICAgJzEuMC4wJzogcmVxdWlyZSgnLi9zZXJpYWxpemF0aW9uLzEuMC4wJykuZGVmYXVsdCxcbiAgICAgICcxLjAuMSc6IHJlcXVpcmUoJy4vc2VyaWFsaXphdGlvbi8xLjAuMScpLmRlZmF1bHRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZWRpdG9yIHN0YXRlIGZvciB0aGUgZ2l2ZW4gdmVyc2lvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgPSB7fVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHZlcnNpb24gPSAnMS4wLjEnXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZXJpYWxpemUgKG9wdGlvbnMgPSB7fSwgdmVyc2lvbiA9ICcxLjAuMScpIHtcbiAgICBjb25zdCBTZXJpYWxpemVyID0gdGhpcy5fc2VyaWFsaXplcnNbdmVyc2lvbl1cbiAgICBpZiAoIVNlcmlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYE5vIHNlcmlhbGl6ZXIgZm9yIHZlcnNpb24gJHt2ZXJzaW9ufSBmb3VuZC5gKSlcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKHRoaXMpXG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZGVzZXJpYWxpemUgKGRhdGEpIHtcbiAgICBjb25zdCBTZXJpYWxpemVyID0gdGhpcy5fc2VyaWFsaXplcnNbZGF0YS52ZXJzaW9uXVxuICAgIGlmICghU2VyaWFsaXplcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgTm8gc2VyaWFsaXplciBmb3IgdmVyc2lvbiAke2RhdGEudmVyc2lvbn0gZm91bmQuYCkpXG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcih0aGlzKVxuICAgIHJldHVybiBzZXJpYWxpemVyLmRlc2VyaWFsaXplKGRhdGEpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgcmVuZGVyaW5nIG9mZnNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5T2Zmc2V0ICgpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9vZmZzZXQuY2xvbmUoKVxuXG4gICAgb2Zmc2V0LnggLT0gdGhpcy5fcGFkZGluZ1sxXSAvIDJcbiAgICBvZmZzZXQueCArPSB0aGlzLl9wYWRkaW5nWzNdIC8gMlxuXG4gICAgb2Zmc2V0LnkgLT0gdGhpcy5fcGFkZGluZ1syXSAvIDJcbiAgICBvZmZzZXQueSArPSB0aGlzLl9wYWRkaW5nWzBdIC8gMlxuXG4gICAgdGhpcy5fc2RrLnNldE9mZnNldChvZmZzZXQpXG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSByZW5kZXIgbG9vcFxuICAgKi9cbiAgc3RhcnQgKCkge1xuICAgIHRoaXMuem9vbS5zZXQoJ2F1dG8nKVxuICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lUmVxdWVzdCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSByZW5kZXIgbG9vcFxuICAgKi9cbiAgc3RvcCAoKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gICAgaWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lUmVxdWVzdCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWVSZXF1ZXN0KVxuICAgICAgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzID0gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgYSByZW5kZXIsIGFkZHMgYGNhbGxiYWNrYCB0byB0aGUgcmVuZGVyIGNhbGxiYWNrc1xuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKi9cbiAgcmVuZGVyIChjYWxsYmFjaykge1xuICAgIHRoaXMuX3JlbmRlclJlcXVlc3RlZCA9IHRydWVcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvZmZzZXQgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gb2Zmc2V0XG4gICAqL1xuICBzZXRPZmZzZXQgKG9mZnNldCkge1xuICAgIHRoaXMuX29mZnNldCA9IHRoaXMuX2NsYW1wT2Zmc2V0KG9mZnNldClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG9mZnNldFxuICAgKiBAcmV0dXJucyB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0T2Zmc2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0XG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgc3VyZSB0aGUgaW1hZ2Ugc3RheXMgaW5zaWRlIHRoZSB2aWV3cG9ydFxuICAgKi9cbiAgZml4T2Zmc2V0ICgpIHtcbiAgICB0aGlzLnNldE9mZnNldCh0aGlzLl9zZGsuZ2V0T2Zmc2V0KCkpXG4gIH1cblxuICAvKipcbiAgICogRml4ZXMgdGhlIGdpdmVuIG9mZnNldCB0byBtYWtlIHN1cmUgdGhlIGltYWdlIHN0YXlzIGluc2lkZSB0aGUgdmlld3BvcnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGFtcE9mZnNldCAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9zZGsuZ2V0UmVuZGVyZXIoKVxuICAgIGNvbnN0IHJlbmRlcmVyRGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKHJlbmRlcmVyLmdldFdpZHRoKCksIHJlbmRlcmVyLmdldEhlaWdodCgpKVxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSB0aGlzLl9zZGsuZ2V0T3V0cHV0RGltZW5zaW9ucyhmYWxzZSlcblxuICAgIGNvbnN0IG1pbk9mZnNldCA9IHJlbmRlcmVyRGltZW5zaW9ucy5jbG9uZSgpXG4gICAgICAuc3VidHJhY3Qob3V0cHV0RGltZW5zaW9ucylcbiAgICAgIC5kaXZpZGUoMilcbiAgICAgIC5jbGFtcChudWxsLCBuZXcgVmVjdG9yMigwLCAwKSlcblxuICAgIGNvbnN0IG1heE9mZnNldCA9IG91dHB1dERpbWVuc2lvbnMuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KHJlbmRlcmVyRGltZW5zaW9ucylcbiAgICAgIC5kaXZpZGUoMilcbiAgICAgIC5jbGFtcChuZXcgVmVjdG9yMigwLCAwKSwgbnVsbClcblxuICAgIGNvbnN0IG5ld09mZnNldCA9IG9mZnNldC5jbG9uZSgpXG4gICAgICAuY2xhbXAobWluT2Zmc2V0LCBtYXhPZmZzZXQpXG4gICAgICAucm91bmQoKVxuXG4gICAgcmV0dXJuIG5ld09mZnNldFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gYW5pbWF0aW9uIGZyYW1lIGlzIGJlaW5nIHByb2Nlc3NlZC4gUmVuZGVycyB0aGVcbiAgICogY2FudmFzIGlmIG5lY2Vzc2FyeSwgcmVxdWVzdHMgYW5vdGhlciBhbmltYXRpb24gZnJhbWUgY2FsbGJhY2tzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdGljayAoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclJlcXVlc3RlZCkge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnNsaWNlKDApXG4gICAgICB0aGlzLl9yZW5kZXJDYWxsYmFja3MgPSBbXVxuXG4gICAgICB0aGlzLl9yZW5kZXIoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goKHIpID0+IHIoKSlcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25GcmFtZVJlcXVlc3QgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljaylcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgTG9nLnByaW50RXJyb3IoZSlcbiAgICAgICAgfSlcbiAgICAgIHRoaXMuX3JlbmRlclJlcXVlc3RlZCA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lUmVxdWVzdCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIHJlbmRlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlciAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkeSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cbiAgICB0aGlzLl9hcHBseU9mZnNldCgpXG5cbiAgICByZXR1cm4gdGhpcy5fc2RrLnJlbmRlcigpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RPdXRwdXRCb3VuZHMgPSB0aGlzLl9zZGsuZ2V0U3ByaXRlKCkuZ2V0Qm91bmRzKClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCdyZW5kZXItZXJyb3InLCBlKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgZXZlcnl0aGluZ1xuICAgKi9cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMuX3Nkay5yZXNldCgpXG5cbiAgICB0aGlzLmhpc3RvcnkucmVzZXQoKVxuICAgIHRoaXMub3BlcmF0aW9ucy5yZXNldCgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBESVNQT1NBTFxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdGhpcyBpbnN0YW5jZSB1cFxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5zdG9wKClcblxuICAgIHRoaXMuX3Nkay5kaXNwb3NlKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEdFVFRFUlMgLyBTRVRURVJTXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgRWRpdG9yIGlzIHJlYWR5IHRvIHJlbmRlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNSZWFkeSAoKSB7IHJldHVybiB0aGlzLl9yZWFkeSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9XG4gICAqL1xuICBnZXRSZW5kZXJlciAoKSB7IHJldHVybiB0aGlzLl9zZGsuZ2V0UmVuZGVyZXIoKSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFNES1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNES31cbiAgICovXG4gIGdldFNESyAoKSB7IHJldHVybiB0aGlzLl9zZGsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnB1dCBpbWFnZSBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1zXG4gICAqL1xuICBnZXRJbnB1dERpbWVuc2lvbnMgKCkgeyByZXR1cm4gdGhpcy5fc2RrLmdldElucHV0RGltZW5zaW9ucygpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFkZGluZyB2YWx1ZXNcbiAgICogQHJldHVybiB7TnVtYmVyW119XG4gICAqL1xuICBnZXRQYWRkaW5nICgpIHsgcmV0dXJuIHRoaXMuX3BhZGRpbmcgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYWRkaW5nICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpXG4gICAqIEBwYXJhbSB7TnVtYmVyW119IHBhZGRpbmdcbiAgICovXG4gIHNldFBhZGRpbmcgKHBhZGRpbmcpIHtcbiAgICBpZiAoIXBhZGRpbmcpIHtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSBbMCwgMCwgMCwgMF1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmdcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW1hZ2VcbiAgICogQHJldHVybiB7SW1hZ2V9XG4gICAqL1xuICBnZXRJbWFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZWRpdG9yLmltYWdlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFVJXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUl9XG4gICAqL1xuICBnZXRVSSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpXG4gIH1cblxuICAvKipcbiAgICogQnJvYWRjYXN0cyBhIGNyb3AgdG8gYWxsIG9wZXJhdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNoYW5nZWRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5Dcm9wT3BlcmF0aW9ufSBjcm9wT3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgYnJvYWRjYXN0Q3JvcCAoY3JvcE9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNyb3BwYWJsZU9wZXJhdGlvbnMgPSBbJ3Nwcml0ZScsICdzZWxlY3RpdmUtYmx1ciddXG4gICAgY3JvcHBhYmxlT3BlcmF0aW9ucy5mb3JFYWNoKChpZGVudGlmaWVyKSA9PiB7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLm9wZXJhdGlvbnMuZ2V0KGlkZW50aWZpZXIpXG4gICAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG9wZXJhdGlvbi5jcm9wKGNyb3BPcGVyYXRpb24sIG9wdGlvbnMpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCcm9hZGNhc3RzIGEgZmxpcCB0byBhbGwgb3BlcmF0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKi9cbiAgYnJvYWRjYXN0RmxpcCAoZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgZmxpcHBhYmxlT3BlcmF0aW9ucyA9IFsnbGluZWFyLWZvY3VzJywgJ3JhZGlhbC1mb2N1cycsICdzcHJpdGUnLCAnc2VsZWN0aXZlLWJsdXInXVxuICAgIGZsaXBwYWJsZU9wZXJhdGlvbnMuZm9yRWFjaCgoaWRlbnRpZmllcikgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5vcGVyYXRpb25zLmdldChpZGVudGlmaWVyKVxuICAgICAgaWYgKCFvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBvcGVyYXRpb24uZmxpcChkaXJlY3Rpb24pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCcm9hZGNhc3RzIGEgcm90YXRpb24gdG8gYWxsIG9wZXJhdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNoYW5nZWRcbiAgICogQHBhcmFtICB7TnVtYmVyfSBkZWdyZWVzXG4gICAqL1xuICBicm9hZGNhc3RSb3RhdGUgKGRlZ3JlZXMpIHtcbiAgICBjb25zdCBmbGlwcGFibGVPcGVyYXRpb25zID0gWydjcm9wJywgJ2xpbmVhci1mb2N1cycsICdyYWRpYWwtZm9jdXMnLCAnc3ByaXRlJywgJ3NlbGVjdGl2ZS1ibHVyJ11cbiAgICBmbGlwcGFibGVPcGVyYXRpb25zLmZvckVhY2goKGlkZW50aWZpZXIpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9ucy5nZXQoaWRlbnRpZmllcilcbiAgICAgIGlmICghb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgb3BlcmF0aW9uLnJvdGF0ZShkZWdyZWVzKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRWRpdG9yXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvZWRpdG9yLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBTREsgfSBmcm9tICcuLi9nbG9iYWxzJ1xuY29uc3QgeyBPcHRpb25UeXBlIH0gPSBTREtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9udCBleHRlbmRzIFNESy5Db25maWd1cmFibGUge31cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGUgRm9udCBjbGFzc1xuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuRm9udC5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgbmFtZTogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgZm9udFdlaWdodDogeyB0eXBlOiBPcHRpb25UeXBlLkFMTCwgZGVmYXVsdDogNDAwIH0sXG4gIGZvbnRGYW1pbHk6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gIGZvbnRTdHlsZTogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORywgZGVmYXVsdDogJ25vcm1hbCcgfSxcbiAgcHJvdmlkZXI6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIGF2YWlsYWJsZTogWydnb29nbGUnXSB9LFxuICBkZWZhdWx0OiB7IHR5cGU6IE9wdGlvblR5cGUuQk9PTEVBTiwgZGVmYXVsdDogZmFsc2UgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvZm9udC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVXRpbHMsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgSlNPTkxvYWRlciBmcm9tICcuLi9qc29uLWxvYWRlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RpY2tlck1hbmFnZXIge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5fY2F0ZWdvcmllc0J5SWQgPSB7fVxuICAgIHRoaXMuX2NhdGVnb3JpZXMgPSBDb25zdGFudHMuREVGQVVMVFMuU1RJQ0tFUl9DQVRFR09SSUVTLnNsaWNlKDApXG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jYXRlZ29yaWVzKSB7XG4gICAgICB0aGlzLl9hZGRDYXRlZ29yaWVzKHRoaXMuX29wdGlvbnMuY2F0ZWdvcmllcylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlQWxsQ2F0ZWdvcnkoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBzdGlja2VycyBmcm9tIHRoZSBnaXZlbiBleHRlcm5hbCBVUkxcbiAgICogQHBhcmFtICB7U3RyaW5nfSB1cmxcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGxvYWRFeHRlcm5hbCAodXJsKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEpTT05Mb2FkZXIodXJsKVxuICAgIHJldHVybiBsb2FkZXIubG9hZCgpXG4gICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICB0aGlzLl9hZGRDYXRlZ29yaWVzKHJlc3VsdC5jYXRlZ29yaWVzKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2F0ZWdvcmllc1xuICAgKiBAcGFyYW0ge09iamVjdFtdfSBjYXRlZ29yaWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkQ2F0ZWdvcmllcyAoY2F0ZWdvcmllcykge1xuICAgIGxldCB7IHJlcGxhY2VDYXRlZ29yaWVzIH0gPSB0aGlzLl9vcHRpb25zXG5cbiAgICBpZiAocmVwbGFjZUNhdGVnb3JpZXMpIHtcbiAgICAgIHRoaXMuX2NhdGVnb3JpZXMgPSBjYXRlZ29yaWVzLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NhdGVnb3JpZXMgPSBVdGlscy5tZXJnZUNhdGVnb3JpZXMoXG4gICAgICAgIHRoaXMuX2NhdGVnb3JpZXMsXG4gICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgICdzdGlja2VycydcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBjYXQgaWQgPT4gY2F0ZWdvcnkgaGFzaFxuICAgIHRoaXMuX2NhdGVnb3JpZXNCeUlkID0ge31cbiAgICB0aGlzLl9jYXRlZ29yaWVzLmZvckVhY2goKGMpID0+IHsgdGhpcy5fY2F0ZWdvcmllc0J5SWRbYy5uYW1lXSA9IGMgfSlcblxuICAgIHRoaXMuX3VwZGF0ZUFsbENhdGVnb3J5KClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBgYWxsYCBjYXRlZ29yeSB3aGljaCBjb250YWlucyBhbGwgc3RpY2tlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVBbGxDYXRlZ29yeSAoKSB7XG4gICAgdGhpcy5fYWxsQ2F0ZWdvcnkgPSB7XG4gICAgICBuYW1lOiAnYWxsJyxcbiAgICAgIGxhYmVsOiB0aGlzLl9vcHRpb25zLmFsbENhdGVnb3J5TGFiZWwsXG4gICAgICBzdGlja2VyczogdGhpcy5fY2F0ZWdvcmllc1xuICAgICAgICAubWFwKChjKSA9PiBjLnN0aWNrZXJzKVxuICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pXG4gICAgfVxuICAgIHRoaXMuX2NhdGVnb3JpZXNCeUlkLmFsbCA9IHRoaXMuX2FsbENhdGVnb3J5XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RpY2tlcnMgZm9yIHRoZSBjYXRlZ29yeSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gY2F0ZWdvcnlOYW1lXG4gICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgKi9cbiAgZ2V0U3RpY2tlcnNGb3JDYXRlZ29yeSAoY2F0ZWdvcnlOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9jYXRlZ29yaWVzQnlJZFtjYXRlZ29yeU5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RpY2tlciBjYXRlZ29yeSAnJHtjYXRlZ29yeU5hbWV9J2ApXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYXRlZ29yaWVzQnlJZFtjYXRlZ29yeU5hbWVdLnN0aWNrZXJzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2F0ZWdvcmllc1xuICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICovXG4gIGdldENhdGVnb3JpZXMgKCkge1xuICAgIHJldHVybiBbdGhpcy5fYWxsQ2F0ZWdvcnldLmNvbmNhdCh0aGlzLl9jYXRlZ29yaWVzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNhdGVnb3J5IG9iamVjdCBmb3IgdGhlIGdpdmVuIGlkXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaWRcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0Q2F0ZWdvcnkgKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhdGVnb3JpZXNCeUlkW2lkXVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvbWFuYWdlcnMvc3RpY2tlci1tYW5hZ2VyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgQ2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJ1xuaW1wb3J0IEJFTSBmcm9tICcuL2JlbSdcblxuZnVuY3Rpb24gZmxhdHRlbiAoYXJyKSB7XG4gIGxldCByZXN1bHQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChmbGF0dGVuKGFycltpXSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycltpXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5jb25zdCBCRU1fVFlQRVMgPSB7XG4gIGI6ICdibG9jaycsXG4gIGU6ICdlbGVtZW50JyxcbiAgbTogJ21vZGlmaWVyJ1xufVxuY29uc3QgUmVhY3RCRU0gPSB7XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIFJlYWN0QkVNIHNwZWNpZmllciBhbmQgcmV0dXJucyBhbiBhcnJheSBvZlxuICAgKiBCRU0gaW5mb3JtYXRpb24gKHR5cGUsIG5hbWUsIHBhc3MpXG4gICAqIEBwYXJhbSAge3N0cmluZ30gc3BlY2lmaWVyXG4gICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BhcnNlQmVtU3BlY2lmaWVyIChzcGVjaWZpZXIpIHtcbiAgICBpZiAoIXNwZWNpZmllcikgcmV0dXJuIFtdXG5cbiAgICBjb25zdCBwYXJ0cyA9IHNwZWNpZmllci5zcGxpdCgnICcpXG4gICAgbGV0IGRhdGEgPSBwYXJ0cy5tYXAoKHBhcnQpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gcGFydC5tYXRjaCgvXihcXCQpPyhbYmVtXSk6KC4qKSQvaSlcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEJFTSBzcGVjaWZpZXI6ICcgKyBwYXJ0KVxuICAgICAgfVxuXG4gICAgICBsZXQgcGFzcyA9IHR5cGVvZiBtYXRjaFsxXSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgIGxldCB0eXBlID0gQkVNX1RZUEVTW21hdGNoWzJdXVxuICAgICAgbGV0IG5hbWUgPSBtYXRjaFszXVxuICAgICAgcmV0dXJuIHsgdHlwZSwgbmFtZSwgcGFzcyB9XG4gICAgfSlcbiAgICByZXR1cm4gZGF0YVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBCRU0gaW5mbyBmb3IgdGhlIGdpdmVuIG5vZGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRCZW1JbmZvRm9yTm9kZSAobm9kZSkge1xuICAgIGNvbnN0IGlzQmVtTm9kZSA9IG5vZGUudHlwZSA9PT0gJ2JlbSdcbiAgICBjb25zdCBzcGVjaWZpZXIgPSBpc0JlbU5vZGUgPyBub2RlLnByb3BzLnNwZWNpZmllciA6IG5vZGUucHJvcHMuYmVtXG5cbiAgICBpZiAoaXNCZW1Ob2RlICYmICFzcGVjaWZpZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignPGJlbT4gZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBoYXZlIGEgYHNwZWNpZmllcmAgcHJvcGVydHknKVxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9wYXJzZUJlbVNwZWNpZmllcihzcGVjaWZpZXIpXG5cbiAgICAvLyA8YmVtPiBub2RlcyBwYXNzIGFsbCBiZW0gaW5mb3JtYXRpb24gdG8gdGhlIGNoaWxkcmVuXG4gICAgaWYgKGlzQmVtTm9kZSkge1xuICAgICAgZGF0YS5mb3JFYWNoKChvYmopID0+IHtcbiAgICAgICAgb2JqLnBhc3MgPSB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7IGRhdGEsIGlzQmVtTm9kZSB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZWQgaW4gUmVhY3QuQ29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSAge0FycmF5LjxPYmplY3Q+fSBbLi4uY2hpbGRyZW5dXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGNyZWF0ZUVsZW1lbnQgKHR5cGUsIHByb3BzLCAuLi5jaGlsZHJlbikge1xuICAgIHByb3BzID0gcHJvcHMgfHwge31cbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuXG4gICAgICAuZmlsdGVyKChjaGlsZCkgPT5cbiAgICAgICAgY2hpbGQgIT09IG51bGwgJiYgdHlwZW9mIGNoaWxkICE9PSAndW5kZWZpbmVkJ1xuICAgICAgKVxuICAgIHJldHVybiB7IHR5cGUsIHByb3BzLCBjaGlsZHJlbiB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHdlIGNhbiBhcHBseSBhIGJlbSBjbGFzcyB0byB0aGUgZ2l2ZW4gbm9kZVxuICAgKiBAcGFyYW0gIHs/fSAgbm9kZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2lzTm9kZUJFTWFibGUgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAhPT0gbnVsbCAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5vZGUpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIEJFTSBjbGFzcyBmb3IgdGhlIGdpdmVuIG5vZGUuIEl0ZXJhdGVzIHRocm91Z2ggaXRzXG4gICAqIGNoaWxkcmVuIGFuZCBzZXRzIHRoZWlyIEJFTSBjbGFzcyBhcyB3ZWxsXG4gICAqIEBwYXJhbSAge09iamVjdH0gbm9kZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlCRU1DbGFzc2VzIChub2RlKSB7XG4gICAgaWYgKCF0aGlzLl9pc05vZGVCRU1hYmxlKG5vZGUpKSByZXR1cm4gbm9kZVxuXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBub2RlLnByb3BzLmNsYXNzTmFtZSA/IFtub2RlLnByb3BzLmNsYXNzTmFtZV0gOiBbXVxuXG4gICAgLy8gUHJlcGFyZSBCRU0gb2JqZWN0c1xuICAgIGNvbnN0IGJlbUluZm8gPSB0aGlzLl9nZXRCZW1JbmZvRm9yTm9kZShub2RlKVxuICAgIGxldCBvd25CZW1PYmplY3QgPSBub2RlLnByb3BzLl9fYmVtT2JqZWN0XG4gICAgbGV0IGNoaWxkcmVuQmVtT2JqZWN0ID0gbm9kZS5wcm9wcy5fX2JlbU9iamVjdFxuICAgIGJlbUluZm8uZGF0YS5mb3JFYWNoKChvYmopID0+IHtcbiAgICAgIGlmIChvYmoudHlwZSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICBvd25CZW1PYmplY3QgPSBCRU0uYmxvY2sob2JqLm5hbWUpXG4gICAgICAgIGlmIChvYmoucGFzcykge1xuICAgICAgICAgIGNoaWxkcmVuQmVtT2JqZWN0ID0gQkVNLmJsb2NrKG9iai5uYW1lKVxuICAgICAgICB9XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaChvd25CZW1PYmplY3Quc3RyKVxuICAgICAgfSBlbHNlIGlmIChvYmoudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAgIGlmICghb3duQmVtT2JqZWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBjcmVhdGUgYW4gZWxlbWVudCwgYnV0IG5vIHBhcmVudCBibG9jayBoYXMgYmVlbiBmb3VuZC4nKVxuICAgICAgICB9XG5cbiAgICAgICAgb3duQmVtT2JqZWN0ID0gb3duQmVtT2JqZWN0LmVsZW1lbnQob2JqLm5hbWUpXG4gICAgICAgIGlmIChvYmoucGFzcykge1xuICAgICAgICAgIGNoaWxkcmVuQmVtT2JqZWN0ID0gY2hpbGRyZW5CZW1PYmplY3QuZWxlbWVudChvYmoubmFtZSlcbiAgICAgICAgfVxuICAgICAgICBjbGFzc05hbWVzLnB1c2gob3duQmVtT2JqZWN0LnN0cilcbiAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgICAgaWYgKCFvd25CZW1PYmplY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGNyZWF0ZSBhIG1vZGlmaWVyLCBidXQgbm8gcGFyZW50IGJsb2NrIGhhcyBiZWVuIGZvdW5kLicpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLnBhc3MpIHtcbiAgICAgICAgICBjaGlsZHJlbkJlbU9iamVjdCA9IGNoaWxkcmVuQmVtT2JqZWN0Lm1vZGlmaWVyKG9iai5uYW1lKVxuICAgICAgICB9XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaChvd25CZW1PYmplY3QubW9kaWZpZXIob2JqLm5hbWUpLnN0cilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gQXBwbHkgY2xhc3NuYW1lIChpZiBuZWNlc3NhcnkpXG4gICAgY29uc3QgY2xhc3NOYW1lID0gQ2xhc3NuYW1lcyhjbGFzc05hbWVzKVxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIG5vZGUucHJvcHMuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG4gICAgfVxuXG4gICAgbm9kZS5jaGlsZHJlbiA9IGZsYXR0ZW4obm9kZS5jaGlsZHJlbilcblxuICAgIC8vIFBhc3MgYGNoaWxkcmVuQmVtT2JqZWN0YCB0byBjaGlsZCBub2Rlc1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGlmICghdGhpcy5faXNOb2RlQkVNYWJsZShjaGlsZCkpIHJldHVyblxuICAgICAgY2hpbGQucHJvcHMuX19iZW1PYmplY3QgPSBjaGlsZHJlbkJlbU9iamVjdFxuICAgIH0pXG5cbiAgICAvLyBBcHBseSBCRU0gb2JqZWN0cyB0byBjaGlsZHJlblxuICAgIG5vZGUuY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseUJFTUNsYXNzZXMoY2hpbGQpXG4gICAgfSlcblxuICAgIG5vZGUuY2hpbGRyZW4gPSBmbGF0dGVuKG5vZGUuY2hpbGRyZW4pXG5cbiAgICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcHNcbiAgICBkZWxldGUgbm9kZS5wcm9wcy5fX2JlbU9iamVjdFxuICAgIGRlbGV0ZSBub2RlLnByb3BzLmJlbVxuXG4gICAgaWYgKGJlbUluZm8uaXNCZW1Ob2RlKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbiBpbnN0YW5jZW9mIEFycmF5ICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIFJlYWN0QkVNIGVsZW1lbnQgYW5kIGl0cyBjaGlsZHJlbiBpbnRvXG4gICAqIGFjdHVhbCBSZWFjdEpTIGVsZW1lbnRzXG4gICAqIEBwYXJhbSAge09iamVjdH0gbm9kZVxuICAgKiBAcmV0dXJuIHtSZWFjdC5FbGVtZW50fVxuICAgKi9cbiAgX3RyYW5zZm9ybVRvUmVhY3QgKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuX2lzTm9kZUJFTWFibGUobm9kZSkpIHJldHVybiBub2RlXG5cbiAgICBub2RlLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtVG9SZWFjdChjaGlsZClcbiAgICB9KVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQobm9kZS50eXBlLCBub2RlLnByb3BzLCAuLi5ub2RlLmNoaWxkcmVuKVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBSZWFjdEJFTSBvYmplY3QgYW5kIGl0cyBjaGlsZHJlblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJvb3RcbiAgICogQHJldHVybiB7UmVhY3QuRWxlbWVudH1cbiAgICovXG4gIHRyYW5zZm9ybSAocm9vdCkge1xuICAgIHJvb3QgPSB0aGlzLl9hcHBseUJFTUNsYXNzZXMocm9vdClcblxuICAgIC8vIFJvb3Qgbm9kZSBzaG91bGQgYmUgYSBzaW5nbGUgbm9kZSwgbm90IGFuIGFycmF5LiBSZXR1cm5pbmcgdGhlIGFycmF5XG4gICAgLy8gaGVyZSB3aWxsIGNhdXNlIFJlYWN0IHRvIHRocm93IGFuIGVycm9yIHNheWluZyB0aGF0IHRoaXMgaXMgYSBuby1nb1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmV0dXJuIHJvb3RcbiAgICB9XG5cbiAgICByb290ID0gdGhpcy5fdHJhbnNmb3JtVG9SZWFjdChyb290KVxuICAgIHJldHVybiByb290XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RCRU1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9yZWFjdC1iZW0uanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFNESywgVmVjdG9yMiwgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IEZpbHRlck1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlcnMvZmlsdGVyLW1hbmFnZXInXG5pbXBvcnQgU3RpY2tlck1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlcnMvc3RpY2tlci1tYW5hZ2VyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXNlcmlhbGl6ZXIge1xuICBjb25zdHJ1Y3RvciAoZWRpdG9yLCBkYXRhKSB7XG4gICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5fZGF0YSA9IGRhdGFcblxuICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIgPSBuZXcgRmlsdGVyTWFuYWdlcih0aGlzLl9lZGl0b3IuX29wdGlvbnMpXG4gICAgdGhpcy5fc3RpY2tlck1hbmFnZXIgPSBuZXcgU3RpY2tlck1hbmFnZXIodGhpcy5fZWRpdG9yLl9vcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgZ2l2ZW4gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZGVzZXJpYWxpemUgKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZVZlcnNpb24oKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fZGVzZXJpYWxpemVJbnB1dEltYWdlKCkpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLl9kZXNlcmlhbGl6ZU9wZXJhdGlvbnMoKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuX2VkaXRvci56b29tLnNldCgnYXV0bycpKVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgdmVyc2lvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgX3ZhbGlkYXRlVmVyc2lvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEudmVyc2lvbiAhPT0gJzEuMC4wJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgSW52YWxpZCB2ZXJzaW9uICR7dGhpcy5fZGF0YS52ZXJzaW9ufSwgZXhwZWN0ZWQgMS4wLjBgKSlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBpbnB1dCBpbWFnZSAoaWYgcHJlc2VudClcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUlucHV0SW1hZ2UgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGEsIHR5cGUgfSA9IHRoaXMuX2RhdGEuaW5wdXRJbWFnZVxuICAgICAgaWYgKGRhdGEgJiYgdHlwZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2VkaXRvci5zZXRJbWFnZShpbWFnZSlcbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgICAgaW1hZ2Uuc3JjID0gYGRhdGE6JHt0eXBlfTtiYXNlNjQsJHtkYXRhfWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBvcGVyYXRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVPcGVyYXRpb25zICgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX2RhdGEub3BlcmF0aW9ucy5tYXAoKG9wZXJhdGlvbikgPT4ge1xuICAgICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgICBjYXNlICdjcm9wJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVDcm9wT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgICAgICAgY2FzZSAnb3JpZW50YXRpb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZU9yaWVudGF0aW9uT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgICAgICAgY2FzZSAnZmlsdGVyJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVGaWx0ZXJPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgICBjYXNlICdhZGp1c3RtZW50cyc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplQWRqdXN0bWVudHNPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgICBjYXNlICdzcHJpdGUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVNwcml0ZU9wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVGb2N1c09wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGNyb3Agb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVDcm9wT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9wZXJhdGlvblxuICAgIGxldCB7IHNjYWxlLCByb3RhdGlvbiB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHN0YXJ0ID0gVmVjdG9yMi5mcm9tT2JqZWN0KG9wdGlvbnMuc3RhcnQpXG4gICAgY29uc3QgZW5kID0gVmVjdG9yMi5mcm9tT2JqZWN0KG9wdGlvbnMuZW5kKVxuXG4gICAgLy8gTm9ybWFsaXplIHJvdGF0aW9uXG4gICAgaWYgKHJvdGF0aW9uID4gTWF0aC5QSSkge1xuICAgICAgcm90YXRpb24gLT0gTWF0aC5QSSAqIDJcbiAgICB9XG5cbiAgICB0aGlzLl9lZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnY3JvcCcsIHtcbiAgICAgIHN0YXJ0LCBlbmQsIHNjYWxlLCByb3RhdGlvblxuICAgIH0pXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBvcmllbnRhdGlvbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZU9yaWVudGF0aW9uT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9wZXJhdGlvblxuICAgIHRoaXMuX2VkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdvcmllbnRhdGlvbicsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBmaWx0ZXIgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVzZXJpYWxpemVGaWx0ZXJPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gb3BlcmF0aW9uXG5cbiAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5fZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJzRm9yQ2F0ZWdvcnkoJ2FsbCcpXG4gICAgbGV0IEZpbHRlckNsYXNzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBGaWx0ZXIgPSBmaWx0ZXJzW2ldXG4gICAgICBpZiAoRmlsdGVyLmlkZW50aWZpZXIgPT09IG9wdGlvbnMubmFtZSkge1xuICAgICAgICBGaWx0ZXJDbGFzcyA9IEZpbHRlclxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghRmlsdGVyQ2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWx0ZXIgJyR7b3B0aW9ucy5uYW1lfSdgKVxuICAgIH1cblxuICAgIHRoaXMuX2VkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdmaWx0ZXInLCB7XG4gICAgICBmaWx0ZXI6IG5ldyBGaWx0ZXJDbGFzcygpLFxuICAgICAgaW50ZW5zaXR5OiBvcHRpb25zLmludGVuc2l0eVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBhZGp1c3RtZW50cyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUFkanVzdG1lbnRzT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IEFkanVzdG1lbnRzT3BlcmF0aW9uIH0gPSBTREsuT3BlcmF0aW9uc1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gb3BlcmF0aW9uXG4gICAgY29uc3Qgb3BlcmF0aW9uT3B0aW9ucyA9IHt9XG5cbiAgICBmb3IgKGxldCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV1cbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IEFkanVzdG1lbnRzT3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zW2tleV0uZGVmYXVsdFxuICAgICAgb3BlcmF0aW9uT3B0aW9uc1trZXldID0gdmFsdWUgKyBkZWZhdWx0VmFsdWVcbiAgICB9XG5cbiAgICB0aGlzLl9lZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnYWRqdXN0bWVudHMnLCBvcGVyYXRpb25PcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgZ2l2ZW4gc3ByaXRlIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplU3ByaXRlT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9wZXJhdGlvblxuICAgIGNvbnN0IHNwcml0ZU9wZXJhdGlvbiA9IHRoaXMuX2VkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzcHJpdGUnKVxuICAgIGNvbnN0IHByb21pc2VzID0gb3B0aW9ucy5zcHJpdGVzLm1hcCgoc3ByaXRlKSA9PiB7XG4gICAgICBzd2l0Y2ggKHNwcml0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3N0aWNrZXInOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVN0aWNrZXIoc3ByaXRlT3BlcmF0aW9uLCBzcHJpdGUpXG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVRleHQoc3ByaXRlT3BlcmF0aW9uLCBzcHJpdGUpXG4gICAgICAgIGNhc2UgJ2JydXNoJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVCcnVzaChzcHJpdGVPcGVyYXRpb24sIHNwcml0ZSlcbiAgICAgIH1cbiAgICB9KS5maWx0ZXIoKHMpID0+ICEhcylcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAudGhlbigoc3ByaXRlcykgPT4ge1xuICAgICAgICBzcHJpdGVPcGVyYXRpb24uc2V0U3ByaXRlcyhzcHJpdGVzKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIHN0aWNrZXIgZm9yIHRoZSBnaXZlbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNwcml0ZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5TdGlja2VyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplU3RpY2tlciAob3BlcmF0aW9uLCBzcHJpdGUpIHtcbiAgICBjb25zdCB7IFNwcml0ZU9wZXJhdGlvbiB9ID0gU0RLLk9wZXJhdGlvbnNcblxuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gc3ByaXRlXG4gICAgY29uc3Qgc3RpY2tlcnMgPSB0aGlzLl9zdGlja2VyTWFuYWdlci5nZXRTdGlja2Vyc0ZvckNhdGVnb3J5KCdhbGwnKVxuXG4gICAgbGV0IHN0aWNrZXJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0aWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RpY2tlcnNbaV0ubmFtZSA9PT0gb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHN0aWNrZXIgPSBzdGlja2Vyc1tpXVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc3RpY2tlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0aWNrZXIgJyR7b3B0aW9ucy5uYW1lfSdgKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKClcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkanVzdG1lbnRzID0gU3ByaXRlT3BlcmF0aW9uLlN0aWNrZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMuYWRqdXN0bWVudHMuc3RydWN0dXJlXG4gICAgICAgIGNvbnN0IHsgcm90YXRpb24sIGZsaXBIb3Jpem9udGFsbHksIGZsaXBWZXJ0aWNhbGx5IH0gPSBvcHRpb25zXG4gICAgICAgIHJlc29sdmUob3BlcmF0aW9uLmNyZWF0ZVN0aWNrZXIoe1xuICAgICAgICAgIGltYWdlLFxuICAgICAgICAgIHBvc2l0aW9uOiBWZWN0b3IyLmZyb21PYmplY3Qob3B0aW9ucy5wb3NpdGlvbiksXG4gICAgICAgICAgZGltZW5zaW9uczogVmVjdG9yMi5mcm9tT2JqZWN0KG9wdGlvbnMuZGltZW5zaW9ucyksXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgZmxpcEhvcml6b250YWxseSxcbiAgICAgICAgICBmbGlwVmVydGljYWxseSxcbiAgICAgICAgICBhZGp1c3RtZW50czoge1xuICAgICAgICAgICAgYnJpZ2h0bmVzczogb3B0aW9ucy5hZGp1c3RtZW50cy5icmlnaHRuZXNzICsgYWRqdXN0bWVudHMuYnJpZ2h0bmVzcy5kZWZhdWx0LFxuICAgICAgICAgICAgc2F0dXJhdGlvbjogb3B0aW9ucy5hZGp1c3RtZW50cy5zYXR1cmF0aW9uICsgYWRqdXN0bWVudHMuc2F0dXJhdGlvbi5kZWZhdWx0LFxuICAgICAgICAgICAgY29udHJhc3Q6IG9wdGlvbnMuYWRqdXN0bWVudHMuY29udHJhc3QgKyBhZGp1c3RtZW50cy5jb250cmFzdC5kZWZhdWx0XG4gICAgICAgICAgfVxuICAgICAgICB9KSlcbiAgICAgIH0pXG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnXG4gICAgICBpbWFnZS5zcmMgPSB0aGlzLl9lZGl0b3IuZ2V0VUkoKS5nZXRBc3NldFBhdGgoc3RpY2tlci5pbWFnZXMubWVkaWFCYXNlLnVyaSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgZ2l2ZW4gdGV4dCBmb3IgdGhlIGdpdmVuIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gdGV4dFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5UZXh0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplVGV4dCAob3BlcmF0aW9uLCB0ZXh0KSB7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0ZXh0XG4gICAgY29uc3QgeyBmb250U2l6ZSwgbGluZUhlaWdodCwgZm9udEZhbWlseSwgZm9udFdlaWdodCwgYWxpZ25tZW50LCByb3RhdGlvbiwgbWF4V2lkdGgsIGNvbG9yLCBiYWNrZ3JvdW5kQ29sb3IgfSA9IG9wdGlvbnNcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wZXJhdGlvbi5jcmVhdGVUZXh0KHtcbiAgICAgIGZvbnRTaXplLFxuICAgICAgbGluZUhlaWdodCxcbiAgICAgIGZvbnRGYW1pbHksXG4gICAgICBmb250V2VpZ2h0LFxuICAgICAgYWxpZ25tZW50LFxuICAgICAgcm90YXRpb24sXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHRleHQ6IG9wdGlvbnMudGV4dCxcbiAgICAgIGNvbG9yOiBDb2xvci5mcm9tQXJyYXkoY29sb3IpLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBDb2xvci5mcm9tQXJyYXkoYmFja2dyb3VuZENvbG9yKSxcbiAgICAgIHBvc2l0aW9uOiBWZWN0b3IyLmZyb21PYmplY3Qob3B0aW9ucy5wb3NpdGlvbilcbiAgICB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGJydXNoIGZvciB0aGUgZ2l2ZW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBicnVzaFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5CcnVzaH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXNlcmlhbGl6ZUJydXNoIChvcGVyYXRpb24sIGJydXNoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSBicnVzaFxuICAgIGNvbnN0IHsgcGF0aHMgfSA9IG9wdGlvbnNcblxuICAgIGNvbnN0IGJydXNoT2JqZWN0ID0gb3BlcmF0aW9uLmNyZWF0ZUJydXNoKClcbiAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICBjb25zdCB7IGNvbG9yLCBzaXplLCBwb2ludHMgfSA9IHBhdGhcbiAgICAgIGNvbnN0IGNvbG9yT2JqZWN0ID0gbmV3IENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIGNvbG9yWzNdKVxuICAgICAgY29uc3QgcGF0aE9iamVjdCA9IGJydXNoT2JqZWN0LmNyZWF0ZVBhdGgoc2l6ZSwgMSwgY29sb3JPYmplY3QpXG4gICAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICAgICAgcGF0aE9iamVjdC5hZGRDb250cm9sUG9pbnQoXG4gICAgICAgICAgVmVjdG9yMi5mcm9tT2JqZWN0KHBvaW50KVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH0pXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShicnVzaE9iamVjdClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGZvY3VzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rlc2VyaWFsaXplRm9jdXNPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gb3BlcmF0aW9uLm9wdGlvbnNcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi5vcHRpb25zLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3JhZGlhbCc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCByYWRpdXMsIGdyYWRpZW50UmFkaXVzLCBibHVyUmFkaXVzIH0gPSBvcHRpb25zXG4gICAgICAgICAgdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3JhZGlhbC1mb2N1cycsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBWZWN0b3IyLmZyb21PYmplY3QocG9zaXRpb24pLFxuICAgICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgICAgZ3JhZGllbnRSYWRpdXMsXG4gICAgICAgICAgICBibHVyUmFkaXVzXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbGluZWFyJzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgc2l6ZSwgZ3JhZGllbnRTaXplLCBibHVyUmFkaXVzIH0gPSBvcHRpb25zXG4gICAgICAgICAgdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ2xpbmVhci1mb2N1cycsIHtcbiAgICAgICAgICAgIHN0YXJ0OiBWZWN0b3IyLmZyb21PYmplY3Qoc3RhcnQpLFxuICAgICAgICAgICAgZW5kOiBWZWN0b3IyLmZyb21PYmplY3QoZW5kKSxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBncmFkaWVudFNpemUsXG4gICAgICAgICAgICBibHVyUmFkaXVzXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnB1dCBkaW1lbnNpb25zIGZvciB0aGUgZ2l2ZW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRJbnB1dERpbWVuc2lvbnNGb3JPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGxldCBvcGVyYXRpb25Gb3VuZCA9IGZhbHNlXG4gICAgbGV0IGlucHV0RGltZW5zaW9ucyA9IHRoaXMuX2VkaXRvci5nZXRJbnB1dERpbWVuc2lvbnMoKVxuXG4gICAgdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0U3RhY2soKVxuICAgICAgLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIGlmIChvcCA9PT0gb3BlcmF0aW9uKSBvcGVyYXRpb25Gb3VuZCA9IHRydWVcbiAgICAgICAgaWYgKG9wZXJhdGlvbkZvdW5kKSByZXR1cm5cbiAgICAgICAgaW5wdXREaW1lbnNpb25zID0gb3AuZ2V0TmV3RGltZW5zaW9ucyhpbnB1dERpbWVuc2lvbnMpXG4gICAgICB9KVxuXG4gICAgcmV0dXJuIGlucHV0RGltZW5zaW9uc1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvc2VyaWFsaXphdGlvbi8xLjAuMC9kZXNlcmlhbGl6ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFNESywgU0RLVXRpbHMsIEltYWdlRm9ybWF0LCBSZW5kZXJUeXBlIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmNvbnN0IFRXSUNFX1BJID0gTWF0aC5QSSAqIDJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VyaWFsaXplciB7XG4gIGNvbnN0cnVjdG9yIChlZGl0b3IpIHtcbiAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3JcblxuICAgIHRoaXMuX3NlcmlhbGl6ZU9wZXJhdGlvbnMgPSB0aGlzLl9zZXJpYWxpemVPcGVyYXRpb25zLmJpbmQodGhpcylcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNFUklBTElaQVRJT05cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZWRpdG9yIHN0YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zID0ge31cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHNlcmlhbGl6ZSAob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IFNES1V0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIGltYWdlOiB0cnVlXG4gICAgfSlcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICB2ZXJzaW9uOiAnMS4wLjAnXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZUlucHV0SW1hZ2UoZGF0YSlcbiAgICAgIC50aGVuKHRoaXMuX3NlcmlhbGl6ZU9wZXJhdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgaW5wdXQgaW1hZ2UgYXMgYmFzZTY0IGFuZCBhdHRhY2hlcyBpdCB0byBgZGF0YWBcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplSW5wdXRJbWFnZSAoZGF0YSkge1xuICAgIGNvbnN0IGltYWdlID0gdGhpcy5fZWRpdG9yLmdldEltYWdlKClcblxuICAgIGlmICghdGhpcy5fb3B0aW9ucy5pbWFnZSkge1xuICAgICAgZGF0YS5pbnB1dEltYWdlID0ge1xuICAgICAgICB3aWR0aDogaW1hZ2Uud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW1hZ2UuaGVpZ2h0XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpXG4gICAgfVxuXG4gICAgY29uc3Qgc2RrID0gbmV3IFNESygnd2ViZ2wnLCB7IGltYWdlIH0pXG5cbiAgICByZXR1cm4gc2RrLmV4cG9ydChSZW5kZXJUeXBlLkRBVEFfVVJMLCBJbWFnZUZvcm1hdC5QTkcpXG4gICAgICAudGhlbigoZGF0YVVybCkgPT4ge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltYWdlXG4gICAgICAgIGRhdGEuaW5wdXRJbWFnZSA9IHtcbiAgICAgICAgICB0eXBlOiBJbWFnZUZvcm1hdC5QTkcsXG4gICAgICAgICAgZGF0YTogZGF0YVVybC5yZXBsYWNlKC9eZGF0YTppbWFnZVxcLyguKj8pO2Jhc2U2NCwvLCAnJyksXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgb3BlcmF0aW9ucyBhbmQgYXR0YWNoZXMgdGhlbSB0byBgZGF0YWBcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplT3BlcmF0aW9ucyAoZGF0YSkge1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5fZWRpdG9yLm9wZXJhdGlvbnMuZ2V0U3RhY2soKVxuICAgIHN0YWNrLmZvckVhY2goKG9wZXJhdGlvbikgPT4ge1xuICAgICAgb3BlcmF0aW9ucy5wdXNoKHRoaXMuX3NlcmlhbGl6ZU9wZXJhdGlvbihvcGVyYXRpb24pKVxuICAgIH0pXG4gICAgZGF0YS5vcGVyYXRpb25zID0gb3BlcmF0aW9uc1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZU9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgc3dpdGNoIChvcGVyYXRpb24uY29uc3RydWN0b3IuaWRlbnRpZmllcikge1xuICAgICAgY2FzZSAnY3JvcCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVDcm9wT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgICAgIGNhc2UgJ29yaWVudGF0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZU9yaWVudGF0aW9uT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgICAgIGNhc2UgJ2ZpbHRlcic6XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVGaWx0ZXJPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgY2FzZSAnYWRqdXN0bWVudHMnOlxuICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplQWRqdXN0bWVudHNPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgY2FzZSAnc3ByaXRlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZVNwcml0ZU9wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgICBjYXNlICdyYWRpYWwtZm9jdXMnOlxuICAgICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplUmFkaWFsRm9jdXNPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgICAgY2FzZSAnbGluZWFyLWZvY3VzJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZUxpbmVhckZvY3VzT3BlcmF0aW9uKG9wZXJhdGlvbilcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHNlcmlhbGl6ZSBvcGVyYXRpb24gb2YgdHlwZSAke29wZXJhdGlvbi5jb25zdHJ1Y3Rvci5pZGVudGlmaWVyfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGNyb3Agb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbi5Dcm9wT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZUNyb3BPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBvcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucyhbJ3N0YXJ0JywgJ2VuZCcsICdyb3RhdGlvbicsICdzY2FsZSddLCB0cnVlKVxuICAgIG9wdGlvbnMucm90YXRpb24gPSAob3B0aW9ucy5yb3RhdGlvbiArIFRXSUNFX1BJKSAlIFRXSUNFX1BJXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdjcm9wJyxcbiAgICAgIG9wdGlvbnNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gb3JpZW50YXRpb24gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbi5PcmllbnRhdGlvbk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVPcmllbnRhdGlvbk9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdvcmllbnRhdGlvbicsXG4gICAgICBvcHRpb25zOiBvcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucyhbXG4gICAgICAgICdmbGlwVmVydGljYWxseScsXG4gICAgICAgICdmbGlwSG9yaXpvbnRhbGx5JyxcbiAgICAgICAgJ3JvdGF0aW9uJ1xuICAgICAgXSwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gZmlsdGVyIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkZpbHRlck9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVGaWx0ZXJPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZmlsdGVyJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgaW50ZW5zaXR5OiBvcGVyYXRpb24uZ2V0SW50ZW5zaXR5KCksXG4gICAgICAgIG5hbWU6IG9wZXJhdGlvbi5nZXRGaWx0ZXIoKS5jb25zdHJ1Y3Rvci5pZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGFkanVzdG1lbnRzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkFkanVzdG1lbnRzT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZUFkanVzdG1lbnRzT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IGF2YWlsYWJsZU9wdGlvbnMgfSA9IG9wZXJhdGlvblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7fVxuICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gYXZhaWxhYmxlT3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uID0gYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXVxuICAgICAgY29uc3QgdmFsdWUgPSBvcGVyYXRpb24uZ2V0T3B0aW9uKG9wdGlvbk5hbWUpXG4gICAgICBpZiAodmFsdWUgIT09IG9wdGlvbi5kZWZhdWx0KSB7XG4gICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZSAtIG9wdGlvbi5kZWZhdWx0IC8vIHNjYWxlIHRvIC0xLi4uMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2FkanVzdG1lbnRzJyxcbiAgICAgIG9wdGlvbnNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gc3ByaXRlIG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VyaWFsaXplU3ByaXRlT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCBzcHJpdGVzID0gb3BlcmF0aW9uLmdldFNwcml0ZXMoKVxuICAgICAgLm1hcCgoc3ByaXRlKSA9PiB7XG4gICAgICAgIGlmIChzcHJpdGUgaW5zdGFuY2VvZiBvcGVyYXRpb24uY29uc3RydWN0b3IuU3RpY2tlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVTdGlja2VyKG9wZXJhdGlvbiwgc3ByaXRlKVxuICAgICAgICB9IGVsc2UgaWYgKHNwcml0ZSBpbnN0YW5jZW9mIG9wZXJhdGlvbi5jb25zdHJ1Y3Rvci5UZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZVRleHQob3BlcmF0aW9uLCBzcHJpdGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3ByaXRlIGluc3RhbmNlb2Ygb3BlcmF0aW9uLmNvbnN0cnVjdG9yLkJydXNoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZUJydXNoKG9wZXJhdGlvbiwgc3ByaXRlKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcHJpdGUnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBzcHJpdGVzXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIHN0aWNrZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uU3RpY2tlcn0gc3ByaXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXJpYWxpemVTdGlja2VyIChvcGVyYXRpb24sIHNwcml0ZSkge1xuICAgIGNvbnN0IGFkanVzdG1lbnRzID0gc3ByaXRlLmdldEFkanVzdG1lbnRzKClcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBzcHJpdGUuc2VyaWFsaXplT3B0aW9ucyhbXG4gICAgICAnbmFtZScsICdwb3NpdGlvbicsICdkaW1lbnNpb25zJywgJ2ZsaXBWZXJ0aWNhbGx5JywgJ2ZsaXBIb3Jpem9udGFsbHknLCAncm90YXRpb24nXG4gICAgXSwgdHJ1ZSlcbiAgICBvcHRpb25zLnJvdGF0aW9uID0gKG9wdGlvbnMucm90YXRpb24gKyBUV0lDRV9QSSkgJSBUV0lDRV9QSVxuXG4gICAgY29uc3QgYWRqdXN0bWVudHNPcHRpb25zID0gYWRqdXN0bWVudHMuYXZhaWxhYmxlT3B0aW9uc1xuICAgIG9wdGlvbnMuYWRqdXN0bWVudHMgPSB7XG4gICAgICBicmlnaHRuZXNzOiBhZGp1c3RtZW50cy5nZXRCcmlnaHRuZXNzKCkgLSBhZGp1c3RtZW50c09wdGlvbnMuYnJpZ2h0bmVzcy5kZWZhdWx0LFxuICAgICAgc2F0dXJhdGlvbjogYWRqdXN0bWVudHMuZ2V0U2F0dXJhdGlvbigpIC0gYWRqdXN0bWVudHNPcHRpb25zLnNhdHVyYXRpb24uZGVmYXVsdCxcbiAgICAgIGNvbnRyYXN0OiBhZGp1c3RtZW50cy5nZXRDb250cmFzdCgpIC0gYWRqdXN0bWVudHNPcHRpb25zLmNvbnRyYXN0LmRlZmF1bHRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3N0aWNrZXInLFxuICAgICAgb3B0aW9uc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiB0ZXh0IHNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5UZXh0fSBzcHJpdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVRleHQgKG9wZXJhdGlvbiwgc3ByaXRlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHNwcml0ZS5zZXJpYWxpemVPcHRpb25zKFtcbiAgICAgICdmb250U2l6ZScsICdsaW5lSGVpZ2h0JywgJ2ZvbnRGYW1pbHknLCAnZm9udFdlaWdodCcsICdhbGlnbm1lbnQnLFxuICAgICAgJ2NvbG9yJywgJ2JhY2tncm91bmRDb2xvcicsXG4gICAgICAncG9zaXRpb24nLCAncm90YXRpb24nLFxuICAgICAgJ3RleHQnLCAnbWF4V2lkdGgnXG4gICAgXSwgdHJ1ZSlcbiAgICBvcHRpb25zLnJvdGF0aW9uID0gKG9wdGlvbnMucm90YXRpb24gKyBUV0lDRV9QSSkgJSBUV0lDRV9QSVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgIG9wdGlvbnNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gYnJ1c2ggc3ByaXRlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLkJydXNofSBzcHJpdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZUJydXNoIChvcGVyYXRpb24sIHNwcml0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYnJ1c2gnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBwYXRoczogc3ByaXRlLmdldFBhdGhzKClcbiAgICAgICAgICAubWFwKChwYXRoKSA9PiB0aGlzLl9zZXJpYWxpemVQYXRoKHBhdGgpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBwYXRoXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLkJydXNoLlBhdGh9IHBhdGhcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVBhdGggKHBhdGgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gcGF0aC5zZXJpYWxpemVPcHRpb25zKFsnY29sb3InLCAndGhpY2tuZXNzJ10sIHRydWUpXG5cbiAgICBvcHRpb25zLnNpemUgPSBvcHRpb25zLnRoaWNrbmVzc1xuICAgIGRlbGV0ZSBvcHRpb25zLnRoaWNrbmVzc1xuXG4gICAgb3B0aW9ucy5wb2ludHMgPSBwYXRoLmdldENvbnRyb2xQb2ludHMoKS5tYXAoKHBvaW50KSA9PlxuICAgICAgcG9pbnQuZ2V0UG9zaXRpb24oKS50b09iamVjdCgpXG4gICAgKVxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gcmFkaWFsIGZvY3VzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlJhZGlhbEZvY3VzT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZVJhZGlhbEZvY3VzT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2ZvY3VzJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogJ3JhZGlhbCcsXG4gICAgICAgIG9wdGlvbnM6IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKFsncG9zaXRpb24nLCAncmFkaXVzJywgJ2dyYWRpZW50UmFkaXVzJywgJ2JsdXJSYWRpdXMnXSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gbGluZWFyIGZvY3VzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkxpbmVhckZvY3VzT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlcmlhbGl6ZUxpbmVhckZvY3VzT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2ZvY3VzJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgIG9wdGlvbnM6IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKFsnc3RhcnQnLCAnZW5kJywgJ2JsdXJSYWRpdXMnLCAnc2l6ZScsICdncmFkaWVudFNpemUnXSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5wdXQgZGltZW5zaW9ucyBmb3IgdGhlIGdpdmVuIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5wdXREaW1lbnNpb25zRm9yT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICBsZXQgb3BlcmF0aW9uRm91bmQgPSBmYWxzZVxuICAgIGxldCBpbnB1dERpbWVuc2lvbnMgPSB0aGlzLl9lZGl0b3IuZ2V0SW5wdXREaW1lbnNpb25zKClcblxuICAgIHRoaXMuX2VkaXRvci5vcGVyYXRpb25zLmdldFN0YWNrKClcbiAgICAgIC5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICBpZiAob3AgPT09IG9wZXJhdGlvbikgb3BlcmF0aW9uRm91bmQgPSB0cnVlXG4gICAgICAgIGlmIChvcGVyYXRpb25Gb3VuZCkgcmV0dXJuXG4gICAgICAgIGlucHV0RGltZW5zaW9ucyA9IG9wLmdldE5ld0RpbWVuc2lvbnMoaW5wdXREaW1lbnNpb25zKVxuICAgICAgfSlcblxuICAgIHJldHVybiBpbnB1dERpbWVuc2lvbnNcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3NlcmlhbGl6YXRpb24vMS4wLjAvc2VyaWFsaXplci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxubGV0IG1heExvZ0xldmVsID0gJ3dhcm4nXG5cbmNvbnN0IExFVkVMUyA9IFtcbiAgeyB0eXBlOiAndHJhY2UnLCBiYWNrZ3JvdW5kOiAnI0VFRUVFRScsIGNvbG9yOiAnI0FBQUFBQScgfSxcbiAgeyB0eXBlOiAnaW5mbycsIGJhY2tncm91bmQ6ICcjQkRFNUY4JywgY29sb3I6ICcjMDA1MjlCJyB9LFxuICB7IHR5cGU6ICd3YXJuJywgYmFja2dyb3VuZDogJyNGRUVGQjMnLCBjb2xvcjogJyM5RjYwMDAnIH0sXG4gIHsgdHlwZTogJ2Vycm9yJywgYmFja2dyb3VuZDogJyNGRkJBQkEnLCBjb2xvcjogJyNEODAwMEMnIH0sXG4gIHsgdHlwZTogJ2xvZycsIGJhY2tncm91bmQ6ICcjRUVFRUVFJywgY29sb3I6ICcjMWY0ZjZiJyB9XG5dXG5jb25zdCBMRVZFTF9UWVBFUyA9IExFVkVMUy5tYXAoKGwpID0+IGwudHlwZSlcblxubGV0IExvZyA9IHt9XG5cbkxvZy5zZXRMZXZlbCA9IChfbGV2ZWwpID0+IHsgbWF4TG9nTGV2ZWwgPSBfbGV2ZWwgfVxuTG9nLmNhbkxvZyA9ICh0eXBlKSA9PiB7XG4gIGlmIChtYXhMb2dMZXZlbCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXG4gIGNvbnN0IGN1cnJlbnRMZXZlbEluZGV4ID0gTEVWRUxfVFlQRVMuaW5kZXhPZih0eXBlKVxuICBjb25zdCBtYXhMZXZlbEluZGV4ID0gTEVWRUxfVFlQRVMuaW5kZXhPZihtYXhMb2dMZXZlbClcbiAgaWYgKGN1cnJlbnRMZXZlbEluZGV4IDwgbWF4TGV2ZWxJbmRleCkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB0cnVlXG59XG5Mb2cuaGFzQ29sb3JmdWxPdXRwdXQgPSAoKSA9PiB7XG4gIHJldHVybiAoIXByb2Nlc3MgfHwgKHByb2Nlc3MgJiYgcHJvY2Vzcy5icm93c2VyKSkgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9HZWNrb3xXZWJLaXQvaSkgJiZcbiAgICAgICFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9UcmlkZW50LylcbiAgICApXG59XG5cbkxvZy5wcmludEVycm9yID0gKGUpID0+IHtcbiAgY29uc3QgbGluZXMgPSBlLnN0YWNrLnNwbGl0KCdcXG4nKVxuICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgTG9nLmVycm9yKCdFcnJvcicsIGxpbmUpXG4gIH0pXG59XG5cbkxFVkVMUy5mb3JFYWNoKChsZXZlbCkgPT4ge1xuICBjb25zdCB7IHR5cGUsIGJhY2tncm91bmQsIGNvbG9yIH0gPSBsZXZlbFxuICBMb2dbdHlwZV0gPSBmdW5jdGlvbiAodGFnLCAuLi5hcmdzKSB7XG4gICAgaWYgKCFMb2cuY2FuTG9nKHR5cGUpKSByZXR1cm5cblxuICAgIGNvbnN0IG91dHB1dCA9IGFyZ3NcbiAgICAgIC5tYXAoKGEpID0+ICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpID8gYSA6IGEudG9TdHJpbmcoKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICBpZiAoIUxvZy5oYXNDb2xvcmZ1bE91dHB1dCgpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5sb2coYFBob3RvRWRpdG9yU0RLIHwgJHt0YWd9IHwgJHtvdXRwdXR9YClcbiAgICB9XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgJWMgICVjIFBob3RvRWRpdG9yU0RLICVjICAlYyAke3RhZ30gJWMgICR7b3V0cHV0fSAgJWMgIGAsXG4gICAgICAnYmFja2dyb3VuZDogIzQzQURFQjsgbGluZS1oZWlnaHQ6IDIwcHg7IHBhZGRpbmc6IDRweCAwJyxcbiAgICAgICdiYWNrZ3JvdW5kOiAjMkIyQjJCOyBjb2xvcjogd2hpdGU7IGxpbmUtaGVpZ2h0OiAyMHB4OyBwYWRkaW5nOiA0cHggMCcsXG4gICAgICAnYmFja2dyb3VuZDogIzQzQURFQjsgbGluZS1oZWlnaHQ6IDIwcHg7IHBhZGRpbmc6IDRweCAwJyxcbiAgICAgIGBiYWNrZ3JvdW5kOiAke2JhY2tncm91bmR9OyBjb2xvcjogJHtjb2xvcn07IGxpbmUtaGVpZ2h0OiAyMHB4OyBwYWRkaW5nOiA0cHggMDsgZm9udC13ZWlnaHQ6IGJvbGRgLFxuICAgICAgJ2JhY2tncm91bmQ6ICMyQjJCMkI7IGNvbG9yOiB3aGl0ZTsgbGluZS1oZWlnaHQ6IDIwcHg7IHBhZGRpbmc6IDRweCAwJyxcbiAgICAgICdiYWNrZ3JvdW5kOiAjNDNBREVCOyBsaW5lLWhlaWdodDogMjBweDsgcGFkZGluZzogNHB4IDAnKVxuICB9XG59KVxuXG5leHBvcnQgZGVmYXVsdCBMb2dcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zaGFyZWQvbG9nLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcElFICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vY2xhc3NuYW1lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0LCBSZWFjdEJFTSwgUHJvbWlzZSB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgTG9hZGluZ1NjcmVlbkNvbXBvbmVudCBmcm9tICcuL3NjcmVlbnMvbG9hZGluZy9sb2FkaW5nLXNjcmVlbi1jb21wb25lbnQnXG5pbXBvcnQgU3BsYXNoU2NyZWVuQ29tcG9uZW50IGZyb20gJy4vc2NyZWVucy9zcGxhc2gvc3BsYXNoLXNjcmVlbi1jb21wb25lbnQnXG5pbXBvcnQgUGhvdG9Sb2xsU2NyZWVuQ29tcG9uZW50IGZyb20gJy4vc2NyZWVucy9waG90by1yb2xsL3Bob3RvLXJvbGwtc2NyZWVuLWNvbXBvbmVudCdcbmltcG9ydCBXZWJjYW1TY3JlZW5Db21wb25lbnQgZnJvbSAnLi9zY3JlZW5zL3dlYmNhbS93ZWJjYW0tc2NyZWVuLWNvbXBvbmVudCdcbmltcG9ydCBFZGl0b3JTY3JlZW5Db21wb25lbnQgZnJvbSAnLi9zY3JlZW5zL2VkaXRvci9lZGl0b3Itc2NyZWVuLWNvbXBvbmVudCdcbmltcG9ydCBFbXB0eVNjcmVlbkNvbXBvbmVudCBmcm9tICcuL3NjcmVlbnMvc2NyZWVuLWNvbXBvbmVudCdcbmltcG9ydCBNb2RhbENvbnRhaW5lckNvbXBvbmVudCBmcm9tICcuL21vZGFsLWNvbnRhaW5lci1jb21wb25lbnQnXG5pbXBvcnQgTW9kYWxNYW5hZ2VyIGZyb20gJy4uL2xpYi9tb2RhbC1tYW5hZ2VyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHBDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9zY3JlZW5zID0ge1xuICAgICAgbG9hZGluZzogTG9hZGluZ1NjcmVlbkNvbXBvbmVudCxcbiAgICAgIHNwbGFzaDogU3BsYXNoU2NyZWVuQ29tcG9uZW50LFxuICAgICAgcGhvdG9Sb2xsOiBQaG90b1JvbGxTY3JlZW5Db21wb25lbnQsXG4gICAgICB3ZWJjYW06IFdlYmNhbVNjcmVlbkNvbXBvbmVudCxcbiAgICAgIGVkaXRvcjogRWRpdG9yU2NyZWVuQ29tcG9uZW50LFxuICAgICAgZW1wdHk6IEVtcHR5U2NyZWVuQ29tcG9uZW50XG4gICAgfVxuXG4gICAgbGV0IGluaXRpYWxTY3JlZW5cbiAgICBpZiAodGhpcy5wcm9wcy5vcHRpb25zLnByZWxvYWRlcikge1xuICAgICAgaW5pdGlhbFNjcmVlbiA9ICdsb2FkaW5nJ1xuICAgIH1cblxuICAgIHRoaXMuX3NjcmVlbkFmdGVyTG9hZGluZ1xuICAgIGlmICh0aGlzLnByb3BzLm9wdGlvbnMuZWRpdG9yLmltYWdlKSB7XG4gICAgICB0aGlzLl9zY3JlZW5BZnRlckxvYWRpbmcgPSAnZWRpdG9yJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zY3JlZW5BZnRlckxvYWRpbmcgPSAnc3BsYXNoJ1xuICAgIH1cblxuICAgIGlmICghaW5pdGlhbFNjcmVlbikge1xuICAgICAgaW5pdGlhbFNjcmVlbiA9IHRoaXMuX3NjcmVlbkFmdGVyTG9hZGluZ1xuICAgIH1cblxuICAgIHRoaXMuX3ByZXZpb3VzU2NyZWVuc1N0YWNrID0gW11cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYWN0aXZlU2NyZWVuOiB0aGlzLl9zY3JlZW5zW2luaXRpYWxTY3JlZW5dLFxuICAgICAgYWN0aXZlU2NyZWVuTmFtZTogaW5pdGlhbFNjcmVlbixcbiAgICAgIHNjcmVlbnM6IHtcbiAgICAgICAgW2luaXRpYWxTY3JlZW5dOiB0aGlzLl9zY3JlZW5zW2luaXRpYWxTY3JlZW5dXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgYXBwIGhhcyBhIHByZXZpb3VzIHNjcmVlbiBvbiB0aGUgc3RhY2tcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGhhc1ByZXZpb3VzU2NyZWVuICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9wcmV2aW91c1NjcmVlbnNTdGFjay5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBzY3JlZW5cbiAgICogQHJldHVybiB7U2NyZWVufVxuICAgKi9cbiAgZ2V0UHJldmlvdXNTY3JlZW4gKCkge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5fcHJldmlvdXNTY3JlZW5zU3RhY2tcbiAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2hlcyB0byB0aGUgc2NyZWVuIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICBzd2l0Y2hUb1NjcmVlbiAobmFtZSkge1xuICAgIGxldCBTY3JlZW4gPSBudWxsXG4gICAgaWYgKG5hbWUgPT09ICdiYWNrJykge1xuICAgICAgU2NyZWVuID0gdGhpcy5fcHJldmlvdXNTY3JlZW5zU3RhY2sucG9wKClcbiAgICAgIGlmICghU2NyZWVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHN3aXRjaCB0byBwcmV2aW91cyBzY3JlZW4gLSBubyBwcmV2aW91cyBzY3JlZW4gZm91bmQuJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5hbWUgPT09ICdwb3N0LWxvYWRpbmcnKSBuYW1lID0gdGhpcy5fc2NyZWVuQWZ0ZXJMb2FkaW5nXG5cbiAgICAgIFNjcmVlbiA9IHRoaXMuX3NjcmVlbnNbbmFtZV1cbiAgICAgIGlmICghU2NyZWVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzY3JlZW4gXFxgJHtuYW1lfVxcYGApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ByZXZpb3VzU2NyZWVuc1N0YWNrLnB1c2godGhpcy5zdGF0ZS5hY3RpdmVTY3JlZW4pXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXRlLnNjcmVlbnNbbmFtZV0pIHtcbiAgICAgIHRoaXMuc3RhdGUuc2NyZWVuc1tuYW1lXSA9IFNjcmVlblxuICAgIH1cblxuICAgIC8vIFJldGFpbiBlZGl0b3IgY29tcG9uZW50XG4gICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlU2NyZWVuTmFtZSAhPT0gJ2VkaXRvcicpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0YXRlLnNjcmVlbnNbdGhpcy5zdGF0ZS5hY3RpdmVTY3JlZW5OYW1lXVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZVNjcmVlbjogU2NyZWVuLCBhY3RpdmVTY3JlZW5OYW1lOiBuYW1lIH0sICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBpbWFnZSBpcyByZWFkeSBmb3IgZWRpdGluZ1xuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlc2V0RWRpdG9yXG4gICAqL1xuICBzZXRJbWFnZSAoaW1hZ2UsIHJlc2V0RWRpdG9yKSB7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzXG4gICAgb3B0aW9ucy5lZGl0b3IuaW1hZ2UgPSBpbWFnZVxuXG4gICAgY29uc3QgZmlyc3RFZGl0b3JMYXVuY2ggPSAhdGhpcy5yZWZzLmVkaXRvclNjcmVlblxuICAgIHRoaXMuc3dpdGNoVG9TY3JlZW4oJ2VkaXRvcicpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICghZmlyc3RFZGl0b3JMYXVuY2gpIHtcbiAgICAgICAgICB0aGlzLnJlZnMuZWRpdG9yU2NyZWVuLnNldEltYWdlKGltYWdlLCByZXNldEVkaXRvcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRzIGFuIGltYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZG93bmxvYWQgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZXhwb3J0ICguLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlU2NyZWVuICE9PSB0aGlzLl9zY3JlZW5zLmVkaXRvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVW5hYmxlIHRvIGV4cG9ydDogQWN0aXZlIHNjcmVlbiBpcyBub3QgdGhlIGVkaXRvciBzY3JlZW4uJykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUuc2NyZWVucy5lZGl0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZnMuZWRpdG9yU2NyZWVuLmV4cG9ydCguLi5hcmdzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3JcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9XG4gICAqL1xuICBnZXRFZGl0b3IgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmFjdGl2ZVNjcmVlbiAhPT0gdGhpcy5fc2NyZWVucy5lZGl0b3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgZWRpdG9yOiBBY3RpdmUgc2NyZWVuIGlzIG5vdCB0aGUgZWRpdG9yIHNjcmVlbi4nKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5zY3JlZW5zLmVkaXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMucmVmcy5lZGl0b3JTY3JlZW4uZ2V0RWRpdG9yKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZWRpdG9yIHN0YXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzZXJpYWxpemUgKC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuc2NyZWVucy5lZGl0b3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0VkaXRvciBzY3JlZW4gdW5hdmFpbGFibGUnKSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVmcy5lZGl0b3JTY3JlZW4uc2VyaWFsaXplKC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZGVzZXJpYWxpemUgKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuc2NyZWVucy5lZGl0b3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0VkaXRvciBzY3JlZW4gdW5hdmFpbGFibGUnKSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVmcy5lZGl0b3JTY3JlZW4uZGVzZXJpYWxpemUoZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250ZXh0IHBhc3NlZCB0byBhbGwgY2hpbGRyZW5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0ICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdWk6IHRoaXMucHJvcHMudWksXG4gICAgICBvcHRpb25zOiB0aGlzLnByb3BzLm9wdGlvbnMsXG4gICAgICBtZWRpYXRvcjogdGhpcy5wcm9wcy5tZWRpYXRvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBleGlzdGluZyBzY3JlZW5zXG4gICAqIEByZXR1cm4ge1NjcmVlbkNvbXBvbmVudFtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclNjcmVlbnMgKCkge1xuICAgIGxldCByZW5kZXJlZFNjcmVlbnMgPSBbXVxuXG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnN0YXRlLnNjcmVlbnMpIHtcbiAgICAgIGNvbnN0IFNjcmVlbiA9IHRoaXMuc3RhdGUuc2NyZWVuc1tuYW1lXVxuICAgICAgY29uc3QgdmlzaWJsZSA9IHRoaXMuc3RhdGUuYWN0aXZlU2NyZWVuID09PSBTY3JlZW5cbiAgICAgIHJlbmRlcmVkU2NyZWVucy5wdXNoKDxTY3JlZW4gcmVmPXtgJHtuYW1lfVNjcmVlbmB9IGFwcD17dGhpc30gdmlzaWJsZT17dmlzaWJsZX0gLz4pXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkU2NyZWVuc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3QuQ29tcG9uZW50fVxuICAgKi9cbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gUmVhY3RCRU0udHJhbnNmb3JtKDxkaXYgYmVtPSdiOmVkaXRvcic+XG4gICAgICA8TW9kYWxDb250YWluZXJDb21wb25lbnRcbiAgICAgICAgbW9kYWxNYW5hZ2VyPXtNb2RhbE1hbmFnZXIuaW5zdGFuY2V9IC8+XG5cbiAgICAgIHt0aGlzLl9yZW5kZXJTY3JlZW5zKCl9XG4gICAgPC9kaXY+KVxuICB9XG59XG5cbkFwcENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgdWk6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbWVkaWF0b3I6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgb3B0aW9uczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59XG5cbkFwcENvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIHVpOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIG1lZGlhdG9yOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIG9wdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9hcHAtY29tcG9uZW50LmpzeCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cbmltcG9ydCBHb29nbGVGb250c0xvYWRlciBmcm9tICcuL2ZvbnQtbG9hZGVycy9nb29nbGUnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbnRMb2FkZXIge1xuICBjb25zdHJ1Y3RvciAoZm9udHMpIHtcbiAgICB0aGlzLl9mb250cyA9IGZvbnRzXG4gICAgdGhpcy5fbG9hZGVkRm9udHMgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZvbnRzXG4gICAqIEBwYXJhbSB7Rm9udFtdfSBmb250c1xuICAgKi9cbiAgc2V0Rm9udHMgKGZvbnRzKSB7XG4gICAgdGhpcy5fZm9udHMgPSBmb250c1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZm9udCBsb2FkZXIgbmVlZHMgdG8gbG9hZCBzb21ldGhpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIG5lZWRzVG9Mb2FkICgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZvbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuX2ZvbnRzW2ldLmdldFByb3ZpZGVyKClcbiAgICAgIGlmICghcHJvdmlkZXIpIGNvbnRpbnVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIGlkZW50aWZpZXIgZm9yIHRoZSBnaXZlbiBmb250XG4gICAqIEBwYXJhbSAge0ZvbnR9IGZvbnRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEZvbnRJZGVudGlmaWVyIChmb250KSB7XG4gICAgcmV0dXJuIGAke2ZvbnQuZ2V0TmFtZSgpfS0ke2ZvbnQuZ2V0Rm9udFdlaWdodCgpfS0ke2ZvbnQuZ2V0Rm9udEZhbWlseSgpfS0ke2ZvbnQuZ2V0Rm9udFN0eWxlKCl9YFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZm9udCBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZFxuICAgKiBAcGFyYW0gIHtGb250fSBmb250XG4gICAqL1xuICBmb250TG9hZGVkIChmb250KSB7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuX2dldEZvbnRJZGVudGlmaWVyKGZvbnQpXG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlZEZvbnRzLmluZGV4T2YoaWRlbnRpZmllcikgIT09IC0xXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gZm9udCB0byBsb2FkZWRcbiAgICogQHBhcmFtIHtGb250fSBmb250XG4gICAqL1xuICBzZXRGb250TG9hZGVkIChmb250KSB7XG4gICAgaWYgKCF0aGlzLmZvbnRMb2FkZWQoZm9udCkpIHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLl9nZXRGb250SWRlbnRpZmllcihmb250KVxuICAgICAgdGhpcy5fbG9hZGVkRm9udHMucHVzaChpZGVudGlmaWVyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgZ2l2ZW4gZm9udHNcbiAgICogQHBhcmFtICB7T2JqZWN0W119IGZvbnRzXG4gICAqL1xuICBsb2FkICgpIHtcbiAgICBjb25zdCBmb250cyA9IHRoaXMuX2ZvbnRzLnNsaWNlKClcbiAgICBjb25zdCBsb2FkZXJzID0ge1xuICAgICAgZ29vZ2xlOiBuZXcgR29vZ2xlRm9udHNMb2FkZXIoKVxuICAgIH1cblxuICAgIGZvbnRzXG4gICAgICAuZmlsdGVyKChmb250KSA9PiAhdGhpcy5mb250TG9hZGVkKGZvbnQpKVxuICAgICAgLmZvckVhY2goKGZvbnQpID0+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBmb250LmdldFByb3ZpZGVyKClcbiAgICAgICAgaWYgKCFwcm92aWRlcikgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgbG9hZGVyID0gbG9hZGVyc1twcm92aWRlcl1cbiAgICAgICAgbG9hZGVyLmFkZChmb250KVxuICAgICAgfSlcblxuICAgIGNvbnN0IHByb21pc2VzID0gW11cbiAgICBmb3IgKGxldCBuYW1lIGluIGxvYWRlcnMpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobG9hZGVyc1tuYW1lXS5sb2FkKCkpXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZm9udHMuZm9yRWFjaCgoZm9udCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0Rm9udExvYWRlZChmb250KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL2ZvbnQtbG9hZGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlicmFyeSB9IGZyb20gJy4vbGlicmFyeSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VhcmNoU3VnZ2VzdGlvbiB9IGZyb20gJy4vc2VhcmNoLXN1Z2dlc3Rpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBob3RvIH0gZnJvbSAnLi9waG90bydcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9waG90by1yb2xsL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiY29udHJvbHNcIjoge1xuXHRcdFwib3ZlcnZpZXdcIjoge1xuXHRcdFx0XCJmaWx0ZXJzXCI6IFwiRmlsdGVyXCIsXG5cdFx0XHRcImFkanVzdG1lbnRzXCI6IFwiS29ycmVrdHVyZW5cIixcblx0XHRcdFwiY3JvcFwiOiBcIlp1c2NobmVpZGVuXCIsXG5cdFx0XHRcImJsdXJcIjogXCJXZWljaHplaWNobmVuXCIsXG5cdFx0XHRcImZyYW1lXCI6IFwiUmFobWVuXCIsXG5cdFx0XHRcInN0aWNrZXJcIjogXCJTdGlja2VyXCIsXG5cdFx0XHRcInRleHRcIjogXCJUZXh0XCIsXG5cdFx0XHRcImJydXNoXCI6IFwiTWFsZW5cIixcblx0XHRcdFwic2VsZWN0aXZlLWJsdXJcIjogXCJTZWwuIFVuc2Now6RyZmVcIlxuXHRcdH0sXG5cdFx0XCJ0ZXh0XCI6IHtcblx0XHRcdFwiZm9yZWdyb3VuZFwiOiBcIlZvcmRlcmdydW5kXCIsXG5cdFx0XHRcImJhY2tncm91bmRcIjogXCJIaW50ZXJncnVuZFwiLFxuXHRcdFx0XCJzaXplXCI6IFwiR3LDtsOfZVwiLFxuXHRcdFx0XCJmb250XCI6IFwiU2NocmlmdGFydFwiLFxuXHRcdFx0XCJhbGlnbm1lbnRcIjogXCJBdXNyaWNodHVuZ1wiLFxuXHRcdFx0XCJ0YWtlVG9Gcm9udFwiOiBcIk5hY2ggb2JlblwiXG5cdFx0fSxcblx0XHRcImFkanVzdG1lbnRzXCI6IHtcblx0XHRcdFwiYnJpZ2h0bmVzc1wiOiBcIkhlbGxpZ2tlaXRcIixcblx0XHRcdFwiY29udHJhc3RcIjogXCJLb250cmFzdFwiLFxuXHRcdFx0XCJzYXR1cmF0aW9uXCI6IFwiU8OkdHRpZ3VuZ1wiLFxuXHRcdFx0XCJnYW1tYVwiOiBcIkdhbW1hXCIsXG5cdFx0XHRcImV4cG9zdXJlXCI6IFwiQmVsaWNodHVuZ1wiLFxuXHRcdFx0XCJzaGFkb3dzXCI6IFwiU2NoYXR0ZW5cIixcblx0XHRcdFwiaGlnaGxpZ2h0c1wiOiBcIkxpY2h0ZXJcIixcblx0XHRcdFwiY2xhcml0eVwiOiBcIktsYXJoZWl0XCJcblx0XHR9LFxuXHRcdFwiY3JvcFwiOiB7XG5cdFx0XHRcIm5vbmVcIjogXCJPcmlnaW5hbFwiLFxuXHRcdFx0XCJjdXN0b21cIjogXCJNYW51ZWxsXCIsXG5cdFx0XHRcInNxdWFyZVwiOiBcIlF1YWRyYXRpc2NoXCIsXG5cdFx0XHRcIjQtM1wiOiBcIjQ6M1wiLFxuXHRcdFx0XCIxNi05XCI6IFwiMTY6OVwiLFxuXHRcdFx0XCJzb2NpYWxcIjogXCJTb2NpYWwgTWVkaWFcIixcblx0XHRcdFwiZmItYWRcIjogXCJGYWNlYm9vayBBZFwiLFxuXHRcdFx0XCJmYi1wb3N0XCI6IFwiRmFjZWJvb2sgUG9zdFwiLFxuXHRcdFx0XCJmYi1jb3ZlclwiOiBcIkZhY2Vib29rIENvdmVyXCIsXG5cdFx0XHRcInJvdGF0aW9uXCI6IFwiRHJlaHVuZ1wiXG5cdFx0fSxcblx0XHRcImZvY3VzXCI6IHtcblx0XHRcdFwibm9uZVwiOiBcIk9yaWdpbmFsXCIsXG5cdFx0XHRcInJhZGlhbFwiOiBcIktyZWlzZsO2cm1pZ1wiLFxuXHRcdFx0XCJsaW5lYXJcIjogXCJMaW5lYXJcIixcblx0XHRcdFwiYmx1clJhZGl1c1wiOiBcIlJhZGl1c1wiXG5cdFx0fSxcblx0XHRcInNlbGVjdGl2ZUJsdXJcIjoge1xuXHRcdFx0XCJibHVyUmFkaXVzXCI6IFwiUmFkaXVzXCIsXG5cdFx0XHRcInRoaWNrbmVzc1wiOiBcIkRpY2tlXCJcblx0XHR9LFxuXHRcdFwiZmlsdGVyc1wiOiB7XG5cdFx0XHRcImludGVuc2l0eVwiOiBcIkludGVuc2l0w6R0XCIsXG5cdFx0XHRcImNhdGVnb3JpZXNcIjoge1xuXHRcdFx0XHRcImFsbFwiOiBcIkFsbGVcIixcblx0XHRcdFx0XCJyZXRyb1wiOiBcIlJldHJvXCIsXG5cdFx0XHRcdFwiYndcIjogXCJTY2h3YXJ6ICYgV2Vpw59cIixcblx0XHRcdFx0XCJzdW1tZXJcIjogXCJTb21tZXJcIixcblx0XHRcdFx0XCJ3aW50ZXJcIjogXCJXaW50ZXJcIixcblx0XHRcdFx0XCJzcGVjaWFsXCI6IFwiU3BlemlhbFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcInN0aWNrZXJcIjoge1xuXHRcdFx0XCJicmlnaHRuZXNzXCI6IFwiSGVsbGlna2VpdFwiLFxuXHRcdFx0XCJjb250cmFzdFwiOiBcIktvbnRyYXN0XCIsXG5cdFx0XHRcInNhdHVyYXRpb25cIjogXCJTw6R0dGlndW5nXCIsXG5cdFx0XHRcImJsdXJcIjogXCJXZWljaHplaWNobmVuXCIsXG5cdFx0XHRcImZsaXBcIjogXCJTcGllZ2VsblwiLFxuXHRcdFx0XCJmbGlwLXZcIjogXCJTcGllZ2VsbiAoVilcIixcblx0XHRcdFwiZmxpcC1oXCI6IFwiU3BpZWdlbG4gKEgpXCIsXG5cdFx0XHRcInRha2VUb0Zyb250XCI6IFwiTmFjaCBvYmVuXCIsXG5cdFx0XHRcImNhdGVnb3JpZXNcIjoge1xuXHRcdFx0XHRcImFsbFwiOiBcIkFsbGVcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJicnVzaFwiOiB7XG5cdFx0XHRcInRoaWNrbmVzc1wiOiBcIkRpY2tlXCIsXG5cdFx0XHRcImNvbG9yXCI6IFwiRmFyYmVcIlxuXHRcdH0sXG5cdFx0XCJmcmFtZVwiOiB7XG5cdFx0XHRcIm5vRnJhbWVcIjogXCJLZWluIFJhaG1lblwiLFxuXHRcdFx0XCJzY2FsZVwiOiBcIkdyw7bDn2VcIlxuXHRcdH1cblx0fSxcblx0XCJ3ZWJjYW1cIjoge1xuXHRcdFwiaGVhZGxpbmVcIjogXCJNYWNoZSBlaW4gRm90byFcIlxuXHR9LFxuXHRcImVkaXRvclwiOiB7XG5cdFx0XCJoZWFkbGluZVwiOiBcIkZvdG8gZWRpdGllcmVuXCIsXG5cdFx0XCJuZXdcIjogXCJOZXVcIixcblx0XHRcImJhY2tncm91bmRJbWFnZVwiOiBcIkhpbnRlcmdydW5kYmlsZFwiLFxuXHRcdFwidW5kb1wiOiBcIlLDvGNrZ8OkbmdpZ1wiLFxuXHRcdFwiZXhwb3J0XCI6IFwiU3BlaWNoZXJuXCJcblx0fSxcblx0XCJzcGxhc2hcIjoge1xuXHRcdFwidXBsb2FkXCI6IHtcblx0XHRcdFwiYnV0dG9uXCI6IFwiTGFkZSBlaW4gRm90byBob2NoXCIsXG5cdFx0XHRcImRlc2NyaXB0aW9uXCI6IFwiS2xpY2tlIGhpZXIsIHVtIGVpbiBGb3RvIHZvbiBkZWluZW0gUmVjaG5lciBob2NoenVsYWRlbiBvZGVyIGxhZGUgZXMgcGVyIERyYWctYW5kLURyb3AgaG9jaFwiXG5cdFx0fSxcblx0XHRcIndlYmNhbVwiOiB7XG5cdFx0XHRcImhlYWRsaW5lXCI6IFwiV2ViY2FtXCIsXG5cdFx0XHRcImRlc2NyaXB0aW9uXCI6IFwiS2xpY2tlIGhpZXIsIHVtIGVpbiBGb3RvIG1pdCBkZWluZXIgV2ViY2FtIHp1IG1hY2hlblwiXG5cdFx0fSxcblx0XHRcInBob3RvUm9sbFwiOiB7XG5cdFx0XHRcImhlYWRsaW5lXCI6IFwiS29zdGVubG9zZXMgQmlsZG1hdGVyaWFsXCIsXG5cdFx0XHRcImRlc2NyaXB0aW9uXCI6IFwiU3VjaGUgZGlyIGVpbmVzIHZvbiB0YXVzZW5kZW4gU3RvY2sgUGhvdG9zIGF1cy5cIlxuXHRcdH1cblx0fSxcblx0XCJwaG90b1JvbGxcIjoge1xuXHRcdFwic2VhcmNoXCI6IHtcblx0XHRcdFwicGxhY2Vob2xkZXJcIjogXCJOYWNoIEZvdG9zIHN1Y2hlblwiLFxuXHRcdFx0XCJub1NlYXJjaFJlc3VsdHNcIjogXCJFbnRzY2h1bGRpZ3VuZywgYWJlciB3aXIga29ubnRlbiBmw7xyIDxzdHJvbmc+XFxcIiR7cXVlcnl9XFxcIjwvc3Ryb25nPiBsZWlkZXIga2VpbmUgRXJnZWJuaXNzZSBmaW5kZW4uXCIsXG5cdFx0XHRcInJlc3VsdHNcIjoge1xuXHRcdFx0XHRcImhlYWRsaW5lXCI6IFwiU3VjaGVyZ2Vibmlzc2UgZsO8ciBcXFwiJHtxdWVyeX1cXFwiXCJcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdFwiZ2VuZXJpY1wiOiB7XG5cdFx0XCJiYWNrXCI6IFwiWnVyw7xja1wiLFxuXHRcdFwiY2FuY2VsXCI6IFwiQWJicmVjaGVuXCIsXG5cdFx0XCJjb2xvclwiOiBcIkZhcmJlXCJcblx0fSxcblx0XCJsb2FkaW5nXCI6IHtcblx0XHRcInJlc2l6aW5nXCI6IFwiQmlsZCB3aXJkIGJlYXJiZWl0ZXQuLi5cIixcblx0XHRcImV4cG9ydGluZ1wiOiBcIkV4cG9ydGllcmUuLi5cIixcblx0XHRcImxvYWRpbmdcIjogXCJMYWRlLi4uXCJcblx0fSxcblx0XCJ3YXJuaW5nc1wiOiB7XG5cdFx0XCJpbWFnZVJlc2l6ZWRfbWF4TWVnYVBpeGVsc1wiOiB7XG5cdFx0XHRcInRpdGxlXCI6IFwiQmlsZCB2ZXJrbGVpbmVydFwiLFxuXHRcdFx0XCJ0ZXh0XCI6IFwiRGEgZGVpbiBCaWxkIGRpZSBtYXhpbWFsZSBHcsO2w59lIHZvbiAke21heE1lZ2FQaXhlbHN9IE1lZ2FwaXhlbG4gw7xiZXJzY2hyZWl0ZXQsIHd1cmRlIGVzIGF1ZiAke3dpZHRofXgke2hlaWdodH0gUGl4ZWwgdmVya2xlaW5lcnQuXCJcblx0XHR9LFxuXHRcdFwiaW1hZ2VSZXNpemVkX21heERpbWVuc2lvbnNcIjoge1xuXHRcdFx0XCJ0aXRsZVwiOiBcIkJpbGQgdmVya2xlaW5lcnRcIixcblx0XHRcdFwidGV4dFwiOiBcIkF1ZmdydW5kIHZvbiBIYXJkd2FyZS1CZXNjaHLDpG5rdW5nZW4gd3VyZGUgZGFzIEJpbGQgYXVmICR7d2lkdGh9eCR7aGVpZ2h0fSBQaXhlbCB2ZXJrbGVpbmVydC5cIlxuXHRcdH1cblx0fSxcblx0XCJlcnJvcnNcIjoge1xuXHRcdFwiaW1hZ2VMb2FkRmFpbFwiOiB7XG5cdFx0XHRcInRpdGxlXCI6IFwiQmlsZCBrb25udGUgbmljaHQgZ2VsYWRlbiB3ZXJkZW5cIixcblx0XHRcdFwidGV4dFwiOiBcIkJlaW0gTGFkZW4gZGVzIEJpbGRlcyB1bnRlciAke3BhdGh9IGlzdCBlaW4gRmVobGVyIGF1ZmdldHJldGVuLlwiXG5cdFx0fSxcblx0XHRcIndlYmNhbVVuYXZhaWxhYmxlXCI6IHtcblx0XHRcdFwidGl0bGVcIjogXCJXZWJjYW0gbmljaHQgdmVyZsO8Z2JhclwiLFxuXHRcdFx0XCJ0ZXh0XCI6IFwiV2ViY2FtLUJpbGQga2FubiBuaWNodCBkYXJnZXN0ZWxsdCB3ZXJkZW4uIChGZWhsZXI6ICR7ZXJyb3J9KVwiXG5cdFx0fSxcblx0XHRcIndlYmNhbU5vdFN1cHBvcnRlZFwiOiB7XG5cdFx0XHRcInRpdGxlXCI6IFwiV2ViY2FtIG5pY2h0IHVudGVyc3TDvHR6dFwiLFxuXHRcdFx0XCJ0ZXh0XCI6IFwiRGVpbiBCcm93c2VyIHVudGVyc3TDvHR6dCBkYXMgV2ViY2FtLUZlYXR1cmUgbGVpZGVyIG5vY2ggbmljaHQuXCJcblx0XHR9LFxuXHRcdFwicmVuZGVyaW5nRXJyb3JcIjoge1xuXHRcdFx0XCJ0aXRsZVwiOiBcIlJlbmRlcmluZy1GZWhsZXJcIixcblx0XHRcdFwidGV4dFwiOiBcIkJlaW0gUmVuZGVybiBkZXMgQmlsZGVzIGlzdCBlaW4gRmVobGVyIGF1ZmdldHJldGVuLlwiXG5cdFx0fSxcblx0XHRcImNvbnRleHRfbG9zdFwiOiB7XG5cdFx0XHRcInRpdGxlXCI6IFwiRXMgaXN0IGVpbiBGZWhsZXIgYXVmZ2V0cmV0ZW5cIixcblx0XHRcdFwidGV4dFwiOiBcIkRlaW4gQnJvd3NlciBoYXQgenUgbGFuZ2UgZ2VicmF1Y2h0LCB1bSBkYXMgQmlsZCB6dSBnZW5lcmllcmVuLiBCaXR0ZSB2ZXJzdWNoZSBlcyBub2NoIGVpbm1hbC5cIlxuXHRcdH0sXG5cdFx0XCJjb250ZXh0X2xvc3RfbGltaXRcIjoge1xuXHRcdFx0XCJ0aXRsZVwiOiBcIkVzIGlzdCBlaW4gRmVobGVyIGF1ZmdldHJldGVuXCIsXG5cdFx0XHRcInRleHRcIjogXCJCaWxkLUdlbmVyaWVydW5nIGlzdCBtZWhybWFscyBmZWhsZ2VzY2hsYWdlbi5cIlxuXHRcdH0sXG5cdFx0XCJsb2FkaW5nU3RpY2tlcnNGYWlsZWRcIjoge1xuXHRcdFx0XCJ0aXRsZVwiOiBcIkxhZGVuIGRlciBTdGlja2VyIGZlaGxnZXNjaGxhZ2VuXCJcblx0XHR9LFxuXHRcdFwibG9hZGluZ0ZvbnRzRmFpbGVkXCI6IHtcblx0XHRcdFwidGl0bGVcIjogXCJMYWRlbiBkZXIgU2NocmlmdGFydGVuIGZlaGxnZXNjaGxhZ2VuXCIsXG5cdFx0XHRcInRleHRcIjogXCJFaW5pZ2UgU2NocmlmdGFydGVuIHNpbmQgbcO2Z2xpY2hlcndlaXNlIG5pY2h0IHZlcmbDvGdiYXIuXCJcblx0XHR9LFxuXHRcdFwicGhvdG9Sb2xsTG9hZEZhaWxcIjoge1xuXHRcdFx0XCJ0aXRsZVwiOiBcIkxhZGVuIGRlciBQaG90byBSb2xsIGZlaGxnZXNjaGxhZ2VuXCIsXG5cdFx0XHRcInRleHRcIjogXCJEaWUgUGhvdG8gUm9sbCBrb25udGUgbmljaHQgZ2VsYWRlbiB3ZXJkZW46ICR7ZXJyb3J9XCJcblx0XHR9LFxuXHRcdFwidGl0bGVcIjogXCJFcyBpc3QgZWluIEZlaGxlciBhdWZnZXRyZXRlblwiXG5cdH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sYW5nL2RlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcImNvbnRyb2xzXCI6IHtcblx0XHRcIm92ZXJ2aWV3XCI6IHtcblx0XHRcdFwiZmlsdGVyc1wiOiBcIkZpbHRlcnNcIixcblx0XHRcdFwiYWRqdXN0bWVudHNcIjogXCJBZGp1c3RcIixcblx0XHRcdFwiY3JvcFwiOiBcIkNyb3BcIixcblx0XHRcdFwiZm9jdXNcIjogXCJGb2N1c1wiLFxuXHRcdFx0XCJmcmFtZVwiOiBcIkZyYW1lXCIsXG5cdFx0XHRcInN0aWNrZXJcIjogXCJTdGlja2VyXCIsXG5cdFx0XHRcInRleHRcIjogXCJUZXh0XCIsXG5cdFx0XHRcImJydXNoXCI6IFwiQnJ1c2hcIixcblx0XHRcdFwic2VsZWN0aXZlLWJsdXJcIjogXCJTZWxlY3RpdmUgQmx1clwiXG5cdFx0fSxcblx0XHRcInRleHRcIjoge1xuXHRcdFx0XCJmb3JlZ3JvdW5kXCI6IFwiRm9yZWdyb3VuZFwiLFxuXHRcdFx0XCJiYWNrZ3JvdW5kXCI6IFwiQmFja2dyb3VuZFwiLFxuXHRcdFx0XCJzaXplXCI6IFwiU2l6ZVwiLFxuXHRcdFx0XCJmb250XCI6IFwiRm9udFwiLFxuXHRcdFx0XCJhbGlnbm1lbnRcIjogXCJBbGlnbm1lbnRcIixcblx0XHRcdFwidGFrZVRvRnJvbnRcIjogXCJUbyBGcm9udFwiXG5cdFx0fSxcblx0XHRcImFkanVzdG1lbnRzXCI6IHtcblx0XHRcdFwiYnJpZ2h0bmVzc1wiOiBcIkJyaWdodG5lc3NcIixcblx0XHRcdFwiY29udHJhc3RcIjogXCJDb250cmFzdFwiLFxuXHRcdFx0XCJzYXR1cmF0aW9uXCI6IFwiU2F0dXJhdGlvblwiLFxuXHRcdFx0XCJleHBvc3VyZVwiOiBcIkV4cG9zdXJlXCIsXG5cdFx0XHRcImdhbW1hXCI6IFwiR2FtbWFcIixcblx0XHRcdFwic2hhZG93c1wiOiBcIlNoYWRvd3NcIixcblx0XHRcdFwiaGlnaGxpZ2h0c1wiOiBcIkhpZ2hsaWdodHNcIixcblx0XHRcdFwiY2xhcml0eVwiOiBcIkNsYXJpdHlcIlxuXHRcdH0sXG5cdFx0XCJjcm9wXCI6IHtcblx0XHRcdFwibm9uZVwiOiBcIk9yaWdpbmFsXCIsXG5cdFx0XHRcImN1c3RvbVwiOiBcIkN1c3RvbVwiLFxuXHRcdFx0XCJzcXVhcmVcIjogXCJTcXVhcmVcIixcblx0XHRcdFwiNC0zXCI6IFwiNDozXCIsXG5cdFx0XHRcIjE2LTlcIjogXCIxNjo5XCIsXG5cdFx0XHRcInNvY2lhbFwiOiBcIlNvY2lhbCBNZWRpYVwiLFxuXHRcdFx0XCJmYi1hZFwiOiBcIkZhY2Vib29rIEFkXCIsXG5cdFx0XHRcImZiLXBvc3RcIjogXCJGYWNlYm9vayBQb3N0XCIsXG5cdFx0XHRcImZiLWNvdmVyXCI6IFwiRmFjZWJvb2sgQ292ZXJcIixcblx0XHRcdFwicm90YXRpb25cIjogXCJSb3RhdGlvblwiXG5cdFx0fSxcblx0XHRcImZvY3VzXCI6IHtcblx0XHRcdFwibm9uZVwiOiBcIk5vbmVcIixcblx0XHRcdFwicmFkaWFsXCI6IFwiUmFkaWFsXCIsXG5cdFx0XHRcImxpbmVhclwiOiBcIkxpbmVhclwiLFxuXHRcdFx0XCJibHVyUmFkaXVzXCI6IFwiQmx1ciByYWRpdXNcIlxuXHRcdH0sXG5cdFx0XCJzZWxlY3RpdmVCbHVyXCI6IHtcblx0XHRcdFwiYmx1clJhZGl1c1wiOiBcIkJsdXIgcmFkaXVzXCIsXG5cdFx0XHRcInRoaWNrbmVzc1wiOiBcIlRoaWNrbmVzc1wiXG5cdFx0fSxcblx0XHRcImZpbHRlcnNcIjoge1xuXHRcdFx0XCJpbnRlbnNpdHlcIjogXCJJbnRlbnNpdHlcIixcblx0XHRcdFwiY2F0ZWdvcmllc1wiOiB7XG5cdFx0XHRcdFwiYWxsXCI6IFwiQWxsXCIsXG5cdFx0XHRcdFwicmV0cm9cIjogXCJSZXRyb1wiLFxuXHRcdFx0XHRcImJ3XCI6IFwiQmxhY2sgJiBXaGl0ZVwiLFxuXHRcdFx0XHRcInN1bW1lclwiOiBcIlN1bW1lclwiLFxuXHRcdFx0XHRcIndpbnRlclwiOiBcIldpbnRlclwiLFxuXHRcdFx0XHRcInNwZWNpYWxcIjogXCJTcGVjaWFsXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwic3RpY2tlclwiOiB7XG5cdFx0XHRcImJyaWdodG5lc3NcIjogXCJCcmlnaHRuZXNzXCIsXG5cdFx0XHRcImNvbnRyYXN0XCI6IFwiQ29udHJhc3RcIixcblx0XHRcdFwic2F0dXJhdGlvblwiOiBcIlNhdHVyYXRpb25cIixcblx0XHRcdFwiYmx1clwiOiBcIkJsdXJcIixcblx0XHRcdFwiZmxpcFwiOiBcIkZsaXBcIixcblx0XHRcdFwiZmxpcC12XCI6IFwiRmxpcCAoVilcIixcblx0XHRcdFwiZmxpcC1oXCI6IFwiRmxpcCAoSClcIixcblx0XHRcdFwidGFrZVRvRnJvbnRcIjogXCJUbyBGcm9udFwiLFxuXHRcdFx0XCJjYXRlZ29yaWVzXCI6IHtcblx0XHRcdFx0XCJhbGxcIjogXCJBbGxcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJicnVzaFwiOiB7XG5cdFx0XHRcInRoaWNrbmVzc1wiOiBcIlRoaWNrbmVzc1wiLFxuXHRcdFx0XCJjb2xvclwiOiBcIkNvbG9yXCJcblx0XHR9LFxuXHRcdFwiZnJhbWVcIjoge1xuXHRcdFx0XCJub0ZyYW1lXCI6IFwiTm8gRnJhbWVcIixcblx0XHRcdFwic2NhbGVcIjogXCJTY2FsZVwiXG5cdFx0fVxuXHR9LFxuXHRcIndlYmNhbVwiOiB7XG5cdFx0XCJoZWFkbGluZVwiOiBcIlRha2UgYSBwaG90byFcIlxuXHR9LFxuXHRcImVkaXRvclwiOiB7XG5cdFx0XCJoZWFkbGluZVwiOiBcIkVkaXQgUGhvdG9cIixcblx0XHRcIm5ld1wiOiBcIk5ld1wiLFxuXHRcdFwiYmFja2dyb3VuZEltYWdlXCI6IFwiQmFja2dyb3VuZCBJbWFnZVwiLFxuXHRcdFwidW5kb1wiOiBcIlVuZG9cIixcblx0XHRcImV4cG9ydFwiOiBcIkV4cG9ydFwiXG5cdH0sXG5cdFwic3BsYXNoXCI6IHtcblx0XHRcInVwbG9hZFwiOiB7XG5cdFx0XHRcImJ1dHRvblwiOiBcIlVwbG9hZCB5b3VyIGltYWdlXCIsXG5cdFx0XHRcImRlc2NyaXB0aW9uXCI6IFwiVXBsb2FkIGEgcGljdHVyZSBmcm9tIHlvdXIgbGlicmFyeSBvciBqdXN0IGRyYWcgYW5kIGRyb3BcIlxuXHRcdH0sXG5cdFx0XCJ3ZWJjYW1cIjoge1xuXHRcdFx0XCJoZWFkbGluZVwiOiBcIldlYmNhbVwiLFxuXHRcdFx0XCJkZXNjcmlwdGlvblwiOiBcIlRha2UgYSBwaWN0dXJlIHdpdGggeW91ciB3ZWJjYW0gb3IgcGhvbmVcIlxuXHRcdH0sXG5cdFx0XCJwaG90b1JvbGxcIjoge1xuXHRcdFx0XCJoZWFkbGluZVwiOiBcIkZyZWUgc3RvY2sgZm9vdGFnZVwiLFxuXHRcdFx0XCJkZXNjcmlwdGlvblwiOiBcIlNlbGVjdCBmcm9tIHRob3VzYW5kcyBvZiBGcmVlIFN0b2NrIFBob3Rvc1wiXG5cdFx0fVxuXHR9LFxuXHRcInBob3RvUm9sbFwiOiB7XG5cdFx0XCJzZWFyY2hcIjoge1xuXHRcdFx0XCJwbGFjZWhvbGRlclwiOiBcIlNlYXJjaCBmb3IgcGhvdG9zXCIsXG5cdFx0XHRcIm5vU2VhcmNoUmVzdWx0c1wiOiBcIlNvcnJ5LCBidXQgd2UgY291bGRuJ3QgZmluZCBhbnkgcGhvdG9zIGZvciA8c3Ryb25nPlxcXCIke3F1ZXJ5fVxcXCI8L3N0cm9uZz4uXCIsXG5cdFx0XHRcInJlc3VsdHNcIjoge1xuXHRcdFx0XHRcImhlYWRsaW5lXCI6IFwiU2VhcmNoIHJlc3VsdHMgZm9yIFxcXCIke3F1ZXJ5fVxcXCJcIlxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0XCJnZW5lcmljXCI6IHtcblx0XHRcImJhY2tcIjogXCJCYWNrXCIsXG5cdFx0XCJjYW5jZWxcIjogXCJDYW5jZWxcIixcblx0XHRcImNvbG9yXCI6IFwiQ29sb3JcIlxuXHR9LFxuXHRcImxvYWRpbmdcIjoge1xuXHRcdFwicmVzaXppbmdcIjogXCJSZXNpemluZy4uLlwiLFxuXHRcdFwiZXhwb3J0aW5nXCI6IFwiRXhwb3J0aW5nLi4uXCIsXG5cdFx0XCJsb2FkaW5nXCI6IFwiTG9hZGluZy4uLlwiXG5cdH0sXG5cdFwid2FybmluZ3NcIjoge1xuXHRcdFwiaW1hZ2VSZXNpemVkX21heE1lZ2FQaXhlbHNcIjoge1xuXHRcdFx0XCJ0aXRsZVwiOiBcIkltYWdlIHJlc2l6ZWRcIixcblx0XHRcdFwidGV4dFwiOiBcIllvdXIgaW1hZ2UgZXhjZWVkcyB0aGUgbWF4aW11bSBzaXplIG9mICR7bWF4TWVnYVBpeGVsc30gbWVnYXBpeGVscyBhbmQgaGFzIHRoZXJlZm9yZSBiZWVuIHJlc2l6ZWQgdG8gJHt3aWR0aH14JHtoZWlnaHR9IHBpeGVscy5cIlxuXHRcdH0sXG5cdFx0XCJpbWFnZVJlc2l6ZWRfbWF4RGltZW5zaW9uc1wiOiB7XG5cdFx0XHRcInRpdGxlXCI6IFwiSW1hZ2UgcmVzaXplZFwiLFxuXHRcdFx0XCJ0ZXh0XCI6IFwiRHVlIHRvIGhhcmR3YXJlIGxpbWl0YXRpb25zIHlvdXIgaW1hZ2UgaGFzIGJlZW4gcmVzaXplZCB0byAke3dpZHRofXgke2hlaWdodH0gcGl4ZWxzLlwiXG5cdFx0fVxuXHR9LFxuXHRcImVycm9yc1wiOiB7XG5cdFx0XCJpbWFnZUxvYWRGYWlsXCI6IHtcblx0XHRcdFwidGl0bGVcIjogXCJGYWlsZWQgdG8gbG9hZCBpbWFnZVwiLFxuXHRcdFx0XCJ0ZXh0XCI6IFwiRmFpbGVkIHRvIGxvYWQgdGhlIGltYWdlIGF0ICR7cGF0aH1cIlxuXHRcdH0sXG5cdFx0XCJ3ZWJjYW1VbmF2YWlsYWJsZVwiOiB7XG5cdFx0XHRcInRpdGxlXCI6IFwiV2ViY2FtIHVuYXZhaWxhYmxlXCIsXG5cdFx0XHRcInRleHRcIjogXCJVbmFibGUgdG8gZGlzcGxheSB3ZWJjYW0gaW1hZ2UgKEVycm9yOiAke2Vycm9yfSlcIlxuXHRcdH0sXG5cdFx0XCJ3ZWJjYW1Ob3RTdXBwb3J0ZWRcIjoge1xuXHRcdFx0XCJ0aXRsZVwiOiBcIldlYmNhbSBub3Qgc3VwcG9ydGVkXCIsXG5cdFx0XHRcInRleHRcIjogXCJUaGUgd2ViY2FtIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXIuXCJcblx0XHR9LFxuXHRcdFwicmVuZGVyaW5nRXJyb3JcIjoge1xuXHRcdFx0XCJ0aXRsZVwiOiBcIkVycm9yIHdoaWxlIHJlbmRlcmluZ1wiLFxuXHRcdFx0XCJ0ZXh0XCI6IFwiQW4gZXJyb3IgaGFzIG9jY3VycmVkIHdoaWxlIHJlbmRlcmluZyB0aGUgaW1hZ2UuXCJcblx0XHR9LFxuXHRcdFwiY29udGV4dF9sb3N0XCI6IHtcblx0XHRcdFwidGl0bGVcIjogXCJBbiBlcnJvciBoYXMgb2NjdXJyZWRcIixcblx0XHRcdFwidGV4dFwiOiBcIllvdXIgYnJvd3NlciB0b29rIHRvbyBsb25nIHRvIHJlbmRlciB0aGUgaW1hZ2UuIFBsZWFzZSB0cnkgYXBwbHlpbmcgbGVzcyBvcGVyYXRpb25zLlwiXG5cdFx0fSxcblx0XHRcImNvbnRleHRfbG9zdF9saW1pdFwiOiB7XG5cdFx0XHRcInRpdGxlXCI6IFwiQW4gZXJyb3IgaGFzIG9jY3VycmVkXCIsXG5cdFx0XHRcInRleHRcIjogXCJZb3VyIGJyb3dzZXIgZmFpbGVkIG11bHRpcGxlIHRpbWVzIHdoaWxlIHJlbmRlcmluZyB0aGUgaW1hZ2UuXCJcblx0XHR9LFxuXHRcdFwibG9hZGluZ1N0aWNrZXJzRmFpbGVkXCI6IHtcblx0XHRcdFwidGl0bGVcIjogXCJGYWlsZWQgdG8gbG9hZCBzdGlja2Vyc1wiXG5cdFx0fSxcblx0XHRcImxvYWRpbmdGb250c0ZhaWxlZFwiOiB7XG5cdFx0XHRcInRpdGxlXCI6IFwiRmFpbGVkIHRvIGxvYWQgZm9udHNcIixcblx0XHRcdFwidGV4dFwiOiBcIlNvbWUgZm9udHMgbWlnaHQgbm90IGJlIGF2YWlsYWJsZS5cIlxuXHRcdH0sXG5cdFx0XCJwaG90b1JvbGxMb2FkRmFpbFwiOiB7XG5cdFx0XHRcInRpdGxlXCI6IFwiRmFpbGVkIHRvIGxvYWQgUGhvdG8gUm9sbFwiLFxuXHRcdFx0XCJ0ZXh0XCI6IFwiRmFpbGVkIHRvIGxvYWQgcGhvdG9zIGZvciB0aGUgcGhvdG8gcm9sbDogJHtlcnJvcn1cIlxuXHRcdH0sXG5cdFx0XCJ0aXRsZVwiOiBcIkFuIGVycm9yIGhhcyBvY2N1cnJlZFwiXG5cdH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sYW5nL2VuLmpzb25cbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFja0J1dHRvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmxhcmdlQnV0dG9uJz5cbiAgICAgICAgPGRpdiBiZW09JyRlOmxhcmdlQnV0dG9uJyBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xpY2t9PlxuICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9iYWNrLnBuZycsIHRydWUpfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5CYWNrQnV0dG9uQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2JhY2stYnV0dG9uLWNvbXBvbmVudC5qc3giLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdEJFTSBmcm9tICcuLi9saWIvcmVhY3QtYmVtJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlQ29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9XG4gICAgdGhpcy5fbmVlZHNTdHlsZUZpeGVzID0gZmFsc2VcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uU2hhcmVkU3RhdGVVcGRhdGUnLFxuICAgICAgJ2ZpeFN0eWxlcydcbiAgICApXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXT1JLQVJPVU5EU1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBzdHlsZXMgbmVlZCB0byBiZSBmaXhlZCBieSB0aGUgSmF2YVNjcmlwdC5cbiAgICogVGhpcyBuZWVkcyB0byBiZSBkb25lIHRoYW5rcyB0byBvbGRlciBJbnRlcm5ldCBFeHBsb3JlciBicm93c2VycyB3aGljaCBoYXZlXG4gICAqIGEgYnVuY2ggb2YgQ1NTIGJ1Z3MuXG4gICAqL1xuICBmaXhTdHlsZXMgKCkge1xuXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpXG4gICAgaWYgKHRoaXMucHJvcHMuc2hhcmVkU3RhdGUpIHtcbiAgICAgIHRoaXMucHJvcHMuc2hhcmVkU3RhdGUub24oJ3VwZGF0ZScsIHRoaXMuX29uU2hhcmVkU3RhdGVVcGRhdGUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzU3R5bGVGaXhlcykge1xuICAgICAgdGhpcy5maXhTdHlsZXMoKVxuICAgICAgaWYgKHRoaXMuY29udGV4dC5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuZml4U3R5bGVzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgdGhpcy5fdW5iaW5kRXZlbnRzKClcblxuICAgIGlmICh0aGlzLnByb3BzLnNoYXJlZFN0YXRlKSB7XG4gICAgICB0aGlzLnByb3BzLnNoYXJlZFN0YXRlLm9mZigndXBkYXRlJywgdGhpcy5fb25TaGFyZWRTdGF0ZVVwZGF0ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb250ZXh0Lm9wdGlvbnMucmVzcG9uc2l2ZSAmJiB0aGlzLl9uZWVkc1N0eWxlRml4ZXMpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmZpeFN0eWxlcylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBhYm91dCB0byByZWNlaXZlIG5ldyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV4dFByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLnNoYXJlZFN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5zaGFyZWRTdGF0ZSkge1xuICAgICAgICB0aGlzLnByb3BzLnNoYXJlZFN0YXRlLm9mZigndXBkYXRlJywgdGhpcy5fb25TaGFyZWRTdGF0ZVVwZGF0ZSlcbiAgICAgIH1cbiAgICAgIG5leHRQcm9wcy5zaGFyZWRTdGF0ZS5vbigndXBkYXRlJywgdGhpcy5fb25TaGFyZWRTdGF0ZVVwZGF0ZSlcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBIRUxQRVIgRlVOQ1RJT05TXG5cbiAgLyoqXG4gICAqIEJpbmRzIHRoZSBpbnN0YW5jZSBtZXRob2RzIHdpdGggdGhlIGdpdmVuIG5hbWVzXG4gICAqIHRvIHRoZSBjbGFzcyBjb250ZXh0XG4gICAqIEBwYXJhbSAge0FycmF5LjxTdHJpbmc+fSAuLi5mbk5hbWVzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9iaW5kQWxsICguLi5mbk5hbWVzKSB7XG4gICAgZm5OYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRoaXNbbmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBfYmluZEFsbDogJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9LiR7bmFtZX0gaXMgbm90IGEgZnVuY3Rpb24uYClcbiAgICAgIH1cbiAgICAgIHRoaXNbbmFtZV0gPSB0aGlzW25hbWVdLmJpbmQodGhpcylcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGZvciBga2V5YFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtpbnRlcnBvbGF0aW9uT3B0aW9uc11cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgX3QgKGtleSwgaW50ZXJwb2xhdGlvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnVpLnRyYW5zbGF0ZShrZXksIGludGVycG9sYXRpb25PcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCBmb3IgVUkuaGVscGVycy5hc3NldFBhdGhcbiAgICogQHBhcmFtIHs/fSAuLi5hcmdzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9nZXRBc3NldFBhdGggKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnVpLmdldEFzc2V0UGF0aCguLi5hcmdzKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU0hBUkVEIFNUQVRFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNoYXJlZCBzdGF0ZSBkaWQgY2hhbmdlXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2xkU3RhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU2hhcmVkU3RhdGVVcGRhdGUgKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgIHRoaXMuc2hhcmVkU3RhdGVEaWRDaGFuZ2UobmV3U3RhdGUpXG5cbiAgICBpZiAodGhpcy5zaG91bGRTaGFyZWRDb21wb25lbnRVcGRhdGUob2xkU3RhdGUsIG5ld1N0YXRlKSkge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBjaGFuZ2UgZnJvbSB0aGUgZ2l2ZW4gc3RhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvbGRTdGF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5ld1N0YXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzaG91bGRTaGFyZWRDb21wb25lbnRVcGRhdGUgKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2hhcmVkIHN0YXRlIGRpZCBjaGFuZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG5ld1N0YXRlXG4gICAqL1xuICBzaGFyZWRTdGF0ZURpZENoYW5nZSAobmV3U3RhdGUpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIHN0YXRlIG9uIHRoZSBzaGFyZWQgc3RhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlXG4gICAqL1xuICBzZXRTaGFyZWRTdGF0ZSAoc3RhdGUsIHVwZGF0ZSkge1xuICAgIHRoaXMucHJvcHMuc2hhcmVkU3RhdGUuc2V0KHN0YXRlLCB1cGRhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2hhcmVkIHN0YXRlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldFNoYXJlZFN0YXRlIChwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuc2hhcmVkU3RhdGUuZ2V0KHByb3ApXG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZSBvZiB0aGUgc2hhcmVkIHN0YXRlXG4gICAqL1xuICBmb3JjZVNoYXJlZFVwZGF0ZSAoKSB7XG4gICAgdGhpcy5wcm9wcy5zaGFyZWRTdGF0ZS5icm9hZGNhc3RVcGRhdGUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlQgSEFORExJTkdcblxuICAvKipcbiAgICogQmluZHMgdGhlIGV2ZW50cyBpbiBfZXZlbnRzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9iaW5kRXZlbnRzICgpIHtcbiAgICBmb3IgKGxldCBldmVudE5hbWUgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV1cbiAgICAgIHRoaXMuY29udGV4dC5tZWRpYXRvci5vbihldmVudE5hbWUsIGhhbmRsZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuYmluZHMgdGhlIGV2ZW50cyBpbiBfZXZlbnRzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF91bmJpbmRFdmVudHMgKCkge1xuICAgIGZvciAobGV0IGV2ZW50TmFtZSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXVxuICAgICAgdGhpcy5jb250ZXh0Lm1lZGlhdG9yLm9mZihldmVudE5hbWUsIGhhbmRsZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdpdGggdGhlIGdpdmVuIGV2ZW50IG5hbWUgYW5kIGFyZ3VtZW50cyB0aHJvdWdoXG4gICAqIHRoZSBtZWRpYXRvclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0gIHtBcnJheS48Kj59IC4uLmFyZ3NcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2VtaXRFdmVudCAoZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgdGhpcy5jb250ZXh0Lm1lZGlhdG9yLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBlbGVtZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLmVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gUmVhY3RCRU0uY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoZSBSZWFjdEJFTS5lbGVtZW50IHJldHVybmVkIGJ5IGByZW5kZXJXaXRoQkVNYCBpbnRvXG4gICAqIFJlYWN0LkVsZW1lbnQgb2JqZWN0cyB3aXRoIHByb3BlciBjbGFzcyBuYW1lc1xuICAgKiBAcmV0dXJuIHtSZWFjdC5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyICgpIHtcbiAgICByZXR1cm4gUmVhY3RCRU0udHJhbnNmb3JtKHRoaXMucmVuZGVyV2l0aEJFTSgpKVxuICB9XG59XG5cbkJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzID0ge1xuICBlZGl0b3I6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gIHVpOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICBvcHRpb25zOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICBtZWRpYXRvcjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgZWRpdG9yU2NyZWVuOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG59XG5cbkJhc2VDb21wb25lbnQucHJvcFR5cGVzID0ge1xuICBzaGFyZWRTdGF0ZTogUmVhY3QuUHJvcFR5cGVzLmFueVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9iYXNlLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdCwgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGxldCBiZW1TcGVjaWZpZXIgPSAnYjpidXR0b24nXG4gICAgaWYgKHRoaXMucHJvcHMudXBwZXJjYXNlKSB7XG4gICAgICBiZW1TcGVjaWZpZXIgKz0gJyBtOnVwcGVyY2FzZSdcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvbiBiZW09e2JlbVNwZWNpZmllcn0gY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX0gb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfT5cbiAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cbn1cblxuQnV0dG9uQ29tcG9uZW50LnByb3BUeXBlcyA9IHtcbiAgb25DbGljazogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIGNoaWxkcmVuOiBSZWFjdC5Qcm9wVHlwZXMuYW55LmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufVxuXG5CdXR0b25Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvYnV0dG9uLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhdGVnb3J5RHJvcGRvd25PdmVybGF5Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBpdGVtXG4gICAqIEBwYXJhbSAge09iamVjdH0gaXRlbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uSXRlbUNsaWNrIChpdGVtKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJlxuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShpdGVtKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGxpc3QgaXRlbXNcbiAgICogQHJldHVybiB7QXJyYXkuPFJlYWN0LkVsZW1lbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckxpc3RJdGVtcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuaXRlbXNcbiAgICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gaXRlbS5uYW1lID09PSB0aGlzLnByb3BzLnNlbGVjdGVkSXRlbS5uYW1lXG4gICAgICAgIHJldHVybiA8bGlcbiAgICAgICAgICBiZW09JyRlOml0ZW0nXG4gICAgICAgICAgY2xhc3NOYW1lPXthY3RpdmUgPyAnIGlzLWFjdGl2ZScgOiAnJ31cbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9vbkl0ZW1DbGljay5iaW5kKHRoaXMsIGl0ZW0pfT5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e2l0ZW0uaWNvbn0gLz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e2l0ZW0ubGFiZWx9PC9kaXY+XG4gICAgICAgIDwvbGk+XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOmNhdGVnb3J5RHJvcGRvd24gJGU6b3ZlcmxheSc+XG4gICAgICA8dWwgYmVtPSckZTpsaXN0Jz5cbiAgICAgICAge3RoaXMuX3JlbmRlckxpc3RJdGVtcygpfVxuICAgICAgPC91bD5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuQ2F0ZWdvcnlEcm9wZG93bk92ZXJsYXlDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY2F0ZWdvcnktZHJvcGRvd24vb3ZlcmxheS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQsIFV0aWxzIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi4vZHJhZ2dhYmxlLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxwaGFDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbktub2JEcmFnJyxcbiAgICAgICdfb25Lbm9iRHJhZ1N0YXJ0J1xuICAgIClcblxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5wcm9wcy5pbml0aWFsVmFsdWUuY2xvbmUoKVxuICAgIHRoaXMuX3RyYW5zcGFyZW50UGF0dGVybkNhbnZhcyA9IFV0aWxzLmNyZWF0ZVRyYW5zcGFyZW50UGF0dGVybkNhbnZhcygpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcbiAgICB0aGlzLl9yZW5kZXJDYW52YXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzIG9yIHN0YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV3UHJvcHMpIHtcbiAgICBjb25zdCB7IGluaXRpYWxWYWx1ZSB9ID0gbmV3UHJvcHNcbiAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgdGhpcy5fdmFsdWUgPSBpbml0aWFsVmFsdWUuY2xvbmUoKVxuICAgICAgdGhpcy5fcmVuZGVyQ2FudmFzKClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRFJBRyBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIGtub2JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnU3RhcnQgKHBvc2l0aW9uLCBlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLnJlZnMua25vYikge1xuICAgICAgdGhpcy5faW5pdGlhbEFscGhhID0gdGhpcy5fdmFsdWUuYVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRBbHBoYUZyb21Qb3NpdGlvbihwb3NpdGlvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIGtub2JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZyAob2Zmc2V0LCBlKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5yZWZzLmNhbnZhc1xuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoXG5cbiAgICBjb25zdCBhbHBoYUNoYW5nZSA9IG9mZnNldC54IC8gY2FudmFzV2lkdGhcbiAgICB0aGlzLl9zZXRBbHBoYSh0aGlzLl9pbml0aWFsQWxwaGEgKyBhbHBoYUNoYW5nZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGUgb2JqZWN0IGZvciB0aGUga25vYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0S25vYlN0eWxlICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogKHRoaXMuX3ZhbHVlLmEgKiAxMDApLnRvRml4ZWQoMikgKyAnJScsXG4gICAgICB0b3A6ICc1MCUnXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhbHBoYSB2YWx1ZSBvZiB0aGUgY29sb3IgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEFscGhhIChhKSB7XG4gICAgdGhpcy5fdmFsdWUuYSA9IGFcbiAgICB0aGlzLl92YWx1ZS5hID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdGhpcy5fdmFsdWUuYSkpXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJiB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMuX3ZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFscGhhIGZyb20gdGhlIGdpdmVuIGN1cnNvciBwb3NpdGlvblxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0QWxwaGFGcm9tUG9zaXRpb24gKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5yZWZzLmNhbnZhc1xuICAgIHRoaXMuX2luaXRpYWxBbHBoYSA9IHBvc2l0aW9uLnggLyBjYW52YXMub2Zmc2V0V2lkdGhcbiAgICB0aGlzLl9zZXRBbHBoYSh0aGlzLl9pbml0aWFsQWxwaGEpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY2FudmFzIHdpdGggdGhlIGN1cnJlbnQgY29sb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMucmVmcy5jYW52YXNcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0XG5cbiAgICAvLyBGaWxsIHdpdGggcGF0dGVyblxuICAgIGNvbnN0IHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4odGhpcy5fdHJhbnNwYXJlbnRQYXR0ZXJuQ2FudmFzLCAncmVwZWF0JylcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBhdHRlcm5cbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIC8vIENyZWF0ZSBncmFkaWVudFxuICAgIGNvbnN0IGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gICAgbGV0IGNvbG9yID0gdGhpcy5fdmFsdWUuY2xvbmUoKVxuICAgIGNvbG9yLmEgPSAwXG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGNvbG9yLnRvUkdCQSgpKVxuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCB0aGlzLl92YWx1ZS50b0hleCgpKVxuXG4gICAgLy8gRHJhdyBncmFkaWVudFxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnRcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpjb2xvclBpY2tlciAkZTphbHBoYSc+XG4gICAgICA8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uS25vYkRyYWdTdGFydH1cbiAgICAgICAgb25EcmFnPXt0aGlzLl9vbktub2JEcmFnfT5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8Y2FudmFzIGJlbT0nZTpjYW52YXMnIHJlZj0nY2FudmFzJyAvPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGJlbT0nZTprbm9iICRiOmtub2IgbTp0cmFuc3BhcmVudCdcbiAgICAgICAgICAgIHJlZj0na25vYidcbiAgICAgICAgICAgIHN0eWxlPXt0aGlzLl9nZXRLbm9iU3R5bGUoKX0gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuQWxwaGFDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL2FscGhhLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCwgQ29sb3IgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IERyYWdnYWJsZUNvbXBvbmVudCBmcm9tICcuLi9kcmFnZ2FibGUtY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIdWVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbktub2JEcmFnJyxcbiAgICAgICdfb25Lbm9iRHJhZ1N0YXJ0J1xuICAgIClcblxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5wcm9wcy5pbml0aWFsVmFsdWUuY2xvbmUoKVxuICAgIGNvbnN0IGhzdkFyciA9IHRoaXMuX3ZhbHVlLnRvSFNWKClcbiAgICBjb25zdCBoID0gaHN2QXJyWzBdXG4gICAgY29uc3QgcyA9IGhzdkFyclsxXVxuICAgIGNvbnN0IHYgPSBoc3ZBcnJbMl1cbiAgICB0aGlzLl9oc3ZDb2xvciA9IHsgaCwgcywgdiB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcbiAgICB0aGlzLl9yZW5kZXJDYW52YXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzIG9yIHN0YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV3UHJvcHMpIHtcbiAgICBjb25zdCB7IGluaXRpYWxWYWx1ZSB9ID0gbmV3UHJvcHNcbiAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgdGhpcy5fdmFsdWUgPSBpbml0aWFsVmFsdWUuY2xvbmUoKVxuICAgICAgY29uc3QgaHN2QXJyID0gdGhpcy5fdmFsdWUudG9IU1YoKVxuICAgICAgY29uc3QgaCA9IGhzdkFyclswXVxuICAgICAgY29uc3QgcyA9IGhzdkFyclsxXVxuICAgICAgY29uc3QgdiA9IGhzdkFyclsyXVxuICAgICAgdGhpcy5faHN2Q29sb3IgPSB7IGgsIHMsIHYgfVxuICAgICAgdGhpcy5fcmVuZGVyQ2FudmFzKClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRFJBRyBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIGtub2JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnU3RhcnQgKHBvc2l0aW9uLCBlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLnJlZnMua25vYikge1xuICAgICAgdGhpcy5faW5pdGlhbEh1ZSA9IHRoaXMuX2hzdkNvbG9yLmhcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0VmFsdWVGcm9tUG9zaXRpb24ocG9zaXRpb24pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBrbm9iXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG9mZnNldFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWcgKG9mZnNldCwgZSkge1xuICAgIGNvbnN0IHsgY2FudmFzIH0gPSB0aGlzLnJlZnNcbiAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0XG5cbiAgICBjb25zdCBodWVDaGFuZ2UgPSBvZmZzZXQueSAvIGNhbnZhc0hlaWdodFxuICAgIHRoaXMuX3NldEh1ZSh0aGlzLl9pbml0aWFsSHVlICsgaHVlQ2hhbmdlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSBrbm9iXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRLbm9iU3R5bGUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgIHRvcDogKHRoaXMuX2hzdkNvbG9yLmggKiAxMDApLnRvRml4ZWQoMikgKyAnJSdcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGh1ZSB2YWx1ZSBvZiB0aGUgY29sb3IgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEh1ZSAoaCkge1xuICAgIGxldCB7IHMsIHYgfSA9IHRoaXMuX2hzdkNvbG9yXG4gICAgaCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGgpKVxuICAgIHMgPSBNYXRoLm1heCgwLjAxLCBNYXRoLm1pbihzLCAwLjk5KSlcbiAgICB2ID0gTWF0aC5tYXgoMC4wMSwgTWF0aC5taW4odiwgMC45OSkpXG5cbiAgICB0aGlzLl92YWx1ZSA9IENvbG9yLmZyb21IU1YoaCwgcywgdiwgdGhpcy5fdmFsdWUuYSlcbiAgICB0aGlzLl9oc3ZDb2xvciA9IHsgaCwgcywgdiB9XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJiB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMuX3ZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZyb20gdGhlIGdpdmVuIGN1cnNvciBwb3NpdGlvblxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VmFsdWVGcm9tUG9zaXRpb24gKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgeyBjYW52YXMgfSA9IHRoaXMucmVmc1xuICAgIHRoaXMuX2luaXRpYWxIdWUgPSBwb3NpdGlvbi55IC8gY2FudmFzLm9mZnNldEhlaWdodFxuICAgIHRoaXMuX3NldEh1ZSh0aGlzLl9pbml0aWFsSHVlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGh1ZSBjb2xvcnMgdG8gdGhlIGNhbnZhc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAoKSB7XG4gICAgY29uc3QgeyBjYW52YXMgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHRcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICBjb25zdCByYXRpbyA9IHkgLyBjYW52YXMuaGVpZ2h0XG4gICAgICBjb25zdCBjb2xvciA9IENvbG9yLmZyb21IU1YocmF0aW8sIDEsIDEpXG5cbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1JHQkEoKVxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKVxuICAgICAgY29udGV4dC5tb3ZlVG8oMCwgeSlcbiAgICAgIGNvbnRleHQubGluZVRvKGNhbnZhcy53aWR0aCwgeSlcbiAgICAgIGNvbnRleHQuc3Ryb2tlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nJGI6Y29sb3JQaWNrZXIgJGU6aHVlJz5cbiAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgb25TdGFydD17dGhpcy5fb25Lbm9iRHJhZ1N0YXJ0fVxuICAgICAgICBvbkRyYWc9e3RoaXMuX29uS25vYkRyYWd9PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxjYW52YXMgYmVtPSdlOmNhbnZhcycgcmVmPSdjYW52YXMnIC8+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgYmVtPSdlOmtub2IgJGI6a25vYiBtOnRyYW5zcGFyZW50J1xuICAgICAgICAgICAgcmVmPSdrbm9iJ1xuICAgICAgICAgICAgc3R5bGU9e3RoaXMuX2dldEtub2JTdHlsZSgpfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5IdWVDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL2h1ZS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IEFscGhhQ29tcG9uZW50IGZyb20gJy4vYWxwaGEtY29tcG9uZW50J1xuaW1wb3J0IFNhdHVyYXRpb25Db21wb25lbnQgZnJvbSAnLi9zYXR1cmF0aW9uLWNvbXBvbmVudCdcbmltcG9ydCBIdWVDb21wb25lbnQgZnJvbSAnLi9odWUtY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvclBpY2tlck92ZXJsYXlDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnByb3BzLmluaXRpYWxWYWx1ZS5jbG9uZSgpXG4gICAgY29uc3QgaHN2QXJyID0gdGhpcy5fdmFsdWUudG9IU1YoKVxuICAgIGNvbnN0IGggPSBoc3ZBcnJbMF1cbiAgICBjb25zdCBzID0gaHN2QXJyWzFdXG4gICAgY29uc3QgdiA9IGhzdkFyclsyXVxuICAgIHRoaXMuX2hzdiA9IHsgaCwgcywgdiB9XG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkVsZW1lbnRDbGljaycsXG4gICAgICAnX29uQ29sb3JDaGFuZ2UnLFxuICAgICAgJ19vbkRvY3VtZW50Q2xpY2snXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Eb2N1bWVudENsaWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgdW5tb3VudGVkXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQoKVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkRvY3VtZW50Q2xpY2spXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgYW55d2hlcmUgb24gdGhlIHNjcmVlbi4gSWYgdGhlIGNsaWNrIGlzIG91dHNpZGVcbiAgICogb2YgdGhlIGNvbG9yIHBpY2tlciBhbmQgdGhlIGNvbG9yIHBpY2tlciBpcyB2aXNpYmxlLCB3ZSBoaWRlIHRoaXMgY29sb3IgcGlja2VyLlxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRG9jdW1lbnRDbGljayAoZSkge1xuICAgIGZvciAobGV0IGVsZW1lbnQgPSBlLnRhcmdldDsgZWxlbWVudDsgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGVsZW1lbnQgPT09IHRoaXMucmVmcy5yb290KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByb3BzLm9uQ2xvc2UgJiZcbiAgICAgIHRoaXMucHJvcHMub25DbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogQ2F0Y2hlcyBjbGlja3Mgb24gdGhlIGVsZW1lbnQgYW5kIG1ha2VzIHN1cmUgdGhhdCBubyBjbGljayBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICogb24gdGhlIHBhcmVudCBlbGVtZW50XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25FbGVtZW50Q2xpY2sgKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgY29sb3IgY2hhbmdlc1xuICAgKiBAcGFyYW0gIHtDb2xvcn0gY29sb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNvbG9yQ2hhbmdlIChjb2xvcikge1xuICAgIHRoaXMuX3ZhbHVlID0gY29sb3JcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlICYmIHRoaXMucHJvcHMub25DaGFuZ2UoY29sb3IpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgbGV0IGFscGhhQ29tcG9uZW50XG4gICAgaWYgKHRoaXMucHJvcHMuYWxwaGEgIT09IGZhbHNlKSB7XG4gICAgICBhbHBoYUNvbXBvbmVudCA9IDxBbHBoYUNvbXBvbmVudFxuICAgICAgICBpbml0aWFsVmFsdWU9e3RoaXMuX3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25Db2xvckNoYW5nZX1cbiAgICAgICAgLz5cbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpjb2xvclBpY2tlciAkZTpvdmVybGF5JyBvbkNsaWNrPXt0aGlzLl9vbkVsZW1lbnRDbGlja30gcmVmPSdyb290Jz5cbiAgICAgIHthbHBoYUNvbXBvbmVudH1cbiAgICAgIDxkaXYgYmVtPSdlOmJvdHRvbSc+XG4gICAgICAgIDxTYXR1cmF0aW9uQ29tcG9uZW50XG4gICAgICAgICAgaW5pdGlhbFZhbHVlPXt0aGlzLl92YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25Db2xvckNoYW5nZX1cbiAgICAgICAgICAvPlxuICAgICAgICA8SHVlQ29tcG9uZW50XG4gICAgICAgICAgaW5pdGlhbFZhbHVlPXt0aGlzLl92YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25Db2xvckNoYW5nZX1cbiAgICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cbkNvbG9yUGlja2VyT3ZlcmxheUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb2xvci1waWNrZXIvb3ZlcmxheS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQsIENvbG9yIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi4vZHJhZ2dhYmxlLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2F0dXJhdGlvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uS25vYkRyYWcnLFxuICAgICAgJ19vbktub2JEcmFnU3RhcnQnXG4gICAgKVxuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLnByb3BzLmluaXRpYWxWYWx1ZS5jbG9uZSgpXG4gICAgY29uc3QgaHN2QXJyID0gdGhpcy5fdmFsdWUudG9IU1YoKVxuICAgIGNvbnN0IGggPSBoc3ZBcnJbMF1cbiAgICBjb25zdCBzID0gaHN2QXJyWzFdXG4gICAgY29uc3QgdiA9IGhzdkFyclsyXVxuICAgIHRoaXMuX2hzdkNvbG9yID0geyBoLCBzLCB2IH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIHRoaXMuX3JlbmRlckNhbnZhcygpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMgb3Igc3RhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBuZXdQcm9wc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlIChuZXdQcm9wcykge1xuICAgIGNvbnN0IHsgaW5pdGlhbFZhbHVlIH0gPSBuZXdQcm9wc1xuICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IGluaXRpYWxWYWx1ZS5jbG9uZSgpXG4gICAgICBjb25zdCBoc3ZBcnIgPSB0aGlzLl92YWx1ZS50b0hTVigpXG4gICAgICBjb25zdCBoID0gaHN2QXJyWzBdXG4gICAgICBjb25zdCBzID0gaHN2QXJyWzFdXG4gICAgICBjb25zdCB2ID0gaHN2QXJyWzJdXG4gICAgICB0aGlzLl9oc3ZDb2xvciA9IHsgaCwgcywgdiB9XG4gICAgICB0aGlzLl9yZW5kZXJDYW52YXMoKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBEUkFHIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUga25vYlxuICAgKiBAcGFyYW0gIHtWZWN0b3J9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZ1N0YXJ0IChwb3NpdGlvbiwgZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5yZWZzLmtub2IpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxWYWx1ZSA9IHRoaXMuX2hzdkNvbG9yLnZcbiAgICAgIHRoaXMuX2luaXRpYWxTYXR1cmF0aW9uID0gdGhpcy5faHN2Q29sb3Iuc1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRWYWx1ZXNGcm9tUG9zaXRpb24ocG9zaXRpb24pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBrbm9iXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG9mZnNldFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWcgKG9mZnNldCwgZSkge1xuICAgIGNvbnN0IHsgY2FudmFzIH0gPSB0aGlzLnJlZnNcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aFxuICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHRcblxuICAgIGNvbnN0IHNhdHVyYXRpb25DaGFuZ2UgPSBvZmZzZXQueCAvIGNhbnZhc1dpZHRoXG4gICAgY29uc3QgdmFsdWVDaGFuZ2UgPSBvZmZzZXQueSAvIGNhbnZhc0hlaWdodCAqIC0xXG5cbiAgICBsZXQgeyBoIH0gPSB0aGlzLl9oc3ZDb2xvclxuICAgIHRoaXMuX3NldEhTVihcbiAgICAgIGgsXG4gICAgICB0aGlzLl9pbml0aWFsU2F0dXJhdGlvbiArIHNhdHVyYXRpb25DaGFuZ2UsXG4gICAgICB0aGlzLl9pbml0aWFsVmFsdWUgKyB2YWx1ZUNoYW5nZVxuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGUgb2JqZWN0IGZvciB0aGUga25vYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0S25vYlN0eWxlICgpIHtcbiAgICBjb25zdCB7IHMsIHYgfSA9IHRoaXMuX2hzdkNvbG9yXG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogKHMgKiAxMDApLnRvRml4ZWQoMikgKyAnJScsXG4gICAgICB0b3A6ICgoMSAtIHYpICogMTAwKS50b0ZpeGVkKDIpICsgJyUnXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBIU1YgdmFsdWVzIG9mIHRoZSBjb2xvciB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0SFNWIChoLCBzLCB2KSB7XG4gICAgcyA9IE1hdGgubWF4KDAuMDEsIE1hdGgubWluKHMsIDAuOTkpKVxuICAgIHYgPSBNYXRoLm1heCgwLjAxLCBNYXRoLm1pbih2LCAwLjk5KSlcbiAgICB0aGlzLl92YWx1ZSA9IENvbG9yLmZyb21IU1YoaCwgcywgdiwgdGhpcy5fdmFsdWUuYSlcbiAgICB0aGlzLl9oc3ZDb2xvciA9IHsgaCwgcywgdiB9XG5cbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlICYmIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy5fdmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGN1cnNvciBwb3NpdGlvblxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VmFsdWVzRnJvbVBvc2l0aW9uIChwb3NpdGlvbikge1xuICAgIGNvbnN0IHsgY2FudmFzIH0gPSB0aGlzLnJlZnNcbiAgICB0aGlzLl9pbml0aWFsU2F0dXJhdGlvbiA9IHBvc2l0aW9uLnggLyBjYW52YXMub2Zmc2V0V2lkdGhcbiAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSAxIC0gKHBvc2l0aW9uLnkgLyBjYW52YXMub2Zmc2V0SGVpZ2h0KVxuXG4gICAgbGV0IHsgaCB9ID0gdGhpcy5faHN2Q29sb3JcbiAgICB0aGlzLl9zZXRIU1YoXG4gICAgICBoLFxuICAgICAgdGhpcy5faW5pdGlhbFNhdHVyYXRpb24sXG4gICAgICB0aGlzLl9pbml0aWFsVmFsdWVcbiAgICApXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY3VycmVudCBjb2xvciB0byB0aGUgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQ2FudmFzICgpIHtcbiAgICBjb25zdCB7IGNhbnZhcyB9ID0gdGhpcy5yZWZzXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodFxuXG4gICAgbGV0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IChjYW52YXMuaGVpZ2h0IC0geSkgLyBjYW52YXMuaGVpZ2h0XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICAgIGNvbnN0IHNhdHVyYXRpb24gPSB4IC8gY2FudmFzLndpZHRoXG4gICAgICAgIGNvbnN0IGNvbG9yID0gQ29sb3IuZnJvbUhTVih0aGlzLl9oc3ZDb2xvci5oLCBzYXR1cmF0aW9uLCB2YWx1ZSlcbiAgICAgICAgY29uc3QgeyByLCBnLCBiLCBhIH0gPSBjb2xvclxuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gKHkgKiBjYW52YXMud2lkdGggKyB4KSAqIDRcblxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSByICogMjU1XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBnICogMjU1XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBiICogMjU1XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgM10gPSBhICogMjU1XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOmNvbG9yUGlja2VyICRlOnNhdHVyYXRpb24nPlxuICAgICAgPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbktub2JEcmFnU3RhcnR9XG4gICAgICAgIG9uRHJhZz17dGhpcy5fb25Lbm9iRHJhZ30+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPGNhbnZhcyBiZW09J2U6Y2FudmFzJyByZWY9J2NhbnZhcycgLz5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBiZW09J2U6a25vYiAkYjprbm9iIG06dHJhbnNwYXJlbnQnXG4gICAgICAgICAgICByZWY9J2tub2InXG4gICAgICAgICAgICBzdHlsZT17dGhpcy5fZ2V0S25vYlN0eWxlKCl9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblNhdHVyYXRpb25Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29sb3ItcGlja2VyL3NhdHVyYXRpb24tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi9jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU2Nyb2xsYmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3Njcm9sbGJhci1jb21wb25lbnQnXG5pbXBvcnQgU2xpZGVyT3ZlcmxheUNvbXBvbmVudCBmcm9tICcuLi9zbGlkZXItb3ZlcmxheS1jb21wb25lbnQnXG5pbXBvcnQgTWluaVNsaWRlckNvbXBvbmVudCBmcm9tICcuLi9taW5pLXNsaWRlci1jb21wb25lbnQnXG5cbmNvbnN0IElURU1TID0gW1xuICB7XG4gICAgaWRlbnRpZmllcjogJ2JyaWdodG5lc3MnLFxuICAgIGlzQXZhaWxhYmxlOiAoZWRpdG9yKSA9PiBlZGl0b3IuaXNUb29sRW5hYmxlZCgnYnJpZ2h0bmVzcycpLFxuICAgIG1pblZhbHVlOiAtMSxcbiAgICBtaWRWYWx1ZTogMCxcbiAgICBtYXhWYWx1ZTogMVxuICB9LFxuICB7XG4gICAgaWRlbnRpZmllcjogJ3NhdHVyYXRpb24nLFxuICAgIGlzQXZhaWxhYmxlOiAoZWRpdG9yKSA9PiBlZGl0b3IuaXNUb29sRW5hYmxlZCgnc2F0dXJhdGlvbicpLFxuICAgIG1pblZhbHVlOiAwLFxuICAgIG1pZFZhbHVlOiAxLFxuICAgIG1heFZhbHVlOiAyXG4gIH0sXG4gIHtcbiAgICBpZGVudGlmaWVyOiAnY29udHJhc3QnLFxuICAgIGlzQXZhaWxhYmxlOiAoZWRpdG9yKSA9PiBlZGl0b3IuaXNUb29sRW5hYmxlZCgnY29udHJhc3QnKSxcbiAgICBtaW5WYWx1ZTogMCxcbiAgICBtaWRWYWx1ZTogMSxcbiAgICBtYXhWYWx1ZTogMlxuICB9LFxuICB7XG4gICAgaWRlbnRpZmllcjogJ2dhbW1hJyxcbiAgICBpc0F2YWlsYWJsZTogKGVkaXRvcikgPT4gZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ2dhbW1hJyksXG4gICAgbWluVmFsdWU6IDAuNSxcbiAgICBtaWRWYWx1ZTogMSxcbiAgICBtYXhWYWx1ZTogM1xuICB9LFxuICB7XG4gICAgaWRlbnRpZmllcjogJ2NsYXJpdHknLFxuICAgIGlzQXZhaWxhYmxlOiAoZWRpdG9yKSA9PiBlZGl0b3IuaXNUb29sRW5hYmxlZCgnY2xhcml0eScpLFxuICAgIG1pblZhbHVlOiAtMSxcbiAgICBtaWRWYWx1ZTogMCxcbiAgICBtYXhWYWx1ZTogMVxuICB9LFxuICB7XG4gICAgaWRlbnRpZmllcjogJ2V4cG9zdXJlJyxcbiAgICBpc0F2YWlsYWJsZTogKGVkaXRvcikgPT4gZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ2V4cG9zdXJlJyksXG4gICAgbWluVmFsdWU6IC0xLFxuICAgIG1pZFZhbHVlOiAwLFxuICAgIG1heFZhbHVlOiAxXG4gIH0sXG4gIHtcbiAgICBpZGVudGlmaWVyOiAnc2hhZG93cycsXG4gICAgaXNBdmFpbGFibGU6IChlZGl0b3IpID0+IGVkaXRvci5pc1Rvb2xFbmFibGVkKCdzaGFkb3dzJyksXG4gICAgbWluVmFsdWU6IDAsXG4gICAgbWlkVmFsdWU6IDEsXG4gICAgbWF4VmFsdWU6IDJcbiAgfSxcbiAge1xuICAgIGlkZW50aWZpZXI6ICdoaWdobGlnaHRzJyxcbiAgICBpc0F2YWlsYWJsZTogKGVkaXRvcikgPT4gZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ2hpZ2hsaWdodHMnKSxcbiAgICBtaW5WYWx1ZTogLTEsXG4gICAgbWlkVmFsdWU6IDAsXG4gICAgbWF4VmFsdWU6IDFcbiAgfVxuXVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGp1c3RtZW50c0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vblNsaWRlclZhbHVlQ2hhbmdlJ1xuICAgIClcblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICB0aGlzLl9vcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnYWRqdXN0bWVudHMnKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHsgc2VsZWN0ZWRDb250cm9sczogbnVsbCB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGJhY2sgYnV0dG9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhY2tDbGljayAoZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uRXhpc3RlZEJlZm9yZScpXG4gICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbml0aWFsT3B0aW9ucycpXG5cbiAgICBpZiAoIXRoaXMuX29wZXJhdGlvbi5vcHRpb25zRXF1YWwoaW5pdGlhbE9wdGlvbnMpKSB7XG4gICAgICBlZGl0b3IuaGlzdG9yeS5hZGQodGhpcy5fb3BlcmF0aW9uLFxuICAgICAgICBpbml0aWFsT3B0aW9ucyxcbiAgICAgIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUpXG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RGVmYXVsdE9wdGlvbnMoKVxuICAgIGlmICh0aGlzLl9vcGVyYXRpb24ub3B0aW9uc0VxdWFsKGRlZmF1bHRPcHRpb25zKSkge1xuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMucmVtb3ZlKHRoaXMuX29wZXJhdGlvbilcbiAgICB9XG5cbiAgICBzdXBlci5fb25CYWNrQ2xpY2soZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIHNsaWRlciB2YWx1ZVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TbGlkZXJWYWx1ZUNoYW5nZSAodmFsdWUpIHtcbiAgICBjb25zdCB7IHNlbGVjdGVkQ29udHJvbHMgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCB7IGlkZW50aWZpZXIsIG1pblZhbHVlLCBtaWRWYWx1ZSwgbWF4VmFsdWUgfSA9IHNlbGVjdGVkQ29udHJvbHNcblxuICAgIHZhbHVlID0gdmFsdWUgPCAwXG4gICAgICA/IChtaWRWYWx1ZSArIChtaWRWYWx1ZSAtIG1pblZhbHVlKSAqIHZhbHVlIC8gMTAwKVxuICAgICAgOiAobWlkVmFsdWUgKyAobWF4VmFsdWUgLSBtaWRWYWx1ZSkgKiB2YWx1ZSAvIDEwMClcblxuICAgIHRoaXMuX29wZXJhdGlvbi5zZXRPcHRpb24oaWRlbnRpZmllciwgdmFsdWUpXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb25lIG9mIHRoZSB0aHJlZSBidXR0b25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250cm9sc0l0ZW1cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQnV0dG9uQ2xpY2sgKGNvbnRyb2xzSXRlbSwgZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWxlY3RlZENvbnRyb2xzOiBjb250cm9sc0l0ZW0gfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBwcm9wcyBoYXNoIHBhc3NlZCB0byB0aGUgc2xpZGVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfYnVpbGRTbGlkZXJQcm9wcyAoY29udHJvbHMpIHtcbiAgICBsZXQgeyBpZGVudGlmaWVyLCBtaW5WYWx1ZSwgbWlkVmFsdWUsIG1heFZhbHVlIH0gPSBjb250cm9sc1xuXG4gICAgbGV0IHZhbHVlID0gdGhpcy5fb3BlcmF0aW9uXG4gICAgICA/IHRoaXMuX29wZXJhdGlvbi5nZXRPcHRpb24oaWRlbnRpZmllcilcbiAgICAgIDogbWlkVmFsdWVcblxuICAgIGxldCBzbGlkZXJWYWx1ZSA9ICh2YWx1ZSA8PSBtaWRWYWx1ZVxuICAgICAgPyAodmFsdWUgLSBtaW5WYWx1ZSkgLyAobWlkVmFsdWUgLSBtaW5WYWx1ZSkgLSAxXG4gICAgICA6ICh2YWx1ZSAtIG1pZFZhbHVlKSAvIChtYXhWYWx1ZSAtIG1pZFZhbHVlKSkgKiAxMDBcblxuICAgIHJldHVybiB7XG4gICAgICBtaW5WYWx1ZTogLTEwMCxcbiAgICAgIG1heFZhbHVlOiAxMDAsXG4gICAgICB2YWx1ZTogc2xpZGVyVmFsdWUsXG4gICAgICB2YWx1ZVVuaXQ6ICclJyxcbiAgICAgIHBvc2l0aXZlVmFsdWVQcmVmaXg6ICcrJyxcbiAgICAgIGxhYmVsOiB0aGlzLl90KGBjb250cm9scy5hZGp1c3RtZW50cy4ke2lkZW50aWZpZXJ9YCksXG4gICAgICBtaWRkbGVEb3Q6IHRydWUsXG4gICAgICBvbkNoYW5nZTogdGhpcy5fb25TbGlkZXJWYWx1ZUNoYW5nZVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIHJlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgY29uc3QgeyBzZWxlY3RlZENvbnRyb2xzIH0gPSB0aGlzLnN0YXRlXG4gICAgaWYgKCFzZWxlY3RlZENvbnRyb2xzKSByZXR1cm5cblxuICAgIGNvbnN0IHNsaWRlclByb3BzID0gdGhpcy5fYnVpbGRTbGlkZXJQcm9wcyhzZWxlY3RlZENvbnRyb2xzKVxuICAgIHJldHVybiAoPFNsaWRlck92ZXJsYXlDb21wb25lbnQgey4uLnNsaWRlclByb3BzfSAvPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBsaXN0IGl0ZW1zXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaXN0SXRlbXMgKCkge1xuICAgIHJldHVybiBJVEVNU1xuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5pc0F2YWlsYWJsZSh0aGlzLmNvbnRleHQuZWRpdG9yKSlcbiAgICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRDb250cm9scyA9PT0gaXRlbVxuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBpc1NlbGVjdGVkID8gJ2lzLWFjdGl2ZScgOiBudWxsXG5cbiAgICAgICAgbGV0IG1pbmlTbGlkZXJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG4gICAgICAgIGlmICghaXNTZWxlY3RlZCAmJiBmYWxzZSkgeyAvLyBNaW5pIHNsaWRlcnMgdGVtcG9yYXJpbHkgZGlzYWJsZWRcbiAgICAgICAgICBjb25zdCBzbGlkZXJQcm9wcyA9IHRoaXMuX2J1aWxkU2xpZGVyUHJvcHMoaXRlbSlcbiAgICAgICAgICBtaW5pU2xpZGVyID0gKDxiZW0gc3BlY2lmaWVyPSdiOmFkanVzdG1lbnRzQ29udHJvbHMnPlxuICAgICAgICAgICAgPGRpdiBiZW09J2U6bWluaVNsaWRlcic+XG4gICAgICAgICAgICAgIDxNaW5pU2xpZGVyQ29tcG9uZW50IHsuLi5zbGlkZXJQcm9wc30gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvYmVtPilcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnN0YW50LWNvbmRpdGlvbiAqL1xuXG4gICAgICAgIHJldHVybiAoPGxpXG4gICAgICAgICAgYmVtPSdlOml0ZW0nXG4gICAgICAgICAga2V5PXtpdGVtLmlkZW50aWZpZXJ9XG4gICAgICAgICAgZGF0YS1pZGVudGlmaWVyPXtpdGVtLmlkZW50aWZpZXJ9PlxuICAgICAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nJGU6YnV0dG9uIG06d2l0aExhYmVsJyBvbkNsaWNrPXt0aGlzLl9vbkJ1dHRvbkNsaWNrLmJpbmQodGhpcywgaXRlbSl9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoYGNvbnRyb2xzL2FkanVzdG1lbnRzLyR7aXRlbS5pZGVudGlmaWVyfS5wbmdgLCB0cnVlKX0gLz5cbiAgICAgICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLl90KGBjb250cm9scy5hZGp1c3RtZW50cy4ke2l0ZW0uaWRlbnRpZmllcn1gKX08L2Rpdj5cbiAgICAgICAgICAgICAge21pbmlTbGlkZXJ9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2JlbT5cbiAgICAgICAgPC9saT4pXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJDb250cm9scyAoKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1zID0gdGhpcy5fcmVuZGVyTGlzdEl0ZW1zKClcblxuICAgIHJldHVybiAoPGRpdiBiZW09J2U6Y2VsbCBtOmxpc3QnPlxuICAgICAgPFNjcm9sbGJhckNvbXBvbmVudD5cbiAgICAgICAgPHVsIGJlbT0nJGU6bGlzdCc+XG4gICAgICAgICAge2xpc3RJdGVtc31cbiAgICAgICAgPC91bD5cbiAgICAgIDwvU2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5BZGp1c3RtZW50c0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9hZGp1c3RtZW50cy9hZGp1c3RtZW50cy1jb250cm9scy1jb21wb25lbnQuanN4IiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnLi4vY29udHJvbHMnXG5pbXBvcnQgQWRqdXN0bWVudHNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL2FkanVzdG1lbnRzLWNvbnRyb2xzLWNvbXBvbmVudCdcblxuY29uc3QgVE9PTFMgPSBbXG4gICdicmlnaHRuZXNzJywgJ2NsYXJpdHknLCAnY29udHJhc3QnLCAnZXhwb3N1cmUnLCAnaGlnaGxpZ2h0cycsICdzYXR1cmF0aW9uJywgJ3NoYWRvd3MnLCAnZ2FtbWEnXG5dXG5cbi8qKlxuICogVGhlIGFkanVzdG1lbnRzIGNvbnRyb2xzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbFxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNcbiAqL1xuY2xhc3MgQWRqdXN0bWVudHNDb250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZW50ZXJzIHRoZXNlIGNvbnRyb2xzXG4gICAqIEB0aGlzIHtBZGp1c3RtZW50c0NvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAcGFyYW0ge1NoYXJlZFN0YXRlfSBzaGFyZWRTdGF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRW50ZXIgKHNoYXJlZFN0YXRlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSBlZGl0b3Iub3BlcmF0aW9ucy5leGlzdHMoJ2FkanVzdG1lbnRzJylcbiAgICBjb25zdCBvcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnYWRqdXN0bWVudHMnKVxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IG9wZXJhdGlvbiwgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSwgaW5pdGlhbE9wdGlvbnMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjb250cm9sIGlzIGF2YWlsYWJsZSB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgaXNBdmFpbGFibGUgKGVkaXRvcikge1xuICAgIHJldHVybiBUT09MUy5maWx0ZXIoKHRvb2wpID0+IGVkaXRvci5pc1Rvb2xFbmFibGVkKHRvb2wpKS5sZW5ndGggPiAwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzZXRzIHRoYXQgc2hvdWxkIGJlIHByZWxvYWRlZCBmb3IgdGhpcyBjb250cm9sXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRWRpdG9yfSBlZGl0b3JcbiAgICogQHJldHVybiB7U3RyaW5nW119XG4gICAqL1xuICBzdGF0aWMgZ2V0UHJlbG9hZEFzc2V0cyAoZWRpdG9yKSB7XG4gICAgcmV0dXJuIFRPT0xTXG4gICAgICAuZmlsdGVyKCh0b29sKSA9PiBlZGl0b3IuaXNUb29sRW5hYmxlZCh0b29sKSlcbiAgICAgIC5tYXAoKHRvb2wpID0+IGBjb250cm9scy9hZGp1c3RtZW50cy8ke3Rvb2x9LnBuZ2ApXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjb250cm9scyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSBsb3dlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IuXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuQWRqdXN0bWVudHNDb250cm9scy5jb250cm9sc0NvbXBvbmVudCA9IEFkanVzdG1lbnRzQ29udHJvbHNDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuQWRqdXN0bWVudHNDb250cm9scy5pZGVudGlmaWVyID0gJ2FkanVzdG1lbnRzJ1xuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGljb24gcGF0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuQWRqdXN0bWVudHNDb250cm9scy5pY29uUGF0aCA9ICdjb250cm9scy9vdmVydmlldy9hZGp1c3RtZW50cy5wbmcnXG5cbi8qKlxuICogVGhlIGxhbmd1YWdlIGtleSB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGlzIGZpbHRlclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuQWRqdXN0bWVudHNDb250cm9scy5sYW5ndWFnZUtleSA9ICdjb250cm9scy5vdmVydmlldy5hZGp1c3RtZW50cydcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkFkanVzdG1lbnRzQ29udHJvbHMuZGVmYXVsdE9wdGlvbnMgPSB7XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWRqdXN0bWVudHNDb250cm9sc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9hZGp1c3RtZW50cy9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBWZWN0b3IyLCBVdGlscywgU0RLVXRpbHMsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL3Nwcml0ZXMvc3ByaXRlcy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcnVzaENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fd2luZG93UmVzaXplZCA9IGZhbHNlXG4gICAgdGhpcy5fZHJhd2luZyA9IGZhbHNlXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25Nb3VzZUVudGVyJyxcbiAgICAgICdfb25Nb3VzZUxlYXZlJyxcbiAgICAgICdfb25Nb3VzZURvd24nLFxuICAgICAgJ19vbk1vdXNlTW92ZScsXG4gICAgICAnX29uTW91c2VVcCcsXG4gICAgICAnX29uTW91c2VNb3ZlT25DYW52YXMnLFxuICAgICAgJ19vbldpbmRvd1Jlc2l6ZSdcbiAgICApXG5cbiAgICB0aGlzLl9sYXN0RHJhd1Bvc2l0aW9uID0gbnVsbFxuXG4gICAgdGhpcy5fZXZlbnRzID0gU0RLVXRpbHMuZXh0ZW5kKHRoaXMuX2V2ZW50cywge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuV0lORE9XX1JFU0laRV06IHRoaXMuX29uV2luZG93UmVzaXplXG4gICAgfSlcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBjdXJzb3JWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGN1cnNvclBvc2l0aW9uOiBuZXcgVmVjdG9yMigpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcbiAgICB0aGlzLl91cGRhdGVDb250YWluZXJSZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuX3dpbmRvd1Jlc2l6ZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbnRhaW5lclJlY3QoKVxuICAgICAgdGhpcy5fd2luZG93UmVzaXplZCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHdpbmRvdyBoYXMgYmVlbiByZXNpemVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25XaW5kb3dSZXNpemUgKCkge1xuICAgIHRoaXMuX3dpbmRvd1Jlc2l6ZWQgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uUmVtb3ZlZCAob3BlcmF0aW9uKSB7XG4gICAgdm9pZCAwXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlZCAob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykpIHtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBtb3VzZSBidXR0b25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vdXNlRG93biAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgdGhpcy5fb3B0aW9uc0JlZm9yZURyYXcgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKS5zZXJpYWxpemVPcHRpb25zKClcbiAgICBkZWxldGUgdGhpcy5fb3B0aW9uc0JlZm9yZURyYXcuZW5hYmxlZFxuXG4gICAgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZURyYXcgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb25FeGlzdGVkQmVmb3JlJylcbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZTogdHJ1ZSB9LCBmYWxzZSlcblxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gdGhpcy5fZ2V0Q3Vyc29yUG9zaXRpb24oZSlcblxuICAgIGNvbnN0IGJydXNoID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnYnJ1c2gnKVxuICAgIGNvbnN0IHRoaWNrbmVzcyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3RoaWNrbmVzcycpIC8gb3V0cHV0RGltZW5zaW9ucy5taW4oKVxuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnY29sb3InKVxuICAgIGNvbnN0IGhhcmRuZXNzID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaGFyZG5lc3MnKVxuICAgIHRoaXMuX2RyYXdpbmcgPSB0cnVlXG4gICAgdGhpcy5fY3VycmVudFBhdGggPSBicnVzaC5jcmVhdGVQYXRoKHRoaWNrbmVzcywgaGFyZG5lc3MsIGNvbG9yKVxuICAgIHRoaXMuX2N1cnJlbnRQYXRoLmFkZENvbnRyb2xQb2ludChjdXJzb3JQb3NpdGlvbi5jbG9uZSgpLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKSlcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXApXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIG1vdXNlIGJ1dHRvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VVcCAoKSB7XG4gICAgdGhpcy5fY3VycmVudFBhdGguc2V0Q2xvc2VkKHRydWUpXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZURpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0VGV4dHVyZURpbWVuc2lvbnMoKVxuICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2JydXNoJykucmVuZGVyKG91dHB1dFRleHR1cmVEaW1lbnNpb25zKVxuXG4gICAgdGhpcy5fY3VycmVudFBhdGggPSBudWxsXG4gICAgdGhpcy5fZHJhd2luZyA9IGZhbHNlXG5cbiAgICBlZGl0b3IuaGlzdG9yeS5hZGQoXG4gICAgICB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSxcbiAgICAgIHRoaXMuX29wdGlvbnNCZWZvcmVEcmF3LFxuICAgICAgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZURyYXcpXG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZW50ZXJzIHRoZSBjYW52YXNcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vdXNlRW50ZXIgKGUpIHtcbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuX2dldEN1cnNvclBvc2l0aW9uKGUpXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJzb3JWaXNpYmxlOiB0cnVlLFxuICAgICAgY3Vyc29yUG9zaXRpb25cbiAgICB9KVxuICAgIHRoaXMuX29uTW91c2VNb3ZlKGUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBsZWF2ZXMgdGhlIGNhbnZhc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VMZWF2ZSAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJzb3JWaXNpYmxlOiBmYWxzZVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vdXNlTW92ZSAoZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IG91dHB1dFRleHR1cmVEaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dFRleHR1cmVEaW1lbnNpb25zKClcblxuICAgIGNvbnN0IHpvb20gPSBlZGl0b3Iuem9vbS5nZXQoKVxuICAgIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gdGhpcy5fZ2V0Q3Vyc29yUG9zaXRpb24oZSlcbiAgICB0aGlzLnNldFN0YXRlKHsgY3Vyc29yUG9zaXRpb24gfSlcblxuICAgIGxldCBzaG91bGREcmF3XG4gICAgaWYgKCF0aGlzLl9sYXN0RHJhd1Bvc2l0aW9uKSB7XG4gICAgICBzaG91bGREcmF3ID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBicnVzaFNpemUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCd0aGlja25lc3MnKVxuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLl9sYXN0RHJhd1Bvc2l0aW9uLmNsb25lKClcbiAgICAgICAgLnN1YnRyYWN0KGN1cnNvclBvc2l0aW9uKVxuICAgICAgICAuYWJzKCkubGVuKCkgLyB6b29tXG4gICAgICBzaG91bGREcmF3ID0gZGlzdGFuY2UgPj0gYnJ1c2hTaXplIC8gMTBcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZHJhd2luZyAmJiBzaG91bGREcmF3KSB7XG4gICAgICB0aGlzLl9jdXJyZW50UGF0aC5hZGRDb250cm9sUG9pbnQoY3Vyc29yUG9zaXRpb24uY2xvbmUoKS5kaXZpZGUob3V0cHV0RGltZW5zaW9ucykpXG5cbiAgICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2JydXNoJykucmVuZGVyKG91dHB1dFRleHR1cmVEaW1lbnNpb25zKVxuXG4gICAgICB0aGlzLl9sYXN0RHJhd1Bvc2l0aW9uID0gY3Vyc29yUG9zaXRpb24uY2xvbmUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2Ugb24gdG9wIG9mIHRoZSBjYW52YXMuIFVwZGF0ZXNcbiAgICogdGhlIGN1cnNvciBjdXJzb3IgcG9zaXRpb25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vdXNlTW92ZU9uQ2FudmFzIChlKSB7XG4gICAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSB0aGlzLl9nZXRDdXJzb3JQb3NpdGlvbihlKVxuICAgIHRoaXMuc2V0U3RhdGUoeyBjdXJzb3JQb3NpdGlvbiB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IncyBzdHlsZSBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEN1cnNvclN0eWxlICgpIHtcbiAgICBjb25zdCB0aGlja25lc3MgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCd0aGlja25lc3MnKVxuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnY29sb3InKVxuXG4gICAgY29uc3QgeyBjdXJzb3JQb3NpdGlvbiB9ID0gdGhpcy5zdGF0ZVxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBjdXJzb3JQb3NpdGlvbi54LFxuICAgICAgdG9wOiBjdXJzb3JQb3NpdGlvbi55LFxuICAgICAgd2lkdGg6IHRoaWNrbmVzcyxcbiAgICAgIGhlaWdodDogdGhpY2tuZXNzLFxuICAgICAgYmFja2dyb3VuZDogY29sb3IudG9SR0JBKCksXG4gICAgICBtYXJnaW5MZWZ0OiB0aGlja25lc3MgKiAtMC41LFxuICAgICAgbWFyZ2luVG9wOiB0aGlja25lc3MgKiAtMC41XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb250YWluZXIgYm91bmRpbmcgcmVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUNvbnRhaW5lclJlY3QgKCkge1xuICAgIHRoaXMuX2NvbnRhaW5lckJvdW5kaW5nUmVjdCA9IHRoaXMucmVmcy5pbm5lckNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnNvciBwb3NpdGlvbiBmb3IgdGhlIGdpdmVuIGV2ZW50XG4gICAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEN1cnNvclBvc2l0aW9uIChldmVudCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihldmVudClcbiAgICBjb25zdCBib3VuZGluZ1JlY3QgPSB0aGlzLl9jb250YWluZXJCb3VuZGluZ1JlY3RcbiAgICByZXR1cm4gcG9zaXRpb25cbiAgICAgIC5zdWJ0cmFjdChib3VuZGluZ1JlY3QubGVmdCwgYm91bmRpbmdSZWN0LnRvcClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgb3V0ZXIgY29udGFpbmVyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDb250YWluZXJQcm9wcyAoKSB7XG4gICAgbGV0IHByb3BzID0gc3VwZXIuX2dldENvbnRhaW5lclByb3BzKClcblxuICAgIHByb3BzLm9uTW91c2VEb3duID0gcHJvcHMub25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Nb3VzZURvd25cbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgY2FudmFzIGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5uZXJDb250YWluZXJQcm9wcyAoKSB7XG4gICAgbGV0IHByb3BzID0gc3VwZXIuX2dldElubmVyQ29udGFpbmVyUHJvcHMoKVxuXG4gICAgLy8gVGhpcyBkaXNhYmxlcyB0aGUgaGl0IHRlc3RpbmcgZm9yIHRoaXMgc3ViIGNvbnRyb2xcbiAgICBkZWxldGUgcHJvcHMub25DbGlja1xuXG4gICAgcHJvcHMub25Nb3VzZUVudGVyID0gdGhpcy5fb25Nb3VzZUVudGVyXG4gICAgcHJvcHMub25Nb3VzZUxlYXZlID0gdGhpcy5fb25Nb3VzZUxlYXZlXG4gICAgcHJvcHMub25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZU9uQ2FudmFzXG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogVGhpcyByZW5kZXJzIGNvbnRyb2xzIG9uIHRvcCBvZiB0aGUgc3ByaXRlc1xuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgY29uc3QgY3Vyc29yQ2xhc3MgPSB0aGlzLnN0YXRlLmN1cnNvclZpc2libGUgPyAnaXMtdmlzaWJsZScgOiBudWxsXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgYmVtPSckYjpicnVzaENhbnZhc0NvbnRyb2xzJz5cbiAgICAgICAgPGRpdiBiZW09J2U6Y3Vyc29yJyBjbGFzc05hbWU9e2N1cnNvckNsYXNzfSBzdHlsZT17dGhpcy5fZ2V0Q3Vyc29yU3R5bGUoKX0gLz5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5CcnVzaENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IFNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvYnJ1c2gvYnJ1c2gtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi9jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU2xpZGVyQ29tcG9uZW50IGZyb20gJy4uLy4uL3NsaWRlci1jb21wb25lbnQnXG5pbXBvcnQgU2Nyb2xsYmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3Njcm9sbGJhci1jb21wb25lbnQnXG5pbXBvcnQgQ29sb3JQaWNrZXJDb21wb25lbnQgZnJvbSAnLi4vLi4vY29sb3ItcGlja2VyL2NvbG9yLXBpY2tlci1jb21wb25lbnQnXG5pbXBvcnQgUHJlc2V0UHJldmlld0l0ZW1Db21wb25lbnQgZnJvbSAnLi9wcmVzZXQtcHJldmlldy1pdGVtLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJ1c2hDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIENvbnRyb2xzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5faGFzRG9uZUJ1dHRvbiA9IGZhbHNlXG4gICAgdGhpcy5fYnJ1c2hPcHRpb25zID0ge1xuICAgICAgdGhpY2tuZXNzOiB0aGlzLmdldFNoYXJlZFN0YXRlKCd0aGlja25lc3MnKSxcbiAgICAgIGNvbG9yOiB0aGlzLmdldFNoYXJlZFN0YXRlKCdjb2xvcicpLmNsb25lKClcbiAgICB9XG5cbiAgICB0aGlzLl9oYXNQcmVzZXRzID0gdGhpcy5wcm9wcy5vcHRpb25zLnRoaWNrbmVzc1ByZXNldHMgJiZcbiAgICAgIHRoaXMucHJvcHMub3B0aW9ucy50aGlja25lc3NQcmVzZXRzLmxlbmd0aCA+IDBcbiAgICB0aGlzLl9oYXNTbGlkZXIgPSAhdGhpcy5faGFzUHJlc2V0c1xuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25UaGlja25lc3NVcGRhdGVkJyxcbiAgICAgICdfb25Db2xvclVwZGF0ZWQnLFxuICAgICAgJ19vbk9wZXJhdGlvblVwZGF0ZWQnLFxuICAgICAgJ19vbk9wZXJhdGlvblJlbW92ZWQnXG4gICAgKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHRoaWNrbmVzc0NvbnRyb2xzRW5hYmxlZDogZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHMgPSB7XG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5PUEVSQVRJT05fVVBEQVRFRF06IHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlZCxcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9SRU1PVkVEXTogdGhpcy5fb25PcGVyYXRpb25SZW1vdmVkXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3Iuem9vbS5zZXQoJ2F1dG8nKVxuICAgIGVkaXRvci5mZWF0dXJlcy5kaXNhYmxlKCd6b29tJywgJ2RyYWcnKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgdGhpY2tuZXNzIHByZXNldFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRoaWNrbmVzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uVGhpY2tuZXNzQ2xpY2sgKHRoaWNrbmVzcykge1xuICAgIHRoaXMuX29uVGhpY2tuZXNzVXBkYXRlZCh0aGlja25lc3MpXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uUmVtb3ZlZCAob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbiAhPT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykpIHJldHVyblxuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uQ2xpY2tlZCkgcmV0dXJuXG5cbiAgICAvLyBPcGVyYXRpb24gY2FuIGJlIHJlbW92ZWQgYnkgdGhlIHVuZG8gYnV0dG9uLiBXZSBuZWVkXG4gICAgLy8gdG8gbWFrZSBzdXJlIHdlIHJlLWNyZWF0ZSB0aGUgb3BlcmF0aW9uIGZvciB0aGUgbGlmZXRpbWVcbiAgICAvLyBvZiB0aGlzIGNvbnRyb2xcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgbmV3T3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3Nwcml0ZScpXG5cbiAgICBjb25zdCBicnVzaCA9IG5ld09wZXJhdGlvbi5jcmVhdGVCcnVzaCgpXG4gICAgbmV3T3BlcmF0aW9uLmFkZFNwcml0ZShicnVzaClcblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgb3BlcmF0aW9uOiBuZXdPcGVyYXRpb24sXG4gICAgICBicnVzaCxcbiAgICAgIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmU6IGZhbHNlLFxuICAgICAgaW5pdGlhbE9wdGlvbnM6IHt9XG4gICAgfSlcblxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHBhcmFtICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblVwZGF0ZWQgKG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24gPT09IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpKSB7XG4gICAgICAvLyBTcHJpdGVPcGVyYXRpb24gcmUtY3JlYXRlcyBhbGwgc3ByaXRlcyB3aGVuIHRoZXkncmUgbWFzcy1hc3NpZ25lZCxcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV3IGluc3RhbmNlIGJ5IG1hdGNoaW5nIGFnYWluc3QgdGhlIHByZXZpb3VzIElEXG4gICAgICBjb25zdCBwcmV2aW91c0JydXNoID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnYnJ1c2gnKVxuICAgICAgaWYgKHByZXZpb3VzQnJ1c2gpIHtcbiAgICAgICAgY29uc3QgYnJ1c2ggPSBvcGVyYXRpb24uZ2V0U3ByaXRlcygpXG4gICAgICAgICAgLmZpbHRlcigocykgPT4gcy5nZXRJZCgpID09PSBwcmV2aW91c0JydXNoLmdldElkKCkpWzBdXG4gICAgICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBicnVzaCB9KVxuICAgICAgfVxuXG4gICAgICAvLyBUcmlnZ2VyIGJydXNoIGNhbnZhcyByZW5kZXJpbmdcbiAgICAgIG9wZXJhdGlvbi5zZXRFbmFibGVkKHRydWUpXG4gICAgICB0aGlzLmNvbnRleHQuZWRpdG9yLnJlbmRlcigoKSA9PiB7XG4gICAgICAgIG9wZXJhdGlvbi5zZXRFbmFibGVkKGZhbHNlKVxuICAgICAgICB0aGlzLmNvbnRleHQuZWRpdG9yLnJlbmRlcigpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB0aGlja25lc3MgaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhpY2tuZXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25UaGlja25lc3NVcGRhdGVkICh0aGlja25lc3MpIHtcbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgdGhpY2tuZXNzIH0pXG4gICAgdGhpcy5fYnJ1c2hPcHRpb25zLnRoaWNrbmVzcyA9IHRoaWNrbmVzc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbG9yIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHBhcmFtICB7Q29sb3J9IGNvbG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db2xvclVwZGF0ZWQgKGNvbG9yKSB7XG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IGNvbG9yIH0pXG4gICAgdGhpcy5fYnJ1c2hPcHRpb25zLmNvbG9yID0gY29sb3IuY2xvbmUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHRoaWNrbmVzcyBsaXN0IGl0ZW1zXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJUaGlja25lc3NJdGVtcyAoKSB7XG4gICAgY29uc3QgeyB0aGlja25lc3NQcmVzZXRzIH0gPSB0aGlzLnByb3BzLm9wdGlvbnNcbiAgICBjb25zdCBtYXhUaGlja25lc3MgPSBNYXRoLm1heC5hcHBseShudWxsLCB0aGlja25lc3NQcmVzZXRzKVxuICAgIHJldHVybiB0aGlja25lc3NQcmVzZXRzLm1hcCgodGhpY2tuZXNzKSA9PiB7XG4gICAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3RoaWNrbmVzcycpID09PSB0aGlja25lc3NcbiAgICAgIHJldHVybiAoPFByZXNldFByZXZpZXdJdGVtQ29tcG9uZW50XG4gICAgICAgIHRoaWNrbmVzcz17dGhpY2tuZXNzfVxuICAgICAgICBtYXhUaGlja25lc3M9e21heFRoaWNrbmVzc31cbiAgICAgICAgYWN0aXZlPXtpc0FjdGl2ZX1cbiAgICAgICAga2V5PXt0aGlja25lc3N9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uVGhpY2tuZXNzQ2xpY2suYmluZCh0aGlzLCB0aGlja25lc3MpfSAvPilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJDb250cm9scyAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHpvb20gPSBlZGl0b3Iuem9vbS5nZXQoKVxuICAgIGxldCBpdGVtcyA9IFtdXG5cbiAgICBpZiAodGhpcy5faGFzU2xpZGVyKSB7XG4gICAgICBjb25zdCBmaW5hbERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0RmluYWxEaW1lbnNpb25zKClcbiAgICAgIGNvbnN0IG1pblRoaWNrbmVzcyA9IDFcbiAgICAgIGNvbnN0IG1heFRoaWNrbmVzcyA9IE1hdGgucm91bmQoZmluYWxEaW1lbnNpb25zLmNsb25lKCkubXVsdGlwbHkoem9vbSkubWluKCkgLyAyKVxuICAgICAgY29uc3QgY3VycmVudFdpZHRoID0gdGhpcy5fYnJ1c2hPcHRpb25zLnRoaWNrbmVzc1xuXG4gICAgICBpdGVtcy5wdXNoKDxkaXYgYmVtPSdlOmNlbGwgbTpzbGlkZXInPlxuICAgICAgICA8U2xpZGVyQ29tcG9uZW50XG4gICAgICAgICAgc3R5bGU9J2xhcmdlJ1xuICAgICAgICAgIG1pblZhbHVlPXttaW5UaGlja25lc3N9XG4gICAgICAgICAgbWF4VmFsdWU9e21heFRoaWNrbmVzc31cbiAgICAgICAgICB2YWx1ZVVuaXQ9J3B4J1xuICAgICAgICAgIG1pZGRsZURvdD17ZmFsc2V9XG4gICAgICAgICAgbGFiZWw9e3RoaXMuX3QoJ2NvbnRyb2xzLmJydXNoLnRoaWNrbmVzcycpfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vblRoaWNrbmVzc1VwZGF0ZWR9XG4gICAgICAgICAgdmFsdWU9e2N1cnJlbnRXaWR0aH0gLz5cbiAgICAgIDwvZGl2PilcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1ByZXNldHMpIHtcbiAgICAgIGl0ZW1zLnB1c2goPGRpdiBiZW09J2U6Y2VsbCBtOmxpc3QnPlxuICAgICAgICA8U2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgICAgICAgIDx1bCBiZW09JyRlOmxpc3QnPlxuICAgICAgICAgICAge3RoaXMuX3JlbmRlclRoaWNrbmVzc0l0ZW1zKCl9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC9TY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgICA8L2Rpdj4pXG4gICAgfVxuXG4gICAgaXRlbXMucHVzaCg8ZGl2IGJlbT0nZTpjZWxsIG06Y29sb3JQaWNrZXInPlxuICAgICAgPENvbG9yUGlja2VyQ29tcG9uZW50XG4gICAgICAgIGluaXRpYWxWYWx1ZT17dGhpcy5fYnJ1c2hPcHRpb25zLmNvbG9yLmNsb25lKCl9XG4gICAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vbkNvbG9yVXBkYXRlZH0gLz5cbiAgICA8L2Rpdj4pXG5cbiAgICByZXR1cm4gaXRlbXNcbiAgfVxufVxuXG5CcnVzaENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9icnVzaC9icnVzaC1jb250cm9scy1jb21wb25lbnQuanN4IiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnLi4vY29udHJvbHMnXG5pbXBvcnQgQnJ1c2hDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL2JydXNoLWNvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBCcnVzaENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vYnJ1c2gtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudCdcblxuLyoqXG4gKiBUaGUgYnJ1c2ggY29udHJvbHNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc1xuICovXG5jbGFzcyBCcnVzaENvbnRyb2xzIGV4dGVuZHMgQ29udHJvbHMge1xuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBsZWF2ZXMgdGhlc2UgY29udHJvbHNcbiAgICogQHRoaXMge1N0aWNrZXJzQ29udHJvbHNDb21wb25lbnR9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgb25FeGl0ICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcblxuICAgIG9wZXJhdGlvbi5zZXRFbmFibGVkKHRydWUpXG5cbiAgICBlZGl0b3Iuem9vbS51bmRvKClcbiAgICBlZGl0b3IuZmVhdHVyZXMuZW5hYmxlKCd6b29tJywgJ2RyYWcnKVxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZW50ZXJzIHRoZXNlIGNvbnRyb2xzXG4gICAqIEB0aGlzIHtCcnVzaENvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAcGFyYW0ge1NoYXJlZFN0YXRlfSBzaGFyZWRTdGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRW50ZXIgKHNoYXJlZFN0YXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJywgKCkgPT4ge1xuICAgICAgb3BlcmF0aW9uLnNldEVuYWJsZWQoZmFsc2UpXG4gICAgICBlZGl0b3IucmVuZGVyKClcbiAgICB9KVxuXG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBvcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gZWRpdG9yLm9wZXJhdGlvbnMuZXhpc3RzKCdzcHJpdGUnKVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzcHJpdGUnKVxuICAgIGNvbnN0IGJydXNoID0gb3BlcmF0aW9uLmNyZWF0ZUJydXNoKClcbiAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKClcbiAgICBvcGVyYXRpb24uYWRkU3ByaXRlKGJydXNoKVxuXG4gICAgbGV0IHRoaWNrbmVzcyA9IE1hdGgubWF4KG91dHB1dERpbWVuc2lvbnMubWluKCkgKiAwLjA1LCAxKVxuICAgIGlmIChvcHRpb25zLnRoaWNrbmVzc1ByZXNldHMgJiYgb3B0aW9ucy50aGlja25lc3NQcmVzZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaWNrbmVzcyA9IG9wdGlvbnMudGhpY2tuZXNzUHJlc2V0c1swXVxuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDEsIDAsIDAsIDEpXG4gICAgY29uc3QgaGFyZG5lc3MgPSAxXG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUsIG9wZXJhdGlvbiwgYnJ1c2gsIGluaXRpYWxPcHRpb25zLCB0aGlja25lc3MsIGNvbG9yLCBoYXJkbmVzc1xuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY29udHJvbCBpcyBhdmFpbGFibGUgdG8gdGhlIHVzZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGlzQXZhaWxhYmxlIChlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ2JydXNoJylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NldHMgdGhhdCBzaG91bGQgYmUgcHJlbG9hZGVkIGZvciB0aGlzIGNvbnRyb2xcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRQcmVsb2FkQXNzZXRzICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ2NvbnRyb2xzL2JydXNoL3RoaWNrbmVzcy5wbmcnXG4gICAgXVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbkJydXNoQ29udHJvbHMuY29udHJvbHNDb21wb25lbnQgPSBCcnVzaENvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbkJydXNoQ29udHJvbHMuY2FudmFzQ29udHJvbHNDb21wb25lbnQgPSBCcnVzaENhbnZhc0NvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkJydXNoQ29udHJvbHMuaWRlbnRpZmllciA9ICdicnVzaCdcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpY29uIHBhdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkJydXNoQ29udHJvbHMuaWNvblBhdGggPSAnY29udHJvbHMvb3ZlcnZpZXcvYnJ1c2gucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkJydXNoQ29udHJvbHMubGFuZ3VhZ2VLZXkgPSAnY29udHJvbHMub3ZlcnZpZXcuYnJ1c2gnXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhpcyBjb250cm9sXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5CcnVzaENvbnRyb2xzLmRlZmF1bHRPcHRpb25zID0ge1xuICB0aGlja25lc3NQcmVzZXRzOiBbXVxufVxuXG5leHBvcnQgZGVmYXVsdCBCcnVzaENvbnRyb2xzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2JydXNoL2luZGV4LmpzIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVzZXRQcmV2aWV3SXRlbUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIHRoaXMuX3JlbmRlckNhbnZhcygpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlICgpIHtcbiAgICB0aGlzLl9yZW5kZXJDYW52YXMoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ0FOVkFTIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjdXJyZW50IGZvbnQgZmFtaWx5IG9udG8gdGhlIGNhbnZhc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAoKSB7XG4gICAgY29uc3QgeyBjYW52YXMgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHRcblxuICAgIGNvbnN0IHsgbWF4VGhpY2tuZXNzLCB0aGlja25lc3MgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBkaWFtZXRlciA9IGNhbnZhcy53aWR0aCAqICh0aGlja25lc3MgLyBtYXhUaGlja25lc3MpXG4gICAgY29uc3QgcmFkaXVzID0gZGlhbWV0ZXIgLyAyXG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSdcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpXG4gICAgY29udGV4dC5hcmMoY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpXG4gICAgY29udGV4dC5maWxsKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyAkZTpsaXN0Jz5cbiAgICAgIDxsaVxuICAgICAgICBiZW09J2U6aXRlbSdcbiAgICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfT5cbiAgICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgICA8ZGl2IGJlbT0nJGU6YnV0dG9uIG06d2l0aExhYmVsJyBjbGFzc05hbWU9e3RoaXMucHJvcHMuYWN0aXZlID8gJ2lzLWFjdGl2ZScgOiBudWxsfT5cbiAgICAgICAgICAgIDxjYW52YXMgYmVtPSdlOmNhbnZhcycgcmVmPSdjYW52YXMnIC8+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMucHJvcHMudGhpY2tuZXNzfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2JlbT5cbiAgICAgIDwvbGk+XG4gICAgPC9iZW0+KVxuICB9XG59XG5cblByZXNldFByZXZpZXdJdGVtQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2JydXNoL3ByZXNldC1wcmV2aWV3LWl0ZW0tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBWZWN0b3IyLCBVdGlscyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgRHJhZ2dhYmxlQ29tcG9uZW50IGZyb20gJy4uLy4uL2RyYWdnYWJsZS1jb21wb25lbnQuanN4J1xuaW1wb3J0IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5cbmNvbnN0IE1JTl9ESU1FTlNJT05TID0gbmV3IFZlY3RvcjIoNTAsIDUwKVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDcm9wQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX25lZWRzU3R5bGVGaXhlcyA9IHRydWVcbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkNlbnRlckRyYWdTdGFydCcsXG4gICAgICAnX29uQ2VudGVyRHJhZydcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZGltZW5zaW9uczogdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaW5pdGlhbERpbWVuc2lvbnMnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXhlcyBzdHlsZXMgaW4gSUVcbiAgICovXG4gIGZpeFN0eWxlcyAoKSB7XG4gICAgaWYgKFV0aWxzLkJyb3dzZXIuaXNJRWx0ZSgxMSkpIHtcbiAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSB0aGlzLnJlZnNcblxuICAgICAgY29uc3QgY2FudmFzRGltZW5zaW9ucyA9IGVkaXRvci5nZXRDYW52YXNEaW1lbnNpb25zKGZhbHNlKVxuICAgICAgY29uc3QgY2VsbEhlaWdodCA9IGNhbnZhc0RpbWVuc2lvbnMueVxuICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2NlbGxIZWlnaHR9cHhgXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNoYXJlZCBzdGF0ZSBkaWQgY2hhbmdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKi9cbiAgc2hhcmVkU3RhdGVEaWRDaGFuZ2UgKG5ld1N0YXRlKSB7XG4gICAgaWYgKG5ld1N0YXRlICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdyYXRpbycpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGltZW5zaW9ucyBkaXNwbGF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlRGltZW5zaW9ucyAoKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCByYXRpbyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3JhdGlvJykgfHwgeyByYXRpbzogJyonIH1cblxuICAgIGxldCBkaW1lbnNpb25zXG4gICAgaWYgKHJhdGlvLmRpbWVuc2lvbnMpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSByYXRpby5kaW1lbnNpb25zLmNsb25lKClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gb3BlcmF0aW9uLmdldElucHV0RGltZW5zaW9ucygpXG4gICAgICBjb25zdCBzdGFydCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3N0YXJ0JylcbiAgICAgIGNvbnN0IGVuZCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2VuZCcpXG4gICAgICBjb25zdCBjcm9wU2l6ZSA9IGVuZC5jbG9uZSgpLnN1YnRyYWN0KHN0YXJ0KVxuICAgICAgZGltZW5zaW9ucyA9IGNyb3BTaXplLm11bHRpcGx5KGlucHV0RGltZW5zaW9ucykuZmxvb3IoKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyBkaW1lbnNpb25zIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDRU5URVIgRFJBR0dJTkdcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFycyBkcmFnZ2luZyB0aGUgY2VudGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DZW50ZXJEcmFnU3RhcnQgKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc3RhcnQnKVxuICAgIGNvbnN0IGVuZCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2VuZCcpXG5cbiAgICB0aGlzLl9pbml0aWFsVmFsdWVzID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LmNsb25lKCksXG4gICAgICBlbmQ6IGVuZC5jbG9uZSgpLFxuICAgICAgc2l6ZTogZW5kLmNsb25lKCkuc3VidHJhY3Qoc3RhcnQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBjZW50ZXJcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNlbnRlckRyYWcgKG9mZnNldCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCB7IHN0YXJ0LCBzaXplIH0gPSB0aGlzLl9pbml0aWFsVmFsdWVzXG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBjcm9wRGlmZmVyZW5jZSA9IG9mZnNldC5jbG9uZSgpLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKVxuXG4gICAgY29uc3QgbWluU3RhcnQgPSBuZXcgVmVjdG9yMigwLCAwKVxuICAgIGNvbnN0IG1heFN0YXJ0ID0gbmV3IFZlY3RvcjIoMSwgMSlcbiAgICAgIC5zdWJ0cmFjdChzaXplKVxuXG4gICAgY29uc3QgbmV3U3RhcnQgPSBzdGFydC5jbG9uZSgpXG4gICAgICAuYWRkKGNyb3BEaWZmZXJlbmNlKVxuICAgICAgLmNsYW1wKG1pblN0YXJ0LCBtYXhTdGFydClcbiAgICBjb25zdCBuZXdFbmQgPSBuZXdTdGFydC5jbG9uZSgpXG4gICAgICAuYWRkKHNpemUpXG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgc3RhcnQ6IG5ld1N0YXJ0LCBlbmQ6IG5ld0VuZCB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gS05PQiBEUkFHR0lOR1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyBhIGtub2JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbktub2JEcmFnU3RhcnQgKG9wdGlvbk5hbWUpIHtcbiAgICB0aGlzLl9jdXJyZW50RHJhZ09wdGlvbiA9IG9wdGlvbk5hbWVcblxuICAgIHRoaXMuX2luaXRpYWxWYWx1ZXMgPSB7XG4gICAgICBzdGFydDogdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc3RhcnQnKS5jbG9uZSgpLFxuICAgICAgZW5kOiB0aGlzLmdldFNoYXJlZFN0YXRlKCdlbmQnKS5jbG9uZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIGEga25vYlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG9mZnNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWcgKG9wdGlvbk5hbWUsIG9mZnNldCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGxldCB7IHJhdGlvLCBkaW1lbnNpb25zIH0gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdyYXRpbycpIHx8IHsgcmF0aW86ICcqJyB9XG4gICAgaWYgKGRpbWVuc2lvbnMgJiYgIXJhdGlvKSB7XG4gICAgICByYXRpbyA9IGRpbWVuc2lvbnMueCAvIGRpbWVuc2lvbnMueVxuICAgIH1cblxuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLl9pbml0aWFsVmFsdWVzLmVuZC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QodGhpcy5faW5pdGlhbFZhbHVlcy5zdGFydClcbiAgICAgIC5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKVxuXG4gICAgLy8gQ2FsY3VsYXRlIG1heCBzaXplIGFuZCBuZXcgc2l6ZVxuICAgIGxldCBtYXhTaXplXG4gICAgaWYgKG9wdGlvbk5hbWUgPT09ICdzdGFydCcpIHtcbiAgICAgIG5ld1NpemUuc3VidHJhY3Qob2Zmc2V0KVxuICAgICAgbWF4U2l6ZSA9IHRoaXMuX2luaXRpYWxWYWx1ZXMuZW5kLmNsb25lKClcbiAgICAgICAgLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG4gICAgfSBlbHNlIGlmIChvcHRpb25OYW1lID09PSAnZW5kJykge1xuICAgICAgbmV3U2l6ZS5hZGQob2Zmc2V0KVxuICAgICAgbWF4U2l6ZSA9IG5ldyBWZWN0b3IyKDEsIDEpXG4gICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9pbml0aWFsVmFsdWVzLnN0YXJ0KVxuICAgICAgICAubXVsdGlwbHkob3V0cHV0RGltZW5zaW9ucylcbiAgICB9XG5cbiAgICBuZXdTaXplLnggPSBNYXRoLm1pbihNYXRoLm1heChNSU5fRElNRU5TSU9OUy54LCBuZXdTaXplLngpLCBtYXhTaXplLngpXG4gICAgaWYgKHJhdGlvICE9PSAnKicpIHtcbiAgICAgIG5ld1NpemUueSA9IG5ld1NpemUueCAvIHJhdGlvXG4gICAgfVxuICAgIG5ld1NpemUueSA9IE1hdGgubWluKE1hdGgubWF4KE1JTl9ESU1FTlNJT05TLnksIG5ld1NpemUueSksIG1heFNpemUueSlcbiAgICBpZiAocmF0aW8gIT09ICcqJykge1xuICAgICAgbmV3U2l6ZS54ID0gbmV3U2l6ZS55ICogcmF0aW9cbiAgICB9XG5cbiAgICBpZiAob3B0aW9uTmFtZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSB0aGlzLl9pbml0aWFsVmFsdWVzLmVuZC5jbG9uZSgpXG4gICAgICAgIC5zdWJ0cmFjdChcbiAgICAgICAgICBuZXdTaXplXG4gICAgICAgICAgICAuY2xvbmUoKVxuICAgICAgICAgICAgLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKVxuICAgICAgICApXG4gICAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgc3RhcnQ6IG5ld1N0YXJ0IH0sIGZhbHNlKVxuICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpXG4gICAgfSBlbHNlIGlmIChvcHRpb25OYW1lID09PSAnZW5kJykge1xuICAgICAgY29uc3QgbmV3RW5kID0gdGhpcy5faW5pdGlhbFZhbHVlcy5zdGFydC5jbG9uZSgpXG4gICAgICAgIC5hZGQoXG4gICAgICAgICAgbmV3U2l6ZVxuICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgIC5kaXZpZGUob3V0cHV0RGltZW5zaW9ucylcbiAgICAgICAgKVxuICAgICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IGVuZDogbmV3RW5kIH0sIGZhbHNlKVxuICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBjcm9wIGRpbWVuc2lvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWxjdWxhdGVEaW1lbnNpb25zICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzdGFydCcpXG4gICAgY29uc3QgZW5kID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJylcblxuICAgIHJldHVybiBlbmQuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KHN0YXJ0KVxuICAgICAgLm11bHRpcGx5KGVkaXRvci5nZXRJbnB1dERpbWVuc2lvbnMoKSlcbiAgICAgIC5yb3VuZCgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRVNJWklORyAvIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGVzICh3aWR0aCAvIGhlaWdodCkgZm9yIHRoZSBjcm9wIGFyZWFzIHRoYXQgZGVmaW5lIHRoZVxuICAgKiBjcm9wIHNpemVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEFyZWFTdHlsZXMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IGNhbnZhc0RpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0Q2FudmFzRGltZW5zaW9ucygpXG5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3N0YXJ0JykuY2xvbmUoKS5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKS5mbG9vcigpXG4gICAgY29uc3QgZW5kID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJykuY2xvbmUoKS5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKS5jZWlsKClcbiAgICBjb25zdCBzaXplID0gZW5kLmNsb25lKCkuc3VidHJhY3Qoc3RhcnQpXG5cbiAgICBjb25zdCBvZmZzZXQgPSBjYW52YXNEaW1lbnNpb25zLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChvdXRwdXREaW1lbnNpb25zKVxuICAgICAgLmRpdmlkZSgyKVxuICAgICAgLmZsb29yKClcblxuICAgIGNvbnN0IHBhZGRpbmcgPSBlZGl0b3IuZ2V0UGFkZGluZygpXG4gICAgc3RhcnQuYWRkKG9mZnNldClcbiAgICAgIC5hZGQoMCwgcGFkZGluZ1swXSlcblxuICAgIHJldHVybiB7XG4gICAgICB0b3BMZWZ0OiB0aGlzLl9nZXREaW1lbnNpb25zU3R5bGVzKHN0YXJ0LngsIHN0YXJ0LnkpLFxuICAgICAgdG9wQ2VudGVyOiB0aGlzLl9nZXREaW1lbnNpb25zU3R5bGVzKHNpemUueCwgc3RhcnQueSksXG4gICAgICBjZW50ZXJMZWZ0OiB0aGlzLl9nZXREaW1lbnNpb25zU3R5bGVzKHN0YXJ0LngsIHNpemUueSksXG4gICAgICBjZW50ZXI6IHRoaXMuX2dldERpbWVuc2lvbnNTdHlsZXMoc2l6ZS54LCBzaXplLnkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgc3R5bGUgKHdpZHRoIC8gaGVpZ2h0KSBmb3IgdGhlIGdpdmVuIGRpbWVuc2lvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldERpbWVuc2lvbnNTdHlsZXMgKHgsIHkpIHtcbiAgICAvLyBUYWJsZSBjZWxscyBhbmQgcm93cyBjYW4ndCBoYXZlIGEgd2lkdGggLyBoZWlnaHQgb2YgMFxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5tYXgoMSwgeCksXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDEsIHkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGNvbnN0IHJhdGlvID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgncmF0aW8nKVxuICAgIGNvbnN0IHsgZGltZW5zaW9ucyB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgbGV0IGNhbnZhc0NvbnRlbnRcbiAgICBpZiAocmF0aW8pIHtcbiAgICAgIGNvbnN0IGFyZWFTdHlsZXMgPSB0aGlzLl9nZXRBcmVhU3R5bGVzKClcbiAgICAgIGNhbnZhc0NvbnRlbnQgPSAoPGRpdiBiZW09JyRiOmNyb3BDYW52YXNDb250cm9scyc+XG4gICAgICAgIDxkaXYgYmVtPSdlOnJvdyc+XG4gICAgICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmRhcmsnIHN0eWxlPXthcmVhU3R5bGVzLnRvcExlZnR9PiZuYnNwOzwvZGl2PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpkYXJrJyBzdHlsZT17YXJlYVN0eWxlcy50b3BDZW50ZXJ9PiZuYnNwOzwvZGl2PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpkYXJrJyAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBiZW09J2U6cm93Jz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpjZWxsIG06ZGFyaycgc3R5bGU9e2FyZWFTdHlsZXMuY2VudGVyTGVmdH0+Jm5ic3A7PC9kaXY+XG4gICAgICAgICAgPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgICAgICAgb25TdGFydD17dGhpcy5fb25DZW50ZXJEcmFnU3RhcnR9XG4gICAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uQ2VudGVyRHJhZ30+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTpjZWxsIG06Ym9yZGVyZWQnIHN0eWxlPXthcmVhU3R5bGVzLmNlbnRlcn0+XG4gICAgICAgICAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbktub2JEcmFnU3RhcnQuYmluZCh0aGlzLCAnc3RhcnQnKX1cbiAgICAgICAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uS25vYkRyYWcuYmluZCh0aGlzLCAnc3RhcnQnKX0+XG4gICAgICAgICAgICAgICAgPGRpdiBiZW09J2U6a25vYiBtOnRvcExlZnQgJGI6a25vYic+XG4gICAgICAgICAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMva25vYnMvcmVzaXplLWRpYWdvbmFsLWRvd24ucG5nJywgdHJ1ZSl9IC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgICAgICAgICAgICA8ZGl2IGJlbT0nZTpkaW1lbnNpb25zJz57YCR7ZGltZW5zaW9ucy54fXgke2RpbWVuc2lvbnMueX1gfTwvZGl2PlxuICAgICAgICAgICAgICA8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgb25TdGFydD17dGhpcy5fb25Lbm9iRHJhZ1N0YXJ0LmJpbmQodGhpcywgJ2VuZCcpfVxuICAgICAgICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25Lbm9iRHJhZy5iaW5kKHRoaXMsICdlbmQnKX0+XG4gICAgICAgICAgICAgICAgPGRpdiBiZW09J2U6a25vYiBtOmJvdHRvbVJpZ2h0ICRiOmtub2InPlxuICAgICAgICAgICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL2tub2JzL3Jlc2l6ZS1kaWFnb25hbC1kb3duLnBuZycsIHRydWUpfSAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpkYXJrJz4mbmJzcDs8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgYmVtPSdlOnJvdyc+XG4gICAgICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmRhcmsnPiZuYnNwOzwvZGl2PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpkYXJrJz4mbmJzcDs8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpjZWxsIG06ZGFyayc+Jm5ic3A7PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+KVxuICAgIH0gZWxzZSB7XG4gICAgICBjYW52YXNDb250ZW50ID0gKDxkaXYgYmVtPSckYjpjcm9wQ2FudmFzQ29udHJvbHMnPlxuICAgICAgICA8ZGl2IGJlbT0nZTpkaW1lbnNpb25zJz57YCR7ZGltZW5zaW9ucy54fXgke2RpbWVuc2lvbnMueX1gfTwvZGl2PlxuICAgICAgPC9kaXY+KVxuICAgIH1cblxuICAgIHJldHVybiAoPGRpdiBiZW09J2I6Y2FudmFzQ29udHJvbHMgZTpjb250YWluZXIgbTpmdWxsJyByZWY9J2NvbnRhaW5lcic+XG4gICAgICB7Y2FudmFzQ29udGVudH1cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuQ3JvcENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9jcm9wL2Nyb3AtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMsIFNES1V0aWxzLCBVdGlscywgUmVhY3RCRU0sIFZlY3RvcjIgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBTY3JvbGxiYXJDb21wb25lbnQgZnJvbSAnLi4vLi4vc2Nyb2xsYmFyLWNvbXBvbmVudCdcbmltcG9ydCBTbGlkZXJPdmVybGF5Q29tcG9uZW50IGZyb20gJy4uL3NsaWRlci1vdmVybGF5LWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3JvcENvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19zZWxlY3RSYXRpbycsXG4gICAgICAnX29uUm90YXRpb25DaGFuZ2UnLFxuICAgICAgJ19yZWFwcGx5UmF0aW8nXG4gICAgKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHsgcmF0aW86IG51bGwgfVxuICAgIHRoaXMuX3JhdGlvcyA9IHRoaXMuY29uc3RydWN0b3IuZ2V0UmF0aW9zKHRoaXMucHJvcHMub3B0aW9ucylcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLkNST1BfUkVBUFBMWV9SQVRJT106IHRoaXMuX3JlYXBwbHlSYXRpb1xuICAgIH1cblxuICAgIHRoaXMuX3NlbGVjdEluaXRpYWxSYXRpbyghdGhpcy5nZXRTaGFyZWRTdGF0ZSgnY3JvcE9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUnKSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIElOSVRJQUxJWkFUSU9OXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBhdmFpbGFibGUgcmF0aW9zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgKi9cbiAgc3RhdGljIGdldFJhdGlvcyAob3B0aW9ucykge1xuICAgIGxldCB7IHJhdGlvcywgcmVwbGFjZVJhdGlvcywgc2VsZWN0YWJsZVJhdGlvcyB9ID0gb3B0aW9uc1xuICAgIHJhdGlvcyA9IHJhdGlvcyB8fCBbXVxuXG4gICAgbGV0IGF2YWlsYWJsZVJhdGlvc1xuICAgIGF2YWlsYWJsZVJhdGlvcyA9IENvbnN0YW50cy5ERUZBVUxUUy5DUk9QX1JBVElPU1xuICAgIGlmIChyZXBsYWNlUmF0aW9zKSB7XG4gICAgICBhdmFpbGFibGVSYXRpb3MgPSByYXRpb3NcbiAgICB9IGVsc2Uge1xuICAgICAgYXZhaWxhYmxlUmF0aW9zID0gYXZhaWxhYmxlUmF0aW9zLmNvbmNhdChyYXRpb3MpXG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGFibGVSYXRpb3MgJiYgc2VsZWN0YWJsZVJhdGlvcy5sZW5ndGgpIHtcbiAgICAgIGF2YWlsYWJsZVJhdGlvcyA9IFV0aWxzLnNlbGVjdChhdmFpbGFibGVSYXRpb3MsIHNlbGVjdGFibGVSYXRpb3MsIChyKSA9PiByLm5hbWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGF2YWlsYWJsZVJhdGlvc1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBjaGFuZ2UgZnJvbSB0aGUgZ2l2ZW4gc3RhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvbGRTdGF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5ld1N0YXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzaG91bGRTaGFyZWRDb21wb25lbnRVcGRhdGUgKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgIHJldHVybiBvbGRTdGF0ZS5yYXRpbyAhPT0gbmV3U3RhdGUucmF0aW9cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSByb3RhdGlvbiBoYXMgYmVlbiBjaGFnbmVkIChieSB1c2luZyB0aGUgc2xpZGVyKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Sb3RhdGlvbkNoYW5nZSAocm90YXRpb24pIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgcm90YXRpb24gPSByb3RhdGlvbiAqIE1hdGguUEkgLyAxODBcbiAgICBlZGl0b3Iuc2V0Um90YXRpb24ocm90YXRpb24pXG5cbiAgICAvLyBVcGRhdGUgc3ByaXRlIHNjYWxlXG4gICAgdGhpcy5fdXBkYXRlU3ByaXRlU2NhbGUoKVxuXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IHJvdGF0aW9uIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3ByaXRlIHNjYWxlIHNvIHRoYXQgdGhlIGNyb3BwZWQgYXJlYSBmaXRzXG4gICAqIGluc2lkZSB0aGUgc3ByaXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3ByaXRlU2NhbGUgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCByb3RhdGVkU3ByaXRlRGltZW5zaW9ucyA9IHRoaXMuX2dldFJvdGF0ZWRTcHJpdGVEaW1lbnNpb25zKClcbiAgICBjb25zdCBkaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoZmFsc2UpXG5cbiAgICBjb25zdCBkaXN0YW5jZVRvQ29ybmVyID0gZGltZW5zaW9ucy5jbG9uZSgpLm11bHRpcGx5KDAuNSlcbiAgICBkaXN0YW5jZVRvQ29ybmVyLnN1YnRyYWN0KHJvdGF0ZWRTcHJpdGVEaW1lbnNpb25zLmNsb25lKCkuZGl2aWRlKDIpKVxuICAgIGRpc3RhbmNlVG9Db3JuZXIuYWJzKClcblxuICAgIGxldCBzY2FsZSA9IDFcbiAgICBpZiAoZGlzdGFuY2VUb0Nvcm5lci55ID4gZGlzdGFuY2VUb0Nvcm5lci54KSB7XG4gICAgICBzY2FsZSA9IChkaXN0YW5jZVRvQ29ybmVyLnkgKiAyIC8gZGltZW5zaW9ucy55KSArIDFcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSAoZGlzdGFuY2VUb0Nvcm5lci54ICogMiAvIGRpbWVuc2lvbnMueCkgKyAxXG4gICAgfVxuICAgIGVkaXRvci5zZXRTcHJpdGVTY2FsZShzY2FsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBvdXRlciBib3VuZGluZyBkaW1lbnNpb25zIG9mIHRoZSByb3RhdGVkIHNwcml0ZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Um90YXRlZFNwcml0ZURpbWVuc2lvbnMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCByb3RhdGlvbiA9IGVkaXRvci5nZXRSb3RhdGlvbigpXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoZmFsc2UpXG5cbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoXG4gICAgICBNYXRoLmFicyhvdXRwdXREaW1lbnNpb25zLnggKiBNYXRoLmNvcyhyb3RhdGlvbikpICsgTWF0aC5hYnMob3V0cHV0RGltZW5zaW9ucy55ICogTWF0aC5zaW4ocm90YXRpb24pKSxcbiAgICAgIE1hdGguYWJzKG91dHB1dERpbWVuc2lvbnMueCAqIE1hdGguc2luKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhvdXRwdXREaW1lbnNpb25zLnkgKiBNYXRoLmNvcyhyb3RhdGlvbikpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHRleHR1cmUgc2NhbGUgdXNpbmcgdGhlIGN1cnJlbnQgc2V0dGluZ3NcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhbGN1bGF0ZVRleHR1cmVTY2FsZSAoKSB7XG4gICAgY29uc3QgY3JvcE9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgY29uc3QgcmF0aW8gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdyYXRpbycpXG4gICAgaWYgKCFyYXRpby5kaW1lbnNpb25zKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc3RhcnQnKVxuICAgIGNvbnN0IGVuZCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2VuZCcpXG5cbiAgICBjb25zdCBzaXplID0gZW5kLmNsb25lKCkuc3VidHJhY3Qoc3RhcnQpXG4gICAgY29uc3QgY3JvcERpbWVuc2lvbnMgPSBjcm9wT3BlcmF0aW9uLmdldElucHV0RGltZW5zaW9ucygpXG4gICAgICAubXVsdGlwbHkoc2l6ZSlcbiAgICByZXR1cm4gcmF0aW8uZGltZW5zaW9ucy54IC8gY3JvcERpbWVuc2lvbnMueFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRoZSBoaXN0b3J5IGl0ZW1zIGZvciBhbGwgb3BlcmF0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEhpc3RvcnlJdGVtcyAoKSB7XG4gICAgY29uc3QgaGlzdG9yeUl0ZW1zID0gW11cblxuICAgIGNvbnN0IGNyb3BIaXN0b3J5SXRlbSA9IHRoaXMuX2dldENyb3BIaXN0b3J5SXRlbSgpXG4gICAgaWYgKGNyb3BIaXN0b3J5SXRlbSkge1xuICAgICAgaGlzdG9yeUl0ZW1zLnB1c2goY3JvcEhpc3RvcnlJdGVtKVxuICAgIH1cblxuICAgIGNvbnN0IG9yaWVudGF0aW9uSGlzdG9yeUl0ZW0gPSB0aGlzLl9nZXRPcmllbnRhdGlvbkhpc3RvcnlJdGVtKClcbiAgICBpZiAob3JpZW50YXRpb25IaXN0b3J5SXRlbSkge1xuICAgICAgaGlzdG9yeUl0ZW1zLnB1c2gob3JpZW50YXRpb25IaXN0b3J5SXRlbSlcbiAgICB9XG5cbiAgICByZXR1cm4gaGlzdG9yeUl0ZW1zXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBpdGVtIGZvciB0aGUgY3JvcCBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDcm9wSGlzdG9yeUl0ZW0gKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBjcm9wT3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCBpbml0aWFsQ3JvcE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbml0aWFsQ3JvcE9wdGlvbnMnKVxuICAgIGNvbnN0IGNyb3BPcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnY3JvcE9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUnKVxuICAgIGlmICghY3JvcE9wZXJhdGlvbi5vcHRpb25zRXF1YWwoaW5pdGlhbENyb3BPcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BlcmF0aW9uOiBjcm9wT3BlcmF0aW9uLFxuICAgICAgICBvcHRpb25zOiBpbml0aWFsQ3JvcE9wdGlvbnMsXG4gICAgICAgIGV4aXN0ZW50OiBjcm9wT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSxcbiAgICAgICAgdW5kbzogKG9wZXJhdGlvbiwgbmV3T3B0aW9ucykgPT4ge1xuICAgICAgICAgIGVkaXRvci5icm9hZGNhc3RDcm9wKG9wZXJhdGlvbiwgbmV3T3B0aW9ucylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaXN0b3J5IGl0ZW0gZm9yIHRoZSBvcmllbnRhdGlvbiBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRPcmllbnRhdGlvbkhpc3RvcnlJdGVtICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3JpZW50YXRpb25PcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcmllbnRhdGlvbk9wZXJhdGlvbicpXG4gICAgY29uc3QgaW5pdGlhbE9yaWVudGF0aW9uT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2luaXRpYWxPcmllbnRhdGlvbk9wdGlvbnMnKVxuICAgIGNvbnN0IG9yaWVudGF0aW9uT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29yaWVudGF0aW9uT3BlcmF0aW9uRXhpc3RlZEJlZm9yZScpXG4gICAgaWYgKCFvcmllbnRhdGlvbk9wZXJhdGlvbi5vcHRpb25zRXF1YWwoaW5pdGlhbE9yaWVudGF0aW9uT3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wZXJhdGlvbjogb3JpZW50YXRpb25PcGVyYXRpb24sXG4gICAgICAgIG9wdGlvbnM6IGluaXRpYWxPcmllbnRhdGlvbk9wdGlvbnMsXG4gICAgICAgIGV4aXN0ZW50OiBvcmllbnRhdGlvbk9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUsXG4gICAgICAgIHVuZG86IChvcGVyYXRpb24sIG5ld09wdGlvbnMpID0+IHtcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLmdldFJvdGF0aW9uKCkgIT09IG5ld09wdGlvbnMucm90YXRpb24pIHtcbiAgICAgICAgICAgIGVkaXRvci5icm9hZGNhc3RSb3RhdGUobmV3T3B0aW9ucy5yb3RhdGlvbiAtIG9wZXJhdGlvbi5nZXRSb3RhdGlvbigpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJvdGF0aW9uID0gbmV3T3B0aW9ucy5yb3RhdGlvblxuICAgICAgICAgIGNvbnN0IGludmVyc2VGbGlwID0gcm90YXRpb24gPT09IDkwIHx8IHJvdGF0aW9uID09PSAyNzBcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLmdldEZsaXBWZXJ0aWNhbGx5KCkgIT09IG5ld09wdGlvbnMuZmxpcFZlcnRpY2FsbHkpIHtcbiAgICAgICAgICAgIGVkaXRvci5icm9hZGNhc3RGbGlwKGludmVyc2VGbGlwID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJylcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5nZXRGbGlwSG9yaXpvbnRhbGx5KCkgIT09IG5ld09wdGlvbnMuZmxpcEhvcml6b250YWxseSkge1xuICAgICAgICAgICAgZWRpdG9yLmJyb2FkY2FzdEZsaXAoaW52ZXJzZUZsaXAgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZS1hcHBsaWVzIHRoZSBjdXJyZW50IHJhdGlvXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVhcHBseVJhdGlvICgpIHtcbiAgICBjb25zdCByYXRpbyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3JhdGlvJylcbiAgICB0aGlzLl9zZWxlY3RSYXRpbyhyYXRpbylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja0NsaWNrIChlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgY29uc3QgcmF0aW8gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdyYXRpbycpXG4gICAgY29uc3QgY3JvcE9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgY29uc3Qgb3JpZW50YXRpb25PcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcmllbnRhdGlvbk9wZXJhdGlvbicpXG5cbiAgICBjb25zdCByb3RhdGlvbiA9IGVkaXRvci5nZXRSb3RhdGlvbigpXG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzdGFydCcpXG4gICAgY29uc3QgZW5kID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJylcbiAgICBpZiAoKHJhdGlvID09PSBudWxsIHx8IChzdGFydC5lcXVhbHMoMCwgMCkgJiYgZW5kLmVxdWFscygxLCAxKSkpICYmIHJvdGF0aW9uID09PSAwKSB7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5yZW1vdmUoY3JvcE9wZXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRleHR1cmUgc2NhbGVcbiAgICAgIGxldCB0ZXh0dXJlU2NhbGUgPSB0aGlzLl9jYWxjdWxhdGVUZXh0dXJlU2NhbGUoKVxuXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgc2NhbGU6IGVkaXRvci5nZXRTcHJpdGVTY2FsZSgpLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICB0ZXh0dXJlU2NhbGUsXG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgIH1cblxuICAgICAgZWRpdG9yLmJyb2FkY2FzdENyb3AoY3JvcE9wZXJhdGlvbiwgb3B0aW9ucylcbiAgICAgIGNyb3BPcGVyYXRpb24uc2V0KG9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKG9yaWVudGF0aW9uT3BlcmF0aW9uLmdldFJvdGF0aW9uKCkgPT09IDAgJiZcbiAgICAgICAgIW9yaWVudGF0aW9uT3BlcmF0aW9uLmdldEZsaXBWZXJ0aWNhbGx5KCkgJiZcbiAgICAgICAgIW9yaWVudGF0aW9uT3BlcmF0aW9uLmdldEZsaXBIb3Jpem9udGFsbHkoKSkge1xuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMucmVtb3ZlKG9yaWVudGF0aW9uT3BlcmF0aW9uKVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGVkaXRvciB0cmFuc2Zvcm1zXG4gICAgZWRpdG9yLnNldFBhZGRpbmcoZmFsc2UpXG4gICAgZWRpdG9yLnNldFJvdGF0aW9uKDApXG4gICAgZWRpdG9yLnNldFNwcml0ZVNjYWxlKDEpXG5cbiAgICAvLyBIYW5kbGUgaGlzdG9yeVxuICAgIGNvbnN0IGhpc3RvcnlJdGVtcyA9IHRoaXMuX2dldEhpc3RvcnlJdGVtcygpXG4gICAgaWYgKGhpc3RvcnlJdGVtcy5sZW5ndGgpIHtcbiAgICAgIGVkaXRvci5oaXN0b3J5LmFkZChoaXN0b3J5SXRlbXMpXG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIHpvb20gYW5kIGRyYWcgYWdhaW4sIHJlc2V0IHpvb21cbiAgICBlZGl0b3IuZmVhdHVyZXMuZW5hYmxlKCd6b29tJywgJ2RyYWcnKVxuICAgIGVkaXRvci56b29tLnVuZG8oKVxuXG4gICAgc3VwZXIuX29uQmFja0NsaWNrKGUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSQVRJTyBIQU5ETElOR1xuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSBpbml0aWFsIHJhdGlvXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2V0RGVmYXVsdE9wdGlvbnMgPSB0cnVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VsZWN0SW5pdGlhbFJhdGlvIChzZXREZWZhdWx0T3B0aW9ucyA9IHRydWUpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGxldCBzZWxlY3RlZFJhdGlvID0gbnVsbFxuICAgIGNvbnN0IHJhdGlvcyA9IFNES1V0aWxzLmZsYXR0ZW4odGhpcy5fcmF0aW9zKVxuXG4gICAgLy8gMS4gU2VsZWN0ZWQgcmF0aW8gc3RvcmVkIGluIG9wZXJhdGlvblxuICAgIGNvbnN0IG9wZXJhdGlvblJhdGlvID0gb3BlcmF0aW9uLl9yYXRpb1xuICAgIGlmIChvcGVyYXRpb25SYXRpbykge1xuICAgICAgY29uc3QgbWF0Y2hpbmdSYXRpb3MgPSByYXRpb3MuZmlsdGVyKChyYXRpbykgPT4gcmF0aW8gPT09IG9wZXJhdGlvblJhdGlvKVxuICAgICAgc2VsZWN0ZWRSYXRpbyA9IG1hdGNoaW5nUmF0aW9zWzBdXG4gICAgfVxuXG4gICAgLy8gMi4gRmlyc3QgcmF0aW8gd2l0aCBgc2VsZWN0ZWRgIGZsYWdcbiAgICBpZiAoIXNlbGVjdGVkUmF0aW8pIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkUmF0aW9zID0gcmF0aW9zLmZpbHRlcigocmF0aW8pID0+IHJhdGlvLnNlbGVjdGVkKVxuICAgICAgc2VsZWN0ZWRSYXRpbyA9IHNlbGVjdGVkUmF0aW9zLnBvcCgpXG4gICAgfVxuXG4gICAgLy8gMy4gRmlyc3QgcmF0aW9cbiAgICBpZiAoIXNlbGVjdGVkUmF0aW8pIHtcbiAgICAgIHNlbGVjdGVkUmF0aW8gPSByYXRpb3NbMF1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0UmF0aW8oc2VsZWN0ZWRSYXRpbywgc2V0RGVmYXVsdE9wdGlvbnMsIGZhbHNlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgdGhlIGdpdmVuIHJhdGlvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByYXRpb1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldERlZmF1bHRPcHRpb25zID0gdHJ1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZSA9IHRydWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZWxlY3RSYXRpbyAocmF0aW8sIHNldERlZmF1bHRPcHRpb25zID0gdHJ1ZSwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgaWYgKHNldERlZmF1bHRPcHRpb25zICYmIHJhdGlvKSB7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0T3B0aW9uc0ZvclJhdGlvKHJhdGlvLCB1cGRhdGUpXG4gICAgfVxuICAgIG9wZXJhdGlvbi5fcmF0aW8gPSByYXRpb1xuXG4gICAgY29uc3QgbmV3U2hhcmVkU3RhdGUgPSB7XG4gICAgICByYXRpb1xuICAgIH1cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgaWYgKCFyYXRpbykge1xuICAgICAgZWRpdG9yLnNldFBhZGRpbmcoZmFsc2UpXG4gICAgICBlZGl0b3Iuc2V0Um90YXRpb24oMClcbiAgICAgIGVkaXRvci5zZXRTcHJpdGVTY2FsZSgxKVxuXG4gICAgICBuZXdTaGFyZWRTdGF0ZS5yb3RhdGlvbiA9IDBcbiAgICAgIG5ld1NoYXJlZFN0YXRlLnN0YXJ0ID0gbmV3IFZlY3RvcjIoMCwgMClcbiAgICAgIG5ld1NoYXJlZFN0YXRlLmVuZCA9IG5ldyBWZWN0b3IyKDEsIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5zZXRQYWRkaW5nKHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2FjdGl2ZVBhZGRpbmcnKSlcbiAgICB9XG4gICAgZWRpdG9yLnJlbmRlcigpXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZShuZXdTaGFyZWRTdGF0ZSwgdXBkYXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucyAoc3RhcnQgLyBlbmQpIGZvciB0aGUgZ2l2ZW4gcmF0aW9cbiAgICogQHBhcmFtIHtPYmplY3R9IHJhdGlvXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXREZWZhdWx0T3B0aW9uc0ZvclJhdGlvICh7IHJhdGlvLCBuYW1lLCBkaW1lbnNpb25zIH0sIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCBzdGFydCA9IG5ldyBWZWN0b3IyKClcbiAgICBsZXQgZW5kID0gbmV3IFZlY3RvcjIoKVxuXG4gICAgaWYgKGRpbWVuc2lvbnMgJiYgIXJhdGlvKSB7XG4gICAgICByYXRpbyA9IGRpbWVuc2lvbnMueCAvIGRpbWVuc2lvbnMueVxuICAgIH1cblxuICAgIGlmIChyYXRpbyA9PT0gJyonKSB7XG4gICAgICBzdGFydCA9IG5ldyBWZWN0b3IyKDAsIDApXG4gICAgICBlbmQgPSBuZXcgVmVjdG9yMigxLCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgICAgY29uc3QgY2FudmFzUmF0aW8gPSBvdXRwdXREaW1lbnNpb25zLnggLyBvdXRwdXREaW1lbnNpb25zLnlcbiAgICAgIGlmIChjYW52YXNSYXRpbyA8PSByYXRpbykge1xuICAgICAgICBjb25zdCBoZWlnaHQgPSAxIC8gb3V0cHV0RGltZW5zaW9ucy55ICogKG91dHB1dERpbWVuc2lvbnMueCAvIHJhdGlvKVxuICAgICAgICBzdGFydC5zZXQoMCwgKDEuMCAtIGhlaWdodCkgLyAyKVxuICAgICAgICBlbmQuc2V0KDEuMCwgMSAtIHN0YXJ0LnkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IDEgLyBvdXRwdXREaW1lbnNpb25zLnggKiAocmF0aW8gKiBvdXRwdXREaW1lbnNpb25zLnkpXG4gICAgICAgIHN0YXJ0LnNldCgoMSAtIHdpZHRoKSAvIDIsIDApXG4gICAgICAgIGVuZC5zZXQoMSAtIHN0YXJ0LngsIDEuMClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgc3RhcnQsIGVuZCB9LCB1cGRhdGUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb3ZlcmxheSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyT3ZlcmxheUNvbnRyb2xzICgpIHtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3JvdGF0aW9uJykgKiAxODAgLyBNYXRoLlBJXG4gICAgaWYgKCF0aGlzLmdldFNoYXJlZFN0YXRlKCdyYXRpbycpKSByZXR1cm4gbnVsbFxuICAgIHJldHVybiAoPFNsaWRlck92ZXJsYXlDb21wb25lbnRcbiAgICAgIHZhbHVlPXtyb3RhdGlvbn1cbiAgICAgIG1pblZhbHVlPXstNDV9XG4gICAgICBtaWRkbGVEb3RcbiAgICAgIG1heFZhbHVlPXs0NX1cbiAgICAgIHZhbHVlVW5pdD0nwrAnXG4gICAgICBsYWJlbD17dGhpcy5fdCgnY29udHJvbHMuY3JvcC5yb3RhdGlvbicpfVxuICAgICAgb25DaGFuZ2U9e3RoaXMuX29uUm90YXRpb25DaGFuZ2V9IC8+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGxpc3QgaXRlbXMgZm9yIHRoaXMgY29udHJvbHNcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudFtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckxpc3RJdGVtcyAoKSB7XG4gICAgbGV0IGl0ZW1zID0gW11cbiAgICBjb25zdCBtYWtlSXRlbSA9IChyYXRpbykgPT4ge1xuICAgICAgcmV0dXJuICg8bGlcbiAgICAgICAgYmVtPSdlOml0ZW0nXG4gICAgICAgIGtleT17cmF0aW8ubmFtZX1cbiAgICAgICAgZGF0YS1pZGVudGlmaWVyPXtyYXRpby5uYW1lfT5cbiAgICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgICA8ZGl2IGJlbT0nJGU6YnV0dG9uIG06d2l0aExhYmVsJ1xuICAgICAgICAgICAgY2xhc3NOYW1lPXt0aGlzLmdldFNoYXJlZFN0YXRlKCdyYXRpbycpID09PSByYXRpbyA/ICdpcy1hY3RpdmUnIDogbnVsbH1cbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX3NlbGVjdFJhdGlvLmJpbmQodGhpcywgcmF0aW8pfT5cbiAgICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKGBjb250cm9scy9jcm9wLyR7cmF0aW8ubmFtZX0ucG5nYCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoYGNvbnRyb2xzLmNyb3AuJHtyYXRpby5uYW1lfWApfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2JlbT5cbiAgICAgIDwvbGk+KVxuICAgIH1cblxuICAgIHRoaXMuX3JhdGlvcy5mb3JFYWNoKChncm91cE9yUmF0aW8pID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyb3VwT3JSYXRpbykpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cE9yUmF0aW9cblxuICAgICAgICBsZXQgZ3JvdXBJdGVtcyA9IFtdXG4gICAgICAgIGdyb3VwLmZvckVhY2goKHJhdGlvKSA9PiB7XG4gICAgICAgICAgZ3JvdXBJdGVtcy5wdXNoKG1ha2VJdGVtKHJhdGlvKSlcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZ3JvdXBJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGdyb3VwSXRlbXMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gZ3JvdXBPclJhdGlvXG4gICAgICAgIGl0ZW1zLnB1c2gobWFrZUl0ZW0ocmF0aW8pKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBsZXQgZmluYWxJdGVtcyA9IFtdXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbU9yR3JvdXApID0+IHtcbiAgICAgIGZpbmFsSXRlbXMgPSBmaW5hbEl0ZW1zLmNvbmNhdChpdGVtT3JHcm91cClcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1Pckdyb3VwKSAmJiBpdGVtT3JHcm91cCAhPT0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgZmluYWxJdGVtcy5wdXNoKDxsaSBiZW09J2U6c2VwYXJhdG9yJyAvPilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3Qgbm9Dcm9wSXRlbSA9ICg8bGlcbiAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAgZGF0YS1pZGVudGlmaWVyPSdub25lJ1xuICAgICAga2V5PSdub0Nyb3AnPlxuICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgPGRpdiBiZW09JyRlOmJ1dHRvbiBtOndpdGhMYWJlbCdcbiAgICAgICAgICBjbGFzc05hbWU9eyF0aGlzLmdldFNoYXJlZFN0YXRlKCdyYXRpbycpID8gJ2lzLWFjdGl2ZScgOiBudWxsfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX3NlbGVjdFJhdGlvLmJpbmQodGhpcywgbnVsbCl9PlxuICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKGBjb250cm9scy9jcm9wL25vbmUucG5nYCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLl90KGBjb250cm9scy5jcm9wLm5vbmVgKX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcblxuICAgIHJldHVybiBbbm9Dcm9wSXRlbSwgPGxpIGJlbT0nZTpzZXBhcmF0b3InIC8+XS5jb25jYXQoZmluYWxJdGVtcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udHJvbHMgKCkge1xuICAgIGNvbnN0IGxpc3RJdGVtcyA9IHRoaXMuX3JlbmRlckxpc3RJdGVtcygpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmxpc3QnPlxuICAgICAgICA8U2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgICAgICAgIDx1bCBiZW09JyRlOmxpc3QnPlxuICAgICAgICAgICAge2xpc3RJdGVtc31cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L1Njcm9sbGJhckNvbXBvbmVudD5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5Dcm9wQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2Nyb3AvY3JvcC1jb250cm9scy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgVG9wQmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3NoYXJlZC90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDcm9wVG9wQmFyQ29tcG9uZW50IGV4dGVuZHMgVG9wQmFyQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uZSBvZiB0aGUgcm90YXRlIGJ1dHRvbnNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblJvdGF0ZUNsaWNrIChkaXJlY3Rpb24pIHtcbiAgICBsZXQgZGVncmVlc1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICdjdycpIHtcbiAgICAgIGRlZ3JlZXMgPSA5MFxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2N3Jykge1xuICAgICAgZGVncmVlcyA9IC05MFxuICAgIH1cblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcmllbnRhdGlvbk9wZXJhdGlvbicpXG4gICAgY29uc3QgbmV3Um90YXRpb24gPSAob3BlcmF0aW9uLmdldFJvdGF0aW9uKCkgKyBkZWdyZWVzKSAlIDM2MFxuXG4gICAgb3BlcmF0aW9uLnNldCh7IHJvdGF0aW9uOiBuZXdSb3RhdGlvbiB9KVxuXG4gICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgb3JpZW50YXRpb25Sb3RhdGlvbjogbmV3Um90YXRpb25cbiAgICB9XG5cbiAgICBjb25zdCByYXRpbyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3JhdGlvJylcbiAgICBpZiAoIXJhdGlvLmRpbWVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc3RhcnQnKVxuICAgICAgY29uc3QgZW5kID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZW5kJylcbiAgICAgIGNvbnN0IHRlbXBTdGFydCA9IHN0YXJ0LmNsb25lKClcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdjdycpIHtcbiAgICAgICAgc3RhcnQuc2V0KDEuMCAtIGVuZC55LCB0ZW1wU3RhcnQueClcbiAgICAgICAgZW5kLnNldCgxLjAgLSB0ZW1wU3RhcnQueSwgZW5kLngpXG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NjdycpIHtcbiAgICAgICAgc3RhcnQuc2V0KHRlbXBTdGFydC55LCAxLjAgLSBlbmQueClcbiAgICAgICAgZW5kLnNldChlbmQueSwgMS4wIC0gdGVtcFN0YXJ0LngpXG4gICAgICB9XG4gICAgICBuZXdTdGF0ZS5zdGFydCA9IHN0YXJ0XG4gICAgICBuZXdTdGF0ZS5lbmQgPSBlbmRcbiAgICB9XG5cbiAgICBpZiAocmF0aW8uZGltZW5zaW9ucykge1xuICAgICAgdGhpcy5fZW1pdEV2ZW50KENvbnN0YW50cy5FVkVOVFMuQ1JPUF9SRUFQUExZX1JBVElPKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUobmV3U3RhdGUpXG5cbiAgICBlZGl0b3IuYnJvYWRjYXN0Um90YXRlKGRlZ3JlZXMpXG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbmUgb2YgdGhlIGZsaXAgYnV0dG9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRmxpcENsaWNrIChkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3JpZW50YXRpb25PcGVyYXRpb24nKVxuXG4gICAgY29uc3QgbmV3RmxpcCA9ICF0aGlzLmdldFNoYXJlZFN0YXRlKGBmbGlwJHtkaXJlY3Rpb259YClcbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3JvdGF0aW9uJykgKiAtMVxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgW2BmbGlwJHtkaXJlY3Rpb259YF06IG5ld0ZsaXAsXG4gICAgICByb3RhdGlvbjogbmV3Um90YXRpb25cbiAgICB9KVxuICAgIGVkaXRvci5zZXRSb3RhdGlvbihuZXdSb3RhdGlvbilcbiAgICBvcGVyYXRpb24uZmxpcChkaXJlY3Rpb24pXG5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3N0YXJ0JylcbiAgICBjb25zdCBlbmQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdlbmQnKVxuICAgIGNvbnN0IHRtcFN0YXJ0ID0gc3RhcnQuY2xvbmUoKVxuICAgIGlmIChkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgc3RhcnQuc2V0KDEuMCAtIGVuZC54LCBzdGFydC55KVxuICAgICAgZW5kLnNldCgxLjAgLSB0bXBTdGFydC54LCBlbmQueSlcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgc3RhcnQuc2V0KHN0YXJ0LngsIDEuMCAtIGVuZC55KVxuICAgICAgZW5kLnNldChlbmQueCwgMS4wIC0gdG1wU3RhcnQueSlcbiAgICB9XG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgc3RhcnQsIGVuZCB9KVxuXG4gICAgZWRpdG9yLmJyb2FkY2FzdEZsaXAoZGlyZWN0aW9uKVxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBjaGFuZ2UgZnJvbSB0aGUgZ2l2ZW4gc3RhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvbGRTdGF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5ld1N0YXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzaG91bGRTaGFyZWRDb21wb25lbnRVcGRhdGUgKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRlbnQgb2YgdGhpcyBPdmVydmlld1RvcEJhckNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udGVudCAoKSB7XG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nJGI6dG9wQmFyJz5cbiAgICAgIDxkaXYgYmVtPSckZTppY29uQnV0dG9uJyBvbkNsaWNrPXt0aGlzLl9vbkZsaXBDbGljay5iaW5kKHRoaXMsICd2ZXJ0aWNhbCcpfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL2Nyb3AvZmxpcC12LnBuZycsIHRydWUpfSAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGJlbT0nJGU6aWNvbkJ1dHRvbicgb25DbGljaz17dGhpcy5fb25GbGlwQ2xpY2suYmluZCh0aGlzLCAnaG9yaXpvbnRhbCcpfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL2Nyb3AvZmxpcC1oLnBuZycsIHRydWUpfSAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGJlbT0nZTpzcGFjZScgLz5cbiAgICAgIDxkaXYgYmVtPSckZTppY29uQnV0dG9uJyBvbkNsaWNrPXt0aGlzLl9vblJvdGF0ZUNsaWNrLmJpbmQodGhpcywgJ2NjdycpfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL2Nyb3Avcm90YXRlLWNjdy5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBiZW09JyRlOmljb25CdXR0b24nIG9uQ2xpY2s9e3RoaXMuX29uUm90YXRlQ2xpY2suYmluZCh0aGlzLCAnY3cnKX0+XG4gICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9jcm9wL3JvdGF0ZS1jdy5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5Dcm9wVG9wQmFyQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IFRvcEJhckNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvY3JvcC9jcm9wLXRvcC1iYXItY29tcG9uZW50LmpzeCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLVXRpbHMsIFZlY3RvcjIgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uL2NvbnRyb2xzJ1xuaW1wb3J0IENyb3BDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL2Nyb3AtY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IENyb3BDYW52YXNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL2Nyb3AtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBDcm9wVG9wQmFyQ29tcG9uZW50IGZyb20gJy4vY3JvcC10b3AtYmFyLWNvbXBvbmVudCdcblxuLyoqXG4gKiBUaGUgY3JvcCBjb250cm9sc1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzXG4gKi9cbmNsYXNzIENyb3BDb250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZW50ZXJzIHRoZXNlIGNvbnRyb2xzXG4gICAqIEB0aGlzIHtDcm9wQ29udHJvbHNDb21wb25lbnR9XG4gICAqIEBwYXJhbSB7U2hhcmVkU3RhdGV9IHNoYXJlZFN0YXRlXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgb25FbnRlciAoc2hhcmVkU3RhdGUpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG5cbiAgICBjb25zdCBjcm9wT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSA9IGVkaXRvci5vcGVyYXRpb25zLmV4aXN0cygnY3JvcCcpXG4gICAgY29uc3QgY3JvcE9wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdjcm9wJylcbiAgICBjcm9wT3BlcmF0aW9uLnNldEVuYWJsZWQoZmFsc2UsIGZhbHNlKVxuXG4gICAgY29uc3Qgb3JpZW50YXRpb25PcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gZWRpdG9yLm9wZXJhdGlvbnMuZXhpc3RzKCdvcmllbnRhdGlvbicpXG4gICAgY29uc3Qgb3JpZW50YXRpb25PcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnb3JpZW50YXRpb24nKVxuXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmQ6IG5ldyBWZWN0b3IyKDEsIDEpLFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICBzdGFydDogbmV3IFZlY3RvcjIoMCwgMCksXG4gICAgICBzY2FsZTogMSxcbiAgICAgIHRleHR1cmVTY2FsZTogMVxuICAgIH1cblxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGNyb3BPcGVyYXRpb24uZ2V0SW5wdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBpbml0aWFsRGltZW5zaW9ucyA9IGNyb3BPcGVyYXRpb24uZ2V0TmV3RGltZW5zaW9ucyhpbnB1dERpbWVuc2lvbnMpXG5cbiAgICBsZXQgaW5pdGlhbENyb3BPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNcbiAgICBpZiAoY3JvcE9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUpIHtcbiAgICAgIGluaXRpYWxDcm9wT3B0aW9ucyA9IGNyb3BPcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucygpXG4gICAgICBkZWxldGUgaW5pdGlhbENyb3BPcHRpb25zLmVuYWJsZWRcbiAgICB9XG5cbiAgICBlZGl0b3IuYnJvYWRjYXN0Q3JvcChjcm9wT3BlcmF0aW9uLCBkZWZhdWx0T3B0aW9ucylcblxuICAgIC8vIFJlc2V0IHN0YXJ0IGFuZCBlbmQgc28gdGhhdCBTcHJpdGVPcGVyYXRpb24gZ2V0cyBhbiB1cGRhdGUgYW5kIHJlcG9zaXRpb25zXG4gICAgLy8gdGhlIHN0aWNrZXJzXG4gICAgY3JvcE9wZXJhdGlvbi5zZXQoZGVmYXVsdE9wdGlvbnMsIGNyb3BPcGVyYXRpb25FeGlzdGVkQmVmb3JlKVxuXG4gICAgY29uc3QgaW5pdGlhbE9yaWVudGF0aW9uT3B0aW9ucyA9IG9yaWVudGF0aW9uT3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoKVxuICAgIGRlbGV0ZSBpbml0aWFsT3JpZW50YXRpb25PcHRpb25zLmVuYWJsZWRcblxuICAgIGNvbnN0IGFjdGl2ZVBhZGRpbmcgPSBbMTAsIDAsIDU4ICsgMTAsIDBdXG4gICAgZWRpdG9yLnNldFNwcml0ZVNjYWxlKGluaXRpYWxDcm9wT3B0aW9ucy5zY2FsZSlcbiAgICBlZGl0b3Iuc2V0Um90YXRpb24oaW5pdGlhbENyb3BPcHRpb25zLnJvdGF0aW9uKVxuICAgIGVkaXRvci5zZXRQYWRkaW5nKGFjdGl2ZVBhZGRpbmcpXG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJywgKCkgPT4ge1xuICAgICAgLy8gRGlzYWJsZSB6b29tIGFuZCBkcmFnIHdoaWxlIHdlJ3JlIGNyb3BwaW5nXG4gICAgICBlZGl0b3IuZmVhdHVyZXMuZGlzYWJsZSgnem9vbScsICdkcmFnJylcbiAgICB9LCBmYWxzZSlcblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgaW5pdGlhbENyb3BPcHRpb25zLFxuICAgICAgaW5pdGlhbE9yaWVudGF0aW9uT3B0aW9ucyxcbiAgICAgIG9wZXJhdGlvbjogY3JvcE9wZXJhdGlvbixcbiAgICAgIG9yaWVudGF0aW9uT3BlcmF0aW9uLFxuICAgICAgYWN0aXZlUGFkZGluZyxcbiAgICAgIG9yaWVudGF0aW9uT3BlcmF0aW9uRXhpc3RlZEJlZm9yZSxcbiAgICAgIGNyb3BPcGVyYXRpb25FeGlzdGVkQmVmb3JlLFxuICAgICAgc3RhcnQ6IFZlY3RvcjIuZnJvbU9iamVjdChpbml0aWFsQ3JvcE9wdGlvbnMuc3RhcnQpLFxuICAgICAgZW5kOiBWZWN0b3IyLmZyb21PYmplY3QoaW5pdGlhbENyb3BPcHRpb25zLmVuZCksXG4gICAgICByb3RhdGlvbjogaW5pdGlhbENyb3BPcHRpb25zLnJvdGF0aW9uLFxuICAgICAgb3JpZW50YXRpb25Sb3RhdGlvbjogb3JpZW50YXRpb25PcGVyYXRpb24uZ2V0Um90YXRpb24oKSxcbiAgICAgIGZsaXBWZXJ0aWNhbGx5OiBvcmllbnRhdGlvbk9wZXJhdGlvbi5nZXRGbGlwVmVydGljYWxseSgpLFxuICAgICAgZmxpcEhvcml6b250YWxseTogb3JpZW50YXRpb25PcGVyYXRpb24uZ2V0RmxpcEhvcml6b250YWxseSgpLFxuICAgICAgaW5pdGlhbERpbWVuc2lvbnMsXG4gICAgICBpbnB1dERpbWVuc2lvbnNcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGNvbnRyb2wgaXMgYXZhaWxhYmxlIHRvIHRoZSB1c2VyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRWRpdG9yfSBlZGl0b3JcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGlzQXZhaWxhYmxlIChlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ2Nyb3AnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFzc2V0cyB0aGF0IHNob3VsZCBiZSBwcmVsb2FkZWQgZm9yIHRoaXMgY29udHJvbFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge1N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIGdldFByZWxvYWRBc3NldHMgKGVkaXRvcikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBlZGl0b3IuZ2V0T3B0aW9ucygpXG4gICAgY29uc3QgY3JvcE9wdGlvbnMgPSBTREtVdGlscy5kZWZhdWx0cyhcbiAgICAgIG9wdGlvbnMuZWRpdG9yLmNvbnRyb2xzT3B0aW9ucy5jcm9wLFxuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9uc1xuICAgIClcblxuICAgIGxldCBhc3NldHMgPSBbXG4gICAgICAnY29udHJvbHMvY3JvcC9yb3RhdGUtY2N3LnBuZycsXG4gICAgICAnY29udHJvbHMvY3JvcC9yb3RhdGUtY3cucG5nJyxcbiAgICAgICdjb250cm9scy9jcm9wL2ZsaXAtaC5wbmcnLFxuICAgICAgJ2NvbnRyb2xzL2Nyb3AvZmxpcC12LnBuZydcbiAgICBdXG5cbiAgICAvLyBBZGQgcmF0aW9zXG4gICAgY29uc3QgcmF0aW9zID0gQ3JvcENvbnRyb2xzQ29tcG9uZW50LmdldFJhdGlvcyhjcm9wT3B0aW9ucylcbiAgICByYXRpb3MuZm9yRWFjaCgoaXRlbU9yR3JvdXApID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1Pckdyb3VwKSkge1xuICAgICAgICBpdGVtT3JHcm91cC5mb3JFYWNoKCh7bmFtZX0pID0+IHtcbiAgICAgICAgICBhc3NldHMucHVzaChgY29udHJvbHMvY3JvcC8ke25hbWV9LnBuZ2ApXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NldHMucHVzaChgY29udHJvbHMvY3JvcC8ke2l0ZW1Pckdyb3VwLm5hbWV9LnBuZ2ApXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBhc3NldHNcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIHRvcCBiYXIgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgdXBwZXIgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuVG9wQmFyQ29udHJvbHNDb21wb25lbnR9XG4gKi9cbkNyb3BDb250cm9scy50b3BCYXJDb250cm9sc0NvbXBvbmVudCA9IENyb3BUb3BCYXJDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjb250cm9scyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSBsb3dlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IuXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuQ3JvcENvbnRyb2xzLmNvbnRyb2xzQ29tcG9uZW50ID0gQ3JvcENvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbkNyb3BDb250cm9scy5jYW52YXNDb250cm9sc0NvbXBvbmVudCA9IENyb3BDYW52YXNDb250cm9sc0NvbXBvbmVudFxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Dcm9wQ29udHJvbHMuaWRlbnRpZmllciA9ICdjcm9wJ1xuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGljb24gcGF0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuQ3JvcENvbnRyb2xzLmljb25QYXRoID0gJ2NvbnRyb2xzL292ZXJ2aWV3L2Nyb3AucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkNyb3BDb250cm9scy5sYW5ndWFnZUtleSA9ICdjb250cm9scy5vdmVydmlldy5jcm9wJ1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgY29udHJvbFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IFtyYXRpb3MgPSBbXV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlcGxhY2VSYXRpb3MgPSBmYWxzZV1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IFthdmFpbGFibGVSYXRpb3MgPSBudWxsXVxuICovXG5Dcm9wQ29udHJvbHMuZGVmYXVsdE9wdGlvbnMgPSB7XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ3JvcENvbnRyb2xzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2Nyb3AvaW5kZXguanMiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBTREssIFJlYWN0QkVNLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBTY3JvbGxiYXJDb21wb25lbnQgZnJvbSAnLi4vLi4vc2Nyb2xsYmFyLWNvbXBvbmVudCdcbmltcG9ydCBDYXRlZ29yeURyb3Bkb3duQ29tcG9uZW50IGZyb20gJy4uLy4uL2NhdGVnb3J5LWRyb3Bkb3duL2NhdGVnb3J5LWRyb3Bkb3duLWNvbXBvbmVudCdcbmltcG9ydCBTbGlkZXJPdmVybGF5Q29tcG9uZW50IGZyb20gJy4uL3NsaWRlci1vdmVybGF5LWNvbXBvbmVudCdcbmltcG9ydCBGaWx0ZXJNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2xpYi9tYW5hZ2Vycy9maWx0ZXItbWFuYWdlcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsdGVyQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uSXRlbUNsaWNrJyxcbiAgICAgICdfb25PcGVyYXRpb25VcGRhdGVkJyxcbiAgICAgICdfb25TbGlkZXJWYWx1ZUNoYW5nZScsXG4gICAgICAnX29uQ2F0ZWdvcnlDaGFuZ2UnXG4gICAgKVxuICAgIHRoaXMuX29wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG5cbiAgICB0aGlzLl9ldmVudHMgPSB7XG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5PUEVSQVRJT05fVVBEQVRFRF06IHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlZFxuICAgIH1cblxuICAgIHRoaXMuX2luaXRGaWx0ZXJNYW5hZ2VyKClcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBjYXRlZ29yeTogJ2FsbCdcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBJTklUSUFMSVpBVElPTlxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZmlsdGVyIG1hbmFnZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0RmlsdGVyTWFuYWdlciAoKSB7XG4gICAgdGhpcy5fZmlsdGVyTWFuYWdlciA9IG5ldyBGaWx0ZXJNYW5hZ2VyKHRoaXMucHJvcHMub3B0aW9ucylcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBzbGlkZXIgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNsaWRlclZhbHVlQ2hhbmdlICh2YWx1ZSkge1xuICAgIHRoaXMuX29wZXJhdGlvbi5zZXRJbnRlbnNpdHkodmFsdWUgLyAxMDApXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzd2l0Y2hlcyB0aGUgY2F0ZWdvcnlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjYXRlZ29yeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2F0ZWdvcnlDaGFuZ2UgKGNhdGVnb3J5KSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGNhdGVnb3J5OiBjYXRlZ29yeS5uYW1lIH0sICgpID0+IHtcbiAgICAgIHRoaXMucmVmcy5zY3JvbGxiYXIudXBkYXRlKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHBhcmFtICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblVwZGF0ZWQgKG9wZXJhdGlvbikge1xuICAgIC8vIFRoZSB1bmRvIGJ1dHRvbiBtaWdodCBjaGFuZ2UgdGhpcyBvcGVyYXRpb24ncyBzZWxlY3RlZCBmaWx0ZXIgb3IgaW50ZW5zaXR5LlxuICAgIC8vIFVwZGF0ZSB0aGUgY29tcG9uZW50IHRvIHJlZmxlY3QgdGhlIGNoYW5nZVxuICAgIGlmIChvcGVyYXRpb24gPT09IHRoaXMuX29wZXJhdGlvbikge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGFuIGl0ZW1cbiAgICogQHBhcmFtIHtDbGFzc30gRmlsdGVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkl0ZW1DbGljayAoRmlsdGVyLCBlKSB7XG4gICAgdGhpcy5fb3BlcmF0aW9uLnNldCh7XG4gICAgICBmaWx0ZXI6IG5ldyBGaWx0ZXIoeyBpbnRlbnNpdHk6IDEgfSksXG4gICAgICBpbnRlbnNpdHk6IDFcbiAgICB9KVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci5yZW5kZXIoKVxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG92ZXJsYXkgY29udHJvbHMgb2YgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgY29uc3QgY3VycmVudEZpbHRlciA9IHRoaXMuX29wZXJhdGlvbi5nZXRGaWx0ZXIoKVxuICAgIGlmIChjdXJyZW50RmlsdGVyLmlzSWRlbnRpdHkpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBpbnRlbnNpdHkgPSB0aGlzLl9vcGVyYXRpb24uZ2V0SW50ZW5zaXR5KClcbiAgICByZXR1cm4gKDxTbGlkZXJPdmVybGF5Q29tcG9uZW50XG4gICAgICBtaW5WYWx1ZT17MH1cbiAgICAgIG1heFZhbHVlPXsxMDB9XG4gICAgICB2YWx1ZT17aW50ZW5zaXR5ICogMTAwfVxuICAgICAgdmFsdWVVbml0PSclJ1xuICAgICAgcG9zaXRpdmVWYWx1ZVByZWZpeD0nKydcbiAgICAgIGxhYmVsPXt0aGlzLl90KCdjb250cm9scy5maWx0ZXJzLmludGVuc2l0eScpfVxuICAgICAgb25DaGFuZ2U9e3RoaXMuX29uU2xpZGVyVmFsdWVDaGFuZ2V9IC8+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGxpc3QgaXRlbXMgZm9yIHRoaXMgY29udHJvbFxuICAgKiBAcmV0dXJuIHtBcnJheS48UmVhY3RCRU0uRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyTGlzdEl0ZW1zICgpIHtcbiAgICBjb25zdCBjdXJyZW50RmlsdGVyID0gdGhpcy5fb3BlcmF0aW9uLmdldEZpbHRlcigpXG5cbiAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5fZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJzRm9yQ2F0ZWdvcnkodGhpcy5zdGF0ZS5jYXRlZ29yeSlcbiAgICByZXR1cm4gW1NESy5GaWx0ZXJzLklkZW50aXR5RmlsdGVyXS5jb25jYXQoZmlsdGVycykubWFwKChmaWx0ZXIpID0+IHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBmaWx0ZXIuaWRlbnRpZmllclxuICAgICAgcmV0dXJuICg8bGlcbiAgICAgICAgYmVtPSdlOml0ZW0nXG4gICAgICAgIGtleT17aWRlbnRpZmllcn1cbiAgICAgICAgb25DbGljaz17dGhpcy5fb25JdGVtQ2xpY2suYmluZCh0aGlzLCBmaWx0ZXIpfT5cbiAgICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBiZW09JyRlOmJ1dHRvbiBtOndpdGhJbmxpbmVMYWJlbCc+XG4gICAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvZmlsdGVycy8ke2lkZW50aWZpZXJ9LnBuZ2AsIHRydWUpfSAvPlxuICAgICAgICAgICAgPGRpdiBiZW09JyRlOmlubGluZUxhYmVsJyBjbGFzc05hbWU9eyhjdXJyZW50RmlsdGVyIGluc3RhbmNlb2YgZmlsdGVyKSA/ICdpcy1hY3RpdmUnIDogbnVsbH0+XG4gICAgICAgICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57ZmlsdGVyLmRpc3BsYXlOYW1lfTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvYmVtPlxuICAgICAgPC9saT4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjYXRlZ29yeSBkcm9wZG93biAoaWYgcHJlc2VudClcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYXRlZ29yeURyb3Bkb3duICgpIHtcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gdGhpcy5fZmlsdGVyTWFuYWdlci5nZXRDYXRlZ29yaWVzKClcbiAgICBjb25zdCBjYXRlZ29yeURyb3Bkb3duVmlzaWJsZSA9XG4gICAgICAhdGhpcy5wcm9wcy5vcHRpb25zLmhpZGVDYXRlZ29yaWVzICYmXG4gICAgICBjYXRlZ29yaWVzLmxlbmd0aCA+IDFcbiAgICBpZiAoIWNhdGVnb3J5RHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IGNhdGVnb3J5SXRlbXMgPSBjYXRlZ29yaWVzLm1hcCgoYykgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogYy5uYW1lLFxuICAgICAgICBsYWJlbDogdGhpcy5fdChgY29udHJvbHMuZmlsdGVycy5jYXRlZ29yaWVzLiR7Yy5uYW1lfWApLFxuICAgICAgICBpY29uOiB0aGlzLl9nZXRBc3NldFBhdGgoYGNvbnRyb2xzL2ZpbHRlcnMvY2F0ZWdvcmllcy8ke2MubmFtZX0ucG5nYCwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIGNvbnN0IHNlbGVjdGVkQ2F0ZWdvcnkgPSB7XG4gICAgICBuYW1lOiB0aGlzLnN0YXRlLmNhdGVnb3J5LFxuICAgICAgbGFiZWw6IHRoaXMuX3QoYGNvbnRyb2xzLmZpbHRlcnMuY2F0ZWdvcmllcy4ke3RoaXMuc3RhdGUuY2F0ZWdvcnl9YCksXG4gICAgICBpY29uOiB0aGlzLl9nZXRBc3NldFBhdGgoYGNvbnRyb2xzL2ZpbHRlcnMvY2F0ZWdvcmllcy8ke3RoaXMuc3RhdGUuY2F0ZWdvcnl9LnBuZ2AsIHRydWUpXG4gICAgfVxuXG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nZTpjZWxsIG06Y2F0ZWdvcnlEcm9wZG93bic+XG4gICAgICA8Q2F0ZWdvcnlEcm9wZG93bkNvbXBvbmVudFxuICAgICAgICBpdGVtcz17Y2F0ZWdvcnlJdGVtc31cbiAgICAgICAgc2VsZWN0ZWRJdGVtPXtzZWxlY3RlZENhdGVnb3J5fVxuICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25DYXRlZ29yeUNoYW5nZX0gLz5cbiAgICA8L2Rpdj4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udHJvbHMgb2YgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlckNvbnRyb2xzICgpIHtcbiAgICBjb25zdCBsaXN0SXRlbXMgPSB0aGlzLl9yZW5kZXJMaXN0SXRlbXMoKVxuICAgIGNvbnN0IGNhdGVnb3J5RHJvcGRvd24gPSB0aGlzLl9yZW5kZXJDYXRlZ29yeURyb3Bkb3duKClcblxuICAgIHJldHVybiBbXG4gICAgICBjYXRlZ29yeURyb3Bkb3duLFxuICAgICAgKDxkaXYgYmVtPSdlOmNlbGwgbTpsaXN0Jz5cbiAgICAgICAgPFNjcm9sbGJhckNvbXBvbmVudCByZWY9J3Njcm9sbGJhcic+XG4gICAgICAgICAgPHVsIGJlbT0nJGU6bGlzdCc+XG4gICAgICAgICAgICB7bGlzdEl0ZW1zfVxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvU2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgICAgPC9kaXY+KVxuICAgIF1cbiAgfVxufVxuXG5GaWx0ZXJDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvZmlsdGVyL2ZpbHRlci1jb250cm9scy1jb21wb25lbnQuanN4IiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBTREtVdGlscyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnLi4vY29udHJvbHMnXG5pbXBvcnQgRmlsdGVyc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vZmlsdGVyLWNvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBGaWx0ZXJNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2xpYi9tYW5hZ2Vycy9maWx0ZXItbWFuYWdlcidcblxuLyoqXG4gKiBUaGUgZmlsdGVycyBjb250cm9sc1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzXG4gKi9cbmNsYXNzIEZpbHRlcnNDb250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZW50ZXJzIHRoZXNlIGNvbnRyb2xzXG4gICAqIEB0aGlzIHtGaWx0ZXJzQ29udHJvbHNDb21wb25lbnR9XG4gICAqIEBwYXJhbSB7U2hhcmVkU3RhdGV9IHNoYXJlZFN0YXRlXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgb25FbnRlciAoc2hhcmVkU3RhdGUpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSA9IGVkaXRvci5vcGVyYXRpb25zLmV4aXN0cygnZmlsdGVyJylcbiAgICBjb25zdCBvcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnZmlsdGVyJylcbiAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKFsnZmlsdGVyJywgJ2ludGVuc2l0eSddKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IG9wZXJhdGlvbiwgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSwgaW5pdGlhbE9wdGlvbnMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7U3RpY2tlcnNDb250cm9sc0NvbXBvbmVudH1cbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkV4aXQgKCkge1xuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaW5pdGlhbE9wdGlvbnMnKVxuICAgIGNvbnN0IEZpbHRlckNvbnN0cnVjdG9yID0gdGhpcy5fb3BlcmF0aW9uLmdldEZpbHRlcigpLmNvbnN0cnVjdG9yXG4gICAgY29uc3QgSW5pdGlhbEZpbHRlckNvbnN0cnVjdG9yID0gaW5pdGlhbE9wdGlvbnMuZmlsdGVyLmNvbnN0cnVjdG9yXG4gICAgY29uc3QgaW50ZW5zaXR5ID0gdGhpcy5fb3BlcmF0aW9uLmdldEludGVuc2l0eSgpXG4gICAgaWYgKEZpbHRlckNvbnN0cnVjdG9yICE9PSBpbml0aWFsT3B0aW9ucy5maWx0ZXIuY29uc3RydWN0b3IgfHxcbiAgICAgIGludGVuc2l0eSAhPT0gaW5pdGlhbE9wdGlvbnMuaW50ZW5zaXR5KSB7XG4gICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgICBlZGl0b3IuaGlzdG9yeS5hZGQodGhpcy5fb3BlcmF0aW9uLFxuICAgICAgICB7XG4gICAgICAgICAgZmlsdGVyOiBuZXcgSW5pdGlhbEZpbHRlckNvbnN0cnVjdG9yKCksXG4gICAgICAgICAgaW50ZW5zaXR5XG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUnKSlcbiAgICB9XG5cbiAgICBpZiAoRmlsdGVyQ29uc3RydWN0b3IuaXNJZGVudGl0eSkge1xuICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMucmVtb3ZlKHRoaXMuX29wZXJhdGlvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY29udHJvbCBpcyBhdmFpbGFibGUgdG8gdGhlIHVzZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBpc0F2YWlsYWJsZSAoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1Rvb2xFbmFibGVkKHRoaXMuaWRlbnRpZmllcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NldHMgdGhhdCBzaG91bGQgYmUgcHJlbG9hZGVkIGZvciB0aGlzIGNvbnRyb2xcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBnZXRQcmVsb2FkQXNzZXRzIChlZGl0b3IpIHtcbiAgICBjb25zdCBvcHRpb25zID0gZWRpdG9yLmdldE9wdGlvbnMoKVxuICAgIGNvbnN0IGZpbHRlck9wdGlvbnMgPSBTREtVdGlscy5kZWZhdWx0cyhcbiAgICAgIG9wdGlvbnMuZWRpdG9yLmNvbnRyb2xzT3B0aW9ucy5maWx0ZXIsXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zXG4gICAgKVxuICAgIGNvbnN0IGZpbHRlck1hbmFnZXIgPSBuZXcgRmlsdGVyTWFuYWdlcihmaWx0ZXJPcHRpb25zKVxuXG4gICAgbGV0IGFzc2V0cyA9IFtdXG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IGZpbHRlck1hbmFnZXIuZ2V0Q2F0ZWdvcmllcygpXG4gICAgY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSkgPT4ge1xuICAgICAgYXNzZXRzLnB1c2goYGNvbnRyb2xzL2ZpbHRlcnMvY2F0ZWdvcmllcy8ke2NhdGVnb3J5Lm5hbWV9LnBuZ2ApXG4gICAgICBjb25zdCBmaWx0ZXJzID0gZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJzRm9yQ2F0ZWdvcnkoY2F0ZWdvcnkubmFtZSlcbiAgICAgIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgICAgIGFzc2V0cy5wdXNoKGBjb250cm9scy9maWx0ZXJzLyR7ZmlsdGVyLmlkZW50aWZpZXJ9LnBuZ2ApXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gYXNzZXRzXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjb250cm9scyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSBsb3dlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IuXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuRmlsdGVyc0NvbnRyb2xzLmNvbnRyb2xzQ29tcG9uZW50ID0gRmlsdGVyc0NvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkZpbHRlcnNDb250cm9scy5pZGVudGlmaWVyID0gJ2ZpbHRlcidcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpY29uIHBhdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cbkZpbHRlcnNDb250cm9scy5pY29uUGF0aCA9ICdjb250cm9scy9vdmVydmlldy9maWx0ZXJzLnBuZydcblxuLyoqXG4gKiBUaGUgbGFuZ3VhZ2Uga2V5IHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoaXMgZmlsdGVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGlnbm9yZVxuICovXG5GaWx0ZXJzQ29udHJvbHMubGFuZ3VhZ2VLZXkgPSAnY29udHJvbHMub3ZlcnZpZXcuZmlsdGVycydcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1Bob3RvRWRpdG9yU0RLLkZpbHRlcltdfSBbY2F0ZWdvcmllcyA9IFtdXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVwbGFjZUNhdGVnb3JpZXMgPSBmYWxzZV1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IFtzZWxlY3RhYmxlRmlsdGVycyA9IG51bGxdXG4gKi9cbkZpbHRlcnNDb250cm9scy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgY2F0ZWdvcmllczogW10sXG4gIHJlcGxhY2VDYXRlZ29yaWVzOiBmYWxzZSxcbiAgc2VsZWN0YWJsZUZpbHRlcnM6IG51bGwsXG4gIGhpZGVDYXRlZ29yaWVzOiBmYWxzZVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaWx0ZXJzQ29udHJvbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvZmlsdGVyL2luZGV4LmpzIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cclxuLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcclxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxyXG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cclxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcclxuICpcclxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgUmVhY3RCRU0gfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xyXG5pbXBvcnQgQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudCdcclxuaW1wb3J0IExpbmVhckZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9saW5lYXItZm9jdXMtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudCdcclxuaW1wb3J0IFJhZGlhbEZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9yYWRpYWwtZm9jdXMtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGFwcHJvcHJpYXRlIGNhbnZhcyBjb250cm9scyBmb3IgdGhlIGdpdmVuIG9wZXJhdGlvblxyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXHJcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9nZXRDb250cm9sc0Zvck9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XHJcbiAgICBpZiAoIW9wZXJhdGlvbikgcmV0dXJuIG51bGxcclxuXHJcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi5jb25zdHJ1Y3Rvci5pZGVudGlmaWVyKSB7XHJcbiAgICAgIGNhc2UgJ2xpbmVhci1mb2N1cyc6XHJcbiAgICAgICAgcmV0dXJuIExpbmVhckZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnRcclxuICAgICAgY2FzZSAncmFkaWFsLWZvY3VzJzpcclxuICAgICAgICByZXR1cm4gUmFkaWFsRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxyXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XHJcbiAgICovXHJcbiAgcmVuZGVyV2l0aEJFTSAoKSB7XHJcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxyXG4gICAgY29uc3QgQ29udHJvbHMgPSB0aGlzLl9nZXRDb250cm9sc0Zvck9wZXJhdGlvbihvcGVyYXRpb24pXHJcbiAgICBpZiAoIUNvbnRyb2xzKSByZXR1cm4gPGRpdiAvPlxyXG4gICAgcmV0dXJuIDxDb250cm9scyB7Li4udGhpcy5wcm9wc30gLz5cclxuICB9XHJcbn1cclxuXHJcbkZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvZm9jdXMtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi9jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU2Nyb2xsYmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3Njcm9sbGJhci1jb21wb25lbnQnXG5pbXBvcnQgU2xpZGVyT3ZlcmxheUNvbXBvbmVudCBmcm9tICcuLi9zbGlkZXItb3ZlcmxheS1jb21wb25lbnQnXG5cbmNvbnN0IElURU1TID0gW1xuICB7IHRvb2xOYW1lOiAncmFkaWFsLWZvY3VzJywgaWNvbk5hbWU6ICdyYWRpYWwnLCBsYW5ndWFnZUtleTogJ2NvbnRyb2xzLmZvY3VzLnJhZGlhbCcgfSxcbiAgeyB0b29sTmFtZTogJ2xpbmVhci1mb2N1cycsIGljb25OYW1lOiAnbGluZWFyJywgbGFuZ3VhZ2VLZXk6ICdjb250cm9scy5mb2N1cy5saW5lYXInIH1cbl1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9jdXNDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIENvbnRyb2xzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQmx1clJhZGl1c0NoYW5nZScsXG4gICAgICAnX29uT3BlcmF0aW9uUmVtb3ZlZCdcbiAgICApXG4gICAgdGhpcy5fcmVtb3ZlZE9wZXJhdGlvbiA9IG51bGxcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9SRU1PVkVEXTogdGhpcy5fb25PcGVyYXRpb25SZW1vdmVkXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNsaWRlciB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJsdXJSYWRpdXNDaGFuZ2UgKHZhbHVlKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbnB1dERpbWVuc2lvbnMnKVxuICAgIG9wZXJhdGlvbi5zZXRCbHVyUmFkaXVzKHZhbHVlIC8gaW5wdXREaW1lbnNpb25zLm1pbigpKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uZSBvZiB0aGUgYnV0dG9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbE5hbWVcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQnV0dG9uQ2xpY2sgKHRvb2xOYW1lLCBlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHByZXZpb3VzT3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBpZiAocHJldmlvdXNPcGVyYXRpb24pIHtcbiAgICAgIHRoaXMuX3JlbW92ZWRPcGVyYXRpb24gPSBwcmV2aW91c09wZXJhdGlvblxuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMucmVtb3ZlKHByZXZpb3VzT3BlcmF0aW9uKVxuICAgIH1cblxuICAgIGxldCBuZXdPcGVyYXRpb24gPSBudWxsXG4gICAgaWYgKHRvb2xOYW1lKSB7XG4gICAgICBuZXdPcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSh0b29sTmFtZSlcbiAgICB9XG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgb3BlcmF0aW9uOiBuZXdPcGVyYXRpb24gfSlcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25SZW1vdmVkIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCBjdXJyZW50T3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBpZiAoIWN1cnJlbnRPcGVyYXRpb24gfHwgb3BlcmF0aW9uICE9PSBjdXJyZW50T3BlcmF0aW9uIHx8IG9wZXJhdGlvbiA9PT0gdGhpcy5fcmVtb3ZlZE9wZXJhdGlvbikgcmV0dXJuXG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25DbGlja2VkKSByZXR1cm5cblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBpZGVudGlmaWVyID0gY3VycmVudE9wZXJhdGlvbi5jb25zdHJ1Y3Rvci5pZGVudGlmaWVyXG4gICAgY29uc3QgbmV3T3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoaWRlbnRpZmllcilcblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgb3BlcmF0aW9uOiBuZXdPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb25FeGlzdGVkQmVmb3JlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxPcHRpb25zOiB7fVxuICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb3ZlcmxheSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyT3ZlcmxheUNvbnRyb2xzICgpIHtcbiAgICBjb25zdCBmb2N1c09wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgaWYgKCFmb2N1c09wZXJhdGlvbikgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2lucHV0RGltZW5zaW9ucycpXG4gICAgY29uc3Qgc2hvcnRlc3RTaWRlID0gaW5wdXREaW1lbnNpb25zLm1pbigpXG4gICAgY29uc3QgdmFsdWUgPSBmb2N1c09wZXJhdGlvbi5nZXRCbHVyUmFkaXVzKCkgKiBzaG9ydGVzdFNpZGVcbiAgICByZXR1cm4gKDxTbGlkZXJPdmVybGF5Q29tcG9uZW50XG4gICAgICBtaW5WYWx1ZT17MH1cbiAgICAgIG1heFZhbHVlPXtNYXRoLm1pbigxODAsIE1hdGgucm91bmQoc2hvcnRlc3RTaWRlICogMC4xKSl9XG4gICAgICB2YWx1ZVVuaXQ9J3B4J1xuICAgICAgbWlkZGxlRG90PXtmYWxzZX1cbiAgICAgIGxhYmVsPXt0aGlzLl90KCdjb250cm9scy5mb2N1cy5ibHVyUmFkaXVzJyl9XG4gICAgICBvbkNoYW5nZT17dGhpcy5fb25CbHVyUmFkaXVzQ2hhbmdlfVxuICAgICAgdmFsdWU9e3ZhbHVlfSAvPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBsaXN0IGl0ZW1zIGZvciB0aGlzIGNvbnRyb2xcbiAgICogQHJldHVybiB7QXJyYXkuPFJlYWN0QkVNLkVsZW1lbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckxpc3RJdGVtcyAoKSB7XG4gICAgY29uc3QgZm9jdXNPcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG5vRm9jdXNJdGVtID0gKDxsaVxuICAgICAgYmVtPSdlOml0ZW0nXG4gICAgICBrZXk9J25vbmUnPlxuICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGJlbT0nJGU6YnV0dG9uIG06d2l0aExhYmVsJ1xuICAgICAgICAgIGNsYXNzTmFtZT17IWZvY3VzT3BlcmF0aW9uID8gJ2lzLWFjdGl2ZScgOiBudWxsfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uQnV0dG9uQ2xpY2suYmluZCh0aGlzLCBudWxsKX0+XG4gICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL2ZvY3VzL25vbmUucG5nJywgdHJ1ZSl9IC8+XG4gICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLl90KCdjb250cm9scy5mb2N1cy5ub25lJyl9PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9iZW0+XG4gICAgPC9saT4pXG5cbiAgICByZXR1cm4gW25vRm9jdXNJdGVtXS5jb25jYXQoSVRFTVNcbiAgICAgIC5maWx0ZXIoKHsgdG9vbE5hbWUgfSkgPT4gZWRpdG9yLmlzVG9vbEVuYWJsZWQodG9vbE5hbWUpKVxuICAgICAgLm1hcCgoeyB0b29sTmFtZSwgaWNvbk5hbWUsIGxhbmd1YWdlS2V5IH0pID0+IHtcbiAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBmb2N1c09wZXJhdGlvbiAmJiBmb2N1c09wZXJhdGlvbi5jb25zdHJ1Y3Rvci5pZGVudGlmaWVyID09PSB0b29sTmFtZVxuICAgICAgICByZXR1cm4gKDxsaVxuICAgICAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAgICAgIGRhdGEtaWRlbnRpZmllcj17dG9vbE5hbWV9XG4gICAgICAgICAga2V5PXt0b29sTmFtZX0+XG4gICAgICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17aXNBY3RpdmUgPyAnaXMtYWN0aXZlJyA6IG51bGx9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uQnV0dG9uQ2xpY2suYmluZCh0aGlzLCB0b29sTmFtZSl9PlxuICAgICAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvZm9jdXMvJHtpY29uTmFtZX0ucG5nYCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57dGhpcy5fdChsYW5ndWFnZUtleSl9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2JlbT5cbiAgICAgICAgPC9saT4pXG4gICAgICB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udHJvbHMgKCkge1xuICAgIGNvbnN0IGxpc3RJdGVtcyA9IHRoaXMuX3JlbmRlckxpc3RJdGVtcygpXG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSdlOmNlbGwgbTpsaXN0Jz5cbiAgICAgIDxTY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgICAgIDx1bCBiZW09JyRlOmxpc3QnPlxuICAgICAgICAgIHtsaXN0SXRlbXN9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L1Njcm9sbGJhckNvbXBvbmVudD5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuRm9jdXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvZm9jdXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uL2NvbnRyb2xzJ1xuaW1wb3J0IEZvY3VzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9mb2N1cy1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL2ZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5cbi8qKlxuICogVGhlIGZvY3VzIGNvbnRyb2xzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbFxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNcbiAqL1xuY2xhc3MgRm9jdXNDb250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGNvbnRyb2wgaXMgYXZhaWxhYmxlIHRvIHRoZSB1c2VyXG4gICAqIEBwYXJhbSAge0VkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBpc0F2YWlsYWJsZSAoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1Rvb2xFbmFibGVkKCdyYWRpYWwtZm9jdXMnKSB8fFxuICAgICAgZWRpdG9yLmlzVG9vbEVuYWJsZWQoJ2xpbmVhci1mb2N1cycpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBsZWF2ZXMgdGhlc2UgY29udHJvbHNcbiAgICogQHRoaXMge0ZvY3VzQ29udHJvbHNDb21wb25lbnR9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgb25FeGl0ICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLmZlYXR1cmVzLmVuYWJsZSgnem9vbScsICdkcmFnJylcblxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaW5pdGlhbE9wdGlvbnMnKVxuICAgIGNvbnN0IGluaXRpYWxPcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbml0aWFsT3BlcmF0aW9uJylcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuXG4gICAgaWYgKCghb3BlcmF0aW9uICYmIGluaXRpYWxPcGVyYXRpb24pIHx8XG4gICAgICAob3BlcmF0aW9uICYmIGluaXRpYWxPcGVyYXRpb24gJiYgb3BlcmF0aW9uLmNvbnN0cnVjdG9yID09PSBpbml0aWFsT3BlcmF0aW9uLmNvbnN0cnVjdG9yKSkge1xuICAgICAgZWRpdG9yLmhpc3RvcnkuYWRkKGluaXRpYWxPcGVyYXRpb24sXG4gICAgICAgIGluaXRpYWxPcHRpb25zLFxuICAgICAgICB0cnVlKVxuICAgIH1cblxuICAgIGlmIChvcGVyYXRpb24gJiYgIWluaXRpYWxPcGVyYXRpb24pIHtcbiAgICAgIGVkaXRvci5oaXN0b3J5LmFkZChvcGVyYXRpb24sXG4gICAgICAgIHt9LFxuICAgICAgICBmYWxzZSlcbiAgICB9XG5cbiAgICBpZiAob3BlcmF0aW9uICYmIGluaXRpYWxPcGVyYXRpb24gJiYgb3BlcmF0aW9uLmNvbnN0cnVjdG9yICE9PSBpbml0aWFsT3BlcmF0aW9uLmNvbnN0cnVjdG9yKSB7XG4gICAgICBlZGl0b3IuaGlzdG9yeS5hZGQoW3tcbiAgICAgICAgb3BlcmF0aW9uOiBpbml0aWFsT3BlcmF0aW9uLFxuICAgICAgICBvcHRpb25zOiBpbml0aWFsT3B0aW9ucyxcbiAgICAgICAgZXhpc3RlbnQ6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgZXhpc3RlbnQ6IGZhbHNlXG4gICAgICB9XSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBlbnRlcnMgdGhlc2UgY29udHJvbHNcbiAgICogQHRoaXMge0ZvY3VzQ29udHJvbHNDb21wb25lbnR9XG4gICAqIEBwYXJhbSB7U2hhcmVkU3RhdGV9IHNoYXJlZFN0YXRlXG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgb25FbnRlciAoc2hhcmVkU3RhdGUpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0KCdsaW5lYXItZm9jdXMnKSB8fCBlZGl0b3Iub3BlcmF0aW9ucy5nZXQoJ3JhZGlhbC1mb2N1cycpXG5cbiAgICBsZXQgaW5pdGlhbE9wdGlvbnMgPSB7fVxuICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgIGluaXRpYWxPcHRpb25zID0gb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoKVxuICAgICAgZGVsZXRlIGluaXRpYWxPcHRpb25zLmVuYWJsZWRcbiAgICB9XG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgIG9wZXJhdGlvbixcbiAgICAgIGluaXRpYWxPcGVyYXRpb246IG9wZXJhdGlvbixcbiAgICAgIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmU6ICEhb3BlcmF0aW9uLFxuICAgICAgaW5pdGlhbE9wdGlvbnMsXG4gICAgICBpbnB1dERpbWVuc2lvbnM6IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFzc2V0cyB0aGF0IHNob3VsZCBiZSBwcmVsb2FkZWQgZm9yIHRoaXMgY29udHJvbFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge1N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIGdldFByZWxvYWRBc3NldHMgKGVkaXRvcikge1xuICAgIGxldCBhc3NldHMgPSBbXVxuICAgIGlmIChlZGl0b3IuaXNUb29sRW5hYmxlZCgncmFkaWFsLWZvY3VzJykpIHtcbiAgICAgIGFzc2V0cy5wdXNoKCdjb250cm9scy9mb2N1cy9yYWRpYWwucG5nJylcbiAgICB9XG4gICAgaWYgKGVkaXRvci5pc1Rvb2xFbmFibGVkKCdsaW5lYXItZm9jdXMnKSkge1xuICAgICAgYXNzZXRzLnB1c2goJ2NvbnRyb2xzL2ZvY3VzL2xpbmVhci5wbmcnKVxuICAgIH1cblxuICAgIHJldHVybiBhc3NldHNcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGNvbnRyb2xzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIGxvd2VyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvci5cbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzQ29tcG9uZW50fVxuICogQGlnbm9yZVxuICovXG5Gb2N1c0NvbnRyb2xzLmNvbnRyb2xzQ29tcG9uZW50ID0gRm9jdXNDb250cm9sc0NvbXBvbmVudFxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGNhbnZhcyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSB1cHBlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IgKG9uXG4gKiB0b3Agb2YgdGhlIGNhbnZhcylcbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzQ29tcG9uZW50fVxuICogQGlnbm9yZVxuICovXG5Gb2N1c0NvbnRyb2xzLmNhbnZhc0NvbnRyb2xzQ29tcG9uZW50ID0gRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudFxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Gb2N1c0NvbnRyb2xzLmlkZW50aWZpZXIgPSAnZm9jdXMnXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWNvbiBwYXRoXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGlnbm9yZVxuICovXG5Gb2N1c0NvbnRyb2xzLmljb25QYXRoID0gJ2NvbnRyb2xzL292ZXJ2aWV3L2ZvY3VzLnBuZydcblxuLyoqXG4gKiBUaGUgbGFuZ3VhZ2Uga2V5IHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoaXMgZmlsdGVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGlnbm9yZVxuICovXG5Gb2N1c0NvbnRyb2xzLmxhbmd1YWdlS2V5ID0gJ2NvbnRyb2xzLm92ZXJ2aWV3LmZvY3VzJ1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgY29udHJvbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xuRm9jdXNDb250cm9scy5kZWZhdWx0T3B0aW9ucyA9IHtcblxufVxuXG5leHBvcnQgZGVmYXVsdCBGb2N1c0NvbnRyb2xzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZvY3VzL2luZGV4LmpzIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIFZlY3RvcjIsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgRHJhZ2dhYmxlQ29tcG9uZW50IGZyb20gJy4uLy4uL2RyYWdnYWJsZS1jb21wb25lbnQuanN4J1xuaW1wb3J0IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhckZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQ2VudGVyRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25DZW50ZXJEcmFnJyxcbiAgICAgICdfb25Lbm9iRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25Lbm9iRHJhZycsXG4gICAgICAnX29uT3BlcmF0aW9uVXBkYXRlZCdcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYXJlYVBvc2l0aW9uOiBuZXcgVmVjdG9yMigpLFxuICAgICAgYXJlYURpbWVuc2lvbnM6IG5ldyBWZWN0b3IyKCksXG4gICAgICBrbm9iUG9zaXRpb246IG5ldyBWZWN0b3IyKClcbiAgICB9XG4gICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9VUERBVEVEXTogdGhpcy5fb25PcGVyYXRpb25VcGRhdGVkXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSBjYW52YXMgaGFzIGJlZW4gem9vbWVkIGluIG9yIG91dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2FudmFzWm9vbURvbmUgKCkge1xuICAgIHRoaXMuX3NldFN0eWxlc0Zyb21PcHRpb25zKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25VcGRhdGVkIChvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSkgcmV0dXJuXG4gICAgdGhpcy5fc2V0U3R5bGVzRnJvbU9wdGlvbnMoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNoYXJlZCBzdGF0ZSBkaWQgY2hhbmdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKi9cbiAgc2hhcmVkU3RhdGVEaWRDaGFuZ2UgKG5ld1N0YXRlKSB7XG4gICAgaWYgKG5ld1N0YXRlLm9wZXJhdGlvbikge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uID0gbmV3U3RhdGUub3BlcmF0aW9uXG4gICAgICBpZiAodGhpcy5fb3BlcmF0aW9uLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIgPT09ICdsaW5lYXItZm9jdXMnKSB0aGlzLl9zZXRTdHlsZXNGcm9tT3B0aW9ucygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3Iuem9vbS5zZXQoJ2F1dG8nLCAoKSA9PiB7XG4gICAgICBlZGl0b3IuZmVhdHVyZXMuZGlzYWJsZSgnem9vbScsICdkcmFnJylcbiAgICAgIHRoaXMuX3NldFN0eWxlc0Zyb21PcHRpb25zKClcbiAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ0VOVEVSIERSQUdHSU5HXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnMgZHJhZ2dpbmcgdGhlIGNlbnRlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2VudGVyRHJhZ1N0YXJ0ICgpIHtcbiAgICB0aGlzLl9pbml0aWFsU3RhcnQgPSB0aGlzLl9vcGVyYXRpb24uZ2V0U3RhcnQoKVxuICAgIHRoaXMuX2luaXRpYWxFbmQgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RW5kKClcbiAgICB0aGlzLl9pbml0aWFsRGlzdCA9IHRoaXMuX2luaXRpYWxFbmQuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KHRoaXMuX2luaXRpYWxTdGFydClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgY2VudGVyXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DZW50ZXJEcmFnIChvZmZzZXQpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IHJlbGF0aXZlT2Zmc2V0ID0gb2Zmc2V0LmNsb25lKClcbiAgICAgIC5kaXZpZGUob3V0cHV0RGltZW5zaW9ucylcblxuICAgIGNvbnN0IG5ld1N0YXJ0ID0gdGhpcy5faW5pdGlhbFN0YXJ0LmNsb25lKCkuYWRkKHJlbGF0aXZlT2Zmc2V0KVxuICAgICAgLmNsYW1wKFxuICAgICAgICBuZXcgVmVjdG9yMigwLCAwKSxcbiAgICAgICAgbmV3IFZlY3RvcjIoMSwgMSkuc3VidHJhY3QodGhpcy5faW5pdGlhbERpc3QpXG4gICAgICApXG4gICAgY29uc3QgbmV3RW5kID0gbmV3U3RhcnQuY2xvbmUoKS5hZGQodGhpcy5faW5pdGlhbERpc3QpXG5cbiAgICB0aGlzLl9vcGVyYXRpb24uc2V0KHtcbiAgICAgIHN0YXJ0OiBuZXdTdGFydCxcbiAgICAgIGVuZDogbmV3RW5kXG4gICAgfSlcblxuICAgIGVkaXRvci5yZW5kZXIoKVxuICAgIHRoaXMuX3NldFN0eWxlc0Zyb21PcHRpb25zKClcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEdSQURJRU5UIEtOT0IgRFJBR1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJzIGRyYWdnaW5nIHRoZSBncmFkaWVudCBrbm9iXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZ1N0YXJ0IChlKSB7XG4gICAgdGhpcy5faW5pdGlhbEtub2JQb3NpdGlvbiA9IHRoaXMuc3RhdGUua25vYlBvc2l0aW9uLmNsb25lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgZ3JhZGllbnQga25vYlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG9mZnNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWcgKG9mZnNldCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuXG4gICAgY29uc3QgbmV3S25vYlBvc2l0aW9uID0gdGhpcy5faW5pdGlhbEtub2JQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAuYWRkKG9mZnNldClcbiAgICAgIC5jbGFtcChuZXcgVmVjdG9yMigwLCAwKSwgb3V0cHV0RGltZW5zaW9ucylcblxuICAgIGNvbnN0IGRpc3RhbmNlRnJvbUNlbnRlciA9IG5ld0tub2JQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QodGhpcy5zdGF0ZS5hcmVhUG9zaXRpb24pXG5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUuYXJlYVBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5hZGQoLWRpc3RhbmNlRnJvbUNlbnRlci55LCBkaXN0YW5jZUZyb21DZW50ZXIueClcbiAgICAgIC5kaXZpZGUob3V0cHV0RGltZW5zaW9ucylcbiAgICBjb25zdCBlbmQgPSB0aGlzLnN0YXRlLmFyZWFQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAuYWRkKGRpc3RhbmNlRnJvbUNlbnRlci55LCAtZGlzdGFuY2VGcm9tQ2VudGVyLngpXG4gICAgICAuZGl2aWRlKG91dHB1dERpbWVuc2lvbnMpXG4gICAgY29uc3Qgc2l6ZSA9IGRpc3RhbmNlRnJvbUNlbnRlci5sZW4oKSAqIDJcblxuICAgIHRoaXMuX29wZXJhdGlvbi5zZXQoe1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQsXG4gICAgICBzaXplOiBzaXplIC8gb3V0cHV0RGltZW5zaW9ucy5taW4oKSxcbiAgICAgIGdyYWRpZW50U2l6ZTogc2l6ZSAvIG91dHB1dERpbWVuc2lvbnMubWluKClcbiAgICB9KVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAga25vYlBvc2l0aW9uOiBuZXdLbm9iUG9zaXRpb24sXG4gICAgICBhcmVhRGltZW5zaW9uczogbmV3IFZlY3RvcjIodGhpcy5zdGF0ZS5hcmVhRGltZW5zaW9ucy54LCBzaXplKVxuICAgIH0pXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTVFlMSU5HXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIENTUyBzdHlsZXMgZm9yIHRoZSBhcmVhIGRpdlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0QXJlYVN0eWxlICgpIHtcbiAgICBjb25zdCBkaXN0ID0gdGhpcy5zdGF0ZS5rbm9iUG9zaXRpb24uY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KHRoaXMuc3RhdGUuYXJlYVBvc2l0aW9uKVxuICAgIGxldCBkZWdyZWVzID0gTWF0aC5hdGFuMihkaXN0LngsIGRpc3QueSkgKiAoMTgwIC8gTWF0aC5QSSlcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBgcm90YXRlKCR7KC1kZWdyZWVzKS50b0ZpeGVkKDIpfWRlZylgXG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMuc3RhdGUuYXJlYURpbWVuc2lvbnMueCxcbiAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5hcmVhRGltZW5zaW9ucy55LFxuICAgICAgbGVmdDogdGhpcy5zdGF0ZS5hcmVhUG9zaXRpb24ueCxcbiAgICAgIHRvcDogdGhpcy5zdGF0ZS5hcmVhUG9zaXRpb24ueSxcbiAgICAgIG1hcmdpbkxlZnQ6IHRoaXMuc3RhdGUuYXJlYURpbWVuc2lvbnMueCAqIC0wLjUsXG4gICAgICBtYXJnaW5Ub3A6IHRoaXMuc3RhdGUuYXJlYURpbWVuc2lvbnMueSAqIC0wLjUsXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIE1velRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgbXNUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNmb3JtXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIENTUyBzdHlsZXMgZm9yIHRoZSBrbm9iXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRLbm9iU3R5bGUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnN0YXRlLmtub2JQb3NpdGlvbi54LFxuICAgICAgdG9wOiB0aGlzLnN0YXRlLmtub2JQb3NpdGlvbi55XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpbWVuc2lvbnMgYW5kIHBvc2l0aW9uIHZhbHVlcyBmcm9tIHRoZSBjdXJyZW50IG9wZXJhdGlvbiBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U3R5bGVzRnJvbU9wdGlvbnMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuXG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9vcGVyYXRpb24uZ2V0U3RhcnQoKS5jbG9uZSgpLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG4gICAgY29uc3QgZW5kID0gdGhpcy5fb3BlcmF0aW9uLmdldEVuZCgpLmNsb25lKCkubXVsdGlwbHkob3V0cHV0RGltZW5zaW9ucylcbiAgICBjb25zdCBzaXplID0gdGhpcy5fb3BlcmF0aW9uLmdldFNpemUoKSAqIG91dHB1dERpbWVuc2lvbnMubWluKClcblxuICAgIGNvbnN0IGRpc3QgPSBlbmQuY2xvbmUoKS5zdWJ0cmFjdChzdGFydClcbiAgICBjb25zdCBtaWRkbGUgPSBzdGFydC5jbG9uZSgpXG4gICAgICAuYWRkKGRpc3QuY2xvbmUoKS5kaXZpZGUoMikpXG5cbiAgICBjb25zdCBhcmVhU2l6ZSA9IG5ldyBWZWN0b3IyKFxuICAgICAgb3V0cHV0RGltZW5zaW9ucy5sZW4oKSAqIDIsXG4gICAgICBzaXplXG4gICAgKVxuXG4gICAgY29uc3QgdG90YWxEaXN0ID0gZGlzdC5sZW4oKVxuICAgIGNvbnN0IGZhY3RvciA9IGRpc3QuY2xvbmUoKS5kaXZpZGUodG90YWxEaXN0KS5kaXZpZGUoMilcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYXJlYURpbWVuc2lvbnM6IGFyZWFTaXplLFxuICAgICAgYXJlYVBvc2l0aW9uOiBtaWRkbGUuY2xvbmUoKSxcbiAgICAgIGtub2JQb3NpdGlvbjogbWlkZGxlLmNsb25lKClcbiAgICAgICAgLmFkZCgtc2l6ZSAqIGZhY3Rvci55LCBzaXplICogZmFjdG9yLngpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250YWluZXIgc3R5bGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldENvbnRhaW5lclN0eWxlICgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0U0RLKCkuZ2V0U3ByaXRlKCkuZ2V0Qm91bmRzKClcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdiBiZW09J2I6Y2FudmFzQ29udHJvbHMgZTpjb250YWluZXIgbTpmdWxsJyByZWY9J2NvbnRhaW5lcicgc3R5bGU9e3RoaXMuX2dldENvbnRhaW5lclN0eWxlKCl9PlxuICAgICAgPGRpdiBiZW09JyRiOmxpbmVhckZvY3VzQ2FudmFzQ29udHJvbHMnPlxuICAgICAgICA8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgb25TdGFydD17dGhpcy5fb25DZW50ZXJEcmFnU3RhcnR9XG4gICAgICAgICAgb25EcmFnPXt0aGlzLl9vbkNlbnRlckRyYWd9PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmFyZWEnIHN0eWxlPXt0aGlzLl9nZXRBcmVhU3R5bGUoKX0gLz5cbiAgICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+XG4gICAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbktub2JEcmFnU3RhcnR9XG4gICAgICAgICAgb25EcmFnPXt0aGlzLl9vbktub2JEcmFnfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTprbm9iICRiOmtub2InIHN0eWxlPXt0aGlzLl9nZXRLbm9iU3R5bGUoKX0gLz5cbiAgICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuTGluZWFyRm9jdXNDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvZm9jdXMvbGluZWFyLWZvY3VzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIFZlY3RvcjIsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgRHJhZ2dhYmxlQ29tcG9uZW50IGZyb20gJy4uLy4uL2RyYWdnYWJsZS1jb21wb25lbnQuanN4J1xuaW1wb3J0IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlhbEZvY3VzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uQ2VudGVyRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25DZW50ZXJEcmFnJyxcbiAgICAgICdfb25Lbm9iRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25Lbm9iRHJhZycsXG4gICAgICAnX29uT3BlcmF0aW9uVXBkYXRlZCdcbiAgICApXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYXJlYVBvc2l0aW9uOiBuZXcgVmVjdG9yMigpLFxuICAgICAgYXJlYURpbWVuc2lvbnM6IG5ldyBWZWN0b3IyKCksXG4gICAgICBrbm9iUG9zaXRpb246IG5ldyBWZWN0b3IyKClcbiAgICB9XG4gICAgdGhpcy5fa25vYkNoYW5nZWRNYW51YWxseSA9IGZhbHNlXG4gICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9VUERBVEVEXTogdGhpcy5fb25PcGVyYXRpb25VcGRhdGVkXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSBjYW52YXMgaGFzIGJlZW4gem9vbWVkIGluIG9yIG91dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2FudmFzWm9vbURvbmUgKCkge1xuICAgIHRoaXMuX3NldFN0eWxlc0Zyb21PcHRpb25zKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25VcGRhdGVkIChvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSkgcmV0dXJuXG4gICAgdGhpcy5fa25vYkNoYW5nZWRNYW51YWxseSA9IGZhbHNlXG4gICAgdGhpcy5fc2V0U3R5bGVzRnJvbU9wdGlvbnMoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNoYXJlZCBzdGF0ZSBkaWQgY2hhbmdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZVxuICAgKi9cbiAgc2hhcmVkU3RhdGVEaWRDaGFuZ2UgKG5ld1N0YXRlKSB7XG4gICAgaWYgKG5ld1N0YXRlLm9wZXJhdGlvbikge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uID0gbmV3U3RhdGUub3BlcmF0aW9uXG4gICAgICBpZiAodGhpcy5fb3BlcmF0aW9uLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIgPT09ICdyYWRpYWwtZm9jdXMnKSB0aGlzLl9zZXRTdHlsZXNGcm9tT3B0aW9ucygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJywgKCkgPT4ge1xuICAgICAgZWRpdG9yLmZlYXR1cmVzLmRpc2FibGUoJ3pvb20nLCAnZHJhZycpXG4gICAgICB0aGlzLl9zZXRTdHlsZXNGcm9tT3B0aW9ucygpXG4gICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENFTlRFUiBEUkFHR0lOR1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJzIGRyYWdnaW5nIHRoZSBjZW50ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNlbnRlckRyYWdTdGFydCAoKSB7XG4gICAgdGhpcy5faW5pdGlhbFBvc2l0aW9uID0gdGhpcy5fb3BlcmF0aW9uLmdldFBvc2l0aW9uKClcbiAgICB0aGlzLl9pbml0aWFsS25vYlBvc2l0aW9uID0gdGhpcy5zdGF0ZS5rbm9iUG9zaXRpb24uY2xvbmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBjZW50ZXJcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNlbnRlckRyYWcgKG9mZnNldCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgY29uc3QgcmVsYXRpdmVPZmZzZXQgPSBvZmZzZXQuY2xvbmUoKS5kaXZpZGUob3V0cHV0RGltZW5zaW9ucylcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMuX2luaXRpYWxQb3NpdGlvblxuICAgICAgLmNsb25lKClcbiAgICAgIC5hZGQocmVsYXRpdmVPZmZzZXQpXG5cbiAgICBjb25zdCBuZXdLbm9iUG9zaXRpb24gPSB0aGlzLl9pbml0aWFsS25vYlBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5hZGQob2Zmc2V0KVxuXG4gICAgdGhpcy5fb3BlcmF0aW9uLnNldCh7XG4gICAgICBwb3NpdGlvbjogbmV3UG9zaXRpb25cbiAgICB9KVxuXG4gICAgdGhpcy5zdGF0ZS5rbm9iUG9zaXRpb24gPSBuZXdLbm9iUG9zaXRpb25cblxuICAgIGVkaXRvci5yZW5kZXIoKVxuICAgIHRoaXMuX3NldFN0eWxlc0Zyb21PcHRpb25zKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEdSQURJRU5UIEtOT0IgRFJBR1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJzIGRyYWdnaW5nIHRoZSBncmFkaWVudCBrbm9iXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZ1N0YXJ0IChlKSB7XG4gICAgdGhpcy5fa25vYkNoYW5nZWRNYW51YWxseSA9IHRydWVcbiAgICB0aGlzLl9pbml0aWFsS25vYlBvc2l0aW9uID0gdGhpcy5zdGF0ZS5rbm9iUG9zaXRpb24uY2xvbmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBncmFkaWVudCBrbm9iXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZyAob2Zmc2V0KSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCBuZXdLbm9iUG9zaXRpb24gPSB0aGlzLl9pbml0aWFsS25vYlBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5hZGQob2Zmc2V0KVxuICAgICAgLmNsYW1wKG5ldyBWZWN0b3IyKDAsIDApLCBvdXRwdXREaW1lbnNpb25zKVxuXG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9vcGVyYXRpb24uZ2V0UG9zaXRpb24oKS5jbG9uZSgpXG4gICAgICAubXVsdGlwbHkob3V0cHV0RGltZW5zaW9ucylcblxuICAgIGNvbnN0IHJhZGl1cyA9IG5ld0tub2JQb3NpdGlvblxuICAgICAgLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChwb3NpdGlvbilcbiAgICAgIC5hYnMoKVxuICAgICAgLmxlbigpXG4gICAgY29uc3QgZ3JhZGllbnRSYWRpdXMgPSByYWRpdXMgLyAyXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGtub2JQb3NpdGlvbjogbmV3S25vYlBvc2l0aW9uLFxuICAgICAgYXJlYURpbWVuc2lvbnM6IG5ldyBWZWN0b3IyKFxuICAgICAgICByYWRpdXMgKiAyLFxuICAgICAgICByYWRpdXMgKiAyXG4gICAgICApXG4gICAgfSlcbiAgICB0aGlzLl9vcGVyYXRpb24uc2V0KHtcbiAgICAgIHJhZGl1czogcmFkaXVzIC8gb3V0cHV0RGltZW5zaW9ucy5taW4oKSxcbiAgICAgIGdyYWRpZW50UmFkaXVzOiBncmFkaWVudFJhZGl1cyAvIG91dHB1dERpbWVuc2lvbnMubWluKClcbiAgICB9KVxuXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTVFlMSU5HXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIENTUyBzdHlsZXMgZm9yIHRoZSBhcmVhIGRpdlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0QXJlYVN0eWxlICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMuc3RhdGUuYXJlYURpbWVuc2lvbnMueCxcbiAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5hcmVhRGltZW5zaW9ucy55LFxuICAgICAgbGVmdDogdGhpcy5zdGF0ZS5hcmVhUG9zaXRpb24ueCxcbiAgICAgIHRvcDogdGhpcy5zdGF0ZS5hcmVhUG9zaXRpb24ueSxcbiAgICAgIG1hcmdpbkxlZnQ6IHRoaXMuc3RhdGUuYXJlYURpbWVuc2lvbnMueCAqIC0wLjUsXG4gICAgICBtYXJnaW5Ub3A6IHRoaXMuc3RhdGUuYXJlYURpbWVuc2lvbnMueSAqIC0wLjVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQ1NTIHN0eWxlcyBmb3IgdGhlIGtub2JcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEtub2JTdHlsZSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMuc3RhdGUua25vYlBvc2l0aW9uLngsXG4gICAgICB0b3A6IHRoaXMuc3RhdGUua25vYlBvc2l0aW9uLnlcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogU2V0cyB0aGUgZGltZW5zaW9ucyBhbmQgcG9zaXRpb24gdmFsdWVzIGZyb20gdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRTdHlsZXNGcm9tT3B0aW9ucyAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX29wZXJhdGlvbi5nZXRQb3NpdGlvbigpLmNsb25lKClcbiAgICAgIC5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKVxuXG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5fb3BlcmF0aW9uLmdldFJhZGl1cygpICogb3V0cHV0RGltZW5zaW9ucy5taW4oKVxuICAgIGNvbnN0IGRpYW1ldGVyID0gcmFkaXVzICogMlxuICAgIGNvbnN0IGFyZWFTaXplID0gbmV3IFZlY3RvcjIoZGlhbWV0ZXIsIGRpYW1ldGVyKVxuXG4gICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgYXJlYURpbWVuc2lvbnM6IGFyZWFTaXplLFxuICAgICAgYXJlYVBvc2l0aW9uOiBwb3NpdGlvblxuICAgIH1cblxuICAgIGlmICghdGhpcy5fa25vYkNoYW5nZWRNYW51YWxseSkge1xuICAgICAgbmV3U3RhdGUua25vYlBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKVxuICAgICAgICAuYWRkKHJhZGl1cywgMClcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRhaW5lciBzdHlsZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q29udGFpbmVyU3R5bGUgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGVkaXRvci5nZXRTREsoKS5nZXRTcHJpdGUoKS5nZXRCb3VuZHMoKVxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nYjpjYW52YXNDb250cm9scyBlOmNvbnRhaW5lciBtOmZ1bGwnIHJlZj0nY29udGFpbmVyJyBzdHlsZT17dGhpcy5fZ2V0Q29udGFpbmVyU3R5bGUoKX0+XG4gICAgICA8ZGl2IGJlbT0nJGI6cmFkaWFsRm9jdXNDYW52YXNDb250cm9scyc+XG4gICAgICAgIDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICBvblN0YXJ0PXt0aGlzLl9vbkNlbnRlckRyYWdTdGFydH1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uQ2VudGVyRHJhZ30+XG4gICAgICAgICAgPGRpdiBiZW09J2U6YXJlYScgc3R5bGU9e3RoaXMuX2dldEFyZWFTdHlsZSgpfSAvPlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICAgICAgPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uS25vYkRyYWdTdGFydH1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uS25vYkRyYWd9PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmtub2IgJGI6a25vYicgc3R5bGU9e3RoaXMuX2dldEtub2JTdHlsZSgpfSAvPlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5SYWRpYWxGb2N1c0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9mb2N1cy9yYWRpYWwtZm9jdXMtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFNjcm9sbGJhckNvbXBvbmVudCBmcm9tICcuLi8uLi9zY3JvbGxiYXItY29tcG9uZW50J1xuaW1wb3J0IE1vZGFsTWFuYWdlciBmcm9tICcuLi8uLi8uLi9saWIvbW9kYWwtbWFuYWdlcidcbmltcG9ydCBGcmFtZU1hbmFnZXIgZnJvbSAnLi4vLi4vLi4vbGliL21hbmFnZXJzL2ZyYW1lLW1hbmFnZXInXG5pbXBvcnQgRnJhbWVJdGVtQ29tcG9uZW50IGZyb20gJy4vZnJhbWUtaXRlbS1jb21wb25lbnQnXG5pbXBvcnQgQ29sb3JQaWNrZXJDb21wb25lbnQgZnJvbSAnLi4vLi4vY29sb3ItcGlja2VyL2NvbG9yLXBpY2tlci1jb21wb25lbnQnXG5pbXBvcnQgU2xpZGVyT3ZlcmxheUNvbXBvbmVudCBmcm9tICcuLi9zbGlkZXItb3ZlcmxheS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZyYW1lT3ZlcnZpZXdDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIENvbnRyb2xzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vblNjYWxlQ2hhbmdlJyxcbiAgICAgICdfb25Db2xvckNoYW5nZScsXG4gICAgICAnX29uT3BlcmF0aW9uVXBkYXRlZCcsXG4gICAgICAnX29uT3BlcmF0aW9uUmVtb3ZlZCdcbiAgICApXG5cbiAgICB0aGlzLl9ldmVudHMgPSB7XG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5PUEVSQVRJT05fVVBEQVRFRF06IHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlZCxcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9SRU1PVkVEXTogdGhpcy5fb25PcGVyYXRpb25SZW1vdmVkXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdEZyYW1lTWFuYWdlcigpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBGUkFNRVNcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGZyYW1lIG1hbmFnZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0RnJhbWVNYW5hZ2VyICgpIHtcbiAgICB0aGlzLl9mcmFtZU1hbmFnZXIgPSBuZXcgRnJhbWVNYW5hZ2VyKHRoaXMuY29udGV4dC51aSwgdGhpcy5wcm9wcy5vcHRpb25zKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHBhcmFtICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblVwZGF0ZWQgKG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24gPT09IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpKSB7XG4gICAgICB0aGlzLmZvcmNlU2hhcmVkVXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uUmVtb3ZlZCAob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbiAhPT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykpIHJldHVyblxuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uQ2xpY2tlZCkgcmV0dXJuXG5cbiAgICAvLyBPcGVyYXRpb24gY2FuIGJlIHJlbW92ZWQgYnkgdGhlIHVuZG8gYnV0dG9uLiBXZSBuZWVkXG4gICAgLy8gdG8gbWFrZSBzdXJlIHdlIHJlLWNyZWF0ZSB0aGUgb3BlcmF0aW9uIGZvciB0aGUgbGlmZXRpbWVcbiAgICAvLyBvZiB0aGlzIGNvbnRyb2xcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgbmV3T3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ2ZyYW1lJylcblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgb3BlcmF0aW9uOiBuZXdPcGVyYXRpb24sXG4gICAgICBmcmFtZTogbnVsbCxcbiAgICAgIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmU6IGZhbHNlLFxuICAgICAgaW5pdGlhbE9wdGlvbnM6IHt9XG4gICAgfSlcblxuICAgIGVkaXRvci5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNjYWxlIGhhcyBiZWVuIGNoYW5nZWRcbiAgICogQHBhcmFtICB7TnVtYmVyfSBzY2FsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU2NhbGVDaGFuZ2UgKHNjYWxlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaW5wdXREaW1lbnNpb25zJylcbiAgICB0aGlzLl9vcGVyYXRpb24uc2V0U2NhbGUoc2NhbGUgLyBpbnB1dERpbWVuc2lvbnMubWluKCkpXG5cbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB0aW50IGNvbG9yIGhhcyBiZWVuIGNoYW5nZWRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuQ29sb3J9IGNvbG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db2xvckNoYW5nZSAoY29sb3IpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIG9wZXJhdGlvbi5zZXRUaW50Q29sb3IoY29sb3IuY2xvbmUoKSlcblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja0NsaWNrIChlKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkNsaWNrZWQgPSB0cnVlXG4gICAgdGhpcy5wcm9wcy5vblN3aXRjaENvbnRyb2xzKCdob21lJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgZnJhbWUgaGFzIGJlZW4gY2xpY2tlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGZyYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25GcmFtZUNsaWNrIChmcmFtZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuICAgIGlmIChmcmFtZSA9PT0gbnVsbCkge1xuICAgICAgb3BlcmF0aW9uLnNldEZyYW1lKG51bGwpXG4gICAgICBlZGl0b3IucmVuZGVyKClcbiAgICAgIHJldHVybiB0aGlzLmZvcmNlU2hhcmVkVXBkYXRlKClcbiAgICB9XG5cbiAgICBsZXQgbG9hZGluZ01vZGFsXG4gICAgbGV0IGxvYWRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2FkaW5nTW9kYWwgPSBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUxvYWRpbmcodGhpcy5fdCgnbG9hZGluZy5sb2FkaW5nJykpXG4gICAgfSwgMTAwKVxuXG4gICAgZnJhbWUubG9hZCgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChsb2FkaW5nTW9kYWwpIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgICAgIGlmIChsb2FkVGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChsb2FkVGltZW91dClcbiAgICAgICAgICBsb2FkVGltZW91dCA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZyYW1lT2JqZWN0ID0gZnJhbWUuZ2V0RnJhbWUoKVxuICAgICAgICBvcGVyYXRpb24uc2V0RnJhbWUoZnJhbWVPYmplY3QpXG5cbiAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgICAgICBlZGl0b3IucmVuZGVyKClcblxuICAgICAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgZnJhbWUgfSlcbiAgICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgb3ZlcmxheSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyT3ZlcmxheUNvbnRyb2xzICgpIHtcbiAgICBjb25zdCBmcmFtZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2ZyYW1lJylcblxuICAgIGlmICghZnJhbWUpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbnB1dERpbWVuc2lvbnMnKVxuXG4gICAgY29uc3QgbWluVGhpY2tuZXNzID0gNVxuICAgIGNvbnN0IG1heFRoaWNrbmVzcyA9IE1hdGgucm91bmQoMC4zICogaW5wdXREaW1lbnNpb25zLm1pbigpKVxuICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IHRoaXMuX29wZXJhdGlvbi5nZXRTY2FsZSgpICogaW5wdXREaW1lbnNpb25zLm1pbigpXG5cbiAgICByZXR1cm4gKDxTbGlkZXJPdmVybGF5Q29tcG9uZW50XG4gICAgICBtaW5WYWx1ZT17bWluVGhpY2tuZXNzfVxuICAgICAgbWF4VmFsdWU9e21heFRoaWNrbmVzc31cbiAgICAgIHZhbHVlPXtjdXJyZW50U2NhbGV9XG4gICAgICB2YWx1ZVVuaXQ9J3B4J1xuICAgICAgbWlkZGxlRG90PXtmYWxzZX1cbiAgICAgIGxhYmVsPXt0aGlzLl90KCdjb250cm9scy5mcmFtZS5zY2FsZScpfVxuICAgICAgb25DaGFuZ2U9e3RoaXMuX29uU2NhbGVDaGFuZ2V9IC8+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGxpc3QgaXRlbXMgZm9yIHRoaXMgY29udHJvbFxuICAgKiBAcmV0dXJuIHtBcnJheS48UmVhY3RCRU0uRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyTGlzdEl0ZW1zICgpIHtcbiAgICBjb25zdCBmcmFtZXMgPSB0aGlzLl9mcmFtZU1hbmFnZXIuZ2V0RnJhbWVzKClcbiAgICBjb25zdCBjdXJyZW50RnJhbWUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKS5nZXRGcmFtZSgpXG5cbiAgICBjb25zdCBub0ZyYW1lSXRlbSA9ICg8bGlcbiAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAga2V5PSduby1mcmFtZSdcbiAgICAgIG9uQ2xpY2s9e3RoaXMuX29uRnJhbWVDbGljay5iaW5kKHRoaXMsIG51bGwpfT5cbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICAgIDxkaXYgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnXG4gICAgICAgICAgY2xhc3NOYW1lPXshY3VycmVudEZyYW1lID8gJ2lzLWFjdGl2ZScgOiBudWxsfT5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aChgY29udHJvbHMvZnJhbWUvbm8tZnJhbWUucG5nYCwgdHJ1ZSl9IC8+XG4gICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLl90KCdjb250cm9scy5mcmFtZS5ub0ZyYW1lJyl9PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9iZW0+XG4gICAgPC9saT4pXG5cbiAgICByZXR1cm4gW25vRnJhbWVJdGVtXS5jb25jYXQoZnJhbWVzLm1hcCgoZnJhbWUsIGkpID0+IHtcbiAgICAgIHJldHVybiAoPEZyYW1lSXRlbUNvbXBvbmVudFxuICAgICAgICBmcmFtZT17ZnJhbWV9XG4gICAgICAgIGFjdGl2ZT17Y3VycmVudEZyYW1lICYmIGN1cnJlbnRGcmFtZS5uYW1lID09PSBmcmFtZS5nZXROYW1lKCl9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uRnJhbWVDbGljay5iaW5kKHRoaXMsIGZyYW1lKX0gLz4pXG4gICAgfSkpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udHJvbHMgb2YgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlckNvbnRyb2xzICgpIHtcbiAgICBjb25zdCBmcmFtZSA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpLmdldEZyYW1lKClcbiAgICBjb25zdCBsaXN0SXRlbXMgPSB0aGlzLl9yZW5kZXJMaXN0SXRlbXMoKVxuXG4gICAgY29uc3QgaXRlbXMgPSBbKDxkaXYgYmVtPSdlOmNlbGwgbTpsaXN0Jz5cbiAgICAgIDxTY3JvbGxiYXJDb21wb25lbnQgcmVmPSdzY3JvbGxiYXInPlxuICAgICAgICA8dWwgYmVtPSckZTpsaXN0Jz5cbiAgICAgICAgICB7bGlzdEl0ZW1zfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9TY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgPC9kaXY+KV1cblxuICAgIGlmIChmcmFtZSAmJiBmcmFtZS50aW50YWJsZSkge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICAgIGl0ZW1zLnB1c2goPGRpdiBiZW09J2U6Y2VsbCBtOmNvbG9yUGlja2VyJz5cbiAgICAgICAgPENvbG9yUGlja2VyQ29tcG9uZW50XG4gICAgICAgICAgaW5pdGlhbFZhbHVlPXtvcGVyYXRpb24uZ2V0VGludENvbG9yKCkuY2xvbmUoKX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25Db2xvckNoYW5nZX0gLz5cbiAgICAgIDwvZGl2PilcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXNcbiAgfVxufVxuXG5GcmFtZU92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL2ZyYW1lL2ZyYW1lLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQsIFZlY3RvcjIgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcmFtZUl0ZW1Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGZyYW1lOiB0aGlzLnByb3BzLmZyYW1lXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHRoaXMuX3JlbmRlckZyYW1lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGFib3V0IHRvIHJlY2VpdmUgbmV3IHByb3BlcnRpZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBuZXh0UHJvcHNcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG5leHRQcm9wcykge1xuICAgIGlmICh0aGlzLnByb3BzLmZyYW1lICE9PSBuZXh0UHJvcHMuZnJhbWUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBmcmFtZTogbmV4dFByb3BzLmZyYW1lIH0sICgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVuZGVyRnJhbWUoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZnJhbWUgb250byB0aGUgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyRnJhbWUgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBzZGsgPSBlZGl0b3IuZ2V0U0RLKClcblxuICAgIGNvbnN0IHsgZnJhbWUgfSA9IHRoaXMucHJvcHNcblxuICAgIGNvbnN0IHJlc29sdmVkRnJhbWVQYXRoID0gdGhpcy5fZ2V0QXNzZXRQYXRoKGZyYW1lLmdldEljb24oKSlcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLnJlZnNbYGNhbnZhcy0ke2ZyYW1lLmdldE5hbWUoKX1gXVxuXG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHNkay5nZXRQaXhlbFJhdGlvKClcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGggKiBwaXhlbFJhdGlvXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHQgKiBwaXhlbFJhdGlvXG5cbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjYW52YXMub2Zmc2V0V2lkdGh9cHhgXG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NhbnZhcy5vZmZzZXRIZWlnaHR9cHhgXG5cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGNvbnN0IGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZSgpXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oY2FudmFzLndpZHRoIC8gaW1hZ2Uud2lkdGgsIGNhbnZhcy5oZWlnaHQgLyBpbWFnZS5oZWlnaHQpXG4gICAgICBjb25zdCBkcmF3U2l6ZSA9IG5ldyBWZWN0b3IyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG4gICAgICAgIC5tdWx0aXBseShzY2FsZSlcbiAgICAgIGNvbnN0IGRyYXdQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAuc3VidHJhY3QoZHJhd1NpemUuY2xvbmUoKS5kaXZpZGUoMikpXG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAwLCAwLFxuICAgICAgICBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LFxuICAgICAgICBkcmF3UG9zaXRpb24ueCwgZHJhd1Bvc2l0aW9uLnksXG4gICAgICAgIGRyYXdTaXplLngsIGRyYXdTaXplLnkpXG4gICAgfSlcbiAgICBpbWFnZS5zcmMgPSByZXNvbHZlZEZyYW1lUGF0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBlbGVtZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLmVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSdiOmNvbnRyb2xzIGU6bGlzdCc+XG4gICAgICA8bGlcbiAgICAgICAgYmVtPSdlOml0ZW0nXG4gICAgICAgIGtleT17dGhpcy5wcm9wcy5mcmFtZS5nZXROYW1lKCl9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMub25DbGlja30+XG4gICAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjpjb250cm9scyc+XG4gICAgICAgICAgPGRpdiBiZW09JyRlOmJ1dHRvbiBtOndpdGhJbmxpbmVMYWJlbCc+XG4gICAgICAgICAgICA8Y2FudmFzIGJlbT0nZTpjYW52YXMgbTpsYXJnZScgcmVmPXtgY2FudmFzLSR7dGhpcy5wcm9wcy5mcmFtZS5nZXROYW1lKCl9YH0gLz5cbiAgICAgICAgICAgIDxkaXYgYmVtPSckZTppbmxpbmVMYWJlbCcgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmFjdGl2ZSA/ICdpcy1hY3RpdmUnIDogbnVsbH0+XG4gICAgICAgICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57dGhpcy5wcm9wcy5mcmFtZS5nZXRMYWJlbCgpfTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvYmVtPlxuICAgICAgPC9saT5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvZnJhbWUvZnJhbWUtaXRlbS1jb21wb25lbnQuanN4IiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uL2NvbnRyb2xzJ1xuaW1wb3J0IEZyYW1lQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9mcmFtZS1jb250cm9scy1jb21wb25lbnQnXG5cbi8qKlxuICogVGhlIGZyYW1lIGNvbnRyb2xzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbFxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNcbiAqL1xuY2xhc3MgRnJhbWVDb250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgbGVhdmVzIHRoZXNlIGNvbnRyb2xzXG4gICAqIEB0aGlzIHtGcmFtZUNvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRXhpdCAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbml0aWFsT3B0aW9ucycpXG5cbiAgICBjb25zdCBmcmFtZSA9IG9wZXJhdGlvbi5nZXRGcmFtZSgpXG4gICAgY29uc3Qgc2NhbGUgPSBvcGVyYXRpb24uZ2V0U2NhbGUoKVxuXG4gICAgaWYgKChmcmFtZSAmJiBmcmFtZS5uYW1lKSAhPT0gKGluaXRpYWxPcHRpb25zLmZyYW1lICYmIGluaXRpYWxPcHRpb25zLmZyYW1lLm5hbWUpIHx8XG4gICAgICAgIHNjYWxlICE9PSBpbml0aWFsT3B0aW9ucy5zY2FsZSkge1xuICAgICAgZWRpdG9yLmhpc3RvcnkuYWRkKFxuICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2luaXRpYWxPcHRpb25zJyksXG4gICAgICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUnKVxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICghb3BlcmF0aW9uLmdldEZyYW1lKCkpIHtcbiAgICAgIGVkaXRvci5vcGVyYXRpb25zLnJlbW92ZShvcGVyYXRpb24pXG4gICAgfVxuXG4gICAgZWRpdG9yLnpvb20udW5kbygpXG4gICAgZWRpdG9yLmZlYXR1cmVzLmVuYWJsZSgnem9vbScsICdkcmFnJylcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGVudGVycyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7RnJhbWVDb250cm9sc0NvbXBvbmVudH1cbiAgICogQHBhcmFtIHtTaGFyZWRTdGF0ZX0gc2hhcmVkU3RhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkVudGVyIChzaGFyZWRTdGF0ZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gZWRpdG9yLm9wZXJhdGlvbnMuZXhpc3RzKCdmcmFtZScpXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ2ZyYW1lJylcbiAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKClcblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgb3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSxcbiAgICAgIGluaXRpYWxPcHRpb25zLFxuICAgICAgaW5wdXREaW1lbnNpb25zOiBvcGVyYXRpb24uZ2V0SW5wdXREaW1lbnNpb25zKCksXG4gICAgICBmcmFtZTogb3BlcmF0aW9uLmdldEZyYW1lKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGNvbnRyb2wgaXMgYXZhaWxhYmxlIHRvIHRoZSB1c2VyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRWRpdG9yfSBlZGl0b3JcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBpc0F2YWlsYWJsZSAoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1Rvb2xFbmFibGVkKCdmcmFtZScpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjb250cm9scyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSBsb3dlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IuXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuRnJhbWVDb250cm9scy5jb250cm9sc0NvbXBvbmVudCA9IEZyYW1lQ29udHJvbHNDb21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuRnJhbWVDb250cm9scy5pZGVudGlmaWVyID0gJ2ZyYW1lJ1xuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGljb24gcGF0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuRnJhbWVDb250cm9scy5pY29uUGF0aCA9ICdjb250cm9scy9vdmVydmlldy9mcmFtZS5wbmcnXG5cbi8qKlxuICogVGhlIGxhbmd1YWdlIGtleSB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGlzIGZpbHRlclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuRnJhbWVDb250cm9scy5sYW5ndWFnZUtleSA9ICdjb250cm9scy5vdmVydmlldy5mcmFtZSdcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge09iamVjdFtdfSBbZnJhbWVzID0gW11dXG4gKi9cbkZyYW1lQ29udHJvbHMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZyYW1lczogW11cbn1cblxuZXhwb3J0IGRlZmF1bHQgRnJhbWVDb250cm9sc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9mcmFtZS9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pbmlTbGlkZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlIHx8IDAsXG4gICAgICBzbGlkZXJQb3NpdGlvbjogMCxcbiAgICAgIGZvcmVncm91bmRMZWZ0OiAwLFxuICAgICAgZm9yZWdyb3VuZFdpZHRoOiAwXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIC8vIFRyaWdnZXIgYSByZS1yZW5kZXIgdG8gcG9zaXRpb24gdGhlIGtub2JcbiAgICB0aGlzLl9zZXRWYWx1ZSh0aGlzLnN0YXRlLnZhbHVlLCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChwcm9wcykge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdGhpcy5zdGF0ZS52YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0VmFsdWUocHJvcHMudmFsdWUsIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBmb3IgdGhlIGtub2IgKHBvc2l0aW9uKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0S25vYlN0eWxlICgpIHtcbiAgICByZXR1cm4geyBsZWZ0OiB0aGlzLnN0YXRlLnNsaWRlclBvc2l0aW9uIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBmb3IgdGhlIGZvcmVncm91bmQgYmFyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGb3JlZ3JvdW5kU3R5bGUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnN0YXRlLmZvcmVncm91bmRMZWZ0LFxuICAgICAgd2lkdGg6IHRoaXMuc3RhdGUuZm9yZWdyb3VuZFdpZHRoXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBEZWNpZGVzIHdoZXRoZXIgb3Igbm90IHRoaXMgc2xpZGVyIHNob3VsZCBoYXZlIGEgbWlkZGxlIGRvdCBvbiB0aGUgYmFyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGlzcGxheU1pZGRsZURvdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMubWlkZGxlRG90ICE9PSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZSwgdXBkYXRlcyB0aGUgc2xpZGVyIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVtaXRDaGFuZ2UgPSB0cnVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VmFsdWUgKHZhbHVlLCBlbWl0Q2hhbmdlID0gdHJ1ZSkge1xuICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSlcbiAgICBjb25zdCB7IG1pblZhbHVlLCBtYXhWYWx1ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHByb2dyZXNzID0gKHZhbHVlIC0gbWluVmFsdWUpIC8gKG1heFZhbHVlIC0gbWluVmFsdWUpXG5cbiAgICAvLyBDYWxjdWxhdGUgc2xpZGVyIHBvc2l0aW9uXG4gICAgY29uc3QgeyBiYXIgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IGJhcldpZHRoID0gYmFyLm9mZnNldFdpZHRoXG4gICAgY29uc3Qgc2xpZGVyUG9zaXRpb24gPSBiYXJXaWR0aCAqIHByb2dyZXNzXG5cbiAgICAvLyBDYWxjdWxhdGUgZm9yZWdyb3VuZCBwb3NpdGlvbiBhbmQgd2lkdGhcbiAgICBsZXQgZm9yZWdyb3VuZFdpZHRoID0gcHJvZ3Jlc3MgKiBiYXJXaWR0aFxuICAgIGxldCBmb3JlZ3JvdW5kTGVmdCA9IDBcbiAgICBpZiAodGhpcy5fZGlzcGxheU1pZGRsZURvdCgpKSB7XG4gICAgICBmb3JlZ3JvdW5kV2lkdGggPSBNYXRoLmFicyhwcm9ncmVzcyAtIDAuNSkgKiBiYXJXaWR0aFxuICAgICAgZm9yZWdyb3VuZExlZnQgPSBwcm9ncmVzcyA8IDAuNVxuICAgICAgICA/IChiYXJXaWR0aCAqIDAuNSAtIGZvcmVncm91bmRXaWR0aClcbiAgICAgICAgOiAnNTAlJ1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZSwgc2xpZGVyUG9zaXRpb24sIGZvcmVncm91bmRXaWR0aCwgZm9yZWdyb3VuZExlZnQgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBjb25zdCBmb3JlZ3JvdW5kUHJvcHMgPSB7XG4gICAgICBzdHlsZTogdGhpcy5fZ2V0Rm9yZWdyb3VuZFN0eWxlKClcbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjptaW5pU2xpZGVyJz5cbiAgICAgIDxkaXYgYmVtPSckZTpiYXInIHJlZj0nYmFyJz5cbiAgICAgICAgPGRpdiBiZW09JyRlOmJhY2tncm91bmQnIC8+XG4gICAgICAgIDxkaXYgYmVtPSckZTpmb3JlZ3JvdW5kJyB7Li4uZm9yZWdyb3VuZFByb3BzfSAvPlxuICAgICAgICA8ZGl2IGJlbT0nZTprbm9iJyBzdHlsZT17dGhpcy5fZ2V0S25vYlN0eWxlKCl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuTWluaVNsaWRlckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9taW5pLXNsaWRlci1jb21wb25lbnQuanN4IiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnLi4vY29udHJvbHMnXG5pbXBvcnQgVG9wQmFyQ29tcG9uZW50IGZyb20gJy4vdG9wLWJhci90b3AtYmFyLWNvbXBvbmVudCdcbmltcG9ydCBPdmVydmlld0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vb3ZlcnZpZXctY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IE92ZXJ2aWV3Q2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi9vdmVydmlldy1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuXG5jbGFzcyBPdmVydmlld0NvbnRyb2xzIGV4dGVuZHMgQ29udHJvbHMge1xuXG59XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgdG9wIGJhciBjb250cm9scyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSBzdWItaGVhZGVyIHBhcnQgb2YgdGhlIGVkaXRvci5cbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzQ29tcG9uZW50fVxuICogQGlnbm9yZVxuICovXG5PdmVydmlld0NvbnRyb2xzLnRvcEJhckNvbnRyb2xzQ29tcG9uZW50ID0gVG9wQmFyQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbk92ZXJ2aWV3Q29udHJvbHMuY29udHJvbHNDb21wb25lbnQgPSBPdmVydmlld0NvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cbk92ZXJ2aWV3Q29udHJvbHMuY2FudmFzQ29udHJvbHNDb21wb25lbnQgPSBPdmVydmlld0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50XG5cbmV4cG9ydCBkZWZhdWx0IE92ZXJ2aWV3Q29udHJvbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvaW5kZXguanMiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgVXRpbHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL2NhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJ2aWV3Q2FudmFzQ29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl9iaW5kQWxsKCdfb25DbGljaycpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgc29tZXdoZXJlIG9uIHRoZSBjYW52YXNcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNsaWNrIChlKSB7XG4gICAgdGhpcy5fcGVyZm9ybUhpdFRlc3QoVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29udGFpbmVyIHN0eWxlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDb250YWluZXJTdHlsZSAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQuZWRpdG9yLmlzUmVhZHkoKSkge1xuICAgICAgcmV0dXJuIHsgbGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMSwgaGVpZ2h0OiAxIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0U0RLKCkuZ2V0U3ByaXRlKCkuZ2V0Qm91bmRzKClcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdlxuICAgICAgYmVtPSckYjpjYW52YXNDb250cm9scyBlOmNvbnRhaW5lciBtOmZ1bGwnXG4gICAgICByZWY9J2NvbnRhaW5lcic+XG4gICAgICA8ZGl2XG4gICAgICAgIGJlbT0nJGI6Y2FudmFzQ29udHJvbHMgZTppbm5lckNvbnRhaW5lcidcbiAgICAgICAgcmVmPSdpbm5lckNvbnRhaW5lcidcbiAgICAgICAgc3R5bGU9e3RoaXMuX2dldENvbnRhaW5lclN0eWxlKCl9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uQ2xpY2t9XG4gICAgICAgIG9uVG91Y2hTdGFydD17dGhpcy5fb25DbGlja30gLz5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuT3ZlcnZpZXdDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvb3ZlcnZpZXctY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgTW9kYWxNYW5hZ2VyIGZyb20gJy4uLy4uLy4uLy4uL2xpYi9tb2RhbC1tYW5hZ2VyJ1xuaW1wb3J0IFRvcEJhckJ1dHRvbkNvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdG9wLWJhci9idXR0b24tY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHBvcnRCdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25CdXR0b25DbGljaydcbiAgICApXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJ1dHRvbkNsaWNrICgpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMsIGVkaXRvciwgZWRpdG9yU2NyZWVuIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBleHBvcnRPcHRpb25zID0gb3B0aW9ucy5lZGl0b3IuZXhwb3J0XG5cbiAgICBlZGl0b3JTY3JlZW4uc3dpdGNoVG9Db250cm9scygnaG9tZScsIG51bGwsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRpbmdNb2RhbCA9IE1vZGFsTWFuYWdlci5pbnN0YW5jZS5kaXNwbGF5TG9hZGluZyh0aGlzLl90KCdsb2FkaW5nLmV4cG9ydGluZycpKVxuXG4gICAgICAvLyBHaXZlIGl0IHNvbWUgdGltZSB0byBkaXNwbGF5IHRoZSBsb2FkaW5nIG1vZGFsXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZWRpdG9yLmV4cG9ydChleHBvcnRPcHRpb25zLmRvd25sb2FkKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIE1vZGFsTWFuYWdlci5pbnN0YW5jZS5kaXNwbGF5RXJyb3IodGhpcy5fdCgnZXJyb3JzLnRpdGxlJyksIGUubWVzc2FnZSlcbiAgICAgICAgICAgIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgICAgICAgfSlcbiAgICAgIH0sIDEwMClcbiAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0XG4gICAgaWYgKCFvcHRpb25zLmVkaXRvci5leHBvcnQuc2hvd0J1dHRvbikgcmV0dXJuIG51bGxcblxuICAgIHJldHVybiAoPFRvcEJhckJ1dHRvbkNvbXBvbmVudFxuICAgICAgc3R5bGU9J2JsdWUnXG4gICAgICBsYWJlbD17dGhpcy5fdCgnZWRpdG9yLmV4cG9ydCcpfVxuICAgICAgaWNvbj0nZWRpdG9yL2V4cG9ydC5wbmcnXG4gICAgICBvbkNsaWNrPXt0aGlzLl9vbkJ1dHRvbkNsaWNrfSAvPilcbiAgfVxufVxuXG5FeHBvcnRCdXR0b25Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvdG9wLWJhci9leHBvcnQtYnV0dG9uLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgVXRpbHMsIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFRvcEJhckJ1dHRvbkNvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdG9wLWJhci9idXR0b24tY29tcG9uZW50J1xuaW1wb3J0IEludmlzaWJsZVVwbG9hZENvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvaW52aXNpYmxlLXVwbG9hZC1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5ld0ZpbGVCdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25OZXdGaWxlJyxcbiAgICAgICdfb25CdXR0b25DbGljaydcbiAgICApXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgYSBuZXcgZmlsZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgKi9cbiAgX29uTmV3RmlsZSAoaW1hZ2UpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlc2V0KClcbiAgICBlZGl0b3Iuc2V0SW1hZ2UoaW1hZ2UpXG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQnV0dG9uQ2xpY2sgKCkge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgd2ViY2FtRW5hYmxlZCA9IChvcHRpb25zLmVuYWJsZVdlYmNhbSA9PT0gZmFsc2UgfHwgVXRpbHMuaXNNb2JpbGUoKSlcbiAgICBjb25zdCBwaG90b1JvbGxFbmFibGVkID0gISFvcHRpb25zLnBob3RvUm9sbC5wcm92aWRlclxuICAgIGlmICh3ZWJjYW1FbmFibGVkICYmICFwaG90b1JvbGxFbmFibGVkKSB7XG4gICAgICB0aGlzLnJlZnMudXBsb2FkLm9wZW4oKVxuICAgIH0gZWxzZSBpZiAocGhvdG9Sb2xsRW5hYmxlZCkge1xuICAgICAgdGhpcy5wcm9wcy5hcHAuc3dpdGNoVG9TY3JlZW4oJ3Bob3RvUm9sbCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvcHMuYXBwLnN3aXRjaFRvU2NyZWVuKCdzcGxhc2gnKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgbGV0IGJ1dHRvbkxhYmVsID0gbnVsbFxuICAgIGlmIChvcHRpb25zLnBob3RvUm9sbC5wcm92aWRlcikge1xuICAgICAgYnV0dG9uTGFiZWwgPSB0aGlzLl90KCdlZGl0b3IuYmFja2dyb3VuZEltYWdlJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnV0dG9uTGFiZWwgPSB0aGlzLl90KCdlZGl0b3IubmV3JylcbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXY+XG4gICAgICA8SW52aXNpYmxlVXBsb2FkQ29tcG9uZW50IG9uTmV3RmlsZT17dGhpcy5fb25OZXdGaWxlfSByZWY9J3VwbG9hZCcgLz5cbiAgICAgIDxUb3BCYXJCdXR0b25Db21wb25lbnRcbiAgICAgICAgbGFiZWw9e2J1dHRvbkxhYmVsfVxuICAgICAgICBpY29uPSdlZGl0b3IvbmV3LnBuZydcbiAgICAgICAgb25DbGljaz17dGhpcy5fb25CdXR0b25DbGlja30gLz5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuTmV3RmlsZUJ1dHRvbkNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy90b3AtYmFyL25ldy1maWxlLWJ1dHRvbi1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0gfSBmcm9tICcuLi8uLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFRvcEJhckNvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdG9wLWJhci90b3AtYmFyLWNvbXBvbmVudCdcbmltcG9ydCBOZXdGaWxlQnV0dG9uQ29tcG9uZW50IGZyb20gJy4vbmV3LWZpbGUtYnV0dG9uLWNvbXBvbmVudCdcbmltcG9ydCBFeHBvcnRCdXR0b25Db21wb25lbnQgZnJvbSAnLi9leHBvcnQtYnV0dG9uLWNvbXBvbmVudCdcbmltcG9ydCBVbmRvQnV0dG9uQ29tcG9uZW50IGZyb20gJy4vdW5kby1idXR0b24tY29tcG9uZW50J1xuaW1wb3J0IFpvb21Db21wb25lbnQgZnJvbSAnLi96b29tLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3ZlcnZpZXdUb3BCYXJDb21wb25lbnQgZXh0ZW5kcyBUb3BCYXJDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udGVudCBvZiB0aGlzIE92ZXJ2aWV3VG9wQmFyQ29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJDb250ZW50ICgpIHtcbiAgICBsZXQgbmV3RmlsZUJ1dHRvbiA9IG51bGxcbiAgICBpZiAodGhpcy5jb250ZXh0Lm9wdGlvbnMuZW5hYmxlVXBsb2FkKSB7XG4gICAgICBuZXdGaWxlQnV0dG9uID0gPE5ld0ZpbGVCdXR0b25Db21wb25lbnQgYXBwPXt0aGlzLnByb3BzLmFwcH0gLz5cbiAgICB9XG5cbiAgICBsZXQgem9vbUNvbXBvbmVudCA9IG51bGxcbiAgICBpZiAodGhpcy5jb250ZXh0Lm9wdGlvbnMuZWRpdG9yLmVuYWJsZVpvb20pIHtcbiAgICAgIHpvb21Db21wb25lbnQgPSA8Wm9vbUNvbXBvbmVudCAvPlxuICAgIH1cblxuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9JyRiOnRvcEJhcic+XG4gICAgICA8ZGl2IGJlbT0nZTpsZWZ0Jz5cbiAgICAgICAge25ld0ZpbGVCdXR0b259XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBiZW09J2U6cmlnaHQnPlxuICAgICAgICA8VW5kb0J1dHRvbkNvbXBvbmVudCAvPlxuICAgICAgICA8RXhwb3J0QnV0dG9uQ29tcG9uZW50IC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAge3pvb21Db21wb25lbnR9XG4gICAgPC9iZW0+KVxuICB9XG59XG5cbk92ZXJ2aWV3VG9wQmFyQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IFRvcEJhckNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvb3ZlcnZpZXcvdG9wLWJhci90b3AtYmFyLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQ29uc3RhbnRzLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBUb3BCYXJCdXR0b25Db21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3RvcC1iYXIvYnV0dG9uLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5kb0J1dHRvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkJ1dHRvbkNsaWNrJyxcbiAgICAgICdfb25IaXN0b3J5VXBkYXRlZCcsXG4gICAgICAnX29uRmVhdHVyZXNVcGRhdGVkJ1xuICAgIClcblxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLkhJU1RPUllfVVBEQVRFRF06IHRoaXMuX29uSGlzdG9yeVVwZGF0ZWQsXG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5GRUFUVVJFU19VUERBVEVEXTogdGhpcy5fb25GZWF0dXJlc1VwZGF0ZWRcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZmVhdHVyZXMgaGF2ZSBiZWVuIGVuYWJsZWQgb3IgZGlzYWJsZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkZlYXR1cmVzVXBkYXRlZCAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgaGlzdG9yeSBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25IaXN0b3J5VXBkYXRlZCAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJ1dHRvbkNsaWNrICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLmhpc3RvcnkudW5kbygpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGlmICghZWRpdG9yLmhpc3RvcnkuaXNBdmFpbGFibGUoKSkgcmV0dXJuIG51bGxcblxuICAgIHJldHVybiAoPFRvcEJhckJ1dHRvbkNvbXBvbmVudFxuICAgICAgbGFiZWw9e3RoaXMuX3QoJ2VkaXRvci51bmRvJyl9XG4gICAgICBpY29uPSdlZGl0b3IvdW5kby5wbmcnXG4gICAgICBvbkNsaWNrPXt0aGlzLl9vbkJ1dHRvbkNsaWNrfSAvPilcbiAgfVxufVxuXG5VbmRvQnV0dG9uQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL292ZXJ2aWV3L3RvcC1iYXIvdW5kby1idXR0b24tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cywgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab29tQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uWm9vbU91dENsaWNrJyxcbiAgICAgICdfb25ab29tSW5DbGljaycsXG4gICAgICAnX29uWm9vbURvbmUnLFxuICAgICAgJ19vbkZlYXR1cmVzVXBkYXRlZCdcbiAgICApXG5cbiAgICB0aGlzLl9ldmVudHMgPSB7XG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5aT09NX0RPTkVdOiB0aGlzLl9vblpvb21Eb25lLFxuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuRkVBVFVSRVNfVVBEQVRFRF06IHRoaXMuX29uRmVhdHVyZXNVcGRhdGVkXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGZlYXR1cmVzIGhhdmUgYmVlbiB1cGRhdGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25GZWF0dXJlc1VwZGF0ZWQgKCkge1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIG5ldyB6b29tIGxldmVsIGhhcyBiZWVuIGFwcGxpZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblpvb21Eb25lICgpIHtcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgXCJ6b29tIG91dFwiIGJ1dHRvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25ab29tT3V0Q2xpY2sgKGUpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgaWYgKCFlZGl0b3IuZmVhdHVyZXMuaXNFbmFibGVkKCd6b29tJykpIHJldHVyblxuXG4gICAgZWRpdG9yLnpvb20uem9vbU91dCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIFwiem9vbSBpblwiIGJ1dHRvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25ab29tSW5DbGljayAoZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBpZiAoIWVkaXRvci5mZWF0dXJlcy5pc0VuYWJsZWQoJ3pvb20nKSkgcmV0dXJuXG5cbiAgICBlZGl0b3Iuem9vbS56b29tSW4oKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCB6b29tID0gZWRpdG9yLnpvb20uZ2V0KClcbiAgICBjb25zdCBlbmFibGVkID0gZWRpdG9yLmZlYXR1cmVzLmlzRW5hYmxlZCgnem9vbScpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGJlbSBzcGVjaWZpZXI9J2I6ZWRpdG9yU2NyZWVuJz5cbiAgICAgICAgPGRpdiBiZW09JyRlOnpvb20nPlxuXG4gICAgICAgICAgPGRpdiBiZW09JyRlOmJ1dHRvbiBtOnpvb21PdXQnXG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLl9vblpvb21PdXRDbGlja31cbiAgICAgICAgICAgIGNsYXNzTmFtZT17ZW5hYmxlZCA/IG51bGwgOiAnaXMtZGlzYWJsZWQnfT5cbiAgICAgICAgICAgIDxpbWcgYmVtPSdlOmltYWdlJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvbWludXMucG5nJywgdHJ1ZSl9IC8+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+XG4gICAgICAgICAgICBab29tPGJyIC8+XG4gICAgICAgICAgICB7TWF0aC5yb3VuZCh6b29tICogMTAwKX0lXG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBiZW09JyRlOmJ1dHRvbiBtOnpvb21JbidcbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uWm9vbUluQ2xpY2t9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2VuYWJsZWQgPyBudWxsIDogJ2lzLWRpc2FibGVkJ30+XG4gICAgICAgICAgICA8aW1nIGJlbT0nZTppbWFnZScgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL3BsdXMucG5nJywgdHJ1ZSl9IC8+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2JlbT5cbiAgICApXG4gIH1cbn1cblxuWm9vbUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9vdmVydmlldy90b3AtYmFyL3pvb20tY29tcG9uZW50LmpzeCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uL2NvbnRyb2xzJ1xuaW1wb3J0IFNlbGVjdGl2ZUJsdXJDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL3NlbGVjdGl2ZS1ibHVyLWNvbnRyb2xzLWNvbXBvbmVudCdcbmltcG9ydCBTZWxlY3RpdmVCbHVyQ2FudmFzQ29udHJvbHNDT21wb25lbnQgZnJvbSAnLi9zZWxlY3RpdmUtYmx1ci1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuXG4vKipcbiAqIFRoZSBzZWxlY3RpdmUgYmx1ciBjb250cm9sc1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzXG4gKi9cbmNsYXNzIFNlbGVjdGl2ZUJsdXJDb250cm9scyBleHRlbmRzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgbGVhdmVzIHRoZXNlIGNvbnRyb2xzXG4gICAqIEB0aGlzIHtTZWxlY3RpdmVCbHVyQ29udHJvbHNDb21wb25lbnR9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgb25FeGl0ICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcblxuICAgIGlmIChvcGVyYXRpb24uZ2V0UGF0aHMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGVkaXRvci5vcGVyYXRpb25zLnJlbW92ZShvcGVyYXRpb24pXG4gICAgfVxuXG4gICAgZWRpdG9yLnpvb20udW5kbygpXG4gICAgZWRpdG9yLmZlYXR1cmVzLmVuYWJsZSgnem9vbScsICdkcmFnJylcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGVudGVycyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7U2VsZWN0aXZlQmx1ckNvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAcGFyYW0ge1NoYXJlZFN0YXRlfSBzaGFyZWRTdGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRW50ZXIgKHNoYXJlZFN0YXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJywgKCkgPT4ge1xuICAgICAgZWRpdG9yLnJlbmRlcigpXG4gICAgfSlcblxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgY29uc3Qgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSA9IGVkaXRvci5vcGVyYXRpb25zLmV4aXN0cygnc2VsZWN0aXZlLWJsdXInKVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzZWxlY3RpdmUtYmx1cicpXG4gICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSBvcGVyYXRpb24uc2VyaWFsaXplT3B0aW9ucygpXG4gICAgY29uc3QgYnJ1c2ggPSBvcGVyYXRpb24uZ2V0QnJ1c2goKVxuXG4gICAgbGV0IHRoaWNrbmVzcyA9IG91dHB1dERpbWVuc2lvbnMubWluKCkgKiAwLjFcbiAgICBjb25zdCBoYXJkbmVzcyA9IDFcblxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IG9wZXJhdGlvbi5nZXRJbnB1dERpbWVuc2lvbnMoKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb25FeGlzdGVkQmVmb3JlLCBvcGVyYXRpb24sIGJydXNoLCBpbml0aWFsT3B0aW9ucywgdGhpY2tuZXNzLCBoYXJkbmVzcywgaW5wdXREaW1lbnNpb25zXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjb250cm9sIGlzIGF2YWlsYWJsZSB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgaXNBdmFpbGFibGUgKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuaXNUb29sRW5hYmxlZCgnc2VsZWN0aXZlLWJsdXInKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY29udHJvbHMgY29tcG9uZW50LiBVc2VkIGZvciB0aGUgbG93ZXIgY29udHJvbHMgcGFydCBvZiB0aGUgZWRpdG9yLlxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cblNlbGVjdGl2ZUJsdXJDb250cm9scy5jb250cm9sc0NvbXBvbmVudCA9IFNlbGVjdGl2ZUJsdXJDb250cm9sc0NvbXBvbmVudFxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGNhbnZhcyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSB1cHBlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IgKG9uXG4gKiB0b3Agb2YgdGhlIGNhbnZhcylcbiAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkNvbnRyb2xzQ29tcG9uZW50fVxuICogQGlnbm9yZVxuICovXG5TZWxlY3RpdmVCbHVyQ29udHJvbHMuY2FudmFzQ29udHJvbHNDb21wb25lbnQgPSBTZWxlY3RpdmVCbHVyQ2FudmFzQ29udHJvbHNDT21wb25lbnRcblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuU2VsZWN0aXZlQmx1ckNvbnRyb2xzLmlkZW50aWZpZXIgPSAnc2VsZWN0aXZlLWJsdXInXG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgaWNvbiBwYXRoXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGlnbm9yZVxuICovXG5TZWxlY3RpdmVCbHVyQ29udHJvbHMuaWNvblBhdGggPSAnY29udHJvbHMvb3ZlcnZpZXcvc2VsZWN0aXZlLWJsdXIucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cblNlbGVjdGl2ZUJsdXJDb250cm9scy5sYW5ndWFnZUtleSA9ICdjb250cm9scy5vdmVydmlldy5zZWxlY3RpdmUtYmx1cidcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbnRyb2xcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblNlbGVjdGl2ZUJsdXJDb250cm9scy5kZWZhdWx0T3B0aW9ucyA9IHtcblxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RpdmVCbHVyQ29udHJvbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc2VsZWN0aXZlLWJsdXIvaW5kZXguanMiLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgVmVjdG9yMiwgVXRpbHMsIFNES1V0aWxzLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi9zcHJpdGVzL3Nwcml0ZXMtY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJ1c2hDYW52YXNDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIFNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3dpbmRvd1Jlc2l6ZWQgPSBmYWxzZVxuICAgIHRoaXMuX2RyYXdpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uTW91c2VFbnRlcicsXG4gICAgICAnX29uTW91c2VMZWF2ZScsXG4gICAgICAnX29uTW91c2VEb3duJyxcbiAgICAgICdfb25Nb3VzZU1vdmUnLFxuICAgICAgJ19vbk1vdXNlVXAnLFxuICAgICAgJ19vbk1vdXNlTW92ZU9uQ2FudmFzJyxcbiAgICAgICdfb25XaW5kb3dSZXNpemUnXG4gICAgKVxuXG4gICAgdGhpcy5fbGFzdERyYXdQb3NpdGlvbiA9IG51bGxcblxuICAgIHRoaXMuX2V2ZW50cyA9IFNES1V0aWxzLmV4dGVuZCh0aGlzLl9ldmVudHMsIHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLldJTkRPV19SRVNJWkVdOiB0aGlzLl9vbldpbmRvd1Jlc2l6ZVxuICAgIH0pXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY3Vyc29yVmlzaWJsZTogZmFsc2UsXG4gICAgICBjdXJzb3JQb3NpdGlvbjogbmV3IFZlY3RvcjIoKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJRkVDWUNMRVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG4gICAgdGhpcy5fdXBkYXRlQ29udGFpbmVyUmVjdCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIGlmICh0aGlzLl93aW5kb3dSZXNpemVkKSB7XG4gICAgICB0aGlzLl91cGRhdGVDb250YWluZXJSZWN0KClcbiAgICAgIHRoaXMuX3dpbmRvd1Jlc2l6ZWQgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB3aW5kb3cgaGFzIGJlZW4gcmVzaXplZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uV2luZG93UmVzaXplICgpIHtcbiAgICB0aGlzLl93aW5kb3dSZXNpemVkID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBiZWVuIHJlbW92ZWRcbiAgICogQHBhcmFtICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblJlbW92ZWQgKG9wZXJhdGlvbikge1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlZCAob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykpIHtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBtb3VzZSBidXR0b25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vdXNlRG93biAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICB0aGlzLl9vcHRpb25zQmVmb3JlRHJhdyA9IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKClcbiAgICBkZWxldGUgdGhpcy5fb3B0aW9uc0JlZm9yZURyYXcuZW5hYmxlZFxuXG4gICAgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZURyYXcgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb25FeGlzdGVkQmVmb3JlJylcbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHsgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZTogdHJ1ZSB9LCBmYWxzZSlcblxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gdGhpcy5fZ2V0Q3Vyc29yUG9zaXRpb24oZSlcblxuICAgIGNvbnN0IHRoaWNrbmVzcyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3RoaWNrbmVzcycpIC8gb3V0cHV0RGltZW5zaW9ucy5taW4oKVxuICAgIGNvbnN0IGhhcmRuZXNzID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaGFyZG5lc3MnKVxuICAgIHRoaXMuX2RyYXdpbmcgPSB0cnVlXG4gICAgdGhpcy5fY3VycmVudFBhdGggPSBvcGVyYXRpb24uY3JlYXRlUGF0aCh0aGlja25lc3MsIGhhcmRuZXNzKVxuICAgIHRoaXMuX2N1cnJlbnRQYXRoLmFkZENvbnRyb2xQb2ludChjdXJzb3JQb3NpdGlvbi5jbG9uZSgpLmRpdmlkZShvdXRwdXREaW1lbnNpb25zKSlcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXApXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIG1vdXNlIGJ1dHRvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VVcCAoKSB7XG4gICAgdGhpcy5fY3VycmVudFBhdGguc2V0Q2xvc2VkKHRydWUpXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlbmRlcigpXG5cbiAgICB0aGlzLl9jdXJyZW50UGF0aCA9IG51bGxcbiAgICB0aGlzLl9kcmF3aW5nID0gZmFsc2VcblxuICAgIGVkaXRvci5oaXN0b3J5LmFkZChcbiAgICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpLFxuICAgICAgdGhpcy5fb3B0aW9uc0JlZm9yZURyYXcsXG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlRHJhdylcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXApXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBlbnRlcnMgdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VFbnRlciAoZSkge1xuICAgIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gdGhpcy5fZ2V0Q3Vyc29yUG9zaXRpb24oZSlcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnNvclZpc2libGU6IHRydWUsXG4gICAgICBjdXJzb3JQb3NpdGlvblxuICAgIH0pXG4gICAgdGhpcy5fb25Nb3VzZU1vdmUoZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGUgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Nb3VzZUxlYXZlICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnNvclZpc2libGU6IGZhbHNlXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2VcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VNb3ZlIChlKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCB6b29tID0gZWRpdG9yLnpvb20uZ2V0KClcbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuX2dldEN1cnNvclBvc2l0aW9uKGUpXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGN1cnNvclBvc2l0aW9uIH0pXG5cbiAgICBsZXQgc2hvdWxkRHJhd1xuICAgIGlmICghdGhpcy5fbGFzdERyYXdQb3NpdGlvbikge1xuICAgICAgc2hvdWxkRHJhdyA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnJ1c2hTaXplID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgndGhpY2tuZXNzJylcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5fbGFzdERyYXdQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAgIC5zdWJ0cmFjdChjdXJzb3JQb3NpdGlvbilcbiAgICAgICAgLmFicygpLmxlbigpIC8gem9vbVxuICAgICAgc2hvdWxkRHJhdyA9IGRpc3RhbmNlID49IGJydXNoU2l6ZSAvIDEwXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RyYXdpbmcgJiYgc2hvdWxkRHJhdykge1xuICAgICAgdGhpcy5fY3VycmVudFBhdGguYWRkQ29udHJvbFBvaW50KGN1cnNvclBvc2l0aW9uLmNsb25lKCkuZGl2aWRlKG91dHB1dERpbWVuc2lvbnMpKVxuICAgICAgdGhpcy5fbGFzdERyYXdQb3NpdGlvbiA9IGN1cnNvclBvc2l0aW9uLmNsb25lKClcblxuICAgICAgZWRpdG9yLnJlbmRlcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZSBvbiB0b3Agb2YgdGhlIGNhbnZhcy4gVXBkYXRlc1xuICAgKiB0aGUgY3Vyc29yIGN1cnNvciBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTW91c2VNb3ZlT25DYW52YXMgKGUpIHtcbiAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuX2dldEN1cnNvclBvc2l0aW9uKGUpXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGN1cnNvclBvc2l0aW9uIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTVFlMSU5HXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnNvcidzIHN0eWxlIG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q3Vyc29yU3R5bGUgKCkge1xuICAgIGNvbnN0IHRoaWNrbmVzcyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3RoaWNrbmVzcycpXG5cbiAgICBjb25zdCB7IGN1cnNvclBvc2l0aW9uIH0gPSB0aGlzLnN0YXRlXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGN1cnNvclBvc2l0aW9uLngsXG4gICAgICB0b3A6IGN1cnNvclBvc2l0aW9uLnksXG4gICAgICB3aWR0aDogdGhpY2tuZXNzLFxuICAgICAgaGVpZ2h0OiB0aGlja25lc3MsXG4gICAgICBtYXJnaW5MZWZ0OiB0aGlja25lc3MgKiAtMC41LFxuICAgICAgbWFyZ2luVG9wOiB0aGlja25lc3MgKiAtMC41XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb250YWluZXIgYm91bmRpbmcgcmVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUNvbnRhaW5lclJlY3QgKCkge1xuICAgIHRoaXMuX2NvbnRhaW5lckJvdW5kaW5nUmVjdCA9IHRoaXMucmVmcy5pbm5lckNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnNvciBwb3NpdGlvbiBmb3IgdGhlIGdpdmVuIGV2ZW50XG4gICAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEN1cnNvclBvc2l0aW9uIChldmVudCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihldmVudClcbiAgICBjb25zdCBib3VuZGluZ1JlY3QgPSB0aGlzLl9jb250YWluZXJCb3VuZGluZ1JlY3RcbiAgICByZXR1cm4gcG9zaXRpb25cbiAgICAgIC5zdWJ0cmFjdChib3VuZGluZ1JlY3QubGVmdCwgYm91bmRpbmdSZWN0LnRvcClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgb3V0ZXIgY29udGFpbmVyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDb250YWluZXJQcm9wcyAoKSB7XG4gICAgbGV0IHByb3BzID0gc3VwZXIuX2dldENvbnRhaW5lclByb3BzKClcblxuICAgIHByb3BzLm9uTW91c2VEb3duID0gcHJvcHMub25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Nb3VzZURvd25cbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgY2FudmFzIGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5uZXJDb250YWluZXJQcm9wcyAoKSB7XG4gICAgbGV0IHByb3BzID0gc3VwZXIuX2dldElubmVyQ29udGFpbmVyUHJvcHMoKVxuXG4gICAgLy8gVGhpcyBkaXNhYmxlcyB0aGUgaGl0IHRlc3RpbmcgZm9yIHRoaXMgc3ViIGNvbnRyb2xcbiAgICBkZWxldGUgcHJvcHMub25DbGlja1xuXG4gICAgcHJvcHMub25Nb3VzZUVudGVyID0gdGhpcy5fb25Nb3VzZUVudGVyXG4gICAgcHJvcHMub25Nb3VzZUxlYXZlID0gdGhpcy5fb25Nb3VzZUxlYXZlXG4gICAgcHJvcHMub25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZU9uQ2FudmFzXG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc3ByaXRlIGl0ZW1zXG4gICAqIEByZXR1cm4ge0FycmF5LjxTcHJpdGVJdGVtQ29tcG9uZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJTcHJpdGVJdGVtcyAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHJlbmRlcnMgY29udHJvbHMgb24gdG9wIG9mIHRoZSBzcHJpdGVzXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyT3ZlcmxheUNvbnRyb2xzICgpIHtcbiAgICBjb25zdCBjdXJzb3JDbGFzcyA9IHRoaXMuc3RhdGUuY3Vyc29yVmlzaWJsZSA/ICdpcy12aXNpYmxlJyA6IG51bGxcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBiZW09JyRiOnNlbGVjdGl2ZUJsdXJDYW52YXNDb250cm9scyc+XG4gICAgICAgIDxkaXYgYmVtPSdlOmN1cnNvcicgY2xhc3NOYW1lPXtjdXJzb3JDbGFzc30gc3R5bGU9e3RoaXMuX2dldEN1cnNvclN0eWxlKCl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuQnJ1c2hDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBTcHJpdGVzQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL3NlbGVjdGl2ZS1ibHVyL3NlbGVjdGl2ZS1ibHVyLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFNsaWRlckNvbXBvbmVudCBmcm9tICcuLi8uLi9zbGlkZXItY29tcG9uZW50J1xuaW1wb3J0IFNsaWRlck92ZXJsYXlDb21wb25lbnQgZnJvbSAnLi4vc2xpZGVyLW92ZXJsYXktY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcnVzaENvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQ29udHJvbHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9oYXNEb25lQnV0dG9uID0gZmFsc2VcbiAgICB0aGlzLl9icnVzaFRoaWNrbmVzcyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3RoaWNrbmVzcycpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbk9wZXJhdGlvblVwZGF0ZWQnLFxuICAgICAgJ19vbk9wZXJhdGlvblJlbW92ZWQnLFxuICAgICAgJ19vblRoaWNrbmVzc1VwZGF0ZWQnLFxuICAgICAgJ19vbkJsdXJSYWRpdXNDaGFuZ2UnXG4gICAgKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHRoaWNrbmVzc0NvbnRyb2xzRW5hYmxlZDogZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHMgPSB7XG4gICAgICBbQ29uc3RhbnRzLkVWRU5UUy5PUEVSQVRJT05fVVBEQVRFRF06IHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlZCxcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLk9QRVJBVElPTl9SRU1PVkVEXTogdGhpcy5fb25PcGVyYXRpb25SZW1vdmVkXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3Iuem9vbS5zZXQoJ2F1dG8nKVxuICAgIGVkaXRvci5mZWF0dXJlcy5kaXNhYmxlKCd6b29tJywgJ2RyYWcnKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGhhcyBiZWVuIHJlbW92ZWRcbiAgICogQHBhcmFtICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblJlbW92ZWQgKG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24gIT09IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpKSByZXR1cm5cbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkNsaWNrZWQpIHJldHVyblxuXG4gICAgLy8gT3BlcmF0aW9uIGNhbiBiZSByZW1vdmVkIGJ5IHRoZSB1bmRvIGJ1dHRvbi4gV2UgbmVlZFxuICAgIC8vIHRvIG1ha2Ugc3VyZSB3ZSByZS1jcmVhdGUgdGhlIG9wZXJhdGlvbiBmb3IgdGhlIGxpZmV0aW1lXG4gICAgLy8gb2YgdGhpcyBjb250cm9sXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG5ld09wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzZWxlY3RpdmUtYmx1cicpXG4gICAgY29uc3QgYnJ1c2ggPSBuZXdPcGVyYXRpb24uZ2V0QnJ1c2goKVxuXG4gICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7XG4gICAgICBvcGVyYXRpb246IG5ld09wZXJhdGlvbixcbiAgICAgIGJydXNoLFxuICAgICAgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZTogZmFsc2UsXG4gICAgICBpbml0aWFsT3B0aW9uczoge31cbiAgICB9KVxuXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcGFyYW0gIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlZCAob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJykpIHtcbiAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICAgIGVkaXRvci5yZW5kZXIoKVxuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHRoaWNrbmVzcyBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlja25lc3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblRoaWNrbmVzc1VwZGF0ZWQgKHRoaWNrbmVzcykge1xuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyB0aGlja25lc3MgfSlcbiAgICB0aGlzLl9icnVzaFRoaWNrbmVzcyA9IHRoaWNrbmVzc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNsaWRlciB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHByZXZpb3VzVmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSByZWxlYXNlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmx1clJhZGl1c0NoYW5nZSAodmFsdWUsIHByZXZpb3VzVmFsdWUsIHJlbGVhc2VkID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbnB1dERpbWVuc2lvbnMnKVxuICAgIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpLnNldEJsdXJSYWRpdXModmFsdWUgLyBpbnB1dERpbWVuc2lvbnMubWluKCkpXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnJlbmRlcigpXG5cbiAgICBpZiAocmVsZWFzZWQpIHtcbiAgICAgIGVkaXRvci5oaXN0b3J5LmFkZChcbiAgICAgICAgdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJyksXG4gICAgICAgIHsgYmx1clJhZGl1czogcHJldmlvdXNWYWx1ZSAvIGlucHV0RGltZW5zaW9ucy5taW4oKSB9LFxuICAgICAgICB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvdmVybGF5IGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJPdmVybGF5Q29udHJvbHMgKCkge1xuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2lucHV0RGltZW5zaW9ucycpXG4gICAgY29uc3Qgc2hvcnRlc3RTaWRlID0gaW5wdXREaW1lbnNpb25zLm1pbigpXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKS5nZXRCbHVyUmFkaXVzKCkgKiBzaG9ydGVzdFNpZGVcblxuICAgIHJldHVybiAoPFNsaWRlck92ZXJsYXlDb21wb25lbnRcbiAgICAgIG1pblZhbHVlPXswfVxuICAgICAgbWF4VmFsdWU9e01hdGgubWluKDE4MCwgTWF0aC5yb3VuZChzaG9ydGVzdFNpZGUgKiAwLjEpKX1cbiAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgIHZhbHVlVW5pdD0ncHgnXG4gICAgICBsYWJlbD17dGhpcy5fdCgnY29udHJvbHMuc2VsZWN0aXZlQmx1ci5ibHVyUmFkaXVzJyl9XG4gICAgICBvbkNoYW5nZT17dGhpcy5fb25CbHVyUmFkaXVzQ2hhbmdlfSAvPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9scyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyQ29udHJvbHMgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCB6b29tID0gZWRpdG9yLnpvb20uZ2V0KClcbiAgICBsZXQgaXRlbXMgPSBbXVxuXG4gICAgY29uc3QgZmluYWxEaW1lbnNpb25zID0gZWRpdG9yLmdldEZpbmFsRGltZW5zaW9ucygpXG4gICAgY29uc3QgbWluVGhpY2tuZXNzID0gMVxuICAgIGNvbnN0IG1heFRoaWNrbmVzcyA9IE1hdGgucm91bmQoZmluYWxEaW1lbnNpb25zLmNsb25lKCkubXVsdGlwbHkoem9vbSkubWluKCkgLyAyKVxuICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHRoaXMuX2JydXNoVGhpY2tuZXNzXG5cbiAgICBpdGVtcy5wdXNoKDxkaXYgYmVtPSdlOmNlbGwgbTpzbGlkZXInPlxuICAgICAgPFNsaWRlckNvbXBvbmVudFxuICAgICAgICBzdHlsZT0nbGFyZ2UnXG4gICAgICAgIG1pblZhbHVlPXttaW5UaGlja25lc3N9XG4gICAgICAgIG1heFZhbHVlPXttYXhUaGlja25lc3N9XG4gICAgICAgIHZhbHVlVW5pdD0ncHgnXG4gICAgICAgIG1pZGRsZURvdD17ZmFsc2V9XG4gICAgICAgIGxhYmVsPXt0aGlzLl90KCdjb250cm9scy5icnVzaC50aGlja25lc3MnKX1cbiAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uVGhpY2tuZXNzVXBkYXRlZH1cbiAgICAgICAgdmFsdWU9e2N1cnJlbnRXaWR0aH0gLz5cbiAgICA8L2Rpdj4pXG5cbiAgICByZXR1cm4gaXRlbXNcbiAgfVxufVxuXG5CcnVzaENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IENvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zZWxlY3RpdmUtYmx1ci9zZWxlY3RpdmUtYmx1ci1jb250cm9scy1jb21wb25lbnQuanN4IiwiICAvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgSXRlbUNvbXBvbmVudCBmcm9tICcuL2l0ZW0tY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcnVzaEl0ZW1Db21wb25lbnQgZXh0ZW5kcyBJdGVtQ29tcG9uZW50IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMucHJvcHMuc3ByaXRlLmdldENhbnZhcygpXG4gICAgdGhpcy5fYXBwZW5kQ2FudmFzKGNhbnZhcylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGFib3V0IHRvIHJlY2VpdmUgbmV3IHByb3BlcnRpZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBuZXh0UHJvcHNcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuc3ByaXRlICE9PSB0aGlzLnByb3BzLnNwcml0ZSkge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5wcm9wcy5zcHJpdGUuZ2V0Q2FudmFzKClcbiAgICAgIGNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbnZhcylcbiAgICAgIGNvbnN0IG5ld0NhbnZhcyA9IG5leHRQcm9wcy5zcHJpdGUuZ2V0Q2FudmFzKClcbiAgICAgIHRoaXMuX2FwcGVuZENhbnZhcyhuZXdDYW52YXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgYW5kIHN0eWxlcyB0aGUgZ2l2ZW4gY2FudmFzXG4gICAqIEBwYXJhbSAge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBlbmRDYW52YXMgKGNhbnZhcykge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG91dHB1dERpbWVuc2lvbnMueCArICdweCdcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3V0cHV0RGltZW5zaW9ucy55ICsgJ3B4J1xuICAgIHRoaXMucmVmcy5icnVzaC5hcHBlbmRDaGlsZChjYW52YXMpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfaXNTZWxlY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2JydXNoJykgPT09IHRoaXMucHJvcHMuc3ByaXRlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgYnJ1c2hDbGFzc05hbWUgPSB0aGlzLl9pc1NlbGVjdGVkKCkgPyAnaXMtc2VsZWN0ZWQnIDogbnVsbFxuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9J2I6c3ByaXRlc0NhbnZhc0NvbnRyb2xzJz5cbiAgICAgIDxkaXYgYmVtPSckZTppdGVtIGU6Y29udGFpbmVyIG06ZnVsbCcgcmVmPSdjb250YWluZXInPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgYmVtPSckZTpicnVzaCdcbiAgICAgICAgICBjbGFzc05hbWU9e2JydXNoQ2xhc3NOYW1lfVxuICAgICAgICAgIHJlZj0nYnJ1c2gnIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuQnJ1c2hJdGVtQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEl0ZW1Db21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL3Nwcml0ZXMvaXRlbXMvYnJ1c2gtaXRlbS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLVXRpbHMsIFJlYWN0QkVNLCBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vZHJhZ2dhYmxlLWNvbXBvbmVudCdcbmltcG9ydCBJdGVtQ29tcG9uZW50IGZyb20gJy4vaXRlbS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0aWNrZXJJdGVtQ29tcG9uZW50IGV4dGVuZHMgSXRlbUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uUm90YXRlS25vYkRyYWdTdGFydCcsXG4gICAgICAnX29uUm90YXRlS25vYkRyYWcnLFxuICAgICAgJ19vblJvdGF0ZUtub2JEcmFnU3RvcCdcbiAgICApXG4gICAgdGhpcy5faWQgPSBTREtVdGlscy5nZXRVVUlEKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyBhIGtub2JcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzaWRlXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZ1N0YXJ0IChzaWRlLCBwb3NpdGlvbiwgZSkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICB0aGlzLl9pbml0aWFsUG9zaXRpb24gPSB0aGlzLl9nZXRCb3R0b21EcmFnS25vYlBvc2l0aW9uKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHRoaXMuX2dldFRvcERyYWdLbm9iUG9zaXRpb24oKVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxEaW1lbnNpb25zID0gc3ByaXRlLmdldERpbWVuc2lvbnMoKS5jbG9uZSgpXG5cbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0ICYmIHRoaXMucHJvcHMub25EcmFnU3RhcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIGEgc3RpY2tlclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNpZGVcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Lbm9iRHJhZyAoc2lkZSwgb2Zmc2V0LCBlKSB7XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBzdGlja2VyUG9zaXRpb24gPSB0aGlzLl9nZXRBYnNvbHV0ZVNwcml0ZVBvc2l0aW9uKClcbiAgICBjb25zdCBuZXdLbm9iUG9zaXRpb24gPSB0aGlzLl9pbml0aWFsUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuYWRkKG9mZnNldClcblxuICAgIC8vIENhbGN1bGF0ZSBuZXcgcm90YXRpb24gYW5kIGRpbWVuc2lvbnMgZnJvbSBuZXcga25vYiBwb3NpdGlvblxuICAgIGNvbnN0IGtub2JEaXN0YW5jZUZyb21DZW50ZXIgPSBuZXdLbm9iUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3Qoc3RpY2tlclBvc2l0aW9uKVxuXG4gICAgY29uc3QgaW5pdGlhbEtub2JEaXN0YW5jZUZyb21DZW50ZXIgPSB0aGlzLl9pbml0aWFsUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3Qoc3RpY2tlclBvc2l0aW9uKVxuXG4gICAgaWYgKHRoaXMucHJvcHMub3B0aW9ucy5maXhlZFJhdGlvKSB7XG4gICAgICBjb25zdCBoYWxmRGltZW5zaW9ucyA9IHRoaXMuX2dldFN0aWNrZXJEaW1lbnNpb25zKClcbiAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAuYWJzKClcblxuICAgICAgY29uc3QgaW5pdGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IHRoaXMuX2luaXRpYWxQb3NpdGlvblxuICAgICAgICAuY2xvbmUoKVxuICAgICAgICAuc3VidHJhY3Qoc3RpY2tlclBvc2l0aW9uKVxuXG4gICAgICBsZXQgcmFkaWFuc1xuXG4gICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICByYWRpYW5zID0gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueSxcbiAgICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueFxuICAgICAgICAgICkgLSBNYXRoLmF0YW4yKGhhbGZEaW1lbnNpb25zLnksIGhhbGZEaW1lbnNpb25zLngpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICByYWRpYW5zID0gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueSxcbiAgICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueFxuICAgICAgICAgICkgLSBNYXRoLmF0YW4yKC1oYWxmRGltZW5zaW9ucy55LCAtaGFsZkRpbWVuc2lvbnMueClcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdEaW1lbnNpb25zID0gdGhpcy5faW5pdGlhbERpbWVuc2lvbnNcbiAgICAgICAgLmNsb25lKClcbiAgICAgICAgLm11bHRpcGx5KFxuICAgICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIubGVuKCkgLyBpbml0aWFsRGlzdGFuY2VGcm9tQ2VudGVyLmxlbigpXG4gICAgICAgIClcblxuICAgICAgc3ByaXRlLnNldCh7XG4gICAgICAgIGRpbWVuc2lvbnM6IG5ld0RpbWVuc2lvbnMsXG4gICAgICAgIHJvdGF0aW9uOiByYWRpYW5zXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB6b29tID0gdGhpcy5jb250ZXh0LmVkaXRvci56b29tLmdldCgpXG4gICAgICBjb25zdCByb3RhdGlvbiA9IHNwcml0ZS5nZXRSb3RhdGlvbigpXG4gICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyb3RhdGlvbiAqIC0xKVxuICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocm90YXRpb24gKiAtMSlcblxuICAgICAgY29uc3QgbG9jYWxEaXN0YW5jZVRvQ2VudGVyID0gbmV3IFZlY3RvcjIoXG4gICAgICAgIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueCAqIGNvcyAtIGtub2JEaXN0YW5jZUZyb21DZW50ZXIueSAqIHNpbixcbiAgICAgICAga25vYkRpc3RhbmNlRnJvbUNlbnRlci54ICogc2luICsga25vYkRpc3RhbmNlRnJvbUNlbnRlci55ICogY29zXG4gICAgICApXG5cbiAgICAgIGNvbnN0IHByZXZpb3VzTG9jYWxEaXN0YW5jZVRvQ2VudGVyID0gbmV3IFZlY3RvcjIoXG4gICAgICAgIGluaXRpYWxLbm9iRGlzdGFuY2VGcm9tQ2VudGVyLnggKiBjb3MgLSBpbml0aWFsS25vYkRpc3RhbmNlRnJvbUNlbnRlci55ICogc2luLFxuICAgICAgICBpbml0aWFsS25vYkRpc3RhbmNlRnJvbUNlbnRlci54ICogc2luICsgaW5pdGlhbEtub2JEaXN0YW5jZUZyb21DZW50ZXIueSAqIGNvc1xuICAgICAgKVxuXG4gICAgICBsZXQgZGlzdGFuY2VUb0NlbnRlckRpZmZcblxuICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgZGlzdGFuY2VUb0NlbnRlckRpZmYgPSBsb2NhbERpc3RhbmNlVG9DZW50ZXIuY2xvbmUoKVxuICAgICAgICAgICAgLnN1YnRyYWN0KHByZXZpb3VzTG9jYWxEaXN0YW5jZVRvQ2VudGVyKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgZGlzdGFuY2VUb0NlbnRlckRpZmYgPSBwcmV2aW91c0xvY2FsRGlzdGFuY2VUb0NlbnRlci5jbG9uZSgpXG4gICAgICAgICAgICAuc3VidHJhY3QobG9jYWxEaXN0YW5jZVRvQ2VudGVyKVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0RpbWVuc2lvbnMgPSB0aGlzLl9pbml0aWFsRGltZW5zaW9ucy5jbG9uZSgpXG4gICAgICAgIC5hZGQoZGlzdGFuY2VUb0NlbnRlckRpZmYuY2xvbmUoKS5kaXZpZGUoem9vbSkubXVsdGlwbHkoMikpXG5cbiAgICAgIHNwcml0ZS5zZXQoe1xuICAgICAgICBkaW1lbnNpb25zOiBuZXdEaW1lbnNpb25zXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIGEga25vYlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uS25vYkRyYWdTdG9wICgpIHtcbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0b3AgJiYgdGhpcy5wcm9wcy5vbkRyYWdTdG9wKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgcm90YXRlIGtub2JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblJvdGF0ZUtub2JEcmFnU3RhcnQgKHBvc2l0aW9uLCBlKSB7XG4gICAgdGhpcy5faW5pdGlhbFBvc2l0aW9uID0gdGhpcy5fZ2V0Um90YXRlS25vYlBvc2l0aW9uKClcbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0ICYmIHRoaXMucHJvcHMub25EcmFnU3RhcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHJvdGF0ZSBrbm9iXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Sb3RhdGVLbm9iRHJhZ1N0b3AgKCkge1xuICAgIHRoaXMucHJvcHMub25EcmFnU3RvcCAmJiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIGEgc3RpY2tlclxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblJvdGF0ZUtub2JEcmFnIChvZmZzZXQsIGUpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHN0aWNrZXJQb3NpdGlvbiA9IHRoaXMuX2dldEFic29sdXRlU3ByaXRlUG9zaXRpb24oKVxuICAgIGNvbnN0IG5ld0tub2JQb3NpdGlvbiA9IHRoaXMuX2luaXRpYWxQb3NpdGlvblxuICAgICAgLmNsb25lKClcbiAgICAgIC5hZGQob2Zmc2V0KVxuXG4gICAgY29uc3QgaGFsZkRpbWVuc2lvbnMgPSB0aGlzLl9nZXRTdGlja2VyRGltZW5zaW9ucygpXG4gICAgICAuZGl2aWRlKDIpXG5cbiAgICAvLyBDYWxjdWxhdGUgbmV3IHJvdGF0aW9uIGFuZCBkaW1lbnNpb25zIGZyb20gbmV3IGtub2IgcG9zaXRpb25cbiAgICBjb25zdCBrbm9iRGlzdGFuY2VGcm9tQ2VudGVyID0gbmV3S25vYlBvc2l0aW9uXG4gICAgICAuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KHN0aWNrZXJQb3NpdGlvbilcblxuICAgIGxldCByYWRpYW5zXG4gICAgcmFkaWFucyA9IE1hdGguYXRhbjIoXG4gICAgICBrbm9iRGlzdGFuY2VGcm9tQ2VudGVyLnksXG4gICAgICBrbm9iRGlzdGFuY2VGcm9tQ2VudGVyLnhcbiAgICApIC0gTWF0aC5hdGFuMigtaGFsZkRpbWVuc2lvbnMueSwgaGFsZkRpbWVuc2lvbnMueClcblxuICAgIHNwcml0ZS5zZXQoe1xuICAgICAgcm90YXRpb246IHJhZGlhbnNcbiAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU1RZTElOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSBib3R0b20gcmlnaHQgZHJhZyBrbm9iXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRCb3R0b21EcmFnS25vYlN0eWxlICgpIHtcbiAgICBjb25zdCBrbm9iUG9zaXRpb24gPSB0aGlzLl9nZXRCb3R0b21EcmFnS25vYlBvc2l0aW9uKClcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBrbm9iUG9zaXRpb24ueCxcbiAgICAgIHRvcDoga25vYlBvc2l0aW9uLnlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGUgb2JqZWN0IGZvciB0aGUgdG9wIHJpZ2h0IGRyYWcga25vYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VG9wRHJhZ0tub2JTdHlsZSAoKSB7XG4gICAgY29uc3Qga25vYlBvc2l0aW9uID0gdGhpcy5fZ2V0VG9wRHJhZ0tub2JQb3NpdGlvbigpXG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDoga25vYlBvc2l0aW9uLngsXG4gICAgICB0b3A6IGtub2JQb3NpdGlvbi55XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0eWxlIG9iamVjdCBmb3IgdGhlIHJvdGF0ZSBrbm9iXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSb3RhdGVLbm9iU3R5bGUgKCkge1xuICAgIGNvbnN0IGtub2JQb3NpdGlvbiA9IHRoaXMuX2dldFJvdGF0ZUtub2JQb3NpdGlvbigpXG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDoga25vYlBvc2l0aW9uLngsXG4gICAgICB0b3A6IGtub2JQb3NpdGlvbi55XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgc3R5bGUgb2JqZWN0IGZvciB0aGlzIHN0aWNrZXJcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFN0aWNrZXJTdHlsZSAoKSB7XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcblxuICAgIGNvbnN0IHByb2Nlc3NlZERpbWVuc2lvbnMgPSB0aGlzLl9nZXRTdGlja2VyRGltZW5zaW9ucygpXG4gICAgICAuYWJzKClcbiAgICBjb25zdCBzcHJpdGVQb3NpdGlvbiA9IHRoaXMuX2dldEFic29sdXRlU3ByaXRlUG9zaXRpb24oKVxuICAgICAgLnN1YnRyYWN0KHByb2Nlc3NlZERpbWVuc2lvbnMuY2xvbmUoKS5kaXZpZGUoMikpXG5cbiAgICBjb25zdCBkZWdyZWVzID0gc3ByaXRlLmdldFJvdGF0aW9uKCkgKiAxODAgLyBNYXRoLlBJXG4gICAgbGV0IHRyYW5zZm9ybSA9IGByb3RhdGUoJHtkZWdyZWVzLnRvRml4ZWQoMil9ZGVnKWBcblxuICAgIGNvbnN0IHNwcml0ZURpbWVuc2lvbnMgPSBzcHJpdGUuZ2V0RGltZW5zaW9ucygpXG5cbiAgICBsZXQgZmxpcFZlcnRpY2FsbHkgPSBzcHJpdGUuZ2V0RmxpcFZlcnRpY2FsbHkoKVxuICAgIGlmIChzcHJpdGVEaW1lbnNpb25zLnkgPCAwKSBmbGlwVmVydGljYWxseSA9ICFmbGlwVmVydGljYWxseVxuICAgIGlmIChmbGlwVmVydGljYWxseSkge1xuICAgICAgdHJhbnNmb3JtICs9ICcgc2NhbGVZKC0xKSdcbiAgICB9XG5cbiAgICBsZXQgZmxpcEhvcml6b250YWxseSA9IHNwcml0ZS5nZXRGbGlwSG9yaXpvbnRhbGx5KClcbiAgICBpZiAoc3ByaXRlRGltZW5zaW9ucy54IDwgMCkgZmxpcEhvcml6b250YWxseSA9ICFmbGlwSG9yaXpvbnRhbGx5XG4gICAgaWYgKGZsaXBIb3Jpem9udGFsbHkpIHtcbiAgICAgIHRyYW5zZm9ybSArPSAnIHNjYWxlWCgtMSknXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogc3ByaXRlUG9zaXRpb24ueSxcbiAgICAgIGxlZnQ6IHNwcml0ZVBvc2l0aW9uLngsXG4gICAgICB3aWR0aDogcHJvY2Vzc2VkRGltZW5zaW9ucy54LFxuICAgICAgaGVpZ2h0OiBwcm9jZXNzZWREaW1lbnNpb25zLnksXG4gICAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIG1zVHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBNb3pUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIE9UcmFuc2Zvcm06IHRyYW5zZm9ybVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENBTENVTEFUSU9OU1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzdGlja2VyIGRpbWVuc2lvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzdGlja2VyXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0U3RpY2tlckRpbWVuc2lvbnMgKCkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgcmV0dXJuIHNwcml0ZS5nZXREaW1lbnNpb25zKClcbiAgICAgIC5jbG9uZSgpXG4gICAgICAubXVsdGlwbHkoZWRpdG9yLnpvb20uZ2V0KCkpXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcm90YXRlIGJ1dHRvbiBrbm9iJ3MgcG9zaXRpb25cbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJvdGF0ZUtub2JQb3NpdGlvbiAoKSB7XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBzdGlja2VyUG9zaXRpb24gPSB0aGlzLl9nZXRBYnNvbHV0ZVNwcml0ZVBvc2l0aW9uKClcbiAgICBjb25zdCBzdGlja2VyUm90YXRpb24gPSBzcHJpdGUuZ2V0Um90YXRpb24oKVxuXG4gICAgLy8gQ2FsY3VsYXRlIHNpbiBhbmQgY29zIGZvciByb3RhdGlvblxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHN0aWNrZXJSb3RhdGlvbiB8fCAwKVxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHN0aWNrZXJSb3RhdGlvbiB8fCAwKVxuXG4gICAgLy8gQ2FsY3VsYXRlIHN0aWNrZXIgZGltZW5zaW9uc1xuICAgIGNvbnN0IGhhbGZEaW1lbnNpb25zID0gdGhpcy5fZ2V0U3RpY2tlckRpbWVuc2lvbnMoKVxuICAgICAgLmRpdmlkZSgyKVxuXG4gICAgLy8gQ2FsY3VsYXRlIGtub2IgcG9zaXRpb25cbiAgICByZXR1cm4gc3RpY2tlclBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5hZGQoXG4gICAgICAgIGhhbGZEaW1lbnNpb25zLnggKiBjb3MgKyBoYWxmRGltZW5zaW9ucy55ICogc2luLFxuICAgICAgICBoYWxmRGltZW5zaW9ucy54ICogc2luIC0gaGFsZkRpbWVuc2lvbnMueSAqIGNvc1xuICAgICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGRyYWcgYm90dG9tIHJpZ2h0IGtub2IncyBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEJvdHRvbURyYWdLbm9iUG9zaXRpb24gKCkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3Qgc3RpY2tlclBvc2l0aW9uID0gdGhpcy5fZ2V0QWJzb2x1dGVTcHJpdGVQb3NpdGlvbigpXG4gICAgY29uc3Qgc3RpY2tlclJvdGF0aW9uID0gc3ByaXRlLmdldFJvdGF0aW9uKClcblxuICAgIC8vIENhbGN1bGF0ZSBzaW4gYW5kIGNvcyBmb3Igcm90YXRpb25cbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihzdGlja2VyUm90YXRpb24gfHwgMClcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhzdGlja2VyUm90YXRpb24gfHwgMClcblxuICAgIC8vIENhbGN1bGF0ZSBzdGlja2VyIGRpbWVuc2lvbnNcbiAgICBjb25zdCBoYWxmRGltZW5zaW9ucyA9IHRoaXMuX2dldFN0aWNrZXJEaW1lbnNpb25zKClcbiAgICAgIC5kaXZpZGUoMilcblxuICAgIC8vIENhbGN1bGF0ZSBrbm9iIHBvc2l0aW9uXG4gICAgcmV0dXJuIHN0aWNrZXJQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAuYWRkKFxuICAgICAgICBoYWxmRGltZW5zaW9ucy54ICogY29zIC0gaGFsZkRpbWVuc2lvbnMueSAqIHNpbixcbiAgICAgICAgaGFsZkRpbWVuc2lvbnMueCAqIHNpbiArIGhhbGZEaW1lbnNpb25zLnkgKiBjb3NcbiAgICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBkcmFnIHRvcCByaWdodCBrbm9iJ3MgcG9zaXRpb25cbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRUb3BEcmFnS25vYlBvc2l0aW9uICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHN0aWNrZXJQb3NpdGlvbiA9IHRoaXMuX2dldEFic29sdXRlU3ByaXRlUG9zaXRpb24oKVxuICAgIGNvbnN0IHN0aWNrZXJSb3RhdGlvbiA9IHNwcml0ZS5nZXRSb3RhdGlvbigpXG5cbiAgICAvLyBDYWxjdWxhdGUgc2luIGFuZCBjb3MgZm9yIHJvdGF0aW9uXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oc3RpY2tlclJvdGF0aW9uIHx8IDApXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3Moc3RpY2tlclJvdGF0aW9uIHx8IDApXG5cbiAgICAvLyBDYWxjdWxhdGUgc3RpY2tlciBkaW1lbnNpb25zXG4gICAgY29uc3QgaGFsZkRpbWVuc2lvbnMgPSB0aGlzLl9nZXRTdGlja2VyRGltZW5zaW9ucyhzcHJpdGUpXG4gICAgICAuZGl2aWRlKDIpXG5cbiAgICAvLyBDYWxjdWxhdGUga25vYiBwb3NpdGlvblxuICAgIHJldHVybiBzdGlja2VyUG9zaXRpb24uY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KFxuICAgICAgICBoYWxmRGltZW5zaW9ucy54ICogY29zIC0gaGFsZkRpbWVuc2lvbnMueSAqIHNpbixcbiAgICAgICAgaGFsZkRpbWVuc2lvbnMueCAqIHNpbiArIGhhbGZEaW1lbnNpb25zLnkgKiBjb3NcbiAgICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBrbm9icyBmb3IgdGhpcyBpdGVtXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJLbm9icyAoKSB7XG4gICAgbGV0IGtub2JzID0gW11cbiAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3RlZCkge1xuICAgICAga25vYnMgPSBbXG4gICAgICAgICg8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgb25TdGFydD17dGhpcy5fb25Lbm9iRHJhZ1N0YXJ0LmJpbmQodGhpcywgJ2JvdHRvbScpfVxuICAgICAgICAgIG9uU3RvcD17dGhpcy5fb25Lbm9iRHJhZ1N0b3AuYmluZCh0aGlzLCAnYm90dG9tJyl9XG4gICAgICAgICAgb25EcmFnPXt0aGlzLl9vbktub2JEcmFnLmJpbmQodGhpcywgJ2JvdHRvbScpfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTprbm9iICRiOmtub2InIHN0eWxlPXt0aGlzLl9nZXRCb3R0b21EcmFnS25vYlN0eWxlKCl9PlxuICAgICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL2tub2JzL3Jlc2l6ZS1kaWFnb25hbC1kb3duLnBuZycsIHRydWUpfSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD4pLFxuICAgICAgICAoPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uS25vYkRyYWdTdGFydC5iaW5kKHRoaXMsICd0b3AnKX1cbiAgICAgICAgICBvblN0b3A9e3RoaXMuX29uS25vYkRyYWdTdG9wLmJpbmQodGhpcywgJ3RvcCcpfVxuICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25Lbm9iRHJhZy5iaW5kKHRoaXMsICd0b3AnKX0+XG4gICAgICAgICAgPGRpdiBiZW09J2U6a25vYiAkYjprbm9iJyBzdHlsZT17dGhpcy5fZ2V0VG9wRHJhZ0tub2JTdHlsZSgpfT5cbiAgICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9rbm9icy9yZXNpemUtZGlhZ29uYWwtZG93bi5wbmcnLCB0cnVlKX0gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+KVxuICAgICAgXVxuXG4gICAgICBpZiAoIXRoaXMucHJvcHMub3B0aW9ucy5maXhlZFJhdGlvKSB7XG4gICAgICAgIGtub2JzLnB1c2goXG4gICAgICAgICAgKDxEcmFnZ2FibGVDb21wb25lbnRcbiAgICAgICAgICAgIG9uU3RhcnQ9e3RoaXMuX29uUm90YXRlS25vYkRyYWdTdGFydH1cbiAgICAgICAgICAgIG9uU3RvcD17dGhpcy5fb25Sb3RhdGVLbm9iRHJhZ1N0b3B9XG4gICAgICAgICAgICBvbkRyYWc9e3RoaXMuX29uUm90YXRlS25vYkRyYWd9PlxuICAgICAgICAgICAgPGRpdiBiZW09J2U6a25vYiAkYjprbm9iJyBzdHlsZT17dGhpcy5fZ2V0Um90YXRlS25vYlN0eWxlKCl9PlxuICAgICAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMva25vYnMvcm90YXRlLnBuZycsIHRydWUpfSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+KVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbm9ic1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIFNWRyBmaWx0ZXJzXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU1ZHRmlsdGVyICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IGFkanVzdG1lbnRzID0gc3ByaXRlLmdldEFkanVzdG1lbnRzKClcbiAgICBjb25zdCBicmlnaHRuZXNzID0gYWRqdXN0bWVudHMuZ2V0QnJpZ2h0bmVzcygpXG4gICAgY29uc3Qgc2F0dXJhdGlvbiA9IGFkanVzdG1lbnRzLmdldFNhdHVyYXRpb24oKVxuICAgIGNvbnN0IGNvbnRyYXN0ID0gYWRqdXN0bWVudHMuZ2V0Q29udHJhc3QoKVxuXG4gICAgY29uc3QgZmlsdGVyc1NWRyA9IChcbiAgICAgIGA8ZmlsdGVyIGlkPSdwZXNkay1zdGlja2VyLSR7dGhpcy5faWR9LWZpbHRlcic+XG4gICAgICAgIDxmZUNvbXBvbmVudFRyYW5zZmVyPlxuICAgICAgICAgIDxmZUZ1bmNSIHR5cGU9J2xpbmVhcicgaW50ZXJjZXB0PScke2JyaWdodG5lc3N9JyAvPlxuICAgICAgICAgIDxmZUZ1bmNHIHR5cGU9J2xpbmVhcicgaW50ZXJjZXB0PScke2JyaWdodG5lc3N9JyAvPlxuICAgICAgICAgIDxmZUZ1bmNCIHR5cGU9J2xpbmVhcicgaW50ZXJjZXB0PScke2JyaWdodG5lc3N9JyAvPlxuICAgICAgICA8L2ZlQ29tcG9uZW50VHJhbnNmZXI+XG4gICAgICAgIDxmZUNvbG9yTWF0cml4IHR5cGU9J3NhdHVyYXRlJyB2YWx1ZXM9JyR7c2F0dXJhdGlvbn0nIC8+XG4gICAgICAgIDxmZUNvbXBvbmVudFRyYW5zZmVyPlxuICAgICAgICAgIDxmZUZ1bmNSIHR5cGU9J2xpbmVhcicgc2xvcGU9JyR7Y29udHJhc3R9JyBpbnRlcmNlcHQ9JyR7LSgwLjUgKiBjb250cmFzdCkgKyAwLjV9JyAvPlxuICAgICAgICAgIDxmZUZ1bmNHIHR5cGU9J2xpbmVhcicgc2xvcGU9JyR7Y29udHJhc3R9JyBpbnRlcmNlcHQ9JyR7LSgwLjUgKiBjb250cmFzdCkgKyAwLjV9JyAvPlxuICAgICAgICAgIDxmZUZ1bmNCIHR5cGU9J2xpbmVhcicgc2xvcGU9JyR7Y29udHJhc3R9JyBpbnRlcmNlcHQ9JyR7LSgwLjUgKiBjb250cmFzdCkgKyAwLjV9JyAvPlxuICAgICAgICA8L2ZlQ29tcG9uZW50VHJhbnNmZXI+XG4gICAgICA8L2ZpbHRlcj5gXG4gICAgKVxuXG4gICAgLy8gV2UgYWRkZWQgYGtleTogTWF0aC5yYW5kb20oKWAgYmVjYXVzZSBpbiBTYWZhcmksIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXG4gICAgLy8gd291bGQgbm90IHVwZGF0ZSB3aXRob3V0IHRoYXQuLi5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzI4NjNcbiAgICByZXR1cm4gKDxzdmcgd2lkdGg9JzAnIGhlaWdodD0nMCcgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSdzUkdCJyBpcz0nc3ZnJz5cbiAgICAgIHtSZWFjdEJFTS5jcmVhdGVFbGVtZW50KCdkZWZzJywge1xuICAgICAgICBrZXk6IE1hdGgucmFuZG9tKCksXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgX19odG1sOiBmaWx0ZXJzU1ZHXG4gICAgICAgIH1cbiAgICAgIH0pfVxuICAgIDwvc3ZnPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBkcmFnZ2FibGUgaXRlbVxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckl0ZW0gKCkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3Qgc3RpY2tlclN0eWxlID0gdGhpcy5fZ2V0U3RpY2tlclN0eWxlKClcbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLnByb3BzLnNlbGVjdGVkID8gJ2lzLXNlbGVjdGVkJyA6IG51bGxcblxuICAgIGNvbnN0IGJhc2VVUkwgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5oYXNoLCAnJylcbiAgICBjb25zdCBzdGlja2VySW1hZ2VTdHlsZSA9IHsgZmlsdGVyOiBgdXJsKFwiJHtiYXNlVVJMfSNwZXNkay1zdGlja2VyLSR7dGhpcy5faWR9LWZpbHRlclwiKWAgfVxuXG4gICAgcmV0dXJuICg8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICBvblN0YXJ0PXt0aGlzLl9vbkl0ZW1EcmFnU3RhcnR9XG4gICAgICBvblN0b3A9e3RoaXMuX29uSXRlbURyYWdTdG9wfVxuICAgICAgb25EcmFnPXt0aGlzLl9vbkl0ZW1EcmFnfVxuICAgICAgZGlzYWJsZWQ9eyF0aGlzLnByb3BzLnNlbGVjdGVkfT5cbiAgICAgIDxkaXZcbiAgICAgICAgYmVtPSckZTpzdGlja2VyJ1xuICAgICAgICBzdHlsZT17c3RpY2tlclN0eWxlfVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgIDxzdmcgd2lkdGg9e3N0aWNrZXJTdHlsZS53aWR0aH0gaGVpZ2h0PXtzdGlja2VyU3R5bGUuaGVpZ2h0fSBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9J3NSR0InIGlzPSdzdmcnPlxuICAgICAgICAgIHtSZWFjdEJFTS5jcmVhdGVFbGVtZW50KCdpbWFnZScsIHtcbiAgICAgICAgICAgIHhsaW5rSHJlZjogc3ByaXRlLmdldEltYWdlKCkuc3JjLFxuICAgICAgICAgICAgd2lkdGg6IHN0aWNrZXJTdHlsZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogc3RpY2tlclN0eWxlLmhlaWdodCxcbiAgICAgICAgICAgIHN0eWxlOiBzdGlja2VySW1hZ2VTdHlsZVxuICAgICAgICAgIH0pfVxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvZGl2PlxuICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSdiOnNwcml0ZXNDYW52YXNDb250cm9scyc+XG4gICAgICA8ZGl2IGJlbT0nJGU6aXRlbSBlOmNvbnRhaW5lcic+XG4gICAgICAgIHt0aGlzLl9yZW5kZXJTVkdGaWx0ZXIoKX1cbiAgICAgICAge3RoaXMuX3JlbmRlckl0ZW0oKX1cbiAgICAgICAge3RoaXMuX3JlbmRlcktub2JzKCl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuU3RpY2tlckl0ZW1Db21wb25lbnQuY29udGV4dFR5cGVzID0gSXRlbUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc3ByaXRlcy9pdGVtcy9zdGlja2VyLWl0ZW0tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFV0aWxzLCBSZWFjdEJFTSwgbm93IH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBEcmFnZ2FibGVDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vZHJhZ2dhYmxlLWNvbXBvbmVudCdcbmltcG9ydCBJdGVtQ29tcG9uZW50IGZyb20gJy4vaXRlbS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRJdGVtQ29tcG9uZW50IGV4dGVuZHMgSXRlbUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uVGV4dENoYW5nZScsXG4gICAgICAnX29uSXRlbURvdWJsZUNsaWNrJyxcbiAgICAgICdfb25JdGVtVG91Y2hTdGFydCcsXG4gICAgICAnX29uSXRlbVRvdWNoRW5kJyxcbiAgICAgICdfb25SZXNpemVLbm9iRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25SZXNpemVLbm9iRHJhZycsXG4gICAgICAnX29uUmVzaXplS25vYkRyYWdTdG9wJyxcbiAgICAgICdfb25Sb3RhdGlvbktub2JEcmFnU3RhcnQnLFxuICAgICAgJ19vblJvdGF0aW9uS25vYkRyYWcnLFxuICAgICAgJ19vblJvdGF0aW9uS25vYkRyYWdTdG9wJ1xuICAgIClcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlZGl0TW9kZTogZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgdGV4dFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uVGV4dENoYW5nZSAoZSkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgc3ByaXRlLnNldFRleHQoZS50YXJnZXQudmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIHRoZSB0ZXh0LiBUdXJucyB0aGUgc3ByaXRlIGludG9cbiAgICogZWRpdGluZyBtb2RlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uSXRlbURvdWJsZUNsaWNrICgpIHtcbiAgICB0aGlzLmVudGVyRWRpdE1vZGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEVudGVycyB0aGUgZWRpdCBtb2RlXG4gICAqL1xuICBlbnRlckVkaXRNb2RlICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGlmICghc3ByaXRlLl9lZGl0ZWQpIHtcbiAgICAgIHNwcml0ZS5zZXRUZXh0KCcnKVxuICAgICAgdGhpcy5yZWZzLnRleHRhcmVhLnZhbHVlID0gJydcbiAgICAgIHNwcml0ZS5fZWRpdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoeyBlZGl0TW9kZTogdHJ1ZSB9LCAoKSA9PiB7XG4gICAgICB0aGlzLnJlZnMudGV4dGFyZWEuZm9jdXMoKVxuICAgICAgdGhpcy5yZWZzLnRleHRhcmVhLnNlbGVjdCgpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyB0b3VjaGluZyB0aGUgaXRlbVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25JdGVtVG91Y2hTdGFydCAoZSkge1xuICAgIHRoaXMuX2luaXRpYWxUb3VjaFBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlKVxuICAgIHRoaXMuX3RhcFN0YXJ0QXQgPSBub3coKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgdG91Y2hpbmcgdGhlIGl0ZW1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkl0ZW1Ub3VjaEVuZCAoKSB7XG4gICAgLy8gUmVjb2duaXplIGRvdWJsZSB0YXBcbiAgICBpZiAobm93KCkgLSB0aGlzLl90YXBTdGFydEF0IDw9IDEwMCkge1xuICAgICAgLy8gVG91Y2ggZGlkbid0IGxhc3QgbG9uZ2VyIHRoYW4gMTAwbXMgPT4gcmVjb2duaXplZCBhcyB0YXBcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fbGFzdFRhcEF0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgIG5vdygpIC0gdGhpcy5fbGFzdFRhcEF0IDw9IDMwMCkge1xuICAgICAgICAvLyBMYXN0IHRhcCB3YXMgbm8gbG9uZ2VyIHRoYW4gMzAwbXMgYWdvID0+IHJlY29nbml6ZWQgYXMgZG91YmxlIHRhcFxuICAgICAgICB0aGlzLl9vbkl0ZW1Eb3VibGVDbGljaygpXG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0VGFwQXQgPSBub3coKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJPVEFUSU9OIERSQUdHSU5HXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSByZXNpemUga25vYlxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUm90YXRpb25Lbm9iRHJhZ1N0YXJ0IChwb3NpdGlvbiwgZSkge1xuICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZVxuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHRoaXMuX2dldFJvdGF0aW9uS25vYlBvc2l0aW9uKClcblxuICAgIHRoaXMucHJvcHMub25EcmFnU3RhcnQgJiYgdGhpcy5wcm9wcy5vbkRyYWdTdGFydCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hpbGUgdGhlIHVzZXIgcm90YXRlcyB0aGUgdGV4dFxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvZmZzZXRcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblJvdGF0aW9uS25vYkRyYWcgKG9mZnNldCwgZSkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgY29uc3Qgc3ByaXRlUG9zaXRpb24gPSB0aGlzLl9nZXRBYnNvbHV0ZVNwcml0ZVBvc2l0aW9uKClcbiAgICBjb25zdCBuZXdLbm9iUG9zaXRpb24gPSB0aGlzLl9pbml0aWFsUG9zaXRpb25cbiAgICAgIC5jbG9uZSgpXG4gICAgICAuYWRkKG9mZnNldClcblxuICAgIC8vIENhbGN1bGF0ZSBuZXcgcm90YXRpb24gYW5kIHNjYWxlIGZyb20gbmV3IGtub2IgcG9zaXRpb25cbiAgICBjb25zdCBrbm9iRGlzdGFuY2VGcm9tQ2VudGVyID0gbmV3S25vYlBvc2l0aW9uXG4gICAgICAuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KHNwcml0ZVBvc2l0aW9uKVxuXG4gICAgY29uc3QgYm91bmRpbmdCb3ggPSBzcHJpdGUuZ2V0Qm91bmRpbmdCb3goZWRpdG9yLmdldFNESygpLCBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpKVxuICAgIGNvbnN0IHJhZGlhbnMgPSBNYXRoLmF0YW4yKFxuICAgICAga25vYkRpc3RhbmNlRnJvbUNlbnRlci55LFxuICAgICAga25vYkRpc3RhbmNlRnJvbUNlbnRlci54XG4gICAgKSAtIE1hdGguYXRhbjIoYm91bmRpbmdCb3gueSwgYm91bmRpbmdCb3gueCAvIDIpXG5cbiAgICBzcHJpdGUuc2V0Um90YXRpb24ocmFkaWFucylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIHJvdGF0aW5nIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Sb3RhdGlvbktub2JEcmFnU3RvcCAoZSkge1xuICAgIHRoaXMucHJvcHMub25EcmFnU3RvcCAmJiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVTSVpFIERSQUdHSU5HXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIHJlc2l6aW5nIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25SZXNpemVLbm9iRHJhZ1N0YXJ0IChwb3NpdGlvbiwgZSkge1xuICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHRoaXMuX2dldFJlc2l6ZUtub2JQb3NpdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0ICYmIHRoaXMucHJvcHMub25EcmFnU3RhcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoaWxlIHRoZSB1c2VyIHJlc2l6ZXMgdGhlIHRleHRcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gb2Zmc2V0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25SZXNpemVLbm9iRHJhZyAob2Zmc2V0LCBlKSB7XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB0ZXh0Um90YXRpb24gPSBzcHJpdGUuZ2V0Um90YXRpb24oKVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBlZGl0b3IuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyh0ZXh0Um90YXRpb24pXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4odGV4dFJvdGF0aW9uKVxuXG4gICAgY29uc3QgbmV3S25vYlBvc2l0aW9uID0gdGhpcy5faW5pdGlhbFBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5hZGQob2Zmc2V0KVxuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fZ2V0QWJzb2x1dGVTcHJpdGVQb3NpdGlvbigpXG4gICAgY29uc3QgZGlzdGFuY2VUb1Bvc2l0aW9uID0gbmV3S25vYlBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChwb3NpdGlvbilcblxuICAgIGNvbnN0IG5ld01heFdpZHRoID0gTWF0aC5tYXgoXG4gICAgICAoZGlzdGFuY2VUb1Bvc2l0aW9uLnggKiBjb3MgKyBkaXN0YW5jZVRvUG9zaXRpb24ueSAqIHNpbikgLyBvdXRwdXREaW1lbnNpb25zLnggKiAyLFxuICAgICAgMC4xXG4gICAgKVxuICAgIHNwcml0ZS5zZXRNYXhXaWR0aChuZXdNYXhXaWR0aClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIHJlc2l6aW5nIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25SZXNpemVLbm9iRHJhZ1N0b3AgKGUpIHtcbiAgICB0aGlzLnByb3BzLm9uRHJhZ1N0b3AgJiYgdGhpcy5wcm9wcy5vbkRyYWdTdG9wKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUWUxJTkdcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGUgb2JqZWN0IGZvciB0aGUgcm90YXRpb24ga25vYlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Um90YXRpb25Lbm9iU3R5bGUgKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fZ2V0Um90YXRpb25Lbm9iUG9zaXRpb24oKVxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBwb3NpdGlvbi54LFxuICAgICAgdG9wOiBwb3NpdGlvbi55XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0eWxlIG9iamVjdCBmb3IgdGhlIHJlc2l6ZSBrbm9iXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSZXNpemVLbm9iU3R5bGUgKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fZ2V0UmVzaXplS25vYlBvc2l0aW9uKClcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogcG9zaXRpb24ueCxcbiAgICAgIHRvcDogcG9zaXRpb24ueVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSBnaXZlbiB0ZXh0IG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VGV4dFN0eWxlICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBzZGsgPSBlZGl0b3IuZ2V0U0RLKClcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IHN0eWxlID0gc3ByaXRlLmdldERPTVN0eWxlKHNkaywgb3V0cHV0RGltZW5zaW9ucylcblxuICAgIGNvbnN0IHNwcml0ZVBvc2l0aW9uID0gdGhpcy5fZ2V0QWJzb2x1dGVTcHJpdGVQb3NpdGlvbigpXG4gICAgY29uc3QgYm91bmRpbmdCb3ggPSBzcHJpdGUuZ2V0Qm91bmRpbmdCb3goc2RrLCBvdXRwdXREaW1lbnNpb25zKVxuICAgIHN0eWxlLmhlaWdodCA9IE1hdGgubWluKGJvdW5kaW5nQm94LnksIG91dHB1dERpbWVuc2lvbnMueSAtIHNwcml0ZVBvc2l0aW9uLnkpXG5cbiAgICByZXR1cm4gc3R5bGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBvYmplY3QgZm9yIHRoZSBpdGVtIGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SXRlbUNvbnRhaW5lclN0eWxlICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcblxuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgdGV4dFBvc2l0aW9uID0gc3ByaXRlLmdldFBvc2l0aW9uKCkuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG5cbiAgICBjb25zdCBkZWdyZWVzID0gc3ByaXRlLmdldFJvdGF0aW9uKCkgKiAxODAgLyBNYXRoLlBJXG4gICAgY29uc3QgdHJhbnNmb3JtID0gYHJvdGF0ZVooJHtkZWdyZWVzLnRvRml4ZWQoMil9ZGVnKWBcbiAgICBjb25zdCB0cmFuc2Zvcm1PcmlnaW4gPSAnNTAlIDAnXG5cbiAgICBjb25zdCBtYXhXaWR0aCA9IHNwcml0ZS5nZXRNYXhXaWR0aCgpICogb3V0cHV0RGltZW5zaW9ucy54XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgIGxlZnQ6IHRleHRQb3NpdGlvbi54LFxuICAgICAgdG9wOiB0ZXh0UG9zaXRpb24ueSxcbiAgICAgIG1hcmdpbkxlZnQ6IG1heFdpZHRoICogLTAuNSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgTW96VHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBtc1RyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbixcbiAgICAgIE1velRyYW5zZm9ybU9yaWdpbjogdHJhbnNmb3JtT3JpZ2luLFxuICAgICAgbXNUcmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbixcbiAgICAgIFdlYmtpdFRyYW5zZm9ybU9yaWdpbjogdHJhbnNmb3JtT3JpZ2luXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ0FMQ1VMQVRJT05TXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSByb3RhdGlvbiBrbm9iXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Um90YXRpb25Lbm9iUG9zaXRpb24gKCkge1xuICAgIGNvbnN0IHsgc3ByaXRlIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oc3ByaXRlLmdldFJvdGF0aW9uKCkpXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3Moc3ByaXRlLmdldFJvdGF0aW9uKCkpXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gc3ByaXRlLmdldEJvdW5kaW5nQm94KGVkaXRvci5nZXRTREsoKSwgb3V0cHV0RGltZW5zaW9ucylcbiAgICBjb25zdCBoYWxmRGltZW5zaW9ucyA9IGJvdW5kaW5nQm94LmNsb25lKCkuZGl2aWRlKDIpXG4gICAgY29uc3QgcG9zaXRpb24gPSBzcHJpdGUuZ2V0UG9zaXRpb24oKVxuICAgICAgLmNsb25lKClcbiAgICAgIC5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKVxuICAgICAgLmFkZChcbiAgICAgICAgaGFsZkRpbWVuc2lvbnMueCAqIGNvcyAtIGJvdW5kaW5nQm94LnkgKiBzaW4sXG4gICAgICAgIGhhbGZEaW1lbnNpb25zLnggKiBzaW4gKyBib3VuZGluZ0JveC55ICogY29zXG4gICAgICApXG4gICAgcmV0dXJuIHBvc2l0aW9uXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHJlc2l6ZSBrbm9iXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0UmVzaXplS25vYlBvc2l0aW9uICgpIHtcbiAgICBjb25zdCB7IHNwcml0ZSB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcblxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHNwcml0ZS5nZXRSb3RhdGlvbigpKVxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHNwcml0ZS5nZXRSb3RhdGlvbigpKVxuXG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBib3VuZGluZ0JveCA9IHNwcml0ZS5nZXRCb3VuZGluZ0JveChlZGl0b3IuZ2V0U0RLKCksIG91dHB1dERpbWVuc2lvbnMpXG4gICAgY29uc3QgaGFsZkRpbWVuc2lvbnMgPSBib3VuZGluZ0JveC5jbG9uZSgpLmRpdmlkZSgyKVxuICAgIGNvbnN0IHBvc2l0aW9uID0gc3ByaXRlLmdldFBvc2l0aW9uKClcbiAgICAgIC5jbG9uZSgpXG4gICAgICAubXVsdGlwbHkob3V0cHV0RGltZW5zaW9ucylcbiAgICAgIC5hZGQoXG4gICAgICAgIGhhbGZEaW1lbnNpb25zLnggKiBjb3MsXG4gICAgICAgIGhhbGZEaW1lbnNpb25zLnggKiBzaW5cbiAgICAgIClcbiAgICByZXR1cm4gcG9zaXRpb25cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBrbm9icyBmb3IgdGhpcyBpdGVtXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJLbm9icyAoKSB7XG4gICAgbGV0IGtub2JzID0gW11cbiAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3RlZCAmJiAhdGhpcy5zdGF0ZS5lZGl0TW9kZSkge1xuICAgICAga25vYnMgPSBbXG4gICAgICAgICg8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgb25TdGFydD17dGhpcy5fb25Sb3RhdGlvbktub2JEcmFnU3RhcnR9XG4gICAgICAgICAgb25EcmFnPXt0aGlzLl9vblJvdGF0aW9uS25vYkRyYWd9XG4gICAgICAgICAgb25TdG9wPXt0aGlzLl9vblJvdGF0aW9uS25vYkRyYWdTdG9wfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTprbm9iIG06cm90YXRlICRiOmtub2InIHN0eWxlPXt0aGlzLl9nZXRSb3RhdGlvbktub2JTdHlsZSgpfT5cbiAgICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24gbTpsYXJnZXInIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9rbm9icy9yb3RhdGUucG5nJywgdHJ1ZSl9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvRHJhZ2dhYmxlQ29tcG9uZW50PiksXG4gICAgICAgICg8RHJhZ2dhYmxlQ29tcG9uZW50XG4gICAgICAgICAgb25TdGFydD17dGhpcy5fb25SZXNpemVLbm9iRHJhZ1N0YXJ0fVxuICAgICAgICAgIG9uRHJhZz17dGhpcy5fb25SZXNpemVLbm9iRHJhZ31cbiAgICAgICAgICBvblN0b3A9e3RoaXMuX29uUmVzaXplS25vYkRyYWdTdG9wfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTprbm9iIG06cmVzaXplICRiOmtub2InIHN0eWxlPXt0aGlzLl9nZXRSZXNpemVLbm9iU3R5bGUoKX0+XG4gICAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMva25vYnMvcmVzaXplLWRpYWdvbmFsLXVwLnBuZycsIHRydWUpfSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0RyYWdnYWJsZUNvbXBvbmVudD4pXG4gICAgICBdXG4gICAgfVxuICAgIHJldHVybiBrbm9ic1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGRyYWdnYWJsZSBpdGVtXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVySXRlbSAoKSB7XG4gICAgY29uc3QgeyBzcHJpdGUgfSA9IHRoaXMucHJvcHNcblxuICAgIGxldCBjb250ZW50ID0gW11cbiAgICBjb250ZW50ID0gWyg8dGV4dGFyZWFcbiAgICAgIGJlbT0nZTpjb250ZW50J1xuICAgICAgcmVmPSd0ZXh0YXJlYSdcbiAgICAgIHN0eWxlPXt0aGlzLl9nZXRUZXh0U3R5bGUoKX1cbiAgICAgIGRlZmF1bHRWYWx1ZT17c3ByaXRlLmdldFRleHQoKX1cbiAgICAgIGRpc2FibGVkPXshdGhpcy5zdGF0ZS5lZGl0TW9kZX1cbiAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vblRleHRDaGFuZ2V9IC8+KV1cblxuICAgIGlmICghdGhpcy5zdGF0ZS5lZGl0TW9kZSkge1xuICAgICAgY29udGVudC5wdXNoKDxkaXZcbiAgICAgICAgYmVtPSdlOmRpc2FibGVkT3ZlcmxheSdcbiAgICAgICAgb25Eb3VibGVDbGljaz17dGhpcy5fb25JdGVtRG91YmxlQ2xpY2t9XG4gICAgICAgIG9uVG91Y2hTdGFydD17dGhpcy5fb25JdGVtVG91Y2hTdGFydH1cbiAgICAgICAgb25Ub3VjaEVuZD17dGhpcy5fb25JdGVtVG91Y2hFbmR9IC8+KVxuICAgIH1cblxuICAgIHJldHVybiAoPERyYWdnYWJsZUNvbXBvbmVudFxuICAgICAgb25TdGFydD17dGhpcy5fb25JdGVtRHJhZ1N0YXJ0fVxuICAgICAgb25TdG9wPXt0aGlzLl9vbkl0ZW1EcmFnU3RvcH1cbiAgICAgIG9uRHJhZz17dGhpcy5fb25JdGVtRHJhZ31cbiAgICAgIGRpc2FibGVkPXshdGhpcy5wcm9wcy5zZWxlY3RlZCB8fCAodGhpcy5wcm9wcy5zZWxlY3RlZCAmJiB0aGlzLnN0YXRlLmVkaXRNb2RlKX0+XG4gICAgICA8ZGl2XG4gICAgICAgIGJlbT0nJGU6dGV4dCdcbiAgICAgICAgc3R5bGU9e3RoaXMuX2dldEl0ZW1Db250YWluZXJTdHlsZSgpfVxuICAgICAgICBjbGFzc05hbWU9e3RoaXMucHJvcHMuc2VsZWN0ZWQgPyAnaXMtc2VsZWN0ZWQnIDogbnVsbH0+XG4gICAgICAgIHtjb250ZW50fVxuICAgICAgPC9kaXY+XG4gICAgPC9EcmFnZ2FibGVDb21wb25lbnQ+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGJlbSBzcGVjaWZpZXI9J2I6c3ByaXRlc0NhbnZhc0NvbnRyb2xzJz5cbiAgICAgIDxkaXYgYmVtPSckZTppdGVtIGU6Y29udGFpbmVyJz5cbiAgICAgICAge3RoaXMuX3JlbmRlckl0ZW0oKX1cbiAgICAgICAge3RoaXMuX3JlbmRlcktub2JzKCl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2JlbT4pXG4gIH1cbn1cblxuVGV4dEl0ZW1Db21wb25lbnQuY29udGV4dFR5cGVzID0gSXRlbUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc3ByaXRlcy9pdGVtcy90ZXh0LWl0ZW0tY29tcG9uZW50LmpzeCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmNvbnN0IHsgU3RpY2tlciB9ID0gU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnLi4vY29udHJvbHMnXG5pbXBvcnQgU3RpY2tlckNvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vc3RpY2tlci1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU3RpY2tlckNhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4vc3RpY2tlci1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuXG4vKipcbiAqIFRoZSBzdGlja2VyIGNvbnRyb2xzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbFxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNcbiAqL1xuY2xhc3MgU3RpY2tlckNvbnRyb2xzIGV4dGVuZHMgQ29udHJvbHMge1xuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBsZWF2ZXMgdGhlc2UgY29udHJvbHNcbiAgICogQHRoaXMge1N0aWNrZXJDb250cm9sc0NvbXBvbmVudH1cbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkV4aXQgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKVxuXG4gICAgaWYgKCF0aGlzLmdldFNoYXJlZFN0YXRlKCdza2lwSGlzdG9yeScpKSB7XG4gICAgICBlZGl0b3IuaGlzdG9yeS5hZGQoXG4gICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgdGhpcy5nZXRTaGFyZWRTdGF0ZSgnaW5pdGlhbE9wdGlvbnMnKSxcbiAgICAgICAgdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uRXhpc3RlZEJlZm9yZScpXG4gICAgICApXG4gICAgfVxuXG4gICAgb3BlcmF0aW9uLnNldEVuYWJsZWQodHJ1ZSlcblxuICAgIGVkaXRvci56b29tLnVuZG8oKVxuICAgIGVkaXRvci5mZWF0dXJlcy5lbmFibGUoJ3pvb20nLCAnZHJhZycpXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBlbnRlcnMgdGhlc2UgY29udHJvbHNcbiAgICogQHRoaXMge1N0aWNrZXJDb250cm9sc0NvbXBvbmVudH1cbiAgICogQHBhcmFtIHtTaGFyZWRTdGF0ZX0gc2hhcmVkU3RhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBvbkVudGVyIChzaGFyZWRTdGF0ZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBvcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gZWRpdG9yLm9wZXJhdGlvbnMuZXhpc3RzKCdzcHJpdGUnKVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzcHJpdGUnKVxuICAgIGNvbnN0IHNwcml0ZXMgPSBvcGVyYXRpb24uZ2V0U3ByaXRlcygpXG4gICAgY29uc3Qgc3RpY2tlcnMgPSBvcGVyYXRpb24uZ2V0U3ByaXRlc09mVHlwZShTdGlja2VyKVxuICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gb3BlcmF0aW9uLnNlcmlhbGl6ZU9wdGlvbnMoKVxuXG4gICAgb3BlcmF0aW9uLnNldEVuYWJsZWQoZmFsc2UpXG4gICAgZWRpdG9yLnpvb20uc2V0KCdhdXRvJylcbiAgICBlZGl0b3IuZmVhdHVyZXMuZGlzYWJsZSgnem9vbScsICdkcmFnJylcblxuICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoe1xuICAgICAgb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSwgb3BlcmF0aW9uLCBzcHJpdGVzLCBzdGlja2VycywgaW5pdGlhbE9wdGlvbnNcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGVyZSBpcyBzb21ldGhpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHRoYXRcbiAgICogd291bGQgY2F1c2UgdGhlIFVJIHRvIHN3aXRjaCB0byB0aGlzIGNvbnRyb2wgb24gY2xpY2tcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4geyp9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgY2xpY2tBdFBvc2l0aW9uIChwb3NpdGlvbiwgZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3Iub3BlcmF0aW9ucy5leGlzdHMoJ3Nwcml0ZScpKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVkaXRvci5vcGVyYXRpb25zLmdldE9yQ3JlYXRlKCdzcHJpdGUnKVxuICAgIGxldCBzcHJpdGVzID0gb3BlcmF0aW9uLmdldFNwcml0ZXNBdFBvc2l0aW9uKHBvc2l0aW9uLCBlZGl0b3IuZ2V0T3V0cHV0VGV4dHVyZURpbWVuc2lvbnMoKSlcbiAgICAgIC5maWx0ZXIoKHMpID0+IHMgaW5zdGFuY2VvZiBTdGlja2VyKVxuXG4gICAgaWYgKHNwcml0ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyBzZWxlY3RlZFNwcml0ZTogc3ByaXRlc1swXSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjb250cm9sIGlzIGF2YWlsYWJsZSB0byB0aGUgdXNlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn0gZWRpdG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBvdmVycmlkZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgaXNBdmFpbGFibGUgKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuaXNUb29sRW5hYmxlZCgnc3RpY2tlcicpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjb250cm9scyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSBsb3dlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IuXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuU3RpY2tlckNvbnRyb2xzLmNvbnRyb2xzQ29tcG9uZW50ID0gU3RpY2tlckNvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cblN0aWNrZXJDb250cm9scy5jYW52YXNDb250cm9sc0NvbXBvbmVudCA9IFN0aWNrZXJDYW52YXNDb250cm9sc0NvbXBvbmVudFxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5TdGlja2VyQ29udHJvbHMuaWRlbnRpZmllciA9ICdzdGlja2VyJ1xuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGljb24gcGF0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuU3RpY2tlckNvbnRyb2xzLmljb25QYXRoID0gJ2NvbnRyb2xzL292ZXJ2aWV3L3N0aWNrZXIucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cblN0aWNrZXJDb250cm9scy5sYW5ndWFnZUtleSA9ICdjb250cm9scy5vdmVydmlldy5zdGlja2VyJ1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgY29udHJvbFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IFtjYXRlZ29yaWVzID0gW11dXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXBsYWNlQ2F0ZWdvcmllcyA9IGZhbHNlXVxuICogQHByb3BlcnR5IHtTdHJpbmdbXX0gW3NlbGVjdGFibGVTdGlja2VycyA9IG51bGxdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwcyA9IGZhbHNlXVxuICovXG5TdGlja2VyQ29udHJvbHMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGNhdGVnb3JpZXM6IG51bGwsXG4gIHJlcGxhY2VDYXRlZ29yaWVzOiBmYWxzZSxcbiAgc2VsZWN0YWJsZVN0aWNrZXJzOiBudWxsLFxuICB0b29sdGlwczogZmFsc2UsXG4gIGhpZGVDYXRlZ29yaWVzOiBmYWxzZSxcbiAgZml4ZWRSYXRpbzogdHJ1ZSxcbiAgc21vb3RoRG93bnNjYWxpbmc6IGZhbHNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0aWNrZXJDb250cm9sc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zdGlja2VyL2luZGV4LmpzIiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cbmltcG9ydCB7IFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTcHJpdGVzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vc3ByaXRlcy9zcHJpdGVzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU3RpY2tlckNvbnRyb2xzT3ZlcmxheUNvbXBvbmVudCBmcm9tICcuLi9zdGlja2VyL3N0aWNrZXItY29udHJvbHMtb3ZlcmxheS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0aWNrZXJDYW52YXNDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIFNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBUaGlzIHJlbmRlcnMgY29udHJvbHMgb24gdG9wIG9mIHRoZSBzcHJpdGVzXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyT3ZlcmxheUNvbnRyb2xzICgpIHtcbiAgICBpZiAoIXRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJykpIHJldHVyblxuXG4gICAgcmV0dXJuICg8U3RpY2tlckNvbnRyb2xzT3ZlcmxheUNvbXBvbmVudFxuICAgICAgb25GbGlwPXt0aGlzLl9vblNwcml0ZUZsaXB9XG4gICAgICBvblRha2VUb0Zyb250PXt0aGlzLl9vblNwcml0ZVRha2VUb0Zyb250fVxuICAgICAgb25SZW1vdmU9e3RoaXMuX29uU3ByaXRlUmVtb3ZlfSAvPilcbiAgfVxufVxuXG5TdGlja2VyQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gU3ByaXRlc0NhbnZhc0NvbnRyb2xzQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy9zdGlja2VyL3N0aWNrZXItY2FudmFzLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBTREtVdGlscywgUmVhY3RCRU0sIFZlY3RvcjIsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFNjcm9sbGJhckNvbXBvbmVudCBmcm9tICcuLi8uLi9zY3JvbGxiYXItY29tcG9uZW50J1xuaW1wb3J0IENhdGVnb3J5RHJvcGRvd25Db21wb25lbnQgZnJvbSAnLi4vLi4vY2F0ZWdvcnktZHJvcGRvd24vY2F0ZWdvcnktZHJvcGRvd24tY29tcG9uZW50J1xuaW1wb3J0IE1vZGFsTWFuYWdlciBmcm9tICcuLi8uLi8uLi9saWIvbW9kYWwtbWFuYWdlcidcbmltcG9ydCBTdGlja2VyTWFuYWdlciBmcm9tICcuLi8uLi8uLi9saWIvbWFuYWdlcnMvc3RpY2tlci1tYW5hZ2VyJ1xuaW1wb3J0IFN0aWNrZXJJdGVtQ29tcG9uZW50IGZyb20gJy4vc3RpY2tlci1pdGVtLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RpY2tlck92ZXJ2aWV3Q29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uU3RpY2tlck1vdXNlTGVhdmUnLFxuICAgICAgJ19yZW5kZXJUb29sdGlwQ2FudmFzJyxcbiAgICAgICdfb25DYXRlZ29yeUNoYW5nZScsXG4gICAgICAnX29uQmVmb3JlSGlzdG9yeVVuZG8nXG4gICAgKVxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLkhJU1RPUllfQkVGT1JFX1VORE9dOiB0aGlzLl9vbkJlZm9yZUhpc3RvcnlVbmRvXG4gICAgfVxuXG4gICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICB0aGlzLl9zcHJpdGVzID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc3ByaXRlcycpXG4gICAgdGhpcy5fc3RpY2tlcnMgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzdGlja2VycycpXG5cbiAgICB0aGlzLl9pbml0U3RpY2tlck1hbmFnZXIoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNhdGVnb3J5OiB0aGlzLl9zdGlja2VyTWFuYWdlci5nZXRDYXRlZ29yeSgnYWxsJylcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYmVmb3JlIGEgaGlzdG9yeSBpdGVtIGlzIGJlaW5nIHVuZG9uZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGhpc3RvcnlPYmplY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJlZm9yZUhpc3RvcnlVbmRvIChoaXN0b3J5T2JqZWN0KSB7XG4gICAgY29uc3QgeyBvcGVyYXRpb24sIG9wdGlvbnMgfSA9IGhpc3RvcnlPYmplY3RcbiAgICBpZiAob3BlcmF0aW9uICE9PSB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb24nKSkgcmV0dXJuXG5cbiAgICBjb25zdCB7IHNwcml0ZXMgfSA9IG9wdGlvbnNcbiAgICBpZiAoc3ByaXRlcy5pbmRleE9mKHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJykpID09PSAtMSkge1xuICAgICAgLy8gQ3VycmVudGx5IHNlbGVjdGVkIHNwcml0ZSBpcyBiZWluZyByZW1vdmVkLiBMZWF2ZSBjb250cm9sIHdpdGhvdXQgYWRkaW5nIGhpc3RvcnkgaXRlbS5cbiAgICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBza2lwSGlzdG9yeTogdHJ1ZSB9LCBmYWxzZSlcbiAgICAgIHRoaXMucHJvcHMub25Td2l0Y2hDb250cm9scygnaG9tZScpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgdGhlIGNhdGVnb3J5XG4gICAqIEBwYXJhbSAge09iamVjdH0gY2F0ZWdvcnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNhdGVnb3J5Q2hhbmdlIChjYXRlZ29yeSkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBjYXRlZ29yeTogY2F0ZWdvcnkgfSwgKCkgPT4ge1xuICAgICAgdGhpcy5yZWZzLnNjcm9sbGJhci51cGRhdGUoKVxuICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuXG4gICAgaWYgKHRoaXMucHJvcHMub3B0aW9ucy5zdGlja2Vyc0pTT05QYXRoKSB7XG4gICAgICB0aGlzLl9sb2FkRXh0ZXJuYWxTdGlja2VycygpXG4gICAgfVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGVkaXRvci56b29tLnNldCgnYXV0bycsICgpID0+IHtcbiAgICAgIGVkaXRvci5mZWF0dXJlcy5kaXNhYmxlKCd6b29tJywgJ2RyYWcnKVxuICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFWFRFUk5BTCBTVElDS0VSIExPQURJTkdcblxuICAvKipcbiAgICogTG9hZHMgdGhlIHN0aWNrZXJzIGZyb20gYW4gZXh0ZXJuYWwgSlNPTiBzb3VyY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkRXh0ZXJuYWxTdGlja2VycyAoKSB7XG4gICAgLy8gRGlzcGxheSBsb2FkaW5nIG1vZGFsIGFmdGVyIDEwMG1zXG4gICAgbGV0IGxvYWRpbmdNb2RhbCA9IG51bGxcbiAgICBsZXQgbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGxvYWRpbmdNb2RhbCA9IE1vZGFsTWFuYWdlci5pbnN0YW5jZS5kaXNwbGF5TG9hZGluZyh0aGlzLl90KCdsb2FkaW5nLmxvYWRpbmcnKSlcbiAgICB9LCAxMDApXG5cbiAgICAvLyBDYWxsZWQgd2hlbiBsb2FkaW5nIGlzIGRvbmUuIENhbmNlbHMgdGhlIGxvYWRpbmcgdGltZW91dFxuICAgIC8vIG9yIGNsb3NlcyB0aGUgbG9hZGluZ01vZGFsIGluIGNhc2UgaXQgaGFzIGJlZW4gb3BlbmVkXG4gICAgY29uc3QgZG9uZUxvYWRpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAobG9hZFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGxvYWRUaW1lb3V0KVxuICAgICAgICBsb2FkVGltZW91dCA9IG51bGxcbiAgICAgIH1cbiAgICAgIGlmIChsb2FkaW5nTW9kYWwpIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgfVxuXG4gICAgdGhpcy5fc3RpY2tlck1hbmFnZXJcbiAgICAgIC5sb2FkRXh0ZXJuYWwodGhpcy5wcm9wcy5vcHRpb25zLnN0aWNrZXJzSlNPTlBhdGgpXG4gICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmVMb2FkaW5nKClcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWZzLnNjcm9sbGJhci51cGRhdGUoKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBkb25lTG9hZGluZygpXG5cbiAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgICBjb25zdCBlcnJvck1vZGFsID0gTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlFcnJvcihcbiAgICAgICAgICB0aGlzLl90KCdlcnJvcnMubG9hZGluZ1N0aWNrZXJzRmFpbGVkLnRpdGxlJyksXG4gICAgICAgICAgZS5tZXNzYWdlXG4gICAgICAgIClcbiAgICAgICAgZXJyb3JNb2RhbC5vbignY2xvc2UnLCAoKSA9PiB7IHRoaXMucHJvcHMub25CYWNrKCkgfSlcbiAgICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTVElDS0VSIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzdGlja2VyIG9uIHRoZSB0b29sdGlwIGNhbnZhc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclRvb2x0aXBDYW52YXMgKCkge1xuICAgIGNvbnN0IHsgaG92ZXJlZFN0aWNrZXIgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUudG9vbHRpcFZpc2libGUgfHxcbiAgICAgICAgICB0aGlzLnN0YXRlLmhvdmVyZWRTdGlja2VyICE9PSBob3ZlcmVkU3RpY2tlcikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5yZWZzLnRvb2x0aXBDYW52YXNcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aFxuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHRcblxuICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWluKGNhbnZhcy53aWR0aCAvIGltYWdlLndpZHRoLCBjYW52YXMuaGVpZ2h0IC8gaW1hZ2UuaGVpZ2h0KVxuICAgICAgY29uc3QgZHJhd1NpemUgPSBuZXcgVmVjdG9yMihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KVxuICAgICAgICAubXVsdGlwbHkoc2NhbGUpXG4gICAgICBjb25zdCBkcmF3UG9zaXRpb24gPSBuZXcgVmVjdG9yMihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gICAgICAgIC5kaXZpZGUoMilcbiAgICAgICAgLnN1YnRyYWN0KGRyYXdTaXplLmNsb25lKCkuZGl2aWRlKDIpKVxuXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSxcbiAgICAgICAgMCwgMCxcbiAgICAgICAgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCxcbiAgICAgICAgZHJhd1Bvc2l0aW9uLngsIGRyYXdQb3NpdGlvbi55LFxuICAgICAgICBkcmF3U2l6ZS54LCBkcmF3U2l6ZS55KVxuICAgIH0pXG5cbiAgICBjb25zdCByZXNvbHZlZFN0aWNrZXJQYXRoID0gdGhpcy5fZ2V0QXNzZXRQYXRoKChcbiAgICAgIGhvdmVyZWRTdGlja2VyLmltYWdlcy5tZWRpYU1lZGl1bSB8fCBob3ZlcmVkU3RpY2tlci5pbWFnZXMubWVkaWFCYXNlXG4gICAgKS51cmkpXG4gICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJ1xuICAgIGltYWdlLnNyYyA9IHJlc29sdmVkU3RpY2tlclBhdGhcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNUSUNLRVJTXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzdGlja2VyIG1hbmFnZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0U3RpY2tlck1hbmFnZXIgKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBTREtVdGlscy5kZWZhdWx0cyh0aGlzLnByb3BzLm9wdGlvbnMsIHtcbiAgICAgIGFsbENhdGVnb3J5TGFiZWw6IHRoaXMuX3QoJ2NvbnRyb2xzLnN0aWNrZXIuY2F0ZWdvcmllcy5hbGwnKVxuICAgIH0pXG4gICAgdGhpcy5fc3RpY2tlck1hbmFnZXIgPSBuZXcgU3RpY2tlck1hbmFnZXIob3B0aW9ucylcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja0NsaWNrIChlKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkNsaWNrZWQgPSB0cnVlXG4gICAgdGhpcy5wcm9wcy5vblN3aXRjaENvbnRyb2xzKCdob21lJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgc3RpY2tlciBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEBwYXJhbSAge09iamVjdH0gc3RpY2tlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU3RpY2tlckNsaWNrIChzdGlja2VyKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRTdGlja2VyUGF0aCA9IHRoaXMuX2dldEFzc2V0UGF0aChzdGlja2VyLmltYWdlcy5tZWRpYUJhc2UudXJpKVxuICAgIGNvbnN0IGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZSgpXG5cbiAgICBsZXQgbG9hZGluZ01vZGFsXG4gICAgbGV0IGxvYWRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2FkaW5nTW9kYWwgPSBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUxvYWRpbmcodGhpcy5fdCgnbG9hZGluZy5sb2FkaW5nJykpXG4gICAgfSwgMTAwKVxuXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGlmIChsb2FkaW5nTW9kYWwpIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgICBpZiAobG9hZFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGxvYWRUaW1lb3V0KVxuICAgICAgICBsb2FkVGltZW91dCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuXG4gICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhbGN1bGF0ZUluaXRpYWxTdGlja2VyU2NhbGUoc3RpY2tlciwgaW1hZ2UpXG4gICAgICBjb25zdCBzcHJpdGUgPSB0aGlzLl9vcGVyYXRpb24uY3JlYXRlU3RpY2tlcih7XG4gICAgICAgIG5hbWU6IHN0aWNrZXIubmFtZSxcbiAgICAgICAgaW1hZ2UsXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMigwLjUsIDAuNSksXG4gICAgICAgIGRpbWVuc2lvbnM6IG5ldyBWZWN0b3IyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpLm11bHRpcGx5KHNjYWxlKSxcbiAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgIHNtb290aERvd25zY2FsaW5nOiB0aGlzLnByb3BzLm9wdGlvbnMuc21vb3RoRG93bnNjYWxpbmdcbiAgICAgIH0pXG4gICAgICB0aGlzLl9vcGVyYXRpb24uYWRkU3ByaXRlKHNwcml0ZSlcbiAgICAgIHRoaXMuX3N0aWNrZXJzLnB1c2goc3ByaXRlKVxuXG4gICAgICBlZGl0b3IucmVuZGVyKCgpID0+IHtcbiAgICAgICAgLy8gQnJvYWRjYXN0IG5ldyBzdGF0ZVxuICAgICAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgICAgICBzZWxlY3RlZFNwcml0ZTogc3ByaXRlLFxuICAgICAgICAgIHNwcml0ZXM6IHRoaXMuX3Nwcml0ZXMsXG4gICAgICAgICAgc3RpY2tlcnM6IHRoaXMuX3N0aWNrZXJzXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgIGlmIChsb2FkaW5nTW9kYWwpIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgICBpZiAobG9hZFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGxvYWRUaW1lb3V0KVxuICAgICAgICBsb2FkVGltZW91dCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlFcnJvcihcbiAgICAgICAgdGhpcy5fdCgnZXJyb3JzLmltYWdlTG9hZEZhaWwudGl0bGUnKSxcbiAgICAgICAgdGhpcy5fdCgnZXJyb3JzLmltYWdlTG9hZEZhaWwudGV4dCcsIHsgcGF0aDogaW1hZ2Uuc3JjIH0pXG4gICAgICApXG4gICAgfSlcblxuICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cydcbiAgICBpbWFnZS5zcmMgPSByZXNvbHZlZFN0aWNrZXJQYXRoXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgaW5pdGlhbCBzdGlja2VyIHNjYWxlXG4gICAqIEBwYXJhbSAge09iamVjdH0gc3RpY2tlclxuICAgKiBAcGFyYW0gIHtJbWFnZX0gaW1hZ2VcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhbGN1bGF0ZUluaXRpYWxTdGlja2VyU2NhbGUgKHN0aWNrZXIsIGltYWdlKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSBvcGVyYXRpb24uZ2V0SW5wdXREaW1lbnNpb25zKCkubXVsdGlwbHkoMC45KVxuICAgIGNvbnN0IGltYWdlRGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG5cbiAgICBjb25zdCBvdmVybGFwID0gaW1hZ2VEaW1lbnNpb25zLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChpbnB1dERpbWVuc2lvbnMpXG5cbiAgICBpZiAob3ZlcmxhcC54IDw9IDAgJiYgb3ZlcmxhcC55IDw9IDApIHJldHVybiAxXG5cbiAgICBpZiAob3ZlcmxhcC54ID4gb3ZlcmxhcC55KSB7XG4gICAgICByZXR1cm4gaW5wdXREaW1lbnNpb25zLnggLyBpbWFnZURpbWVuc2lvbnMueFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5wdXREaW1lbnNpb25zLnkgLyBpbWFnZURpbWVuc2lvbnMueVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBob3ZlcmluZyBhIHN0aWNrZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdGlja2VyUGF0aFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU3RpY2tlck1vdXNlRW50ZXIgKHN0aWNrZXJQYXRoLCBlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0b29sdGlwVmlzaWJsZTogdHJ1ZSxcbiAgICAgIGhvdmVyZWRTdGlja2VyOiBzdGlja2VyUGF0aCxcbiAgICAgIGhvdmVyZWRTdGlja2VyRWxlbWVudDogZS5jdXJyZW50VGFyZ2V0XG4gICAgfSwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVuZGVyVG9vbHRpcENhbnZhcygpXG4gICAgICB0aGlzLl91cGRhdGVUb29sdGlwUG9zaXRpb24oKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdG9vbHRpcCBwb3NpdGlvbiB0byBtYXRjaCB0aGUgY3VycmVudGx5IGhvdmVyZWRcbiAgICogc3RpY2tlcidzIHBvc2l0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlVG9vbHRpcFBvc2l0aW9uICgpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuc3RhdGUuaG92ZXJlZFN0aWNrZXJFbGVtZW50XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5yZWZzLnJvb3RcbiAgICBjb25zdCBib3VuZGluZ1JlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHBhcmVudEJvdW5kaW5nUmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0b29sdGlwUG9zaXRpb246IGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFyZW50Qm91bmRpbmdSZWN0LmxlZnRcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZG9lcyBubyBsb25nZXIgaG92ZXIgYSBzdGlja2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TdGlja2VyTW91c2VMZWF2ZSAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0b29sdGlwVmlzaWJsZTogZmFsc2UsXG4gICAgICBob3ZlcmVkU3RpY2tlcjogbnVsbFxuICAgIH0pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBpdGVtcyBmb3IgdGhpcyBjb250cm9sXG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaXN0SXRlbXMgKCkge1xuICAgIGNvbnN0IHN0aWNrZXJzID0gdGhpcy5fc3RpY2tlck1hbmFnZXIuZ2V0U3RpY2tlcnNGb3JDYXRlZ29yeSh0aGlzLnN0YXRlLmNhdGVnb3J5Lm5hbWUpXG4gICAgcmV0dXJuIHN0aWNrZXJzLm1hcCgoc3RpY2tlciwgaSkgPT4ge1xuICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzXG5cbiAgICAgIGNvbnN0IGl0ZW1FdmVudHMgPSBvcHRpb25zLnRvb2x0aXBzXG4gICAgICAgID8ge1xuICAgICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5fb25TdGlja2VyTW91c2VFbnRlci5iaW5kKHRoaXMsIHN0aWNrZXIpLFxuICAgICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5fb25TdGlja2VyTW91c2VMZWF2ZVxuICAgICAgICB9XG4gICAgICAgIDogbnVsbFxuXG4gICAgICByZXR1cm4gKDxTdGlja2VySXRlbUNvbXBvbmVudFxuICAgICAgICBzdGlja2VyPXtzdGlja2VyfVxuICAgICAgICBvbkNsaWNrPXt0aGlzLl9vblN0aWNrZXJDbGljay5iaW5kKHRoaXMsIHN0aWNrZXIpfVxuICAgICAgICB7Li4uaXRlbUV2ZW50c30gLz4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSB0b29sdGlwIChpZiBwcmVzZW50KVxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclRvb2x0aXAgKCkge1xuICAgIGNvbnN0IHRvb2x0aXBWaXNpYmxlID0gdGhpcy5wcm9wcy5vcHRpb25zLnRvb2x0aXBzICYmXG4gICAgICB0aGlzLnN0YXRlLnRvb2x0aXBWaXNpYmxlXG5cbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIGxlZnQ6IHRoaXMuc3RhdGUudG9vbHRpcFBvc2l0aW9uXG4gICAgfVxuXG4gICAgcmV0dXJuIHRvb2x0aXBWaXNpYmxlXG4gICAgICA/ICg8ZGl2IGJlbT0nZTpjZWxsIG06ZW1wdHknPlxuICAgICAgICA8ZGl2IGJlbT0nJGI6c3RpY2tlcnNDb250cm9scyAkZTp0b29sdGlwJ1xuICAgICAgICAgIHN0eWxlPXtzdHlsZX0+XG4gICAgICAgICAgPGNhbnZhcyBiZW09J2U6Y2FudmFzJyByZWY9J3Rvb2x0aXBDYW52YXMnIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+KVxuICAgICAgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY2F0ZWdvcnkgZHJvcGRvd24gKGlmIHByZXNlbnQpXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQ2F0ZWdvcnlEcm9wZG93biAoKSB7XG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IHRoaXMuX3N0aWNrZXJNYW5hZ2VyLmdldENhdGVnb3JpZXMoKVxuICAgIGNvbnN0IGNhdGVnb3J5RHJvcGRvd25WaXNpYmxlID1cbiAgICAgICF0aGlzLnByb3BzLm9wdGlvbnMuaGlkZUNhdGVnb3JpZXMgJiZcbiAgICAgIGNhdGVnb3JpZXMubGVuZ3RoID4gMVxuICAgIGlmICghY2F0ZWdvcnlEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgY2F0ZWdvcnlJdGVtcyA9IGNhdGVnb3JpZXMubWFwKChjKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBjLm5hbWUsXG4gICAgICAgIGxhYmVsOiBjLmxhYmVsLFxuICAgICAgICBpY29uOiB0aGlzLl9nZXRBc3NldFBhdGgoYGNvbnRyb2xzL3N0aWNrZXJzL2NhdGVnb3JpZXMvJHtjLm5hbWV9LnBuZ2AsIHRydWUpXG4gICAgICB9XG4gICAgfSlcbiAgICBjb25zdCBzZWxlY3RlZENhdGVnb3J5ID0ge1xuICAgICAgbmFtZTogdGhpcy5zdGF0ZS5jYXRlZ29yeS5uYW1lLFxuICAgICAgbGFiZWw6IHRoaXMuc3RhdGUuY2F0ZWdvcnkubGFiZWwsXG4gICAgICBpY29uOiB0aGlzLl9nZXRBc3NldFBhdGgoYGNvbnRyb2xzL3N0aWNrZXJzL2NhdGVnb3JpZXMvJHt0aGlzLnN0YXRlLmNhdGVnb3J5Lm5hbWV9LnBuZ2AsIHRydWUpXG4gICAgfVxuXG4gICAgcmV0dXJuICg8ZGl2IGJlbT0nZTpjZWxsIG06Y2F0ZWdvcnlEcm9wZG93bic+XG4gICAgICA8Q2F0ZWdvcnlEcm9wZG93bkNvbXBvbmVudFxuICAgICAgICBpdGVtcz17Y2F0ZWdvcnlJdGVtc31cbiAgICAgICAgc2VsZWN0ZWRJdGVtPXtzZWxlY3RlZENhdGVnb3J5fVxuICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25DYXRlZ29yeUNoYW5nZX0gLz5cbiAgICA8L2Rpdj4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udHJvbHMgb2YgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlckNvbnRyb2xzICgpIHtcbiAgICBjb25zdCBsaXN0SXRlbXMgPSB0aGlzLl9yZW5kZXJMaXN0SXRlbXMoKVxuICAgIGNvbnN0IHRvb2x0aXAgPSB0aGlzLl9yZW5kZXJUb29sdGlwKClcbiAgICBjb25zdCBjYXRlZ29yeURyb3Bkb3duID0gdGhpcy5fcmVuZGVyQ2F0ZWdvcnlEcm9wZG93bigpXG5cbiAgICByZXR1cm4gW3Rvb2x0aXAsXG4gICAgICBjYXRlZ29yeURyb3Bkb3duLFxuICAgICAgKDxkaXYgYmVtPSdlOmNlbGwgbTpsaXN0Jz5cbiAgICAgICAgPFNjcm9sbGJhckNvbXBvbmVudCByZWY9J3Njcm9sbGJhcic+XG4gICAgICAgICAgPHVsIGJlbT0nJGU6bGlzdCc+XG4gICAgICAgICAgICB7bGlzdEl0ZW1zfVxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvU2Nyb2xsYmFyQ29tcG9uZW50PlxuICAgICAgPC9kaXY+KV1cbiAgfVxufVxuXG5TdGlja2VyT3ZlcnZpZXdDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvc3RpY2tlci9zdGlja2VyLWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50LCBSZWFjdEJFTSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0aWNrZXJDb250cm9sc092ZXJsYXlDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uZSBvZiB0aGUgZmxpcCBpdGVtc1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uRmxpcENsaWNrIChkaXJlY3Rpb24sIGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uRmxpcCAmJiB0aGlzLnByb3BzLm9uRmxpcChkaXJlY3Rpb24pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGB0YWtlIHRvIGZyb250YCBpdGVtXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25UYWtlVG9Gcm9udENsaWNrIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgdGhpcy5wcm9wcy5vblRha2VUb0Zyb250ICYmIHRoaXMucHJvcHMub25UYWtlVG9Gcm9udCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGByZW1vdmVgIGl0ZW1cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblJlbW92ZUNsaWNrIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgdGhpcy5wcm9wcy5vblJlbW92ZSAmJiB0aGlzLnByb3BzLm9uUmVtb3ZlKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBpdGVtcyBvZiB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtBcnJheS48UmVhY3RCRU0uRWxlbWVudD59XG4gICAqL1xuICBfcmVuZGVySXRlbXMgKCkge1xuICAgIHJldHVybiBbXG4gICAgICAoPGRpdiBiZW09JyRlOml0ZW0nIG9uQ2xpY2s9e3RoaXMuX29uRmxpcENsaWNrLmJpbmQodGhpcywgJ2gnKX0+XG4gICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9zcHJpdGVzL2ZsaXAtaC5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PiksXG4gICAgICAoPGRpdiBiZW09JyRlOml0ZW0nIG9uQ2xpY2s9e3RoaXMuX29uRmxpcENsaWNrLmJpbmQodGhpcywgJ3YnKX0+XG4gICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9zcHJpdGVzL2ZsaXAtdi5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PiksXG4gICAgICAoPGRpdiBiZW09JyRlOml0ZW0nIG9uQ2xpY2s9e3RoaXMuX29uVGFrZVRvRnJvbnRDbGljay5iaW5kKHRoaXMpfT5cbiAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL3Nwcml0ZXMvdGFrZS10by1mcm9udC5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PiksXG4gICAgICAoPGRpdiBiZW09JyRlOnNlcGFyYXRvcicgLz4pLFxuICAgICAgKDxkaXYgYmVtPSckZTppdGVtJyBvbkNsaWNrPXt0aGlzLl9vblJlbW92ZUNsaWNrLmJpbmQodGhpcyl9PlxuICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvc3ByaXRlcy9yZW1vdmUucG5nJywgdHJ1ZSl9IC8+XG4gICAgICA8L2Rpdj4pXG4gICAgXVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdlxuICAgICAgYmVtPSckYjpzcHJpdGVzQ29udHJvbHNPdmVybGF5Jz5cbiAgICAgIHt0aGlzLl9yZW5kZXJJdGVtcygpfVxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5TdGlja2VyQ29udHJvbHNPdmVybGF5Q29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL3N0aWNrZXIvc3RpY2tlci1jb250cm9scy1vdmVybGF5LWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCwgVmVjdG9yMiB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0aWNrZXJPdmVydmlld0NvbnRyb2xzQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBzdGlja2VyOiB0aGlzLnByb3BzLnN0aWNrZXJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5fcmVuZGVyU3RpY2tlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBhYm91dCB0byByZWNlaXZlIG5ldyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV4dFByb3BzXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXh0UHJvcHMpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5zdGlja2VyICE9PSBuZXh0UHJvcHMuc3RpY2tlcikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHN0aWNrZXI6IG5leHRQcm9wcy5zdGlja2VyIH0sICgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3RpY2tlcigpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzdGlja2VyIG9udG8gdGhlIGNhbnZhc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclN0aWNrZXIgKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBjb25zdCBzZGsgPSBlZGl0b3IuZ2V0U0RLKClcblxuICAgIGNvbnN0IHsgc3RpY2tlciB9ID0gdGhpcy5wcm9wc1xuXG4gICAgY29uc3QgcmVzb2x2ZWRTdGlja2VyUGF0aCA9IHRoaXMuX2dldEFzc2V0UGF0aChzdGlja2VyLmltYWdlcy5tZWRpYVRodW1iLnVyaSlcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLnJlZnNbYGNhbnZhcy0ke3N0aWNrZXIubmFtZX1gXVxuXG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHNkay5nZXRQaXhlbFJhdGlvKClcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGggKiBwaXhlbFJhdGlvXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHQgKiBwaXhlbFJhdGlvXG5cbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjYW52YXMub2Zmc2V0V2lkdGh9cHhgXG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NhbnZhcy5vZmZzZXRIZWlnaHR9cHhgXG5cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGNvbnN0IGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZSgpXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oY2FudmFzLndpZHRoIC8gaW1hZ2Uud2lkdGgsIGNhbnZhcy5oZWlnaHQgLyBpbWFnZS5oZWlnaHQpXG4gICAgICBjb25zdCBkcmF3U2l6ZSA9IG5ldyBWZWN0b3IyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG4gICAgICAgIC5tdWx0aXBseShzY2FsZSlcbiAgICAgIGNvbnN0IGRyYXdQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAuc3VidHJhY3QoZHJhd1NpemUuY2xvbmUoKS5kaXZpZGUoMikpXG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAwLCAwLFxuICAgICAgICBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LFxuICAgICAgICBkcmF3UG9zaXRpb24ueCwgZHJhd1Bvc2l0aW9uLnksXG4gICAgICAgIGRyYXdTaXplLngsIGRyYXdTaXplLnkpXG4gICAgfSlcbiAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnXG4gICAgaW1hZ2Uuc3JjID0gcmVzb2x2ZWRTdGlja2VyUGF0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBlbGVtZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLmVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxsaVxuICAgICAgYmVtPSckYjpzdGlja2Vyc0NvbnRyb2xzICRlOml0ZW0nXG4gICAgICBrZXk9e3RoaXMucHJvcHMuc3RpY2tlci5uYW1lfVxuICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfVxuICAgICAgb25Nb3VzZUVudGVyPXt0aGlzLnByb3BzLm9uTW91c2VFbnRlcn1cbiAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5wcm9wcy5vbk1vdXNlTGVhdmV9PlxuICAgICAgPGNhbnZhcyBiZW09J2U6Y2FudmFzJyByZWY9e2BjYW52YXMtJHt0aGlzLnByb3BzLnN0aWNrZXIubmFtZX1gfSAvPlxuICAgIDwvbGk+KVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL3N0aWNrZXIvc3RpY2tlci1pdGVtLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgU2Nyb2xsYmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL3Njcm9sbGJhci1jb21wb25lbnQnXG5pbXBvcnQgRm9udFByZXZpZXdDb21wb25lbnQgZnJvbSAnLi9mb250LXByZXZpZXctY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb250Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbmUgb25lIG9mIHRoZSBsaXN0IGl0ZW1zXG4gICAqIEBwYXJhbSAge09iamVjdH0gZm9udFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTGlzdEl0ZW1DbGljayAoZm9udCwgZSkge1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UgJiZcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZm9udClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIExJU1QgSVRFTVNcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBpdGVtc1xuICAgKiBAcmV0dXJuIHtBcnJheS48UmVhY3RCRU0uRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyTGlzdEl0ZW1zICgpIHtcbiAgICBjb25zdCB7IGZvbnRzIH0gPSB0aGlzLnByb3BzXG5cbiAgICByZXR1cm4gZm9udHMubWFwKChmb250LCBpKSA9PiB7XG4gICAgICBjb25zdCB7IGZvbnRGYW1pbHksIGZvbnRXZWlnaHQsIGZvbnRTdHlsZSB9ID0gdGhpcy5wcm9wc1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGZvbnQub3B0aW9uc0VxdWFsKHsgZm9udEZhbWlseSwgZm9udFdlaWdodCwgZm9udFN0eWxlIH0pXG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBpc1NlbGVjdGVkID8gJ2lzLWFjdGl2ZScgOiBudWxsXG5cbiAgICAgIHJldHVybiAoPGxpXG4gICAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAgICBrZXk9e2l9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICBvbkNsaWNrPXt0aGlzLl9vbkxpc3RJdGVtQ2xpY2suYmluZCh0aGlzLCBmb250KX0gPlxuICAgICAgICA8Rm9udFByZXZpZXdDb21wb25lbnRcbiAgICAgICAgICBmb250RmFtaWx5PXtmb250LmdldEZvbnRGYW1pbHkoKX1cbiAgICAgICAgICBmb250V2VpZ2h0PXtmb250LmdldEZvbnRXZWlnaHQoKX1cbiAgICAgICAgICBmb250U3R5bGU9e2ZvbnQuZ2V0Rm9udFN0eWxlKCl9IC8+XG4gICAgICAgIDxkaXYgYmVtPSdlOmxhYmVsJz57Zm9udC5nZXRGb250RmFtaWx5KCl9PC9kaXY+XG4gICAgICA8L2xpPilcbiAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGNvbnN0IGxpc3RJdGVtcyA9IHRoaXMuX3JlbmRlckxpc3RJdGVtcygpXG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpjb250cm9scyBlOm92ZXJsYXkgbTpkYXJrIG06bGFyZ2UnPlxuICAgICAgPFNjcm9sbGJhckNvbXBvbmVudD5cbiAgICAgICAgPHVsIGJlbT0nJGI6Zm9udEZhbWlseSBlOmxpc3QnPlxuICAgICAgICAgIHtsaXN0SXRlbXN9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L1Njcm9sbGJhckNvbXBvbmVudD5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuRm9udENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jb250cm9scy90ZXh0L2ZvbnQtY29tcG9uZW50LmpzeCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgU0RLIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmNvbnN0IHsgVGV4dCB9ID0gU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnLi4vY29udHJvbHMnXG5pbXBvcnQgVGV4dENhbnZhc0NvbnRyb2xzQ29tcG9uZW50IGZyb20gJy4uL3RleHQvdGV4dC1jYW52YXMtY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFRleHRDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL3RleHQtY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IEZvbnRNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2xpYi9tYW5hZ2Vycy9mb250LW1hbmFnZXInXG5cbi8qKlxuICogVGhlIHRleHQgY29udHJvbHNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc1xuICovXG5jbGFzcyBUZXh0Q29udHJvbHMgZXh0ZW5kcyBDb250cm9scyB7XG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7U3RpY2tlcnNDb250cm9sc0NvbXBvbmVudH1cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRXhpdCAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG5cbiAgICBpZiAoIXRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NraXBIaXN0b3J5JykpIHtcbiAgICAgIGVkaXRvci5oaXN0b3J5LmFkZChcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICB0aGlzLmdldFNoYXJlZFN0YXRlKCdpbml0aWFsT3B0aW9ucycpLFxuICAgICAgICB0aGlzLmdldFNoYXJlZFN0YXRlKCdvcGVyYXRpb25FeGlzdGVkQmVmb3JlJylcbiAgICAgIClcbiAgICB9XG5cbiAgICBvcGVyYXRpb24uc2V0RW5hYmxlZCh0cnVlKVxuXG4gICAgZWRpdG9yLnpvb20udW5kbygpXG4gICAgZWRpdG9yLmZlYXR1cmVzLmVuYWJsZSgnem9vbScsICdkcmFnJylcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGVudGVycyB0aGVzZSBjb250cm9sc1xuICAgKiBAdGhpcyB7U3RpY2tlckNvbnRyb2xzQ29tcG9uZW50fVxuICAgKiBAcGFyYW0ge1NoYXJlZFN0YXRlfSBzaGFyZWRTdGF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIG9uRW50ZXIgKHNoYXJlZFN0YXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSBlZGl0b3Iub3BlcmF0aW9ucy5leGlzdHMoJ3Nwcml0ZScpXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gZWRpdG9yLm9wZXJhdGlvbnMuZ2V0T3JDcmVhdGUoJ3Nwcml0ZScpXG4gICAgY29uc3Qgc3ByaXRlcyA9IG9wZXJhdGlvbi5nZXRTcHJpdGVzKClcbiAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IG9wZXJhdGlvbi5zZXJpYWxpemVPcHRpb25zKClcblxuICAgIGNvbnN0IGZvbnRNYW5hZ2VyID0gbmV3IEZvbnRNYW5hZ2VyKG9wdGlvbnMpXG4gICAgY29uc3QgZGVmYXVsdEZvbnQgPSBmb250TWFuYWdlci5nZXREZWZhdWx0Rm9udCgpXG5cbiAgICB0aGlzLnNldFNoYXJlZFN0YXRlKHtcbiAgICAgIG9wZXJhdGlvbkV4aXN0ZWRCZWZvcmUsXG4gICAgICBvcGVyYXRpb24sXG4gICAgICBzcHJpdGVzLFxuICAgICAgaW5pdGlhbE9wdGlvbnMsXG4gICAgICBmb250TWFuYWdlcixcbiAgICAgIGRlZmF1bHRGb250LFxuICAgICAgZm9udHM6IGZvbnRNYW5hZ2VyLmdldEZvbnRzKClcbiAgICB9KVxuXG4gICAgb3BlcmF0aW9uLnNldEVuYWJsZWQoZmFsc2UpXG4gICAgZWRpdG9yLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZXJlIGlzIHNvbWV0aGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gdGhhdFxuICAgKiB3b3VsZCBjYXVzZSB0aGUgVUkgdG8gc3dpdGNoIHRvIHRoaXMgY29udHJvbCBvbiBjbGlja1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRWRpdG9yfSBlZGl0b3JcbiAgICogQHJldHVybiB7Kn1cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIGNsaWNrQXRQb3NpdGlvbiAocG9zaXRpb24sIGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLm9wZXJhdGlvbnMuZXhpc3RzKCdzcHJpdGUnKSkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCBvcGVyYXRpb24gPSBlZGl0b3Iub3BlcmF0aW9ucy5nZXRPckNyZWF0ZSgnc3ByaXRlJylcbiAgICBsZXQgc3ByaXRlcyA9IG9wZXJhdGlvbi5nZXRTcHJpdGVzQXRQb3NpdGlvbihwb3NpdGlvbiwgZWRpdG9yLmdldE91dHB1dFRleHR1cmVEaW1lbnNpb25zKCkpXG4gICAgICAuZmlsdGVyKChzKSA9PiBzIGluc3RhbmNlb2YgVGV4dClcblxuICAgIGlmIChzcHJpdGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgc2VsZWN0ZWRTcHJpdGU6IHNwcml0ZXNbMF0gfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY29udHJvbCBpcyBhdmFpbGFibGUgdG8gdGhlIHVzZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5FZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgaXNBdmFpbGFibGUgKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuaXNUb29sRW5hYmxlZCgndGV4dCcpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzZXRzIHRoYXQgc2hvdWxkIGJlIHByZWxvYWRlZCBmb3IgdGhpcyBjb250cm9sXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuRWRpdG9yfSBlZGl0b3JcbiAgICogQHJldHVybiB7U3RyaW5nW119XG4gICAqL1xuICBzdGF0aWMgZ2V0UHJlbG9hZEFzc2V0cyAoZWRpdG9yKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdjb250cm9scy90ZXh0L2FsaWduX2xlZnQucG5nJyxcbiAgICAgICdjb250cm9scy90ZXh0L2FsaWduX3JpZ2h0LnBuZycsXG4gICAgICAnY29udHJvbHMvdGV4dC9hbGlnbl9jZW50ZXIucG5nJyxcbiAgICAgICdjb250cm9scy90ZXh0L21pbnVzLnBuZycsXG4gICAgICAnY29udHJvbHMvdGV4dC9wbHVzLnBuZydcbiAgICBdXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNvbnRyb2wncyBjb250cm9scyBjb21wb25lbnQuIFVzZWQgZm9yIHRoZSBsb3dlciBjb250cm9scyBwYXJ0IG9mIHRoZSBlZGl0b3IuXG4gKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5Db250cm9sc0NvbXBvbmVudH1cbiAqIEBpZ25vcmVcbiAqL1xuVGV4dENvbnRyb2xzLmNvbnRyb2xzQ29tcG9uZW50ID0gVGV4dENvbnRyb2xzQ29tcG9uZW50XG5cbi8qKlxuICogVGhpcyBjb250cm9sJ3MgY2FudmFzIGNvbXBvbmVudC4gVXNlZCBmb3IgdGhlIHVwcGVyIGNvbnRyb2xzIHBhcnQgb2YgdGhlIGVkaXRvciAob25cbiAqIHRvcCBvZiB0aGUgY2FudmFzKVxuICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuQ29udHJvbHNDb21wb25lbnR9XG4gKiBAaWdub3JlXG4gKi9cblRleHRDb250cm9scy5jYW52YXNDb250cm9sc0NvbXBvbmVudCA9IFRleHRDYW52YXNDb250cm9sc0NvbXBvbmVudFxuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5UZXh0Q29udHJvbHMuaWRlbnRpZmllciA9ICd0ZXh0J1xuXG4vKipcbiAqIFRoaXMgY29udHJvbCdzIGljb24gcGF0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBpZ25vcmVcbiAqL1xuVGV4dENvbnRyb2xzLmljb25QYXRoID0gJ2NvbnRyb2xzL292ZXJ2aWV3L3RleHQucG5nJ1xuXG4vKipcbiAqIFRoZSBsYW5ndWFnZSBrZXkgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAaWdub3JlXG4gKi9cblRleHRDb250cm9scy5sYW5ndWFnZUtleSA9ICdjb250cm9scy5vdmVydmlldy50ZXh0J1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgY29udHJvbFxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IFthZGRpdGlvbmFsRm9udHMgPSBbXV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlcGxhY2VGb250cyA9IGZhbHNlXVxuICogQHByb3BlcnR5IHtTdHJpbmdbXX0gW3NlbGVjdGFibGVGb250cyA9IG51bGxdXG4gKi9cblRleHRDb250cm9scy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWRkaXRpb25hbEZvbnRzOiBbXSxcbiAgcmVwbGFjZUZvbnRzOiBmYWxzZSxcbiAgc2VsZWN0YWJsZUZvbnRzOiBudWxsLFxuICBkZWZhdWx0VGV4dDogbnVsbFxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0Q29udHJvbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvdGV4dC9pbmRleC5qcyIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5pbXBvcnQgeyBSZWFjdEJFTSwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTcHJpdGVzQ2FudmFzQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vc3ByaXRlcy9zcHJpdGVzLWNhbnZhcy1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgVGV4dENvbnRyb2xzT3ZlcmxheUNvbXBvbmVudCBmcm9tICcuL3RleHQtY29udHJvbHMtb3ZlcmxheS1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRDYW52YXNDb250cm9sc0NvbXBvbmVudCBleHRlbmRzIFNwcml0ZXNDYW52YXNDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoJ19vblRleHRFZGl0JylcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBzZWxlY3RlZCBpdGVtIGlzIGRlc2VsZWN0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkl0ZW1CbHVyICgpIHtcbiAgICBjb25zdCBzcHJpdGUgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG4gICAgaWYgKHNwcml0ZSAmJiBzcHJpdGUuZ2V0VGV4dCgpID09PSAnJykge1xuICAgICAgc3ByaXRlLnNldFRleHQoQ29uc3RhbnRzLkRFRkFVTFRTLlRFWFQpXG4gICAgICBzcHJpdGUuX2VkaXRlZCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgcmVtb3ZlcyB0aGUgc2VsZWN0ZWQgc3ByaXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TcHJpdGVSZW1vdmUgKCkge1xuICAgIHN1cGVyLl9vblNwcml0ZVJlbW92ZSgpXG4gICAgdGhpcy5wcm9wcy5vblN3aXRjaENvbnRyb2xzKCdob21lJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBjbGlja3MgdGhlIGVkaXQgYnV0dG9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25UZXh0RWRpdCAoKSB7XG4gICAgY29uc3Qgc3ByaXRlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIHRoaXMucmVmc1tgc3ByaXRlLSR7c3ByaXRlLmdldElkKCl9YF0uZW50ZXJFZGl0TW9kZSgpXG4gIH1cblxuICAvKipcbiAgICogVGhpcyByZW5kZXJzIGNvbnRyb2xzIG9uIHRvcCBvZiB0aGUgc3ByaXRlc1xuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlck92ZXJsYXlDb250cm9scyAoKSB7XG4gICAgaWYgKCF0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpKSByZXR1cm5cblxuICAgIHJldHVybiAoPFRleHRDb250cm9sc092ZXJsYXlDb21wb25lbnRcbiAgICAgIG9uVGFrZVRvRnJvbnQ9e3RoaXMuX29uU3ByaXRlVGFrZVRvRnJvbnR9XG4gICAgICBvblJlbW92ZT17dGhpcy5fb25TcHJpdGVSZW1vdmV9XG4gICAgICBvbkVkaXQ9e3RoaXMuX29uVGV4dEVkaXR9IC8+KVxuICB9XG59XG5cblRleHRDYW52YXNDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBTcHJpdGVzQ2FudmFzQ29udHJvbHNDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NvbnRyb2xzL3RleHQvdGV4dC1jYW52YXMtY29udHJvbHMtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmNvbnN0IEFMSUdOTUVOVFMgPSBbXG4gICdsZWZ0JyxcbiAgJ2NlbnRlcicsXG4gICdyaWdodCdcbl1cblxuaW1wb3J0IHsgUmVhY3RCRU0sIENvbnN0YW50cywgVmVjdG9yMiB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udHJvbHNDb21wb25lbnQgZnJvbSAnLi4vY29udHJvbHMtY29tcG9uZW50J1xuaW1wb3J0IFNjcm9sbGJhckNvbXBvbmVudCBmcm9tICcuLi8uLi9zY3JvbGxiYXItY29tcG9uZW50J1xuaW1wb3J0IENvbG9yUGlja2VyQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbG9yLXBpY2tlci9jb2xvci1waWNrZXItY29tcG9uZW50J1xuaW1wb3J0IFNsaWRlck92ZXJsYXlDb21wb25lbnQgZnJvbSAnLi4vc2xpZGVyLW92ZXJsYXktY29tcG9uZW50J1xuaW1wb3J0IEZvbnRQcmV2aWV3Q29tcG9uZW50IGZyb20gJy4vZm9udC1wcmV2aWV3LWNvbXBvbmVudCdcbmltcG9ydCBGb250Q29tcG9uZW50IGZyb20gJy4vZm9udC1jb21wb25lbnQnXG5pbXBvcnQgTW9kYWxNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2xpYi9tb2RhbC1tYW5hZ2VyLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0Q29udHJvbHNDb21wb25lbnQgZXh0ZW5kcyBDb250cm9sc0NvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uRm9udFNpemVDaGFuZ2UnLFxuICAgICAgJ19vbkZvbnRDaGFuZ2UnLFxuICAgICAgJ19vbkFsaWdubWVudENsaWNrJyxcbiAgICAgICdfb25UYWtlVG9Gcm9udENsaWNrJyxcbiAgICAgICdfb25Gb3JlZ3JvdW5kQ29sb3JDaGFuZ2UnLFxuICAgICAgJ19vbkJhY2tncm91bmRDb2xvckNoYW5nZScsXG4gICAgICAnX29uQmVmb3JlSGlzdG9yeVVuZG8nXG4gICAgKVxuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIFtDb25zdGFudHMuRVZFTlRTLkhJU1RPUllfQkVGT1JFX1VORE9dOiB0aGlzLl9vbkJlZm9yZUhpc3RvcnlVbmRvXG4gICAgfVxuICAgIHRoaXMuX29wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgdGhpcy5fZm9udExvYWRlciA9IHRoaXMuY29udGV4dC51aS5nZXRGb250TG9hZGVyKClcbiAgICB0aGlzLl9mb250TG9hZGVyLnNldEZvbnRzKHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ2ZvbnRzJykpXG5cbiAgICB0aGlzLnN0YXRlID0geyBtb2RlOiBudWxsLCBsb2FkaW5nOiB0cnVlIH1cblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3IucmVuZGVyKClcblxuICAgIHRoaXMuX2ZvbnRzID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnZm9udHMnKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3Iuem9vbS5zZXQoJ2F1dG8nLCAoKSA9PiB7XG4gICAgICBlZGl0b3IuZmVhdHVyZXMuZGlzYWJsZSgnem9vbScsICdkcmFnJylcbiAgICB9KVxuXG4gICAgY29uc3QgZm9udHNMb2FkZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jcmVhdGVUZXh0KClcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBsb2FkaW5nOiBmYWxzZSB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9mb250TG9hZGVyLm5lZWRzVG9Mb2FkKCkpIHtcbiAgICAgIHRoaXMuX2xvYWRGb250cygpXG4gICAgICAgIC50aGVuKGZvbnRzTG9hZGVkLmJpbmQodGhpcykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvbnRzTG9hZGVkKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIGZvbnRzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9hZEZvbnRzICgpIHtcbiAgICBjb25zdCBsb2FkaW5nTW9kYWwgPSBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUxvYWRpbmcodGhpcy5fdCgnbG9hZGluZy5sb2FkaW5nJykpXG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRMb2FkZXIubG9hZCgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgICAgIE1vZGFsTWFuYWdlci5pbnN0YW5jZS5kaXNwbGF5V2FybmluZyhcbiAgICAgICAgICB0aGlzLl90KCdlcnJvcnMubG9hZGluZ0ZvbnRzRmFpbGVkLnRpdGxlJyksXG4gICAgICAgICAgdGhpcy5fdCgnZXJyb3JzLmxvYWRpbmdGb250c0ZhaWxlZC50ZXh0JylcbiAgICAgICAgKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRleHQgb2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlVGV4dCAoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHNlbGVjdGVkU3ByaXRlID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpXG4gICAgY29uc3QgZGVmYXVsdEZvbnQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdkZWZhdWx0Rm9udCcpXG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGlmICghc2VsZWN0ZWRTcHJpdGUpIHtcbiAgICAgIGNvbnN0IHNkayA9IGVkaXRvci5nZXRTREsoKVxuICAgICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuXG4gICAgICBjb25zdCBtYXhUZXh0dXJlU2l6ZSA9IHJlbmRlcmVyLmdldE1heFRleHR1cmVTaXplKClcbiAgICAgIGNvbnN0IHRleHQgPSBvcGVyYXRpb24uY3JlYXRlVGV4dCh7XG4gICAgICAgIHRleHQ6IG9wdGlvbnMuZGVmYXVsdFRleHQgfHwgQ29uc3RhbnRzLkRFRkFVTFRTLlRFWFQsXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMigwLjUsIDAuNSksXG4gICAgICAgIG1heFdpZHRoOiAwLjUsXG4gICAgICAgIG1heEhlaWdodDogbWF4VGV4dHVyZVNpemUgPyBtYXhUZXh0dXJlU2l6ZSAvIG91dHB1dERpbWVuc2lvbnMueSA6IDMsXG4gICAgICAgIGZvbnRTaXplOiAwLjA4LFxuICAgICAgICBmb250RmFtaWx5OiBkZWZhdWx0Rm9udC5nZXRGb250RmFtaWx5KCksXG4gICAgICAgIGZvbnRXZWlnaHQ6IGRlZmF1bHRGb250LmdldEZvbnRXZWlnaHQoKSxcbiAgICAgICAgZm9udFN0eWxlOiBkZWZhdWx0Rm9udC5nZXRGb250U3R5bGUoKSxcbiAgICAgICAgYWxpZ25tZW50OiAnY2VudGVyJ1xuICAgICAgfSlcbiAgICAgIG9wZXJhdGlvbi5hZGRTcHJpdGUodGV4dClcbiAgICAgIHRoaXMuc2V0U2hhcmVkU3RhdGUoeyBzZWxlY3RlZFNwcml0ZTogdGV4dCB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBiZWZvcmUgYSBoaXN0b3J5IGl0ZW0gaXMgYmVpbmcgdW5kb25lXG4gICAqIEBwYXJhbSAge09iamVjdH0gaGlzdG9yeU9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmVmb3JlSGlzdG9yeVVuZG8gKGhpc3RvcnlPYmplY3QpIHtcbiAgICBjb25zdCB7IG9wZXJhdGlvbiwgb3B0aW9ucyB9ID0gaGlzdG9yeU9iamVjdFxuICAgIGlmIChvcGVyYXRpb24gIT09IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ29wZXJhdGlvbicpKSByZXR1cm5cblxuICAgIGNvbnN0IHsgc3ByaXRlcyB9ID0gb3B0aW9uc1xuICAgIGlmIChzcHJpdGVzLmluZGV4T2YodGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKSkgPT09IC0xKSB7XG4gICAgICAvLyBDdXJyZW50bHkgc2VsZWN0ZWQgc3ByaXRlIGlzIGJlaW5nIHJlbW92ZWQuIExlYXZlIGNvbnRyb2wgd2l0aG91dCBhZGRpbmcgaGlzdG9yeSBpdGVtLlxuICAgICAgdGhpcy5zZXRTaGFyZWRTdGF0ZSh7IHNraXBIaXN0b3J5OiB0cnVlIH0sIGZhbHNlKVxuICAgICAgdGhpcy5wcm9wcy5vblN3aXRjaENvbnRyb2xzKCdob21lJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGJhY2sgYnV0dG9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhY2tDbGljayAoZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBlZGl0b3IucmVuZGVyKClcbiAgICB0aGlzLl9iYWNrQnV0dG9uQ2xpY2tlZCA9IHRydWVcbiAgICB0aGlzLnByb3BzLm9uU3dpdGNoQ29udHJvbHMoJ2hvbWUnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNoYXJlZCBzdGF0ZSBoYXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5ld1N0YXRlXG4gICAqL1xuICBzaGFyZWRTdGF0ZURpZENoYW5nZSAobmV3U3RhdGUpIHtcbiAgICBpZiAoJ3NlbGVjdGVkU3ByaXRlJyBpbiBuZXdTdGF0ZSkge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGZvbnQgc2l6ZSBoYXMgYmVlbiBjaGFuZ2VkXG4gICAqIEBwYXJhbSAge051bWJlcn0gZm9udFNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkZvbnRTaXplQ2hhbmdlIChmb250U2l6ZSkge1xuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBzZWxlY3RlZFRleHQuc2V0Rm9udFNpemUoZm9udFNpemUgLyBvdXRwdXREaW1lbnNpb25zLnkpXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZm9udCBmYW1pbHkgb3Igd2VpZ2h0IGhhcyBiZWVuIGNoYW5nZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBmb250XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Gb250Q2hhbmdlIChmb250KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIHNlbGVjdGVkVGV4dC5zZXRGb250RmFtaWx5KGZvbnQuZ2V0Rm9udEZhbWlseSgpKVxuICAgIHNlbGVjdGVkVGV4dC5zZXRGb250V2VpZ2h0KGZvbnQuZ2V0Rm9udFdlaWdodCgpKVxuICAgIHNlbGVjdGVkVGV4dC5zZXRGb250U3R5bGUoZm9udC5nZXRGb250U3R5bGUoKSlcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYWxpZ25tZW50IGJ1dHRvblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQWxpZ25tZW50Q2xpY2sgKGUpIHtcbiAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG4gICAgY29uc3QgYWxpZ25tZW50ID0gc2VsZWN0ZWRUZXh0LmdldEFsaWdubWVudCgpXG5cbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSBBTElHTk1FTlRTLmluZGV4T2YoYWxpZ25tZW50KVxuICAgIGNvbnN0IG5leHRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIEFMSUdOTUVOVFMubGVuZ3RoXG4gICAgY29uc3QgbmV3QWxpZ25tZW50ID0gQUxJR05NRU5UU1tuZXh0SW5kZXhdXG5cbiAgICBzZWxlY3RlZFRleHQuc2V0QWxpZ25tZW50KG5ld0FsaWdubWVudClcbiAgICB0aGlzLmZvcmNlU2hhcmVkVXBkYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgXCJ0YWtlIHRvIGZyb250XCIgYnV0dG9uXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25UYWtlVG9Gcm9udENsaWNrIChlKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnb3BlcmF0aW9uJylcbiAgICBvcGVyYXRpb24udGFrZVNwcml0ZVRvRnJvbnQodGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKSlcbiAgICB0aGlzLmZvcmNlU2hhcmVkVXBkYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIGZvcmVncm91bmQgY29sb3JcbiAgICogQHBhcmFtICB7Q29sb3J9IGNvbG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Gb3JlZ3JvdW5kQ29sb3JDaGFuZ2UgKGNvbG9yKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIHNlbGVjdGVkVGV4dC5zZXRDb2xvcihjb2xvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIGJhY2tncm91bmQgY29sb3JcbiAgICogQHBhcmFtICB7Q29sb3J9IGNvbG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CYWNrZ3JvdW5kQ29sb3JDaGFuZ2UgKGNvbG9yKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIHNlbGVjdGVkVGV4dC5zZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNT0RFU1xuXG4gIC8qKlxuICAgKiBTd2l0Y2hlcyB0byB0aGUgZ2l2ZW4gbW9kZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zd2l0Y2hUb01vZGUgKG1vZGUpIHtcbiAgICBpZiAobW9kZSA9PT0gdGhpcy5zdGF0ZS5tb2RlKSBtb2RlID0gbnVsbFxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IG1vZGUgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBvdmVybGF5IGNvbnRyb2xzIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJPdmVybGF5Q29udHJvbHMgKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckZvbnRTaXplT3ZlcmxheUNvbnRyb2woKVxuICAgICAgY2FzZSAnZm9udCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJGb250RmFtaWx5T3ZlcmxheUNvbnRyb2woKVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBGT05UIFNJWkVcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZm9udCBzaXplIG92ZXJsYXkgY29udHJvbCAoc2xpZGVyKVxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckZvbnRTaXplT3ZlcmxheUNvbnRyb2wgKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBpZiAoIXNlbGVjdGVkVGV4dCkgcmV0dXJuXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgb3V0cHV0RGltZW5zaW9ucyA9IGVkaXRvci5nZXRPdXRwdXREaW1lbnNpb25zKClcblxuICAgIGNvbnN0IG1heEZvbnRTaXplID0gTWF0aC5yb3VuZChvdXRwdXREaW1lbnNpb25zLnkpXG4gICAgY29uc3QgZm9udFNpemUgPSBNYXRoLnJvdW5kKHNlbGVjdGVkVGV4dC5nZXRGb250U2l6ZSgpICogb3V0cHV0RGltZW5zaW9ucy55KVxuICAgIHJldHVybiAoPFNsaWRlck92ZXJsYXlDb21wb25lbnRcbiAgICAgIHZhbHVlPXtmb250U2l6ZX1cbiAgICAgIG1heFZhbHVlPXttYXhGb250U2l6ZX1cbiAgICAgIGxhYmVsPXt0aGlzLl90KCdjb250cm9scy50ZXh0LnNpemUnKX1cbiAgICAgIG9uQ2hhbmdlPXt0aGlzLl9vbkZvbnRTaXplQ2hhbmdlfSAvPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmb250IHNpemUgbGlzdCBpdGVtXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJTaXplSXRlbSAoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIGlmICghc2VsZWN0ZWRUZXh0KSByZXR1cm5cblxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldE91dHB1dERpbWVuc2lvbnMoKVxuXG4gICAgY29uc3QgZm9udFNpemUgPSBzZWxlY3RlZFRleHQuZ2V0Rm9udFNpemUoKVxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMuc3RhdGUubW9kZSA9PT0gJ3NpemUnID8gJ2lzLWFjdGl2ZScgOiBudWxsXG5cbiAgICByZXR1cm4gKDxsaVxuICAgICAgYmVtPSdlOml0ZW0nXG4gICAgICBrZXk9J3NpemUnPlxuICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGJlbT0nJGU6YnV0dG9uIG06d2l0aExhYmVsJ1xuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgIGRhdGEtaWRlbnRpZmllcj0nZm9udFNpemUnXG4gICAgICAgICAgb25DbGljaz17dGhpcy5fc3dpdGNoVG9Nb2RlLmJpbmQodGhpcywgJ3NpemUnKX0+XG4gICAgICAgICAgPGRpdiBiZW09J2I6Zm9udFNpemUgZTp0ZXh0Jz57TWF0aC5yb3VuZChmb250U2l6ZSAqIG91dHB1dERpbWVuc2lvbnMueSl9PC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLl90KCdjb250cm9scy50ZXh0LnNpemUnKX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZPTlQgRkFNSUxZXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZvbnQgZmFtaWx5IG92ZXJsYXkgY29udHJvbFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckZvbnRGYW1pbHlPdmVybGF5Q29udHJvbCAoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIGlmICghc2VsZWN0ZWRUZXh0KSByZXR1cm5cblxuICAgIHJldHVybiAoPEZvbnRDb21wb25lbnRcbiAgICAgIGZvbnRGYW1pbHk9e3NlbGVjdGVkVGV4dC5nZXRGb250RmFtaWx5KCl9XG4gICAgICBmb250V2VpZ2h0PXtzZWxlY3RlZFRleHQuZ2V0Rm9udFdlaWdodCgpfVxuICAgICAgZm9udFN0eWxlPXtzZWxlY3RlZFRleHQuZ2V0Rm9udFN0eWxlKCl9XG4gICAgICBmb250cz17dGhpcy5fZm9udHN9XG4gICAgICBvbkNoYW5nZT17dGhpcy5fb25Gb250Q2hhbmdlfSAvPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmb250IGxpc3QgaXRlbVxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyRm9udEl0ZW0gKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0U2hhcmVkU3RhdGUoJ3NlbGVjdGVkU3ByaXRlJylcbiAgICBpZiAoIXNlbGVjdGVkVGV4dCkgcmV0dXJuXG5cbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLnN0YXRlLm1vZGUgPT09ICdmb250JyA/ICdpcy1hY3RpdmUnIDogbnVsbFxuICAgIHJldHVybiAoPGxpXG4gICAgICBiZW09J2U6aXRlbSdcbiAgICAgIGtleT0nZm9udCc+XG4gICAgICA8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgYmVtPSckZTpidXR0b24gbTp3aXRoTGFiZWwnXG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgZGF0YS1pZGVudGlmaWVyPSdmb250J1xuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX3N3aXRjaFRvTW9kZS5iaW5kKHRoaXMsICdmb250Jyl9PlxuICAgICAgICAgIDxGb250UHJldmlld0NvbXBvbmVudFxuICAgICAgICAgICAgZm9udEZhbWlseT17c2VsZWN0ZWRUZXh0LmdldEZvbnRGYW1pbHkoKX1cbiAgICAgICAgICAgIGZvbnRXZWlnaHQ9e3NlbGVjdGVkVGV4dC5nZXRGb250V2VpZ2h0KCl9XG4gICAgICAgICAgICBmb250U3R5bGU9e3NlbGVjdGVkVGV4dC5nZXRGb250U3R5bGUoKX0gLz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoJ2NvbnRyb2xzLnRleHQuZm9udCcpfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvYmVtPlxuICAgIDwvbGk+KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQUxJR05NRU5UXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHRleHQgYWxpZ25tZW50IGxpc3QgaXRlbVxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQWxpZ25tZW50SXRlbSAoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTaGFyZWRTdGF0ZSgnc2VsZWN0ZWRTcHJpdGUnKVxuICAgIGlmICghc2VsZWN0ZWRUZXh0KSByZXR1cm5cblxuICAgIGNvbnN0IGFsaWdubWVudCA9IHNlbGVjdGVkVGV4dC5nZXRBbGlnbm1lbnQoKVxuXG4gICAgcmV0dXJuICg8bGlcbiAgICAgIGJlbT0nZTppdGVtJ1xuICAgICAga2V5PSdhbGlnbm1lbnQnPlxuICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGJlbT0nJGU6YnV0dG9uIG06d2l0aExhYmVsJ1xuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uQWxpZ25tZW50Q2xpY2t9XG4gICAgICAgICAgZGF0YS1pZGVudGlmaWVyPSdhbGlnbm1lbnQnPlxuICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKGBjb250cm9scy90ZXh0L2FsaWduXyR7YWxpZ25tZW50fS5wbmdgLCB0cnVlKX0gLz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoJ2NvbnRyb2xzLnRleHQuYWxpZ25tZW50Jyl9PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9iZW0+XG4gICAgPC9saT4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgXCJ0YWtlIHRvIGZyb250XCIgbGlzdCBpdGVtXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJUYWtlVG9Gcm9udEl0ZW0gKCkge1xuICAgIHJldHVybiAoPGxpXG4gICAgICBiZW09J2U6aXRlbSdcbiAgICAgIGtleT0ndGFrZVRvRnJvbnQnPlxuICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOmNvbnRyb2xzJz5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGJlbT0nJGU6YnV0dG9uIG06d2l0aExhYmVsJ1xuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uVGFrZVRvRnJvbnRDbGlja30+XG4gICAgICAgICAgPGltZyBiZW09J2U6aWNvbicgc3JjPXt0aGlzLl9nZXRBc3NldFBhdGgoJ2NvbnRyb2xzL3Nwcml0ZXMvdGFrZV90b19mcm9udC5wbmcnLCB0cnVlKX0gLz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpsYWJlbCc+e3RoaXMuX3QoJ2NvbnRyb2xzLnRleHQudGFrZVRvRnJvbnQnKX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICovXG4gIHJlbmRlckNvbnRyb2xzICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5sb2FkaW5nKSByZXR1cm4gPGRpdiAvPlxuXG4gICAgY29uc3QgbGlzdEl0ZW1zID0gW1xuICAgICAgdGhpcy5fcmVuZGVyU2l6ZUl0ZW0oKSxcbiAgICAgIHRoaXMuX3JlbmRlckZvbnRJdGVtKCksXG4gICAgICB0aGlzLl9yZW5kZXJBbGlnbm1lbnRJdGVtKClcbiAgICBdXG5cbiAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFNoYXJlZFN0YXRlKCdzZWxlY3RlZFNwcml0ZScpXG5cbiAgICBjb25zdCBmb3JlZ3JvdW5kQ29sb3IgPSBzZWxlY3RlZFRleHQuZ2V0Q29sb3IoKS5jbG9uZSgpXG4gICAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gc2VsZWN0ZWRUZXh0LmdldEJhY2tncm91bmRDb2xvcigpLmNsb25lKClcblxuICAgIHJldHVybiBbXG4gICAgICAoPGRpdiBiZW09J2U6Y2VsbCBtOmxpc3QnPlxuICAgICAgICA8U2Nyb2xsYmFyQ29tcG9uZW50IHJlZj0nc2Nyb2xsYmFyJz5cbiAgICAgICAgICA8dWwgYmVtPSckZTpsaXN0Jz5cbiAgICAgICAgICAgIHtsaXN0SXRlbXN9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC9TY3JvbGxiYXJDb21wb25lbnQ+XG4gICAgICA8L2Rpdj4pLFxuICAgICAgKDxkaXYgYmVtPSdlOmNlbGwgbTpjb2xvclBpY2tlcic+XG4gICAgICAgIDxDb2xvclBpY2tlckNvbXBvbmVudFxuICAgICAgICAgIGluaXRpYWxWYWx1ZT17Zm9yZWdyb3VuZENvbG9yfVxuICAgICAgICAgIGxhYmVsPXt0aGlzLl90KCdjb250cm9scy50ZXh0LmZvcmVncm91bmQnKX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25Gb3JlZ3JvdW5kQ29sb3JDaGFuZ2V9IC8+XG4gICAgICA8L2Rpdj4pLFxuICAgICAgKDxkaXYgYmVtPSdlOmNlbGwgbTpjb2xvclBpY2tlcic+XG4gICAgICAgIDxDb2xvclBpY2tlckNvbXBvbmVudFxuICAgICAgICAgIGluaXRpYWxWYWx1ZT17YmFja2dyb3VuZENvbG9yfVxuICAgICAgICAgIGxhYmVsPXt0aGlzLl90KCdjb250cm9scy50ZXh0LmJhY2tncm91bmQnKX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25CYWNrZ3JvdW5kQ29sb3JDaGFuZ2V9IC8+XG4gICAgICA8L2Rpdj4pXG4gICAgXVxuICB9XG59XG5cblRleHRDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBDb250cm9sc0NvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvdGV4dC90ZXh0LWNvbnRyb2xzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50LCBSZWFjdEJFTSwgVXRpbHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0Q29udHJvbHNPdmVybGF5Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYGVkaXRgIGl0ZW1cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkVkaXRDbGljayAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIHRoaXMucHJvcHMub25FZGl0ICYmIHRoaXMucHJvcHMub25FZGl0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYHRha2UgdG8gZnJvbnRgIGl0ZW1cbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblRha2VUb0Zyb250Q2xpY2sgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uVGFrZVRvRnJvbnQgJiYgdGhpcy5wcm9wcy5vblRha2VUb0Zyb250KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYHJlbW92ZWAgaXRlbVxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUmVtb3ZlQ2xpY2sgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICB0aGlzLnByb3BzLm9uUmVtb3ZlICYmIHRoaXMucHJvcHMub25SZW1vdmUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGl0ZW1zIG9mIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge0FycmF5LjxSZWFjdEJFTS5FbGVtZW50Pn1cbiAgICovXG4gIF9yZW5kZXJJdGVtcyAoKSB7XG4gICAgbGV0IGl0ZW1zID0gW1xuICAgICAgKDxkaXYgYmVtPSckZTppdGVtJyBvbkNsaWNrPXt0aGlzLl9vblRha2VUb0Zyb250Q2xpY2suYmluZCh0aGlzKX0+XG4gICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9zcHJpdGVzL3Rha2UtdG8tZnJvbnQucG5nJywgdHJ1ZSl9IC8+XG4gICAgICA8L2Rpdj4pXG4gICAgXVxuXG4gICAgaWYgKFV0aWxzLmlzTW9iaWxlKCkpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFtcbiAgICAgICAgKDxkaXYgYmVtPSckZTpzZXBhcmF0b3InIC8+KSxcbiAgICAgICAgKDxkaXYgYmVtPSckZTppdGVtJyBvbkNsaWNrPXt0aGlzLl9vbkVkaXRDbGljay5iaW5kKHRoaXMpfT5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMuX2dldEFzc2V0UGF0aCgnY29udHJvbHMvc3ByaXRlcy9lZGl0LnBuZycsIHRydWUpfSAvPlxuICAgICAgICA8L2Rpdj4pXG4gICAgICBdKVxuICAgIH1cblxuICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFtcbiAgICAgICg8ZGl2IGJlbT0nJGU6c2VwYXJhdG9yJyAvPiksXG4gICAgICAoPGRpdiBiZW09JyRlOml0ZW0nIG9uQ2xpY2s9e3RoaXMuX29uUmVtb3ZlQ2xpY2suYmluZCh0aGlzKX0+XG4gICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy9zcHJpdGVzL3JlbW92ZS5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PilcbiAgICBdKVxuXG4gICAgcmV0dXJuIGl0ZW1zXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8ZGl2XG4gICAgICBiZW09JyRiOnNwcml0ZXNDb250cm9sc092ZXJsYXknPlxuICAgICAge3RoaXMuX3JlbmRlckl0ZW1zKCl9XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblRleHRDb250cm9sc092ZXJsYXlDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY29udHJvbHMvdGV4dC90ZXh0LWNvbnRyb2xzLW92ZXJsYXktY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9uZUJ1dHRvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nJGI6Y29udHJvbHMnPlxuICAgICAgPGRpdiBiZW09J2U6Y2VsbCBtOmxhcmdlQnV0dG9uJz5cbiAgICAgICAgPGRpdiBiZW09JyRlOmxhcmdlQnV0dG9uJyBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xpY2t9PlxuICAgICAgICAgIDxpbWcgYmVtPSdlOmljb24nIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjb250cm9scy90aWNrLnBuZycsIHRydWUpfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5Eb25lQnV0dG9uQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2RvbmUtYnV0dG9uLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuaW1wb3J0IHsgQ29uc3RhbnRzLCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKCdfb25DbG9zZUNsaWNrJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgY2xvc2UgYnV0dG9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DbG9zZUNsaWNrICgpIHtcbiAgICB0aGlzLmNvbnRleHQubWVkaWF0b3IuZW1pdChDb25zdGFudHMuRVZFTlRTLkNMT1NFKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGxldCBjbG9zZUJ1dHRvblxuICAgIGlmICh0aGlzLmNvbnRleHQub3B0aW9ucy5zaG93Q2xvc2VCdXR0b24pIHtcbiAgICAgIGNsb3NlQnV0dG9uID0gKDxkaXYgYmVtPSckZTpjbG9zZScgb25DbGljaz17dGhpcy5fb25DbG9zZUNsaWNrfT5cbiAgICAgICAgPGltZyBiZW09J2U6aW1hZ2UnIHNyYz17dGhpcy5fZ2V0QXNzZXRQYXRoKCdjbG9zZS5wbmcnLCB0cnVlKX0gLz5cbiAgICAgIDwvZGl2PilcbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpoZWFkZXInPlxuICAgICAgPGRpdiBiZW09J2U6bGFiZWwnPnt0aGlzLmNvbnRleHQub3B0aW9ucy50aXRsZX08L2Rpdj5cbiAgICAgIHtjbG9zZUJ1dHRvbn1cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuSGVhZGVyQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2hlYWRlci1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IExvYWRpbmdNb2RhbENvbXBvbmVudCBmcm9tICcuL21vZGFscy9sb2FkaW5nLW1vZGFsLWNvbXBvbmVudCdcbmltcG9ydCBXYXJuaW5nTW9kYWxDb21wb25lbnQgZnJvbSAnLi9tb2RhbHMvd2FybmluZy1tb2RhbC1jb21wb25lbnQnXG5pbXBvcnQgRXJyb3JNb2RhbENvbXBvbmVudCBmcm9tICcuL21vZGFscy9lcnJvci1tb2RhbC1jb21wb25lbnQnXG5pbXBvcnQgUHJvZ3Jlc3NNb2RhbENvbXBvbmVudCBmcm9tICcuL21vZGFscy9wcm9ncmVzcy1tb2RhbC1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQ29udGFpbmVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX21vZGFsTWFuYWdlciA9IHRoaXMucHJvcHMubW9kYWxNYW5hZ2VyXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25Nb2RhbE1hbmFnZXJVcGRhdGUnXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHN1cGVyLmNvbXBvbmVudERpZE1vdW50KClcblxuICAgIHRoaXMuX21vZGFsTWFuYWdlci5vbigndXBkYXRlJywgdGhpcy5fb25Nb2RhbE1hbmFnZXJVcGRhdGUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSB1bm1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCgpXG5cbiAgICB0aGlzLl9tb2RhbE1hbmFnZXIub2ZmKCd1cGRhdGUnLCB0aGlzLl9vbk1vZGFsTWFuYWdlclVwZGF0ZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBtb2RhbCBtYW5hZ2VyIHVwZGF0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vZGFsTWFuYWdlclVwZGF0ZSAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIG1vZGFsIGlzIGNsb3NlZC4gUmVtb3ZlcyBpdCBmcm9tIHRoZSBtYW5hZ2VyLlxuICAgKiBAcGFyYW0gIHtNb2RhbH0gbW9kYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk1vZGFsQ2xvc2VkIChtb2RhbCkge1xuICAgIHRoaXMuX21vZGFsTWFuYWdlci5yZW1vdmVNb2RhbChtb2RhbClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBtb2RhbHNcbiAgICogQHJldHVybiB7QXJyYXkuPFJlYWN0LkNvbXBvbmVudD59XG4gICAqL1xuICBfcmVuZGVyTW9kYWxzICgpIHtcbiAgICBjb25zdCBtb2RhbHMgPSB0aGlzLl9tb2RhbE1hbmFnZXIuZ2V0TW9kYWxzKClcbiAgICByZXR1cm4gbW9kYWxzLm1hcCgobW9kYWwpID0+IHtcbiAgICAgIGxldCBNb2RhbENvbXBvbmVudFxuXG4gICAgICBzd2l0Y2ggKG1vZGFsLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgTW9kYWxDb21wb25lbnQgPSBMb2FkaW5nTW9kYWxDb21wb25lbnRcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgICBNb2RhbENvbXBvbmVudCA9IFdhcm5pbmdNb2RhbENvbXBvbmVudFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBNb2RhbENvbXBvbmVudCA9IEVycm9yTW9kYWxDb21wb25lbnRcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwcm9ncmVzcyc6XG4gICAgICAgICAgTW9kYWxDb21wb25lbnQgPSBQcm9ncmVzc01vZGFsQ29tcG9uZW50XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICg8TW9kYWxDb21wb25lbnRcbiAgICAgICAgbW9kYWw9e21vZGFsfVxuICAgICAgICBvbkNsb3NlPXt0aGlzLl9vbk1vZGFsQ2xvc2VkLmJpbmQodGhpcywgbW9kYWwpfSAvPilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIHJldHVybiAoPGRpdj57dGhpcy5fcmVuZGVyTW9kYWxzKCl9PC9kaXY+KVxuICB9XG59XG5cbk1vZGFsQ29udGFpbmVyQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL21vZGFsLWNvbnRhaW5lci1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3QsIFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JNb2RhbENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fYmluZEFsbCgnX29uQ2xvc2UnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBjbG9zZSBidXR0b25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNsb3NlICgpIHtcbiAgICB0aGlzLnByb3BzLm1vZGFsLmNsb3NlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBjb25zdCBtb2RhbCA9IHRoaXMucHJvcHMubW9kYWxcblxuICAgIGNvbnN0IG1vZGFsRWxlbWVudCA9ICg8ZGl2IGJlbT0nZTptb2RhbCBtOmVycm9yJz5cbiAgICAgIDxkaXYgYmVtPSdlOnRpdGxlJz57bW9kYWwudGl0bGV9PC9kaXY+XG4gICAgICA8ZGl2IGJlbT0nZTp0ZXh0Jz57bW9kYWwudGV4dH08L2Rpdj5cbiAgICAgIDxkaXYgYmVtPSdlOmJ1dHRvbiBiOmJ1dHRvbiBtOmlubGluZScgb25DbGljaz17dGhpcy5fb25DbG9zZX0+T0s8L2Rpdj5cbiAgICA8L2Rpdj4pXG5cbiAgICBjb25zdCBjb250ZW50ID0gbW9kYWwub3ZlcmxheVxuICAgICAgPyAoPGRpdiBiZW09J2U6b3ZlcmxheSc+e21vZGFsRWxlbWVudH08L2Rpdj4pXG4gICAgICA6IG1vZGFsRWxlbWVudFxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjptb2RhbHMnPlxuICAgICAgICB7Y29udGVudH1cbiAgICAgIDwvYmVtPlxuICAgIClcbiAgfVxufVxuXG5FcnJvck1vZGFsQ29tcG9uZW50LnByb3BUeXBlcyA9IHtcbiAgbW9kYWw6IFJlYWN0LlByb3BUeXBlcy5vYmplY3Rcbn1cblxuRXJyb3JNb2RhbENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9tb2RhbHMvZXJyb3ItbW9kYWwtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0LCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRpbmdNb2RhbENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzLnByb3BzLm1vZGFsXG4gICAgcmV0dXJuIChcbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjptb2RhbHMnPlxuICAgICAgICA8ZGl2IGJlbT0nZTpvdmVybGF5Jz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTptb2RhbCBtOmxvYWRpbmcnPlxuICAgICAgICAgICAgPGRpdiBiZW09J2U6dGV4dCc+e21vZGFsLnRleHR9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9iZW0+XG4gICAgKVxuICB9XG59XG5cbkxvYWRpbmdNb2RhbENvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIG1vZGFsOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG59XG5cbkxvYWRpbmdNb2RhbENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9tb2RhbHMvbG9hZGluZy1tb2RhbC1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3QsIFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NNb2RhbENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzLnByb3BzLm1vZGFsXG4gICAgY29uc3QgeyBwcm9ncmVzcyB9ID0gbW9kYWwuZGF0YVxuICAgIGNvbnN0IHByb2dyZXNzU3R5bGUgPSB7XG4gICAgICB3aWR0aDogKChwcm9ncmVzcyB8fCAwKSAqIDEwMCkudG9GaXhlZCgyKSArICclJ1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPGJlbSBzcGVjaWZpZXI9JyRiOm1vZGFscyc+XG4gICAgICAgIDxkaXYgYmVtPSdlOm92ZXJsYXknPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOm1vZGFsIG06bG9hZGluZyc+XG4gICAgICAgICAgICA8ZGl2IGJlbT0nZTp0ZXh0Jz57bW9kYWwudGV4dH08L2Rpdj5cbiAgICAgICAgICAgIDxiZW0gc3BlY2lmaWVyPSdiOmxvYWRpbmdNb2RhbCc+XG4gICAgICAgICAgICAgIDxkaXYgYmVtPSckZTpwcm9ncmVzc0Jhcic+XG4gICAgICAgICAgICAgICAgPGRpdiBiZW09J2U6cHJvZ3Jlc3MnIHN0eWxlPXtwcm9ncmVzc1N0eWxlfSAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvYmVtPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvYmVtPlxuICAgIClcbiAgfVxufVxuXG5Qcm9ncmVzc01vZGFsQ29tcG9uZW50LnByb3BUeXBlcyA9IHtcbiAgbW9kYWw6IFJlYWN0LlByb3BUeXBlcy5vYmplY3Rcbn1cblxuUHJvZ3Jlc3NNb2RhbENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9tb2RhbHMvcHJvZ3Jlc3MtbW9kYWwtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0LCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhcm5pbmdNb2RhbENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgbW9kYWwgPSB0aGlzLnByb3BzLm1vZGFsXG4gICAgcmV0dXJuIChcbiAgICAgIDxiZW0gc3BlY2lmaWVyPSckYjptb2RhbHMnPlxuICAgICAgICA8ZGl2IGJlbT0nZTptb2RhbCBtOndhcm5pbmcnPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOnRpdGxlJz57bW9kYWwudGl0bGV9PC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6dGV4dCc+e21vZGFsLnRleHR9PC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6YnV0dG9uIGI6YnV0dG9uIG06aW5saW5lJyBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xvc2V9Pk9LPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9iZW0+XG4gICAgKVxuICB9XG59XG5cbldhcm5pbmdNb2RhbENvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIG1vZGFsOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG59XG5cbldhcm5pbmdNb2RhbENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9tb2RhbHMvd2FybmluZy1tb2RhbC1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHtcbiAgVXRpbHMsIFJlYWN0QkVNLCBWZWN0b3IyLCBCYXNlQ29tcG9uZW50LCBDb25zdGFudHNcbn0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uRHJhZ1N0YXJ0JyxcbiAgICAgICdfb25EcmFnTW92ZScsXG4gICAgICAnX29uRHJhZ0VuZCcsXG4gICAgICAnX29uV2luZG93UmVzaXplJyxcbiAgICAgICdfb25GZWF0dXJlc1VwZGF0ZWQnLFxuICAgICAgJ19vblpvb21DaGFuZ2UnXG4gICAgKVxuXG4gICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuV0lORE9XX1JFU0laRV06IHRoaXMuX29uV2luZG93UmVzaXplLFxuICAgICAgW0NvbnN0YW50cy5FVkVOVFMuRkVBVFVSRVNfVVBEQVRFRF06IHRoaXMuX29uRmVhdHVyZXNVcGRhdGVkXG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbFJlbmRlckRvbmUgPSBmYWxzZVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNhbnZhc1Bvc2l0aW9uOiBuZXcgVmVjdG9yMigpLFxuICAgICAgY2FudmFzT2Zmc2V0OiBuZXcgVmVjdG9yMigpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSB3aW5kb3cgaGFzIGJlZW4gcmVzaXplZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uV2luZG93UmVzaXplICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3Qgc2RrID0gZWRpdG9yLmdldFNESygpXG4gICAgc2RrLnJlc2l6ZVRvKHRoaXMuX2dldENvbnRhaW5lckRpbWVuc2lvbnMoKSlcbiAgICBlZGl0b3Iuem9vbS5zZXQoJ2F1dG8nKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gZmVhdHVyZXMgKGUuZy4gZHJhZykgYXJlIHVwZGF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gaWRlbnRpZmllcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkZlYXR1cmVzVXBkYXRlZCAoaWRlbnRpZmllcnMpIHtcbiAgICBpZiAoaWRlbnRpZmllcnMuaW5kZXhPZignZHJhZycpICE9PSAtMSkge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG5cbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgY29uc3QgcmVuZGVyZXIgPSBlZGl0b3IuZ2V0UmVuZGVyZXIoKVxuXG4gICAgY29uc3QgeyBjYW52YXNDZWxsLCBjYW52YXMgfSA9IHRoaXMucmVmc1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzQ2VsbC5vZmZzZXRXaWR0aFxuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhc0NlbGwub2Zmc2V0SGVpZ2h0XG4gICAgcmVuZGVyZXIuc2V0Q2FudmFzKGNhbnZhcylcbiAgICByZW5kZXJlci5yZXNpemVUbyhuZXcgVmVjdG9yMih3aWR0aCwgaGVpZ2h0KSwgdHJ1ZSlcblxuICAgIGVkaXRvci56b29tLm9uKCdzZXQnLCB0aGlzLl9vblpvb21DaGFuZ2UpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSB1bm1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcy5jb250ZXh0XG4gICAgZWRpdG9yLnpvb20ub2ZmKCdzZXQnLCB0aGlzLl9vblpvb21DaGFuZ2UpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgem9vbSBoYXMgY2hhbmdlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uWm9vbUNoYW5nZSAoKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBEUkFHR0lOR1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSB7UmVhY3QuU3ludGhldGljRXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRyYWdTdGFydCAoZSkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBpZiAoIWVkaXRvci5mZWF0dXJlcy5pc0VuYWJsZWQoJ2RyYWcnKSkgcmV0dXJuXG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIHRoaXMuX2RyYWdTdGFydFBvc2l0aW9uID0gVXRpbHMuZ2V0RXZlbnRQb3NpdGlvbihlLm5hdGl2ZUV2ZW50KVxuICAgIHRoaXMuX2RyYWdJbml0aWFsT2Zmc2V0ID0gZWRpdG9yLmdldE9mZnNldCgpLmNsb25lKClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkRyYWdNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uRHJhZ01vdmUpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uRHJhZ0VuZClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uRHJhZ0VuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSB7RE9NRXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRyYWdNb3ZlIChlKSB7XG4gICAgY29uc3QgZXZlbnRQb3NpdGlvbiA9IFV0aWxzLmdldEV2ZW50UG9zaXRpb24oZSlcbiAgICBjb25zdCBkaWZmRnJvbVN0YXJ0ID0gZXZlbnRQb3NpdGlvblxuICAgICAgLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdCh0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbilcblxuICAgIGNvbnN0IG5ld09mZnNldCA9IHRoaXMuX2RyYWdJbml0aWFsT2Zmc2V0XG4gICAgICAuY2xvbmUoKVxuICAgICAgLmFkZChkaWZmRnJvbVN0YXJ0KVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IGxhc3RPZmZzZXQgPSBlZGl0b3IuZ2V0T2Zmc2V0KCkuY2xvbmUoKVxuICAgIGVkaXRvci5zZXRPZmZzZXQobmV3T2Zmc2V0KVxuICAgIGlmICghZWRpdG9yLmdldE9mZnNldCgpLmVxdWFscyhsYXN0T2Zmc2V0KSkge1xuICAgICAgZWRpdG9yLnJlbmRlcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge0RPTUV2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25EcmFnRW5kIChlKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25EcmFnTW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkRyYWdNb3ZlKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkRyYWdFbmQpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkRyYWdFbmQpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRhaW5lcidzIGRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDb250YWluZXJEaW1lbnNpb25zICgpIHtcbiAgICBjb25zdCB7IGNhbnZhc0NlbGwgfSA9IHRoaXMucmVmc1xuICAgIHJldHVybiBuZXcgVmVjdG9yMihjYW52YXNDZWxsLm9mZnNldFdpZHRoLCBjYW52YXNDZWxsLm9mZnNldEhlaWdodClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgZHJhZ2dhYmxlIGNhbnZhcyBhcmVhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0RHJhZ2dhYmxlU3R5bGUgKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHRoaXMuc3RhdGUuY2FudmFzUG9zaXRpb24ueSArIHRoaXMuc3RhdGUuY2FudmFzT2Zmc2V0LnksXG4gICAgICBsZWZ0OiB0aGlzLnN0YXRlLmNhbnZhc1Bvc2l0aW9uLnggKyB0aGlzLnN0YXRlLmNhbnZhc09mZnNldC54XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGxldCBjYW52YXNDb250ZW50ID0gbnVsbFxuICAgIGxldCBjb250YWluZXJDb250ZW50ID0gbnVsbFxuICAgIGlmICh0aGlzLnByb3BzLmxhcmdlQ29udHJvbHMpIHtcbiAgICAgIGNvbnRhaW5lckNvbnRlbnQgPSB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhc0NvbnRlbnQgPSB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfVxuXG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXMuY29udGV4dFxuICAgIGNvbnN0IHpvb21BbGxvd3NEcmFnID0gZWRpdG9yLmlzUmVhZHkoKSAmJiBlZGl0b3Iuem9vbS5nZXQoKSA+IGVkaXRvci56b29tLmdldERlZmF1bHQoKVxuICAgIGNvbnN0IGRyYWdFbmFibGVkID0gZWRpdG9yLmZlYXR1cmVzLmlzRW5hYmxlZCgnZHJhZycpICYmIHpvb21BbGxvd3NEcmFnXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBiZW09JyRiOmNhbnZhcyBlOmNvbnRhaW5lciBlOnJvdyc+XG4gICAgICAgIDxkaXYgYmVtPSdlOmNvbnRhaW5lciBlOmNlbGwnIHJlZj0nY2FudmFzQ2VsbCc+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgYmVtPSdlOmlubmVyQ29udGFpbmVyJ1xuICAgICAgICAgICAgY2xhc3NOYW1lPXtkcmFnRW5hYmxlZCA/ICdpcy1kcmFnZ2FibGUnIDogbnVsbH1cbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD17dGhpcy5fb25EcmFnU3RhcnR9XG4gICAgICAgICAgICBvbk1vdXNlRG93bj17dGhpcy5fb25EcmFnU3RhcnR9XG4gICAgICAgICAgICBzdHlsZT17dGhpcy5fZ2V0RHJhZ2dhYmxlU3R5bGUoKX0+XG4gICAgICAgICAgICA8Y2FudmFzXG4gICAgICAgICAgICAgIGJlbT0nZTpjYW52YXMnXG4gICAgICAgICAgICAgIHJlZj0nY2FudmFzJyAvPlxuICAgICAgICAgICAge2NhbnZhc0NvbnRlbnR9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge2NvbnRhaW5lckNvbnRlbnR9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbkNhbnZhc0NvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL2VkaXRvci9jYW52YXMtY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5jb25zdCBXSU5ET1dfUkVTSVpFX0RFTEFZID0gNTAwXG5cbmltcG9ydCB7IFJlYWN0LCBTREtVdGlscywgUmVhY3RCRU0sIENvbnN0YW50cywgU2hhcmVkU3RhdGUsIExvZyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgT3ZlcnZpZXdDb250cm9sc0NvbXBvbmVudCBmcm9tICcuLi8uLi9jb250cm9scy9vdmVydmlldy9vdmVydmlldy1jb250cm9scy1jb21wb25lbnQnXG5pbXBvcnQgU2NyZWVuQ29tcG9uZW50IGZyb20gJy4uL3NjcmVlbi1jb21wb25lbnQnXG5pbXBvcnQgQ2FudmFzQ29tcG9uZW50IGZyb20gJy4vY2FudmFzLWNvbXBvbmVudCdcbmltcG9ydCBNb2RhbE1hbmFnZXIgZnJvbSAnLi4vLi4vLi4vbGliL21vZGFsLW1hbmFnZXInXG5pbXBvcnQgT3ZlcnZpZXdDb250cm9scyBmcm9tICcuLi8uLi9jb250cm9scy9vdmVydmlldy8nXG5pbXBvcnQgRWRpdG9yIGZyb20gJy4uLy4uLy4uL2xpYi9lZGl0b3InXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkaXRvclNjcmVlbkNvbXBvbmVudCBleHRlbmRzIFNjcmVlbkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX292ZXJ2aWV3Q29udHJvbHMgPSBPdmVydmlld0NvbnRyb2xzQ29tcG9uZW50XG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ3N3aXRjaFRvQ29udHJvbHMnLFxuICAgICAgJ19zdGFydEVkaXRvcicsXG4gICAgICAnX29uV2luZG93UmVzaXplJyxcbiAgICAgICdfb25XaW5kb3dSZXNpemVEb25lJyxcbiAgICAgICdfb25JbWFnZVJlc2l6ZScsXG4gICAgICAnX29uTmV3SW1hZ2UnLFxuICAgICAgJ19vblJlbmRlckVycm9yJ1xuICAgIClcblxuICAgIHRoaXMuX3ByZXZpb3VzQ29udHJvbHNTdGFjayA9IFtdXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHpvb206IG51bGwsXG4gICAgICBjb250cm9sczogT3ZlcnZpZXdDb250cm9scyxcbiAgICAgIGRyYWdFbmFibGVkOiB0cnVlLFxuICAgICAgc2hhcmVkU3RhdGU6IG5ldyBTaGFyZWRTdGF0ZSgpXG4gICAgfVxuXG4gICAgdGhpcy5fZWRpdG9yID0gbmV3IEVkaXRvcihcbiAgICAgIHRoaXMuY29udGV4dC51aSxcbiAgICAgIHRoaXMuY29udGV4dC5vcHRpb25zLFxuICAgICAgdGhpcy5jb250ZXh0Lm1lZGlhdG9yXG4gICAgKVxuICAgIHRoaXMuX2VkaXRvci5vbignbmV3LWltYWdlJywgdGhpcy5fb25OZXdJbWFnZSlcbiAgICB0aGlzLl9lZGl0b3Iub24oJ3JlYWR5JywgdGhpcy5fc3RhcnRFZGl0b3IpXG4gICAgdGhpcy5fZWRpdG9yLm9uKCdyZXNpemUnLCB0aGlzLl9vbkltYWdlUmVzaXplKVxuICAgIHRoaXMuX2VkaXRvci5vbigncmVuZGVyLWVycm9yJywgdGhpcy5fb25SZW5kZXJFcnJvcilcblxuICAgIHRoaXMuX2ZvcmNlQ29udHJvbHMgPSB0aGlzLmNvbnRleHQub3B0aW9ucy5lZGl0b3IuZm9yY2VDb250cm9sc1xuICAgIHRoaXMuX2ZvcmNlQ29udHJvbEluZGV4ID0gMFxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG5cbiAgICBjb25zdCB7IGltYWdlIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucy5lZGl0b3JcbiAgICB0aGlzLnNldEltYWdlKGltYWdlKVxuICAgIHRoaXMuX2VkaXRvci5yZW5kZXIoKVxuXG4gICAgdGhpcy5fc3dpdGNoVG9OZXh0Rm9yY2VDb250cm9sKClcblxuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0XG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQoKVxuXG4gICAgdGhpcy5fZWRpdG9yLmRpc3Bvc2UoKVxuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0XG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIGFuZCBzdGFydHMgdGhlIGVkaXRvciByZW5kZXJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdGFydEVkaXRvciAoKSB7XG4gICAgdGhpcy5fZWRpdG9yLnN0YXJ0KClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZPUkNFIENPTlRST0xTXG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIHRvIHRoZSBuZXh0IGZvcmNlZCBjb250cm9sXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3dpdGNoVG9OZXh0Rm9yY2VDb250cm9sICgpIHtcbiAgICBpZiAodGhpcy5fZm9yY2VDb250cm9sSW5kZXggPCB0aGlzLl9mb3JjZUNvbnRyb2xzLmxlbmd0aCkge1xuICAgICAgY29uc3QgeyBjb250cm9sLCBvcHRpb25zIH0gPSB0aGlzLl9mb3JjZUNvbnRyb2xzW3RoaXMuX2ZvcmNlQ29udHJvbEluZGV4XVxuICAgICAgY29uc3QgYXZhaWxhYmxlQ29udHJvbHMgPSB0aGlzLl9lZGl0b3IuY29udHJvbHMuZ2V0QXZhaWxhYmxlKClcbiAgICAgIGNvbnN0IGNvbnRyb2xPYmplY3QgPSBhdmFpbGFibGVDb250cm9sc1tjb250cm9sXVxuXG4gICAgICBsZXQgZml4ZWRPcHRpb25zID0gU0RLVXRpbHMuZGVmYXVsdHMoe1xuICAgICAgICBmb3JjZWRDb250cm9sOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKVxuXG4gICAgICBpZiAoIWNvbnRyb2xPYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JjZSBjb250cm9sczogQ291bGQgbm90IGZpbmQgY29udHJvbCB3aXRoIGlkZW50aWZpZXIgXFxgJHtjb250cm9sfVxcYGApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3dpdGNoVG9Db250cm9scyhjb250cm9sT2JqZWN0LCB7fSwgbnVsbCwgZml4ZWRPcHRpb25zKVxuICAgICAgdGhpcy5fZm9yY2VDb250cm9sSW5kZXgrK1xuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlbmRlcmluZ1xuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUmVuZGVyRXJyb3IgKGUpIHtcbiAgICBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUVycm9yKFxuICAgICAgdGhpcy5fdCgnZXJyb3JzLnJlbmRlcmluZ0Vycm9yLnRpdGxlJyksXG4gICAgICB0aGlzLl90KCdlcnJvcnMucmVuZGVyaW5nRXJyb3IudGV4dCcpLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgICBMb2cuZXJyb3IodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVuZGVyaW5nOiAnICsgZS5tZXNzYWdlKVxuICAgIExvZy5wcmludEVycm9yKGUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgaW1hZ2UgaGFzIGJlZW4gY2hhbmdlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTmV3SW1hZ2UgKCkge1xuICAgIHRoaXMuc3dpdGNoVG9Db250cm9scyhPdmVydmlld0NvbnRyb2xzKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGVkaXRvciBzdGFydHMgcmVzaXppbmcgYW4gaW1hZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkltYWdlUmVzaXplICgpIHtcbiAgICBjb25zdCBsb2FkaW5nTW9kYWwgPSBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUxvYWRpbmcodGhpcy5fdCgnbG9hZGluZy5yZXNpemluZycpKVxuICAgIHRoaXMuX2VkaXRvci5vbmNlKCdyZXNpemVkJywgKHsgZGltZW5zaW9ucywgcmVhc29uIH0pID0+IHtcbiAgICAgIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG5cbiAgICAgIGlmICh0aGlzLmNvbnRleHQub3B0aW9ucy5lZGl0b3IuZGlzcGxheVJlc2l6ZU1lc3NhZ2UpIHtcbiAgICAgICAgTW9kYWxNYW5hZ2VyLmluc3RhbmNlLmRpc3BsYXlXYXJuaW5nKFxuICAgICAgICAgIHRoaXMuX3QoYHdhcm5pbmdzLmltYWdlUmVzaXplZF8ke3JlYXNvbn0udGl0bGVgKSxcbiAgICAgICAgICB0aGlzLl90KGB3YXJuaW5ncy5pbWFnZVJlc2l6ZWRfJHtyZWFzb259LnRleHRgLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXhNZWdhUGl4ZWxzOiB0aGlzLl9lZGl0b3IuZ2V0TWF4TWVnYXBpeGVscygpLFxuICAgICAgICAgICAgICB3aWR0aDogZGltZW5zaW9ucy54LFxuICAgICAgICAgICAgICBoZWlnaHQ6IGRpbWVuc2lvbnMueVxuICAgICAgICAgICAgfVxuICAgICAgICAgICkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBvbiB3aW5kb3cgcmVzaXplXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25XaW5kb3dSZXNpemUgKCkge1xuICAgIGlmICh0aGlzLl9yZXNpemVUaW1lb3V0KSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2l6ZVRpbWVvdXQpXG4gICAgICB0aGlzLl9yZXNpemVUaW1lb3V0ID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLl9yZXNpemVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5fb25XaW5kb3dSZXNpemVEb25lLCBXSU5ET1dfUkVTSVpFX0RFTEFZKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGBXSU5ET1dfUkVTSVpFX0RFTEFZYCBtcyBhZnRlciB0aGUgbGFzdCByZXNpemUgZXZlbnQgaGFzIGJlZW4gY2FsbGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25XaW5kb3dSZXNpemVEb25lICgpIHtcbiAgICB0aGlzLl9lbWl0RXZlbnQoQ29uc3RhbnRzLkVWRU5UUy5XSU5ET1dfUkVTSVpFKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlTQ1xuXG4gIC8qKlxuICAgKiBTd2l0Y2hlcyB0byB0aGUgZ2l2ZW4gY29udHJvbHNcbiAgICogQHBhcmFtICB7Q29tcG9uZW50fSBjb250cm9sc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtpbml0aWFsU3RhdGVdID0ge31cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbY29udHJvbE9wdGlvbnNdXG4gICAqL1xuICBzd2l0Y2hUb0NvbnRyb2xzIChjb250cm9scywgaW5pdGlhbFN0YXRlID0ge30sIGNhbGxiYWNrID0gbnVsbCwgY29udHJvbE9wdGlvbnMpIHtcbiAgICBsZXQgbmV3Q29udHJvbHMgPSBudWxsXG4gICAgaWYgKGNvbnRyb2xzID09PSAnYmFjaycpIHtcbiAgICAgIG5ld0NvbnRyb2xzID0gdGhpcy5fcHJldmlvdXNDb250cm9sc1N0YWNrLnBvcCgpXG4gICAgfSBlbHNlIGlmIChjb250cm9scyA9PT0gJ2hvbWUnKSB7XG4gICAgICAvLyBXaGVuIGEgY29udHJvbCBzd2l0Y2hlcyB0byBgaG9tZWAsIG92ZXJyaWRlIHRoaXMgYWN0aW9uXG4gICAgICAvLyB3aXRoIHN3aXRjaGluZyB0byB0aGUgbmV4dCBmb3JjZSBjb250cm9sIChpZiBwcmVzZW50KVxuICAgICAgaWYgKHRoaXMuX2ZvcmNlQ29udHJvbEluZGV4IDwgdGhpcy5fZm9yY2VDb250cm9scy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N3aXRjaFRvTmV4dEZvcmNlQ29udHJvbCgpXG4gICAgICB9XG5cbiAgICAgIG5ld0NvbnRyb2xzID0gT3ZlcnZpZXdDb250cm9sc1xuICAgICAgdGhpcy5fcHJldmlvdXNDb250cm9sc1N0YWNrID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q29udHJvbHMgPSBjb250cm9sc1xuICAgICAgdGhpcy5fcHJldmlvdXNDb250cm9sc1N0YWNrLnB1c2godGhpcy5zdGF0ZS5jb250cm9scylcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sc0NoYW5nZWQgPSB0aGlzLnN0YXRlLmNvbnRyb2xzICE9PSBuZXdDb250cm9sc1xuXG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIGNvbnRyb2xzIGhhdmUgYW4gYG9uRXhpdGAgbWV0aG9kLCBjYWxsIGl0XG4gICAgLy8gd2l0aCB0aGUgY29udHJvbHMgYXMgYHRoaXNgXG4gICAgaWYgKHRoaXMuc3RhdGUuY29udHJvbHMub25FeGl0KSB7XG4gICAgICB0aGlzLnN0YXRlLmNvbnRyb2xzLm9uRXhpdC5jYWxsKFxuICAgICAgICB0aGlzLnJlZnMuY29udHJvbHNcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLnNoYXJlZFN0YXRlLmNsZWFyKClcbiAgICB0aGlzLnN0YXRlLnNoYXJlZFN0YXRlLnNldChpbml0aWFsU3RhdGUsIGZhbHNlKVxuXG4gICAgbGV0IGNvbnRyb2xzT3B0aW9ucyA9IFNES1V0aWxzLmRlZmF1bHRzKFxuICAgICAgY29udHJvbE9wdGlvbnMgfHwgdGhpcy5jb250ZXh0Lm9wdGlvbnMuZWRpdG9yLmNvbnRyb2xzT3B0aW9uc1tuZXdDb250cm9scy5pZGVudGlmaWVyXSxcbiAgICAgIG5ld0NvbnRyb2xzLmRlZmF1bHRPcHRpb25zXG4gICAgKVxuXG4gICAgLy8gSWYgdGhlIG5ldyBjb250cm9scyBoYXZlIGFuIGBvbkVudGVyYCBtZXRob2QsIGNhbGwgaXRcbiAgICBpZiAobmV3Q29udHJvbHMub25FbnRlcikge1xuICAgICAgbmV3Q29udHJvbHMub25FbnRlci5jYWxsKHRoaXMucmVmcy5jb250cm9scyxcbiAgICAgICAgdGhpcy5zdGF0ZS5zaGFyZWRTdGF0ZSxcbiAgICAgICAgY29udHJvbHNPcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChjb250cm9sc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjb250cm9sczogbmV3Q29udHJvbHMsXG4gICAgICAgIGNvbnRyb2xzT3B0aW9uc1xuICAgICAgfSwgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gcmUtc2V0IHRoZSBzdGF0ZS4gQ2FsbCBjYWxsYmFjayBpbW1lZGlhdGVseVxuICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgem9vbSBsZXZlbFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRab29tICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS56b29tXG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0cyBhbiBpbWFnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRvd25sb2FkID0gZmFsc2VcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGV4cG9ydCAoLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnN3aXRjaFRvQ29udHJvbHMoJ2hvbWUnLCB7fSwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9lZGl0b3IuZXhwb3J0KC4uLmFyZ3MpXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLkVkaXRvcn1cbiAgICovXG4gIGdldEVkaXRvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvclxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGVkaXRvciBzdGF0ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgc2VyaWFsaXplICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvci5zZXJpYWxpemUoLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIGdpdmVuIGRhdGFcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBkZXNlcmlhbGl6ZSAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9lZGl0b3IuZGVzZXJpYWxpemUoZGF0YSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBEZWNpZGVzIHdoZXRoZXIgdGhlIHVuZG8gYnV0dG9uIHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zaG93VW5kb0J1dHRvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvci5oaXN0b3J5LmlzQXZhaWxhYmxlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250ZXh0IHBhc3NlZCB0byBhbGwgY2hpbGRyZW5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0ICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRpdG9yOiB0aGlzLl9lZGl0b3IsXG4gICAgICB1aTogdGhpcy5jb250ZXh0LnVpLFxuICAgICAgb3B0aW9uczogdGhpcy5jb250ZXh0Lm9wdGlvbnMsXG4gICAgICBlZGl0b3JTY3JlZW46IHRoaXMsXG4gICAgICBtZWRpYXRvcjogdGhpcy5jb250ZXh0Lm1lZGlhdG9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICogQHBhcmFtIHtCb29sZWFufSByZXNldEVkaXRvclxuICAgKi9cbiAgc2V0SW1hZ2UgKGltYWdlLCByZXNldEVkaXRvcikge1xuICAgIHRoaXMuX2VkaXRvci5zZXRJbWFnZShpbWFnZSwgcmVzZXRFZGl0b3IpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHNjcmVlblxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclNjcmVlbiAoKSB7XG4gICAgY29uc3QgQ29udHJvbHNDb21wb25lbnQgPSB0aGlzLnN0YXRlLmNvbnRyb2xzLmNvbnRyb2xzQ29tcG9uZW50XG4gICAgbGV0IENhbnZhc0NvbnRyb2xzQ29tcG9uZW50ID0gdGhpcy5zdGF0ZS5jb250cm9scy5jYW52YXNDb250cm9sc0NvbXBvbmVudFxuICAgIGlmICghQ2FudmFzQ29udHJvbHNDb21wb25lbnQpIHtcbiAgICAgIENhbnZhc0NvbnRyb2xzQ29tcG9uZW50ID0gT3ZlcnZpZXdDb250cm9scy5jYW52YXNDb250cm9sc0NvbXBvbmVudFxuICAgIH1cbiAgICBsZXQgVG9wQmFyQ29udHJvbHNDb21wb25lbnQgPSB0aGlzLnN0YXRlLmNvbnRyb2xzLnRvcEJhckNvbnRyb2xzQ29tcG9uZW50XG4gICAgaWYgKCFUb3BCYXJDb250cm9sc0NvbXBvbmVudCkge1xuICAgICAgVG9wQmFyQ29udHJvbHNDb21wb25lbnQgPSBPdmVydmlld0NvbnRyb2xzLnRvcEJhckNvbnRyb2xzQ29tcG9uZW50XG4gICAgfVxuXG4gICAgbGV0IGNvbnRyb2xzLCBjYW52YXNDb250cm9scywgdG9wQmFyQ29udHJvbHNcblxuICAgIGlmIChUb3BCYXJDb250cm9sc0NvbXBvbmVudCAmJiB0aGlzLmNvbnRleHQub3B0aW9ucy5zaG93VG9wQmFyKSB7XG4gICAgICB0b3BCYXJDb250cm9scyA9ICg8VG9wQmFyQ29udHJvbHNDb21wb25lbnRcbiAgICAgICAgc2hhcmVkU3RhdGU9e3RoaXMuc3RhdGUuc2hhcmVkU3RhdGV9XG4gICAgICAgIG9wdGlvbnM9e3RoaXMuc3RhdGUuY29udHJvbHNPcHRpb25zfVxuICAgICAgICBhcHA9e3RoaXMucHJvcHMuYXBwfVxuICAgICAgICByZWY9J3RvcEJhckNvbnRyb2xzJyAvPilcbiAgICB9XG5cbiAgICBpZiAoQ29udHJvbHNDb21wb25lbnQpIHtcbiAgICAgIGNvbnRyb2xzID0gKDxDb250cm9sc0NvbXBvbmVudFxuICAgICAgICBvblN3aXRjaENvbnRyb2xzPXt0aGlzLnN3aXRjaFRvQ29udHJvbHN9XG4gICAgICAgIHNoYXJlZFN0YXRlPXt0aGlzLnN0YXRlLnNoYXJlZFN0YXRlfVxuICAgICAgICBvcHRpb25zPXt0aGlzLnN0YXRlLmNvbnRyb2xzT3B0aW9uc31cbiAgICAgICAgYXBwPXt0aGlzLnByb3BzLmFwcH1cbiAgICAgICAga2V5PXt0aGlzLnN0YXRlLmNvbnRyb2xzLmlkZW50aWZpZXIgKyAnLWNvbnRyb2xzJ31cbiAgICAgICAgcmVmPSdjb250cm9scycgLz4pXG4gICAgfVxuXG4gICAgaWYgKENhbnZhc0NvbnRyb2xzQ29tcG9uZW50KSB7XG4gICAgICBjYW52YXNDb250cm9scyA9ICg8Q2FudmFzQ29udHJvbHNDb21wb25lbnRcbiAgICAgICAgb25Td2l0Y2hDb250cm9scz17dGhpcy5zd2l0Y2hUb0NvbnRyb2xzfVxuICAgICAgICBzaGFyZWRTdGF0ZT17dGhpcy5zdGF0ZS5zaGFyZWRTdGF0ZX1cbiAgICAgICAgb3B0aW9ucz17dGhpcy5zdGF0ZS5jb250cm9sc09wdGlvbnN9XG4gICAgICAgIGFwcD17dGhpcy5wcm9wcy5hcHB9XG4gICAgICAgIGtleT17dGhpcy5zdGF0ZS5jb250cm9scy5pZGVudGlmaWVyICsgJy1jYW52YXNDb250cm9scyd9XG4gICAgICAgIHJlZj0nY2FudmFzQ29udHJvbHMnIC8+KVxuICAgIH1cblxuICAgIGxldCBiZW1TcGVjaWZpZXIgPSAnJGI6ZWRpdG9yU2NyZWVuJ1xuICAgIGlmICghdGhpcy5jb250ZXh0Lm9wdGlvbnMuc2hvd0hlYWRlcikge1xuICAgICAgYmVtU3BlY2lmaWVyICs9ICcgbTpub0hlYWRlcidcbiAgICB9XG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPXtiZW1TcGVjaWZpZXJ9PlxuICAgICAge3RvcEJhckNvbnRyb2xzfVxuXG4gICAgICA8Q2FudmFzQ29tcG9uZW50XG4gICAgICAgIHJlZj0nY2FudmFzJ1xuICAgICAgICBsYXJnZUNvbnRyb2xzPXt0aGlzLnN0YXRlLmNvbnRyb2xzLmxhcmdlQ2FudmFzQ29udHJvbHN9PlxuICAgICAgICB7Y2FudmFzQ29udHJvbHN9XG4gICAgICA8L0NhbnZhc0NvbXBvbmVudD5cblxuICAgICAgPGRpdiBiZW09JyRiOmNvbnRyb2xzICRlOmNvbnRhaW5lciBlOnJvdyc+XG4gICAgICAgIDxkaXYgYmVtPSdlOmNlbGwnPlxuICAgICAgICAgIHtjb250cm9sc31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuRWRpdG9yU2NyZWVuQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICB1aTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBlZGl0b3I6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbWVkaWF0b3I6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgb3B0aW9uczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBlZGl0b3JTY3JlZW46IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufVxuXG5FZGl0b3JTY3JlZW5Db21wb25lbnQuY29udGV4dFR5cGVzID0gU2NyZWVuQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL2VkaXRvci9lZGl0b3Itc2NyZWVuLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCwgUmVhY3RCRU0sIHJlcXVlc3RBbmltYXRpb25GcmFtZSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgUHJlbG9hZGVyIGZyb20gJy4uLy4uLy4uL2xpYi9wcmVsb2FkZXInXG5pbXBvcnQgU2NyZWVuQ29tcG9uZW50IGZyb20gJy4uL3NjcmVlbi1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRpbmdTY3JlZW5Db21wb25lbnQgZXh0ZW5kcyBTY3JlZW5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLnN0YXRlID0geyBwcm9ncmVzczogMCB9XG5cbiAgICB0aGlzLl9wcmVsb2FkZXIgPSBuZXcgUHJlbG9hZGVyKHRoaXMuY29udGV4dC51aSwgdGhpcy5jb250ZXh0Lm9wdGlvbnMsIHRoaXMuY29udGV4dC5tZWRpYXRvcilcbiAgICB0aGlzLl9wcmVsb2FkZXIub24oJ3Byb2dyZXNzJywgKHByb2dyZXNzKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlLnByb2dyZXNzID0gcHJvZ3Jlc3NcbiAgICB9KVxuICAgIHRoaXMuX3ByZWxvYWRlci5vbignZG9uZScsICgpID0+IHtcbiAgICAgIHRoaXMucHJvcHMuYXBwLnN3aXRjaFRvU2NyZWVuKCdwb3N0LWxvYWRpbmcnKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuICAgIGNvbnN0IHsgZGV2aWNlUGl4ZWxSYXRpbyB9ID0gd2luZG93XG4gICAgdGhpcy5fY2FudmFzID0gdGhpcy5yZWZzLmNhbnZhc1xuICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHRoaXMuX2NhbnZhcy5vZmZzZXRXaWR0aCAqIGRldmljZVBpeGVsUmF0aW9cbiAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gdGhpcy5fY2FudmFzLm9mZnNldEhlaWdodCAqIGRldmljZVBpeGVsUmF0aW9cbiAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIHRoaXMuX3ByZWxvYWRlckltYWdlID0gbmV3IHdpbmRvdy5JbWFnZSgpXG4gICAgdGhpcy5fcHJlbG9hZGVySW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIHRoaXMuX3ByZWxvYWRlci5sb2FkKClcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKVxuICAgIH0pXG4gICAgdGhpcy5fcHJlbG9hZGVySW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJ1xuICAgIHRoaXMuX3ByZWxvYWRlckltYWdlLnNyYyA9IHRoaXMuY29udGV4dC51aS5nZXRBc3NldFBhdGgoJ3ByZWxvYWRlci5wbmcnLCB0cnVlKVxuXG4gICAgdGhpcy5fcnVubmluZyA9IHRydWVcbiAgICB0aGlzLl90aWNrID0gdGhpcy5fdGljay5iaW5kKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSB1bm1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCgpXG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90aWNrICgpIHtcbiAgICB0aGlzLl9yZW5kZXJMb2FkaW5nSW5kaWNhdG9yKClcbiAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIChSZS0pUmVuZGVycyB0aGUgbG9hZGluZyBpbmRpY2F0b3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMb2FkaW5nSW5kaWNhdG9yICgpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX2NhbnZhc1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2NvbnRleHRcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpXG5cbiAgICBjdHguc2F2ZSgpXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4Lm1vdmVUbyh3aWR0aCAvIDIsIGhlaWdodCAvIDIpXG4gICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHdpZHRoIC8gMiwgLU1hdGguUEkgKiAwLjUsIE1hdGguUEkgKiAyICogdGhpcy5zdGF0ZS5wcm9ncmVzcyAtIE1hdGguUEkgKiAwLjUsIGZhbHNlKVxuICAgIGN0eC5saW5lVG8od2lkdGggLyAyLCBoZWlnaHQgLyAyKVxuICAgIGN0eC5jbGlwKClcbiAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgdGhpcy5fcHJlbG9hZGVySW1hZ2UsXG4gICAgICAwLCAwLCB0aGlzLl9wcmVsb2FkZXJJbWFnZS53aWR0aCwgdGhpcy5fcHJlbG9hZGVySW1hZ2UuaGVpZ2h0LFxuICAgICAgMCwgMCwgd2lkdGgsIGhlaWdodFxuICAgIClcbiAgICBjdHgucmVzdG9yZSgpXG5cbiAgICBjdHguc2F2ZSgpXG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMC4wNVxuICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICB0aGlzLl9wcmVsb2FkZXJJbWFnZSxcbiAgICAgIDAsIDAsIHRoaXMuX3ByZWxvYWRlckltYWdlLndpZHRoLCB0aGlzLl9wcmVsb2FkZXJJbWFnZS5oZWlnaHQsXG4gICAgICAwLCAwLCB3aWR0aCwgaGVpZ2h0XG4gICAgKVxuICAgIGN0eC5yZXN0b3JlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgc2NyZWVuXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2NyZWVuICgpIHtcbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpsb2FkaW5nU2NyZWVuJz5cbiAgICAgIDxkaXYgYmVtPSdlOmNvbnRhaW5lcic+XG4gICAgICAgIDxjYW52YXMgYmVtPSdlOmNhbnZhcycgcmVmPSdjYW52YXMnIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuTG9hZGluZ1NjcmVlbkNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL2xvYWRpbmcvbG9hZGluZy1zY3JlZW4tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vZ2xvYmFscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlicmFyeUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkNsaWNrJ1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgbGlicmFyeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2xpY2sgKCkge1xuICAgIHRoaXMucHJvcHMub25DbGljayAmJlxuICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKHRoaXMucHJvcHMubGlicmFyeSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBjb25zdCB7IGxpYnJhcnkgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke2xpYnJhcnkuY292ZXJJbWFnZX0pYFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8YmVtIHNwZWNpZmllcj0nYjpwaG90b1JvbGwgZTpsaWJyYXJ5TGlzdCc+XG4gICAgICAgIDxsaSBiZW09J2U6aXRlbScgc3R5bGU9e3N0eWxlfSBvbkNsaWNrPXt0aGlzLl9vbkNsaWNrfT5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpvdmVybGF5JyAvPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOm5hbWUnPntsaWJyYXJ5Lm5hbWV9PC9kaXY+XG4gICAgICAgIDwvbGk+XG4gICAgICA8L2JlbT5cbiAgICApXG4gIH1cbn1cblxuTGlicmFyeUNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvaXRlbXMvbGlicmFyeS1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9nbG9iYWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaG90b0NvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgY29uc3QgeyBwaG90byB9ID0gdGhpcy5wcm9wc1xuICAgIHJldHVybiAoXG4gICAgICA8YmVtIHNwZWNpZmllcj0nYjpwaG90b1JvbGwgZTpwaG90b0xpc3QnPlxuICAgICAgICA8bGkgYmVtPSckZTppdGVtJyBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xpY2t9PlxuICAgICAgICAgIDxkaXYgYmVtPSdlOm92ZXJsYXknIC8+XG4gICAgICAgICAgPGRpdiBiZW09J2U6dGl0bGUnPntwaG90by50aXRsZX08L2Rpdj5cbiAgICAgICAgICA8aW1nIGJlbT0nZTppbWFnZScgc3JjPXtwaG90by51cmxzLnRodW1ifSAvPlxuICAgICAgICA8L2xpPlxuICAgICAgPC9iZW0+XG4gICAgKVxuICB9XG59XG5cblBob3RvQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9pdGVtcy9waG90by1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFNlYXJjaFN1Z2dlc3Rpb25Db21wb25lbnQgZnJvbSAnLi9pdGVtcy9zZWFyY2gtc3VnZ2VzdGlvbi1jb21wb25lbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vU2VhcmNoUmVzdWx0c0NvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vblNlYXJjaFN1Z2dlc3Rpb25DbGljaydcbiAgICApXG5cbiAgICBjb25zdCBQaG90b1JvbGxQcm92aWRlciA9IHRoaXMuY29udGV4dC5vcHRpb25zLnBob3RvUm9sbC5wcm92aWRlclxuICAgIHRoaXMuX3Byb3ZpZGVyID0gbmV3IFBob3RvUm9sbFByb3ZpZGVyKClcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBzZWFyY2hTdWdnZXN0aW9uczogW11cbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIHNlYXJjaCBzdWdnZXN0aW9uIHdhcyBjbGlja2VkXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuUGhvdG9Sb2xsLlNlYXJjaFN1Z2dlc3Rpb259IHNlYXJjaFN1Z2dlc3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNlYXJjaFN1Z2dlc3Rpb25DbGljayAoc2VhcmNoU3VnZ2VzdGlvbikge1xuICAgIHRoaXMucHJvcHMub25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZCAmJlxuICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaFN1Z2dlc3Rpb25DbGlja2VkKHNlYXJjaFN1Z2dlc3Rpb24pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuXG4gICAgdGhpcy5fcHJvdmlkZXIuZ2V0U2VhcmNoU3VnZ2VzdGlvbnMoKVxuICAgICAgLnRoZW4oKHNlYXJjaFN1Z2dlc3Rpb25zKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHNlYXJjaFN1Z2dlc3Rpb25zXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG1lc3NhZ2UgKHdoaWNoIGNhbiBpbmNsdWRlIGh0bWwpXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJNZXNzYWdlICgpIHtcbiAgICByZXR1cm4geyBfX2h0bWw6IHRoaXMuX3QoJ3Bob3RvUm9sbC5zZWFyY2gubm9TZWFyY2hSZXN1bHRzJywge1xuICAgICAgcXVlcnk6IHRoaXMucHJvcHMucXVlcnlcbiAgICB9KSB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2VhcmNoIHN1Z2dlc3Rpb25zXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2VhcmNoU3VnZ2VzdGlvbnMgKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5zZWFyY2hTdWdnZXN0aW9ucy5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuc3RhdGUuc2VhcmNoU3VnZ2VzdGlvbnMubWFwKChzZWFyY2hTdWdnZXN0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gKDxTZWFyY2hTdWdnZXN0aW9uQ29tcG9uZW50XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrfVxuICAgICAgICBzZWFyY2hTdWdnZXN0aW9uPXtzZWFyY2hTdWdnZXN0aW9ufSAvPilcbiAgICB9KVxuXG4gICAgcmV0dXJuICg8ZGl2PlxuICAgICAgPGRpdiBiZW09J2U6aGVhZGxpbmUnPlNlYXJjaCBzdWdnZXN0aW9uczwvZGl2PlxuICAgICAgPHVsIGJlbT0nJGU6bGlicmFyeUxpc3QnPlxuICAgICAgICB7aXRlbXN9XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpwaG90b1JvbGwgZTpyb3cgbTpmdWxsSGVpZ2h0Jz5cbiAgICAgIDxkaXYgYmVtPSdlOmNlbGwnPlxuICAgICAgICA8ZGl2IGJlbT0nZTpjb250YWluZXInPlxuICAgICAgICAgIDxkaXYgYmVtPSdlOmlubmVyQ29udGFpbmVyJz5cbiAgICAgICAgICAgIDxkaXYgYmVtPSdlOm5vU2VhcmNoUmVzdWx0cycgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3RoaXMuX3JlbmRlck1lc3NhZ2UoKX0gLz5cbiAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJTZWFyY2hTdWdnZXN0aW9ucygpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PilcbiAgfVxufVxuXG5Ob1NlYXJjaFJlc3VsdHNDb21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL25vLXNlYXJjaC1yZXN1bHRzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBVdGlscywgUmVhY3RCRU0sIEJhc2VDb21wb25lbnQsIFByb21pc2UgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IE1vZGFsTWFuYWdlciBmcm9tICcuLi8uLi8uLi9saWIvbW9kYWwtbWFuYWdlcidcbmltcG9ydCBMaWJyYXJ5Q29tcG9uZW50IGZyb20gJy4vaXRlbXMvbGlicmFyeS1jb21wb25lbnQnXG5pbXBvcnQgU2VhcmNoU3VnZ2VzdGlvbkNvbXBvbmVudCBmcm9tICcuL2l0ZW1zL3NlYXJjaC1zdWdnZXN0aW9uLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3ZlcnZpZXdDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fbmVlZHNTdHlsZUZpeGVzID0gdHJ1ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgbGlicmFyaWVzOiBbXSxcbiAgICAgIHNlYXJjaFN1Z2dlc3Rpb25zOiBbXVxuICAgIH1cblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uTGlicmFyeUNsaWNrJyxcbiAgICAgICdfb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2snXG4gICAgKVxuXG4gICAgY29uc3QgUGhvdG9Sb2xsUHJvdmlkZXIgPSB0aGlzLmNvbnRleHQub3B0aW9ucy5waG90b1JvbGwucHJvdmlkZXJcbiAgICB0aGlzLl9wcm92aWRlciA9IG5ldyBQaG90b1JvbGxQcm92aWRlcigpXG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgc3R5bGVzIG5lZWQgdG8gYmUgZml4ZWQgYnkgdGhlIEphdmFTY3JpcHQuXG4gICAqIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSB0aGFua3MgdG8gb2xkZXIgSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlcnMgd2hpY2ggaGF2ZVxuICAgKiBhIGJ1bmNoIG9mIENTUyBidWdzLlxuICAgKi9cbiAgZml4U3R5bGVzICgpIHtcbiAgICBpZiAoVXRpbHMuQnJvd3Nlci5pc0lFbHRlKDExKSkge1xuICAgICAgY29uc3QgeyBjZWxsLCBjb250YWluZXIgfSA9IHRoaXMucmVmc1xuICAgICAgaWYgKCEoY2VsbCAmJiBjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgY2VsbEhlaWdodCA9IGNlbGwub2Zmc2V0SGVpZ2h0XG4gICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYCR7Y2VsbEhlaWdodH1weGBcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMSUZFQ1lDTEVcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkTW91bnQoKVxuXG4gICAgY29uc3QgbW9kYWwgPSBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUxvYWRpbmcodGhpcy5fdCgnbG9hZGluZy5sb2FkaW5nJykpXG4gICAgdGhpcy5fbG9hZCgpXG4gICAgICAudGhlbigoW2xpYnJhcmllcywgc2VhcmNoU3VnZ2VzdGlvbnNdKSA9PiB7XG4gICAgICAgIG1vZGFsLmNsb3NlKClcbiAgICAgICAgaWYgKGxpYnJhcmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0aGlzLl9vbkxpYnJhcnlDbGljayhsaWJyYXJpZXNbMF0sIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGxpYnJhcmllcyxcbiAgICAgICAgICAgIHNlYXJjaFN1Z2dlc3Rpb25zXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgbGlicmFyeSB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlBob3RvUm9sbC5MaWJyYXJ5fSBsaWJyYXJ5XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGF1dG9tYXRpY2FsbHkgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTGlicmFyeUNsaWNrIChsaWJyYXJ5LCBhdXRvbWF0aWNhbGx5ID0gZmFsc2UpIHtcbiAgICB0aGlzLnByb3BzLm9uTGlicmFyeUNsaWNrZWQgJiZcbiAgICAgIHRoaXMucHJvcHMub25MaWJyYXJ5Q2xpY2tlZChsaWJyYXJ5LCBhdXRvbWF0aWNhbGx5KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBzZWFyY2ggc3VnZ2VzdGlvbiB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlBob3RvUm9sbC5TZWFyY2hTdWdnZXN0aW9ufSBzZWFyY2hTdWdnZXN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2sgKHNlYXJjaFN1Z2dlc3Rpb24pIHtcbiAgICB0aGlzLnByb3BzLm9uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrZWQgJiZcbiAgICAgIHRoaXMucHJvcHMub25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZChzZWFyY2hTdWdnZXN0aW9uKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTE9BRElOR1xuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgbGlicmFyaWVzIGFuZCBzZWFyY2ggc3VnZ2VzdGlvbnMgKGlmIHByZXNlbnQpXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9hZCAoKSB7XG4gICAgbGV0IHByb21pc2VzID0gW1xuICAgICAgdGhpcy5fcHJvdmlkZXIuZ2V0TGlicmFyaWVzKCksXG4gICAgICB0aGlzLl9wcm92aWRlci5nZXRTZWFyY2hTdWdnZXN0aW9ucygpXG4gICAgXVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBsaWJyYXJ5IGl0ZW1zXG4gICAqIEByZXR1cm4ge1JlYWN0LkNvbXBvbmVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJMaWJyYXJpZXMgKCkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5zdGF0ZS5saWJyYXJpZXMubWFwKChsaWJyYXJ5KSA9PiB7XG4gICAgICByZXR1cm4gKDxMaWJyYXJ5Q29tcG9uZW50XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uTGlicmFyeUNsaWNrfVxuICAgICAgICBsaWJyYXJ5PXtsaWJyYXJ5fSAvPilcbiAgICB9KVxuICAgIHJldHVybiAoPGxpIGJlbT0nZTppdGVtJz5cbiAgICAgIDxiZW0gc3BlY2lmaWVyPSdiOnBob3RvUm9sbCc+XG4gICAgICAgIDxkaXYgYmVtPSdlOmhlYWRsaW5lJz5Ccm93c2UgbGlicmFyaWVzPC9kaXY+XG4gICAgICAgIDx1bCBiZW09JyRlOmxpYnJhcnlMaXN0Jz5cbiAgICAgICAgICB7aXRlbXN9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSbmRlcnMgdGhlIHNlYXJjaCBzdWdnZXN0aW9uIGl0ZW1zXG4gICAqIEByZXR1cm4ge1JlYWN0LkNvbXBvbmVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJTZWFyY2hTdWdnZXN0aW9ucyAoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLnNlYXJjaFN1Z2dlc3Rpb25zLmxlbmd0aCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5zdGF0ZS5zZWFyY2hTdWdnZXN0aW9ucy5tYXAoKHNlYXJjaFN1Z2dlc3Rpb24pID0+IHtcbiAgICAgIHJldHVybiAoPFNlYXJjaFN1Z2dlc3Rpb25Db21wb25lbnRcbiAgICAgICAgb25DbGljaz17dGhpcy5fb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2t9XG4gICAgICAgIHNlYXJjaFN1Z2dlc3Rpb249e3NlYXJjaFN1Z2dlc3Rpb259IC8+KVxuICAgIH0pXG5cbiAgICByZXR1cm4gKDxsaSBiZW09J2U6aXRlbSc+XG4gICAgICA8YmVtIHNwZWNpZmllcj0nYjpwaG90b1JvbGwnPlxuICAgICAgICA8ZGl2IGJlbT0nZTpoZWFkbGluZSc+U2VhcmNoIHN1Z2dlc3Rpb25zPC9kaXY+XG4gICAgICAgIDx1bCBiZW09JyRlOmxpYnJhcnlMaXN0Jz5cbiAgICAgICAgICB7aXRlbXN9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L2JlbT5cbiAgICA8L2xpPilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250ZW50IGZvciB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNvbnRlbnQgKCkge1xuICAgIHJldHVybiAoPGRpdiBiZW09JyRiOnBob3RvUm9sbCBlOnJvdyBtOmZ1bGxIZWlnaHQnPlxuICAgICAgPGRpdiBiZW09J2U6Y2VsbCcgcmVmPSdjZWxsJz5cbiAgICAgICAgPGRpdiBiZW09J2U6Y29udGFpbmVyJyByZWY9J2NvbnRhaW5lcic+XG4gICAgICAgICAgPGRpdiBiZW09J2U6aW5uZXJDb250YWluZXInPlxuICAgICAgICAgICAgPHVsIGJlbT0nJGU6Z3JvdXBMaXN0Jz5cbiAgICAgICAgICAgICAge3RoaXMuX3JlbmRlckxpYnJhcmllcygpfVxuICAgICAgICAgICAgICB7dGhpcy5fcmVuZGVyU2VhcmNoU3VnZ2VzdGlvbnMoKX1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5sb2FkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyQ29udGVudCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiA8ZGl2IC8+XG4gICAgfVxuICB9XG59XG5cbk92ZXJ2aWV3Q29tcG9uZW50LmNvbnRleHRUeXBlcyA9IEJhc2VDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC9vdmVydmlldy1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVhY3QsIFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTY3JlZW5Db21wb25lbnQgZnJvbSAnLi4vc2NyZWVuLWNvbXBvbmVudCdcbmltcG9ydCBUb3BCYXJDb250cm9sc0NvbXBvbmVudCBmcm9tICcuL3RvcC1iYXIvdG9wLWJhci1jb21wb25lbnQnXG5pbXBvcnQgT3ZlcnZpZXdDb21wb25lbnQgZnJvbSAnLi9vdmVydmlldy1jb21wb25lbnQnXG5pbXBvcnQgUGhvdG9MaXN0Q29tcG9uZW50IGZyb20gJy4vcGhvdG8tbGlzdC1jb21wb25lbnQnXG5pbXBvcnQgU2VhcmNoUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL3NlYXJjaC1yZXN1bHRzLWNvbXBvbmVudCdcbmltcG9ydCBNb2RhbE1hbmFnZXIgZnJvbSAnLi4vLi4vLi4vbGliL21vZGFsLW1hbmFnZXInXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBob3RvUm9sbFNjcmVlbkNvbXBvbmVudCBleHRlbmRzIFNjcmVlbkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBzZWN0aW9uOiAnb3ZlcnZpZXcnLFxuICAgICAgc2VjdGlvbnNIaXN0b3J5OiBbXVxuICAgIH1cblxuICAgIHRoaXMuX2JpbmRBbGwoXG4gICAgICAnX29uTGlicmFyeUNsaWNrZWQnLFxuICAgICAgJ19vblNlYXJjaFN1Z2dlc3Rpb25DbGlja2VkJyxcbiAgICAgICdfb25QaG90b0NsaWNrZWQnLFxuICAgICAgJ19vbkZpbGVVcGxvYWQnLFxuICAgICAgJ19vbldlYmNhbUNsaWNrJyxcbiAgICAgICdfb25CYWNrQ2xpY2tlZCcsXG4gICAgICAnX29uU2VhcmNoJ1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNFQ1RJT05TXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGhvdG8gcm9sbCBzY3JlZW4gaGFzIGEgcHJldmlvdXMgc2VjdGlvblxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBoYXNQcmV2aW91c1NlY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuc3RhdGUuc2VjdGlvbnNIaXN0b3J5Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIHRvIHRoZSBnaXZlbiBzZWN0aW9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc2VjdGlvblxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBhbGxvd1NjcmVlblN3aXRjaCA9IHRydWVcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gYWRkVG9TdGFjayA9IHRydWVcbiAgICovXG4gIHN3aXRjaFRvU2VjdGlvbiAoc2VjdGlvbiwgYWxsb3dTY3JlZW5Td2l0Y2ggPSB0cnVlLCBhZGRUb1N0YWNrID0gdHJ1ZSkge1xuICAgIGlmIChzZWN0aW9uID09PSAnYmFjaycpIHtcbiAgICAgIGlmICghdGhpcy5oYXNQcmV2aW91c1NlY3Rpb24oKSkge1xuICAgICAgICBpZiAoYWxsb3dTY3JlZW5Td2l0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5hcHAuc3dpdGNoVG9TY3JlZW4oJ2JhY2snKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN3aXRjaFRvU2VjdGlvbignb3ZlcnZpZXcnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWN0aW9uc0hpc3RvcnkucG9wKClcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuc2VjdGlvbiAhPT0gc2VjdGlvbiAmJiBhZGRUb1N0YWNrKSB7XG4gICAgICB0aGlzLnN0YXRlLnNlY3Rpb25zSGlzdG9yeS5wdXNoKHRoaXMuc3RhdGUuc2VjdGlvbilcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgc2VjdGlvbiB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBsaWJyYXJ5IGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuVUkuUmVhY3RVSS5QaG90b1JvbGwuTGlicmFyeX0gbGlicmFyeVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGF1dG9tYXRpY2FsbHkgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTGlicmFyeUNsaWNrZWQgKGxpYnJhcnksIGF1dG9tYXRpY2FsbHkgPSBmYWxzZSkge1xuICAgIHRoaXMuc3RhdGUubGlicmFyeSA9IGxpYnJhcnlcbiAgICB0aGlzLnN3aXRjaFRvU2VjdGlvbignbGlicmFyeScsIHRydWUsICFhdXRvbWF0aWNhbGx5KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBzZWFyY2ggc3VnZ2VzdGlvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlVJLlJlYWN0VUkuUGhvdG9Sb2xsLlNlYXJjaFN1Z2dlc3Rpb259IHNlYXJjaFN1Z2dlc3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNlYXJjaFN1Z2dlc3Rpb25DbGlja2VkIChzZWFyY2hTdWdnZXN0aW9uKSB7XG4gICAgdGhpcy5zdGF0ZS5zZWFyY2hRdWVyeSA9IHNlYXJjaFN1Z2dlc3Rpb24ucXVlcnlcbiAgICB0aGlzLnN3aXRjaFRvU2VjdGlvbignc2VhcmNoJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBjbGlja2VkIGFuZCB0aGUgUGhvdG9Sb2xsIGhhcyBsb2FkZWQgYSBwaG90b1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5VSS5SZWFjdFVJLlBob3RvUm9sbC5QaG90b30gcGhvdG9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblBob3RvQ2xpY2tlZCAocGhvdG8pIHtcbiAgICBjb25zdCBsb2FkaW5nTW9kYWwgPSBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUxvYWRpbmcodGhpcy5fdCgnbG9hZGluZy5sb2FkaW5nJykpXG5cbiAgICBjb25zdCBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKVxuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICBsb2FkaW5nTW9kYWwuY2xvc2UoKVxuICAgICAgdGhpcy5wcm9wcy5hcHAuc2V0SW1hZ2UoaW1hZ2UsIHRydWUpXG4gICAgfSlcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgIGxvYWRpbmdNb2RhbC5jbG9zZSgpXG4gICAgICBNb2RhbE1hbmFnZXIuaW5zdGFuY2UuZGlzcGxheUVycm9yKFxuICAgICAgICB0aGlzLl90KCdlcnJvcnMuaW1hZ2VMb2FkRmFpbC50aXRsZScpLFxuICAgICAgICB0aGlzLl90KCdlcnJvcnMuaW1hZ2VMb2FkRmFpbC50ZXh0JywgeyBwYXRoOiBpbWFnZS5zcmMgfSlcbiAgICAgIClcbiAgICB9KVxuICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cydcbiAgICBpbWFnZS5zcmMgPSBwaG90by51cmxzLnJhd1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBiYWNrIGJ1dHRvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja0NsaWNrZWQgKCkge1xuICAgIHRoaXMuc3dpdGNoVG9TZWN0aW9uKCdiYWNrJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgc2VhcmNoIGlzIHRyaWdnZXJlZFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25TZWFyY2ggKHF1ZXJ5KSB7XG4gICAgaWYgKCFxdWVyeS50cmltKCkubGVuZ3RoKSB7XG4gICAgICB0aGlzLnN0YXRlLnNlYXJjaFF1ZXJ5ID0gbnVsbFxuICAgICAgcmV0dXJuIHRoaXMuc3dpdGNoVG9TZWN0aW9uKCdiYWNrJywgZmFsc2UpXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5zZWFyY2hRdWVyeSA9IHF1ZXJ5XG4gICAgdGhpcy5zd2l0Y2hUb1NlY3Rpb24oJ3NlYXJjaCcpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIHdlYmNhbSBidXR0b24uIFN3aXRjaGVzIHRvIHRoZVxuICAgKiB3ZWJjYW0gc2NyZWVuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25XZWJjYW1DbGljayAoKSB7XG4gICAgdGhpcy5wcm9wcy5hcHAuc3dpdGNoVG9TY3JlZW4oJ3dlYmNhbScpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgYSBuZXcgZmlsZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgKi9cbiAgX29uRmlsZVVwbG9hZCAoaW1hZ2UpIHtcbiAgICB0aGlzLnByb3BzLmFwcC5zZXRJbWFnZShpbWFnZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEJBQ0sgQlVUVE9OXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgYmFjayBidXR0b24gc2hvdWxkIGJlIHZpc2libGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc0JhY2tCdXR0b25WaXNpYmxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWN0aW9uc0hpc3RvcnkubGVuZ3RoICE9PSAwIHx8XG4gICAgICB0aGlzLnByb3BzLmFwcC5oYXNQcmV2aW91c1NjcmVlbigpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udGVudCBjb21wb25lbnQgZm9yIHRoaXMgc2NyZWVuXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQ29udGVudCAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnNlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3NlYXJjaCc6XG4gICAgICAgIHJldHVybiAoPFNlYXJjaFJlc3VsdHNDb21wb25lbnRcbiAgICAgICAgICBxdWVyeT17dGhpcy5zdGF0ZS5zZWFyY2hRdWVyeX1cbiAgICAgICAgICBvblBob3RvQ2xpY2tlZD17dGhpcy5fb25QaG90b0NsaWNrZWR9XG4gICAgICAgICAgb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZD17dGhpcy5fb25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZH0gLz4pXG4gICAgICBjYXNlICdsaWJyYXJ5JzpcbiAgICAgICAgcmV0dXJuICg8UGhvdG9MaXN0Q29tcG9uZW50XG4gICAgICAgICAgbGlicmFyeT17dGhpcy5zdGF0ZS5saWJyYXJ5fVxuICAgICAgICAgIG9uUGhvdG9DbGlja2VkPXt0aGlzLl9vblBob3RvQ2xpY2tlZH0gLz4pXG4gICAgICBjYXNlICdvdmVydmlldyc6XG4gICAgICAgIHJldHVybiAoPE92ZXJ2aWV3Q29tcG9uZW50XG4gICAgICAgICAgb25MaWJyYXJ5Q2xpY2tlZD17dGhpcy5fb25MaWJyYXJ5Q2xpY2tlZH1cbiAgICAgICAgICBvblNlYXJjaFN1Z2dlc3Rpb25DbGlja2VkPXt0aGlzLl9vblNlYXJjaFN1Z2dlc3Rpb25DbGlja2VkfVxuICAgICAgICAgIC8+KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgc2NyZWVuXG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyU2NyZWVuICgpIHtcbiAgICBjb25zdCBjb250ZW50Q29tcG9uZW50ID0gdGhpcy5fcmVuZGVyQ29udGVudCgpXG5cbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjpwaG90b1JvbGxTY3JlZW4nPlxuICAgICAgPFRvcEJhckNvbnRyb2xzQ29tcG9uZW50XG4gICAgICAgIG9uQmFja0NsaWNrZWQ9e3RoaXMuX29uQmFja0NsaWNrZWR9XG4gICAgICAgIG9uU2VhcmNoPXt0aGlzLl9vblNlYXJjaH1cbiAgICAgICAgc2VhcmNoUXVlcnk9e3RoaXMuc3RhdGUuc2VhcmNoUXVlcnl9XG4gICAgICAgIG9uRmlsZVVwbG9hZD17dGhpcy5fb25GaWxlVXBsb2FkfVxuICAgICAgICBvbldlYmNhbUNsaWNrPXt0aGlzLl9vbldlYmNhbUNsaWNrfVxuICAgICAgICBiYWNrQnV0dG9uPXt0aGlzLl9pc0JhY2tCdXR0b25WaXNpYmxlKCl9XG4gICAgICAgIGJhY2tCdXR0b25MYWJlbD17dGhpcy5fdCgnZ2VuZXJpYy5iYWNrJyl9XG4gICAgICAgIHJlZj0ndG9wQmFyQ29udHJvbHMnIC8+XG4gICAgICB7Y29udGVudENvbXBvbmVudH1cbiAgICA8L2Rpdj4pXG4gIH1cbn1cblxuUGhvdG9Sb2xsU2NyZWVuQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICB1aTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBlZGl0b3I6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbWVkaWF0b3I6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgb3B0aW9uczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBlZGl0b3JTY3JlZW46IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufVxuXG5QaG90b1JvbGxTY3JlZW5Db21wb25lbnQuY29udGV4dFR5cGVzID0gU2NyZWVuQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvcGhvdG8tcm9sbC1zY3JlZW4tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBQaG90b0xpc3RDb21wb25lbnQgZnJvbSAnLi9waG90by1saXN0LWNvbXBvbmVudCdcbmltcG9ydCBOb1NlYXJjaFJlc3VsdHNDb21wb25lbnQgZnJvbSAnLi9uby1zZWFyY2gtcmVzdWx0cy1jb21wb25lbnQnXG5pbXBvcnQgTW9kYWxNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2xpYi9tb2RhbC1tYW5hZ2VyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hSZXN1bHRzQ29tcG9uZW50IGV4dGVuZHMgUGhvdG9MaXN0Q29tcG9uZW50IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHNcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLnF1ZXJ5ICE9PSB0aGlzLnByb3BzLnF1ZXJ5KSB7XG4gICAgICB0aGlzLl9sb2FkUGhvdG9zKHByb3BzLnF1ZXJ5KVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JU0NcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVhZGxpbmUgZm9yIHRoaXMgdmlld1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SGVhZGxpbmUgKCkge1xuICAgIHJldHVybiB0aGlzLl90KCdwaG90b1JvbGwuc2VhcmNoLnJlc3VsdHMuaGVhZGxpbmUnLCB7XG4gICAgICBxdWVyeTogdGhpcy5wcm9wcy5xdWVyeVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIHBob3Rvc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkUGhvdG9zIChxdWVyeSA9IHRoaXMucHJvcHMucXVlcnkpIHtcbiAgICB0aGlzLl90b3RhbFBob3Rvc0hlaWdodCA9IDBcbiAgICBjb25zdCBtb2RhbCA9IE1vZGFsTWFuYWdlci5pbnN0YW5jZS5kaXNwbGF5UHJvZ3Jlc3ModGhpcy5fdCgnbG9hZGluZy5sb2FkaW5nJykpXG4gICAgY29uc3QgUGhvdG9Sb2xsUHJvdmlkZXIgPSB0aGlzLmNvbnRleHQub3B0aW9ucy5waG90b1JvbGwucHJvdmlkZXJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBQaG90b1JvbGxQcm92aWRlcigpXG5cbiAgICBwcm92aWRlci5zZWFyY2hQaG90b3MocXVlcnkpXG4gICAgICAudGhlbigocGhvdG9zKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVsb2FkUGhvdG9zKHBob3RvcywgbW9kYWwpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKHBob3RvcykgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgcGhvdG9zLCBsb2FkaW5nOiBmYWxzZSB9KVxuICAgICAgICBtb2RhbC5jbG9zZSgpXG4gICAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlICdubyByZXN1bHRzIGZvdW5kJyBzY3JlZW5cbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJOb3RGb3VuZCAoKSB7XG4gICAgcmV0dXJuICg8Tm9TZWFyY2hSZXN1bHRzQ29tcG9uZW50XG4gICAgICBxdWVyeT17dGhpcy5wcm9wcy5xdWVyeX1cbiAgICAgIG9uU2VhcmNoU3VnZ2VzdGlvbkNsaWNrZWQ9e3RoaXMucHJvcHMub25TZWFyY2hTdWdnZXN0aW9uQ2xpY2tlZH0gLz4pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmxvYWRpbmcpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBob3Rvcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlck5vdEZvdW5kKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQaG90b3MoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gPGRpdiAvPlxuICAgIH1cbiAgfVxufVxuXG5TZWFyY2hSZXN1bHRzQ29tcG9uZW50LmNvbnRleHRUeXBlcyA9IFBob3RvTGlzdENvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL3NlYXJjaC1yZXN1bHRzLWNvbXBvbmVudC5qc3giLCIvKiogQGpzeCBSZWFjdEJFTS5jcmVhdGVFbGVtZW50ICoqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvcEJhckJ1dHRvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSZWFjdEJFTS5FbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyV2l0aEJFTSAoKSB7XG4gICAgcmV0dXJuICg8YmVtIHNwZWNpZmllcj0nJGI6dG9wQmFyJz5cbiAgICAgIDxkaXYgYmVtPSckZTppY29uQnV0dG9uJyBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xpY2t9PlxuICAgICAgICA8aW1nIGJlbT0nZTppY29uJyBzcmM9e3RoaXMucHJvcHMuaWNvbn0gLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvYmVtPilcbiAgfVxufVxuXG5Ub3BCYXJCdXR0b25Db21wb25lbnQuY29udGV4dFR5cGVzID0gQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvc2NyZWVucy9waG90by1yb2xsL3RvcC1iYXIvdG9wLWJhci1idXR0b24tY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFJlYWN0QkVNLCBVdGlscyB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgVG9wQmFyQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uL3NoYXJlZC90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50J1xuaW1wb3J0IFRvcEJhckJ1dHRvbkNvbXBvbmVudCBmcm9tICcuL3RvcC1iYXItYnV0dG9uLWNvbXBvbmVudCdcbmltcG9ydCBJbnZpc2libGVVcGxvYWRDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2ludmlzaWJsZS11cGxvYWQtY29tcG9uZW50J1xuaW1wb3J0IFNlYXJjaENvbXBvbmVudCBmcm9tICcuL3RvcC1iYXItc2VhcmNoLWNvbXBvbmVudCdcbmltcG9ydCBUb3BCYXJCYWNrQnV0dG9uIGZyb20gJy4uLy4uLy4uL3NoYXJlZC90b3AtYmFyL2JhY2stYnV0dG9uLWNvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGhvdG9Sb2xsVG9wQmFyQ29tcG9uZW50IGV4dGVuZHMgVG9wQmFyQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fYmluZEFsbChcbiAgICAgICdfb25VcGxvYWRCdXR0b25DbGlja2VkJyxcbiAgICAgICdfb25XZWJjYW1CdXR0b25DbGlja2VkJyxcbiAgICAgICdfb25CYWNrQ2xpY2tlZCcsXG4gICAgICAnX29uU2VhcmNoVmFsdWVDaGFuZ2UnLFxuICAgICAgJ19vbk5ld0ZpbGUnXG4gICAgKVxuXG4gICAgdGhpcy5fb25TZWFyY2hWYWx1ZUNoYW5nZSA9IFV0aWxzLmRlYm91bmNlKHRoaXMuX29uU2VhcmNoVmFsdWVDaGFuZ2UsIDI1MClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYmFjayBidXR0b25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhY2tDbGlja2VkICgpIHtcbiAgICB0aGlzLnByb3BzLm9uQmFja0NsaWNrZWQgJiZcbiAgICAgIHRoaXMucHJvcHMub25CYWNrQ2xpY2tlZCgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgc2VhcmNoIHZhbHVlIGhhcyBjaGFuZ2VkICh0aGlzIG1ldGhvZCBpcyBkZWJvdW5jZWQpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU2VhcmNoVmFsdWVDaGFuZ2UgKHZhbHVlKSB7XG4gICAgdGhpcy5wcm9wcy5vblNlYXJjaCAmJlxuICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaCh2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgdXBsb2FkIGJ1dHRvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uVXBsb2FkQnV0dG9uQ2xpY2tlZCAoKSB7XG4gICAgdGhpcy5yZWZzLnVwbG9hZC5vcGVuKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgd2ViY2FtIGJ1dHRvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uV2ViY2FtQnV0dG9uQ2xpY2tlZCAoKSB7XG4gICAgdGhpcy5wcm9wcy5vbldlYmNhbUNsaWNrICYmXG4gICAgICB0aGlzLnByb3BzLm9uV2ViY2FtQ2xpY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBuZXcgZmlsZSBoYXMgYmVlbiBzZWxlY3RlZFxuICAgKiBAcGFyYW0gIHtGaWxlfSBmaWxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25OZXdGaWxlIChmaWxlKSB7XG4gICAgdGhpcy5wcm9wcy5vbkZpbGVVcGxvYWQgJiZcbiAgICAgIHRoaXMucHJvcHMub25GaWxlVXBsb2FkKGZpbGUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB3ZWJjYW0gaXMgYXZhaWxhYmxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaXNXZWJjYW1BdmFpbGFibGUgKCkge1xuICAgIHJldHVybiAhVXRpbHMuaXNNb2JpbGUoKSAmJiB0aGlzLmNvbnRleHQub3B0aW9ucy5lbmFibGVXZWJjYW0gIT09IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYnV0dG9ucyBvbiB0aGUgcmlnaHRcbiAgICogQHJldHVybiB7QXJyYXkuPFJlYWN0LkNvbXBvbmVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyUmlnaHRCdXR0b25zICgpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCBidXR0b25zID0gW11cblxuICAgIGlmIChvcHRpb25zLmVuYWJsZVVwbG9hZCkge1xuICAgICAgYnV0dG9ucy5wdXNoKDxUb3BCYXJCdXR0b25Db21wb25lbnRcbiAgICAgICAgaWNvbj17dGhpcy5fZ2V0QXNzZXRQYXRoKCdwaG90by1yb2xsL3VwbG9hZC5wbmcnLCB0cnVlKX1cbiAgICAgICAgb25DbGljaz17dGhpcy5fb25VcGxvYWRCdXR0b25DbGlja2VkfVxuICAgICAgICAvPilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNXZWJjYW1BdmFpbGFibGUoKSkge1xuICAgICAgYnV0dG9ucy5wdXNoKDxUb3BCYXJCdXR0b25Db21wb25lbnRcbiAgICAgICAgaWNvbj17dGhpcy5fZ2V0QXNzZXRQYXRoKCdwaG90by1yb2xsL3dlYmNhbS5wbmcnLCB0cnVlKX1cbiAgICAgICAgb25DbGljaz17dGhpcy5fb25XZWJjYW1CdXR0b25DbGlja2VkfVxuICAgICAgICAvPilcbiAgICB9XG5cbiAgICByZXR1cm4gYnV0dG9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcldpdGhCRU0gKCkge1xuICAgIGxldCBiYWNrQnV0dG9uXG4gICAgaWYgKHRoaXMucHJvcHMuYmFja0J1dHRvbikge1xuICAgICAgYmFja0J1dHRvbiA9ICg8VG9wQmFyQmFja0J1dHRvblxuICAgICAgICBsYWJlbD17dGhpcy5wcm9wcy5iYWNrQnV0dG9uTGFiZWx9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuX29uQmFja0NsaWNrZWR9IC8+KVxuICAgIH1cbiAgICByZXR1cm4gKDxkaXYgYmVtPSckYjp0b3BCYXIgZTpyb3cnPlxuICAgICAgPGRpdiBiZW09J2U6Y2VsbCc+XG4gICAgICAgIDxkaXYgYmVtPSdlOnRhYmxlJz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpjZWxsIG06bGVmdCc+XG4gICAgICAgICAgICB7YmFja0J1dHRvbn1cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpmdWxsV2lkdGgnPlxuICAgICAgICAgICAgPFNlYXJjaENvbXBvbmVudFxuICAgICAgICAgICAgICBzZWFyY2hRdWVyeT17dGhpcy5wcm9wcy5zZWFyY2hRdWVyeX1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uU2VhcmNoVmFsdWVDaGFuZ2V9IC8+XG4gICAgICAgICAgICA8SW52aXNpYmxlVXBsb2FkQ29tcG9uZW50IG9uTmV3RmlsZT17dGhpcy5fb25OZXdGaWxlfSByZWY9J3VwbG9hZCcgLz5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgYmVtPSdlOmNlbGwgbTpyaWdodCc+XG4gICAgICAgICAgICB7dGhpcy5fcmVuZGVyUmlnaHRCdXR0b25zKCl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KVxuICB9XG59XG5cblBob3RvUm9sbFRvcEJhckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBUb3BCYXJDb21wb25lbnQuY29udGV4dFR5cGVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3NjcmVlbnMvcGhvdG8tcm9sbC90b3AtYmFyL3RvcC1iYXItY29tcG9uZW50LmpzeCIsIi8qKiBAanN4IFJlYWN0QkVNLmNyZWF0ZUVsZW1lbnQgKiovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFV0aWxzLCBSZWFjdEJFTSwgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvcEJhclNlYXJjaENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9iaW5kQWxsKFxuICAgICAgJ19vbkZvY3VzJyxcbiAgICAgICdfb25CbHVyJyxcbiAgICAgICdfb25DaGFuZ2UnLFxuICAgICAgJ19vbkJhckNsaWNrJ1xuICAgIClcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgcGxhY2Vob2xkZXI6IHRoaXMuX3QoJ3Bob3RvUm9sbC5zZWFyY2gucGxhY2Vob2xkZXInKSxcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnNlYXJjaFF1ZXJ5IHx8ICcnXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElGRUNZQ0xFXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYWJvdXQgdG8gcmVjZWl2ZSBuZXcgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5leHRQcm9wc1xuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5zZWFyY2hRdWVyeSB8fCB0aGlzLnN0YXRlLnZhbHVlKSB7XG4gICAgICB0aGlzLnN0YXRlLmFjdGl2ZSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5hY3RpdmUgPSBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWU6IG5leHRQcm9wcy5zZWFyY2hRdWVyeSB8fCAnJ1xuICAgIH0pXG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIHRoaXMucmVmcy5pbnB1dC52YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWRcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBzdXBlci5jb21wb25lbnREaWRNb3VudCgpXG4gICAgdGhpcy5faGlkZGVuSW5wdXREdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICBjb25zdCBzdHlsZU9iamVjdCA9IFV0aWxzLmdldFN0eWxlT2JqZWN0KHRoaXMucmVmcy5pbnB1dClcbiAgICBjb25zdCBvdmVycmlkZUtleXMgPSBbXG4gICAgICAnZm9udCcsXG4gICAgICAnbGluZUhlaWdodCcsXG4gICAgICAndGV4dEFsaWduJyxcbiAgICAgICd0ZXh0SW5kZW50JyxcbiAgICAgICd0ZXh0VHJhbnNmb3JtJyxcbiAgICAgICd0ZXh0RGVjb3JhdGlvbicsXG4gICAgICAndGV4dFJlbmRlcmluZycsXG4gICAgICAndGV4dFNoYWRvdycsXG4gICAgICAndGV4dE92ZXJmbG93JyxcbiAgICAgICd3b3JkU3BhY2luZycsXG4gICAgICAnbGV0dGVyU3BhY2luZycsXG4gICAgICAnd2hpdGVTcGFjZSdcbiAgICBdXG4gICAgb3ZlcnJpZGVLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5faGlkZGVuSW5wdXREdW1teS5zdHlsZVtrZXldID0gc3R5bGVPYmplY3Rba2V5XVxuICAgIH0pXG5cbiAgICB0aGlzLl9oaWRkZW5JbnB1dER1bW15LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIHRoaXMuX2hpZGRlbklucHV0RHVtbXkuc3R5bGUudG9wID0gJy05OTk5cHgnXG4gICAgdGhpcy5faGlkZGVuSW5wdXREdW1teS5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnXG5cbiAgICB0aGlzLnJlZnMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9oaWRkZW5JbnB1dER1bW15KVxuXG4gICAgdGhpcy5fdXBkYXRlSW5wdXRXaWR0aCgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGlucHV0IHdpZHRoIHRvIGZpdCB0aGUgdGV4dCB3aWR0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUlucHV0V2lkdGggKCkge1xuICAgIHRoaXMuX2hpZGRlbklucHV0RHVtbXkuaW5uZXJIVE1MID0gdGhpcy5zdGF0ZS52YWx1ZSB8fCB0aGlzLnN0YXRlLnBsYWNlaG9sZGVyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaW5wdXRXaWR0aDogdGhpcy5faGlkZGVuSW5wdXREdW1teS5vZmZzZXRXaWR0aCArIDVcbiAgICAgIH0pXG4gICAgfSwgMClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBzZWFyY2ggYmFyIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhckNsaWNrICgpIHtcbiAgICB0aGlzLnJlZnMuaW5wdXQuZm9jdXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGlucHV0IGZpZWxkcyBpcyBmb2N1c2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Gb2N1cyAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZTogdHJ1ZSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGlucHV0IGZpZWxkIGxvc2VzIGZvY3VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25CbHVyICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gJycgJiYgIXRoaXMucHJvcHMuc2VhcmNoUXVlcnkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBhY3RpdmU6IGZhbHNlIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGlucHV0IHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DaGFuZ2UgKGUpIHtcbiAgICB0aGlzLnN0YXRlLnZhbHVlID0gZS50YXJnZXQudmFsdWVcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcblxuICAgIHRoaXMucHJvcHMub25DaGFuZ2UgJiZcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy5zdGF0ZS52YWx1ZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlYWN0QkVNLkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJXaXRoQkVNICgpIHtcbiAgICBsZXQgc2VhcmNoQmFyQkVNID0gJyRlOnNlYXJjaEJhcidcbiAgICBsZXQgaWNvblBhdGggPSAncGhvdG8tcm9sbC9zZWFyY2gtbGlnaHQucG5nJ1xuICAgIGlmICh0aGlzLnN0YXRlLmFjdGl2ZSkge1xuICAgICAgc2VhcmNoQmFyQkVNICs9ICcgbTphY3RpdmUnXG4gICAgICBpY29uUGF0aCA9ICdwaG90by1yb2xsL3NlYXJjaC1kYXJrLnBuZydcbiAgICB9XG4gICAgaWNvblBhdGggPSB0aGlzLl9nZXRBc3NldFBhdGgoaWNvblBhdGgsIHRydWUpXG5cbiAgICBjb25zdCBpbnB1dFN0eWxlID0ge1xuICAgICAgd2lkdGg6IHRoaXMuc3RhdGUuaW5wdXRXaWR0aCArICdweCdcbiAgICB9XG5cbiAgICByZXR1cm4gKDxiZW0gc3BlY2lmaWVyPSckYjpwaG90b1JvbGxTY3JlZW4nPlxuICAgICAgPGRpdiBiZW09e3NlYXJjaEJhckJFTX0gcmVmPSdyb290JyBvbkNsaWNrPXt0aGlzLl9vbkJhckNsaWNrfT5cbiAgICAgICAgPGRpdiBiZW09J2U6Y29udGVudCc+XG4gICAgICAgICAgPGRpdiBiZW09JyRlOmljb24nPlxuICAgICAgICAgICAgPGltZyBzcmM9e2ljb25QYXRofSBiZW09J2U6aW1hZ2UnIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBiZW09J2U6aW5wdXRDb250YWluZXInPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIGJlbT0nZTppbnB1dCdcbiAgICAgICAgICAgICAgcmVmPSdpbnB1dCdcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3RoaXMuc3RhdGUucGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgIG9uQmx1cj17dGhpcy5fb25CbHVyfVxuICAgICAgICAgICAgICBvbkZvY3VzPXt0aGlzLl9vbkZvY3VzfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25DaGFuZ2V9XG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICAgICAgc3R5bGU9e2lucHV0U3R5bGV9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9iZW0+KVxuICB9XG59XG5cblRvcEJhclNlYXJjaENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9zY3JlZW5zL3Bob3RvLXJvbGwvdG9wLWJhci90b3AtYmFyLXNlYXJjaC1jb21wb25lbnQuanN4IiwiLyoqIEBqc3ggUmVhY3RCRU0uY3JlYXRlRWxlbWVudCAqKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVXRpbHMsIFJlYWN0QkVNIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBSb3dDb21wb25lbnQgZnJvbSAnLi9yb3ctY29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaG90b1JvbGxDb21wb25lbnQgZXh0ZW5kcyBSb3dDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9uZWVkc1N0eWxlRml4ZXMgPSB0cnVlXG4gICAgdGhpcy5fbW9kaWZpZXIgPSAncGhvdG9Sb2xsJ1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIHN0eWxlcyBuZWVkIHRvIGJlIGZpeGVkIGJ5IHRoZSBKYXZhU2NyaXB0LlxuICAgKiBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgdGhhbmtzIHRvIG9sZGVyIEludGVybmV0IEV4cGxvcmVyIGJyb3dzZXJzIHdoaWNoIGhhdmVcbiAgICogYSBidW5jaCBvZiBDU1MgYnVncy5cbiAgICovXG4gIGZpeFN0eWxlcyAoKSB7XG4gICAgaWYgKFV0aWxzLkJyb3dzZXIuaXNJRWx0ZSgxMSkpIHtcbiAgICAgIGNvbnN0IHsgY2VsbCwgb3ZlcmxheSB9ID0gdGhpcy5yZWZzXG4gICAgICBjb25zdCBjZWxsSGVpZ2h0ID0gY2VsbC5vZmZzZXRIZWlnaHRcbiAgICAgIG92ZXJsYXkuc3R5bGUuaGVpZ2h0ID0gYCR7Y2VsbEhlaWdodH1weGBcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHJvdydzIGNvbnRlbnRcbiAgICogQHJldHVybiB7UmVhY3RCRU0uRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDb250ZW50ICgpIHtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke3RoaXMuX2dldEFzc2V0UGF0aCgnc3BsYXNoL3Bob3RvLXJvbGwucG5nJywgdHJ1ZSwgdHJ1ZSl9KWBcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBiZW09J2U6Y29udGVudFdyYXBwZXInPlxuICAgICAgICA8ZGl2IGJlbT0nZTpjb250ZW50Um93Jz5cbiAgICAgICAgICA8ZGl2IGJlbT0nZTpjb250ZW50Q2VsbCcgb25DbGljaz17dGhpcy5fb25DbGlja30gc3R5bGU9e3N0eWxlfSByZWY9J2NlbGwnPlxuICAgICAgICAgICAgPGRpdiBiZW09J2U6b3ZlcmxheScgcmVmPSdvdmVybGF5JyAvPlxuICAgICAgICAgICAgPGRpdiBiZW09J2U6aGVhZGxpbmUnPl