(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["PhotoEditorSDK"] = factory();
	else
		root["PhotoEditorSDK"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 256);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

"use strict";
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(190);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(189);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(24);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _typeof2 = __webpack_require__(24);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Licensing = exports.Base64 = exports.GLUtils = exports.Promise = exports.Log = exports.Constants = exports.Color = exports.Configurable = exports.Utils = exports.EventEmitter = exports.Engine = exports.cancelAnimationFrame = exports.requestAnimationFrame = undefined;

var _animationFrame = __webpack_require__(186);

Object.defineProperty(exports, 'requestAnimationFrame', {
  enumerable: true,
  get: function get() {
    return _animationFrame.requestAnimationFrame;
  }
});
Object.defineProperty(exports, 'cancelAnimationFrame', {
  enumerable: true,
  get: function get() {
    return _animationFrame.cancelAnimationFrame;
  }
});

var _math = __webpack_require__(67);

Object.keys(_math).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _math[key];
    }
  });
});

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _constants = __webpack_require__(9);

var Constants = _interopRequireWildcard(_constants);

var _base = __webpack_require__(27);

var _base2 = _interopRequireDefault(_base);

var _eventEmitter = __webpack_require__(28);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _utils = __webpack_require__(21);

var _utils2 = _interopRequireDefault(_utils);

var _configurable = __webpack_require__(16);

var _configurable2 = _interopRequireDefault(_configurable);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

var _log = __webpack_require__(22);

var _log2 = _interopRequireDefault(_log);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _glUtils = __webpack_require__(77);

var _glUtils2 = _interopRequireDefault(_glUtils);

var _licensing = __webpack_require__(116);

var _licensing2 = _interopRequireDefault(_licensing);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

if (Function.prototype.name === undefined && Object.defineProperty !== undefined) {
  /* eslint-disable no-extend-native */
  Object.defineProperty(Function.prototype, 'name', {
    get: function get() {
      var funcNameRegex = /function\s([^(]{1,})\(/;
      var results = funcNameRegex.exec(this.toString());
      return results && results.length > 1 ? results[1].trim() : '';
    },
    set: function set(value) {}
  });
  /* eslint-enable no-extend-native */
}

exports.Engine = _engine2.default;
exports.EventEmitter = _eventEmitter2.default;
exports.Utils = _utils2.default;
exports.Configurable = _configurable2.default;
exports.Color = _color2.default;
exports.Constants = Constants;
exports.Log = _log2.default;
exports.Promise = _promise2.default;
exports.GLUtils = _glUtils2.default;
exports.Base64 = _base2.default;
exports.Licensing = _licensing2.default;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _primitivesStack = __webpack_require__(150);

var _primitivesStack2 = _interopRequireDefault(_primitivesStack);

var _configurable = __webpack_require__(16);

var _configurable2 = _interopRequireDefault(_configurable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType; /* jshint unused: false */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * Base class for filters. Extendable via {@link PhotoEditorSDK.Filter#extend}
 * @class
 * @memberof PhotoEditorSDK
 */
var Filter = function (_Configurable) {
  (0, _inherits3.default)(Filter, _Configurable);

  function Filter() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Filter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Configurable.call(this, options, {
      intensity: {
        type: OptionType.NUMBER,
        default: 1.0,
        setter: function setter(intensity) {
          this._stack && this._stack.setIntensity(intensity);
          return intensity;
        }
      },
      dirty: {
        type: OptionType.BOOLEAN,
        default: true
      }
    }));

    _this._stack = new _primitivesStack2.default(_this._options.intensity);
    return _this;
  }

  /**
   * Renders the filter
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @param  {PhotoEditorSDK.Engine.RenderTexture} outputTexture
   * @return {Promise}
   */


  Filter.prototype.render = function render(sdk, inputTexture, outputTexture) {
    var _this2 = this;

    return this._stack.render(sdk, inputTexture, outputTexture).then(function (response) {
      _this2.setDirty(false);
      return response;
    });
  };

  /**
   * Sets the dirtiness for the given renderer
   * @param {Boolean} dirty
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   */


  Filter.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
    this._stack.setDirtyForRenderer(dirty, renderer);
  };

  /**
   * Frees the memory
   */


  Filter.prototype.disposeRenderTextures = function disposeRenderTextures() {
    this._stack.disposeRenderTextures();
  };

  /**
   * Cleans this instance up
   */


  Filter.prototype.dispose = function dispose() {
    this._stack.dispose();
  };

  return Filter;
}(_configurable2.default);

/**
 * A unique string that identifies this filter
 * @type {String}
 */


Filter.identifier = null;

/**
 * If `isIdentity` is true, this filter does not do anything and can be seen as
 * the default filter.
 * @type {Boolean}
 */
Filter.isIdentity = false;

/**
 * This string is used by the UI
 * @type {String}
 */
Filter.displayName = null;

// Exposed classes
Filter.PrimitivesStack = _primitivesStack2.default;

exports.default = Filter;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _brightness = __webpack_require__(151);

Object.defineProperty(exports, 'Brightness', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_brightness).default;
  }
});

var _contrast = __webpack_require__(153);

Object.defineProperty(exports, 'Contrast', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_contrast).default;
  }
});

var _colorMatrix = __webpack_require__(152);

Object.defineProperty(exports, 'ColorMatrixPrimitive', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_colorMatrix).default;
  }
});

var _desaturation = __webpack_require__(154);

Object.defineProperty(exports, 'Desaturation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_desaturation).default;
  }
});

var _gamma = __webpack_require__(155);

Object.defineProperty(exports, 'Gamma', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_gamma).default;
  }
});

var _glow = __webpack_require__(156);

Object.defineProperty(exports, 'Glow', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_glow).default;
  }
});

var _gobblin = __webpack_require__(157);

Object.defineProperty(exports, 'Gobblin', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_gobblin).default;
  }
});

var _grayscale = __webpack_require__(158);

Object.defineProperty(exports, 'Grayscale', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_grayscale).default;
  }
});

var _lookupTable = __webpack_require__(83);

Object.defineProperty(exports, 'LookupTable', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_lookupTable).default;
  }
});

var _lookupTableImage = __webpack_require__(159);

Object.defineProperty(exports, 'LookupTableImage', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_lookupTableImage).default;
  }
});

var _saturation = __webpack_require__(160);

Object.defineProperty(exports, 'Saturation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_saturation).default;
  }
});

var _softColorOverlay = __webpack_require__(161);

Object.defineProperty(exports, 'SoftColorOverlay', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_softColorOverlay).default;
  }
});

var _toneCurve = __webpack_require__(162);

Object.defineProperty(exports, 'ToneCurve', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_toneCurve).default;
  }
});

var _x = __webpack_require__(163);

Object.defineProperty(exports, 'X400', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_x).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var _log = __webpack_require__(22);

var _log2 = _interopRequireDefault(_log);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

var _matrix = __webpack_require__(78);

var _matrix2 = _interopRequireDefault(_matrix);

var _rectangle = __webpack_require__(79);

var _rectangle2 = _interopRequireDefault(_rectangle);

var _vector = __webpack_require__(23);

var _vector2 = _interopRequireDefault(_vector);

var _eventEmitter = __webpack_require__(28);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _utils = __webpack_require__(21);

var _utils2 = _interopRequireDefault(_utils);

var _glUtils = __webpack_require__(77);

var _glUtils2 = _interopRequireDefault(_glUtils);

var _constants = __webpack_require__(9);

var Constants = _interopRequireWildcard(_constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.BATCH_SIZE = 2000; /*
                            * This file is part of PhotoEditorSDK.
                            *
                            * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                            * All rights reserved.
                            *
                            * Redistribution and use in source and binary forms, without
                            * modification, are permitted provided that the following license agreement
                            * is approved and a legal/financial contract was signed by the user.
                            * The license agreement can be found under following link:
                            *
                            * https://www.photoeditorsdk.com/LICENSE.txt
                            */

exports.VERTEX_SIZE = 5;
exports.VERTEX_BYTE_SIZE = exports.VERTEX_SIZE * 4;

exports.Color = _color2.default;
exports.Matrix = _matrix2.default;
exports.Vector2 = _vector2.default;
exports.Rectangle = _rectangle2.default;
exports.EventEmitter = _eventEmitter2.default;
exports.Log = _log2.default;
exports.Utils = _utils2.default;
exports.Constants = Constants;
exports.GLUtils = _glUtils2.default;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

var _typeof2 = __webpack_require__(24);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable */
/*
 * Native Promise Only
 * v0.8.0-a (c) Kyle Simpson
 * MIT License: http://getify.mit-license.org
 * @license
 */
/* istanbul ignore next */
(function UMD(name, context, definition) {
  // special form of UMD for polyfilling across evironments
  context[name] = context[name] || definition();
  if (typeof module != "undefined" && module.exports) {
    module.exports = context[name];
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function $AMD$() {
      return context[name];
    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})("Promise", typeof global != "undefined" ? global : undefined, function DEF() {
  /*jshint validthis:true */
  "use strict";

  var builtInProp,
      cycle,
      scheduling_queue,
      ToString = Object.prototype.toString,
      timer = typeof setImmediate != "undefined" ? function timer(fn) {
    return setImmediate(fn);
  } : setTimeout;

  // dammit, IE8.
  try {
    Object.defineProperty({}, "x", {});
    builtInProp = function builtInProp(obj, name, val, config) {
      return Object.defineProperty(obj, name, {
        value: val,
        writable: true,
        configurable: config !== false
      });
    };
  } catch (err) {
    builtInProp = function builtInProp(obj, name, val) {
      obj[name] = val;
      return obj;
    };
  }

  // Note: using a queue instead of array for efficiency
  scheduling_queue = function Queue() {
    var first, last, item;

    function Item(fn, self) {
      this.fn = fn;
      this.self = self;
      this.next = void 0;
    }

    return {
      add: function add(fn, self) {
        item = new Item(fn, self);
        if (last) {
          last.next = item;
        } else {
          first = item;
        }
        last = item;
        item = void 0;
      },
      drain: function drain() {
        var f = first;
        first = last = cycle = void 0;

        while (f) {
          f.fn.call(f.self);
          f = f.next;
        }
      }
    };
  }();

  function schedule(fn, self) {
    scheduling_queue.add(fn, self);
    if (!cycle) {
      cycle = timer(scheduling_queue.drain);
    }
  }

  // promise duck typing
  function isThenable(o) {
    var _then,
        o_type = typeof o === "undefined" ? "undefined" : (0, _typeof3.default)(o);

    if (o != null && (o_type == "object" || o_type == "function")) {
      _then = o.then;
    }
    return typeof _then == "function" ? _then : false;
  }

  function notify() {
    for (var i = 0; i < this.chain.length; i++) {
      notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
    }
    this.chain.length = 0;
  }

  // NOTE: This is a separate function to isolate
  // the `try..catch` so that other code can be
  // optimized better
  function notifyIsolated(self, cb, chain) {
    var ret, _then;
    try {
      if (cb === false) {
        chain.reject(self.msg);
      } else {
        if (cb === true) {
          ret = self.msg;
        } else {
          ret = cb.call(void 0, self.msg);
        }

        if (ret === chain.promise) {
          chain.reject(TypeError("Promise-chain cycle"));
        } else if (_then = isThenable(ret)) {
          _then.call(ret, chain.resolve, chain.reject);
        } else {
          chain.resolve(ret);
        }
      }
    } catch (err) {
      chain.reject(err);
    }
  }

  function resolve(msg) {
    var _then,
        self = this;

    // already triggered?
    if (self.triggered) {
      return;
    }

    self.triggered = true;

    // unwrap
    if (self.def) {
      self = self.def;
    }

    try {
      if (_then = isThenable(msg)) {
        schedule(function () {
          var def_wrapper = new MakeDefWrapper(self);
          try {
            _then.call(msg, function $resolve$() {
              resolve.apply(def_wrapper, arguments);
            }, function $reject$() {
              reject.apply(def_wrapper, arguments);
            });
          } catch (err) {
            reject.call(def_wrapper, err);
          }
        });
      } else {
        self.msg = msg;
        self.state = 1;
        if (self.chain.length > 0) {
          schedule(notify, self);
        }
      }
    } catch (err) {
      reject.call(new MakeDefWrapper(self), err);
    }
  }

  function reject(msg) {
    var self = this;

    // already triggered?
    if (self.triggered) {
      return;
    }

    self.triggered = true;

    // unwrap
    if (self.def) {
      self = self.def;
    }

    self.msg = msg;
    self.state = 2;
    if (self.chain.length > 0) {
      schedule(notify, self);
    }
  }

  function iteratePromises(Constructor, arr, resolver, rejecter) {
    for (var idx = 0; idx < arr.length; idx++) {
      (function IIFE(idx) {
        Constructor.resolve(arr[idx]).then(function $resolver$(msg) {
          resolver(idx, msg);
        }, rejecter);
      })(idx);
    }
  }

  function MakeDefWrapper(self) {
    this.def = self;
    this.triggered = false;
  }

  function MakeDef(self) {
    this.promise = self;
    this.state = 0;
    this.triggered = false;
    this.chain = [];
    this.msg = void 0;
  }

  function Promise(executor) {
    if (typeof executor != "function") {
      throw TypeError("Not a function");
    }

    if (this.__NPO__ !== 0) {
      throw TypeError("Not a promise");
    }

    // instance shadowing the inherited "brand"
    // to signal an already "initialized" promise
    this.__NPO__ = 1;

    var def = new MakeDef(this);

    this["then"] = function then(success, failure) {
      var o = {
        success: typeof success == "function" ? success : true,
        failure: typeof failure == "function" ? failure : false
      };
      // Note: `then(..)` itself can be borrowed to be used against
      // a different promise constructor for making the chained promise,
      // by substituting a different `this` binding.
      o.promise = new this.constructor(function extractChain(resolve, reject) {
        if (typeof resolve != "function" || typeof reject != "function") {
          throw TypeError("Not a function");
        }

        o.resolve = resolve;
        o.reject = reject;
      });
      def.chain.push(o);

      if (def.state !== 0) {
        schedule(notify, def);
      }

      return o.promise;
    };
    this["catch"] = function $catch$(failure) {
      return this.then(void 0, failure);
    };

    try {
      executor.call(void 0, function publicResolve(msg) {
        resolve.call(def, msg);
      }, function publicReject(msg) {
        reject.call(def, msg);
      });
    } catch (err) {
      reject.call(def, err);
    }
  }

  var PromisePrototype = builtInProp({}, "constructor", Promise,
  /*configurable=*/false);

  // Note: Android 4 cannot use `Object.defineProperty(..)` here
  Promise.prototype = PromisePrototype;

  // built-in "brand" to signal an "uninitialized" promise
  builtInProp(PromisePrototype, "__NPO__", 0,
  /*configurable=*/false);

  builtInProp(Promise, "resolve", function Promise$resolve(msg) {
    var Constructor = this;

    // spec mandated checks
    // note: best "isPromise" check that's practical for now
    if (msg && (typeof msg === "undefined" ? "undefined" : (0, _typeof3.default)(msg)) == "object" && msg.__NPO__ === 1) {
      return msg;
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      resolve(msg);
    });
  });

  builtInProp(Promise, "reject", function Promise$reject(msg) {
    return new this(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      reject(msg);
    });
  });

  builtInProp(Promise, "all", function Promise$all(arr) {
    var Constructor = this;

    // spec mandated checks
    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }
    if (arr.length === 0) {
      return Constructor.resolve([]);
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      var len = arr.length,
          msgs = Array(len),
          count = 0;

      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        msgs[idx] = msg;
        if (++count === len) {
          resolve(msgs);
        }
      }, reject);
    });
  });

  builtInProp(Promise, "race", function Promise$race(arr) {
    var Constructor = this;

    // spec mandated checks
    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        resolve(msg);
      }, reject);
    });
  });

  return Promise;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(98), __webpack_require__(66).setImmediate))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _configurable = __webpack_require__(16);

var _configurable2 = _interopRequireDefault(_configurable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class for filter primitives.
 * @class
 * @memberof PhotoEditorSDK.FilterPrimitives
 */
var Primitive = function (_Configurable) {
  (0, _inherits3.default)(Primitive, _Configurable);

  function Primitive() {
    (0, _classCallCheck3.default)(this, Primitive);
    return (0, _possibleConstructorReturn3.default)(this, _Configurable.apply(this, arguments));
  }

  /**
   * Gets called before this primitive's filter is being applied
   */
  Primitive.prototype.update = function update() {};

  /**
   * Returns this primitive's filter
   * @return {PhotoEditorSDK.Engine.Filter}
   */


  Primitive.prototype.getFilter = function getFilter() {
    return this._filter;
  };

  /**
   * Cleans up this instance
   */


  Primitive.prototype.dispose = function dispose() {
    if (this._filter) {
      this._filter.dispose();
      this._filter = null;
    }
  };

  return Primitive;
}(_configurable2.default); /* jshint unused: false */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = Primitive;

/***/ },
/* 9 */
/***/ function(module, exports) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The available render types
 * @enum {String}
 * @alias RenderType
 * @memberof PhotoEditorSDK
 */
var RenderType = exports.RenderType = {
  IMAGE: 'image',
  DATAURL: 'data-url',
  BUFFER: 'buffer',
  BLOB: 'blob',
  MSBLOB: 'ms-blob'
};

/**
 * The available image types
 * @enum {String}
 * @alias ImageFormat
 * @memberof PhotoEditorSDK
 */
var ImageFormat = exports.ImageFormat = {
  PNG: 'image/png',
  JPEG: 'image/jpeg'
};

/**
 * Events used by the UI
 * @enum {String}
 * @alias Events
 * @memberof PhotoEditorSDK
 */
var Events = exports.Events = {
  OPERATION_UPDATED: 'operation:update'
};

/**
 * The available option types for classes inheriting {@link PhotoEditorSDK.Configurable}
 * @enum {String}
 * @alias OptionType
 * @memberof PhotoEditorSDK
 */
var OptionType = exports.OptionType = {
  NUMBER: 'number',
  VECTOR2: 'vector2',
  COLOR_MATRIX: 'color-matrix',
  COLOR: 'color',
  ARRAY: 'array',
  OBJECT: 'object',
  STRING: 'string',
  BOOLEAN: 'boolean',
  CONFIGURABLE: 'configurable',
  IMAGE: 'image',
  ALL: '*'
};

/**
 * The available uniform types for WebGL shaders
 * @enum {String}
 * @alias UniformType
 * @memberof PhotoEditorSDK
 */
var UniformType = exports.UniformType = {
  SAMPLER2D: 'sampler2d',
  INT: 'i',
  INT1: '1i',
  FLOAT: 'f',
  FLOAT1: '1f',
  FLOAT2: '2f',
  FLOAT_VECTOR2: '2fv',
  FLOAT3: '3f',
  FLOAT4: '4f',
  MAT3: 'mat3',
  MAT3FV: 'mat3fv',
  MAT4: 'mat4'
};

/**
 * The available renderer types
 * @enum {String}
 * @alias RendererType
 * @memberOf PhotoEditorSDK
 */
var RendererType = exports.RendererType = {
  WEBGL: 'webgl',
  CANVAS: 'canvas'
};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _constants = __webpack_require__(9);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _log = __webpack_require__(22);

var _log2 = _interopRequireDefault(_log);

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _configurable = __webpack_require__(16);

var _configurable2 = _interopRequireDefault(_configurable);

var _performanceTest = __webpack_require__(80);

var _performanceTest2 = _interopRequireDefault(_performanceTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class for Operations
 * @class
 * @alias Operation
 * @extends PhotoEditorSDK.Configurable
 * @memberof PhotoEditorSDK
 */
/* jshint unused:false */
/* jshint -W083 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Operation = function (_Configurable) {
  (0, _inherits3.default)(Operation, _Configurable);

  /**
   * Creates an Operation
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} [options]
   */
  function Operation(sdk) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, Operation);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Configurable.call(this, options, {
      enabled: { type: _constants.OptionType.BOOLEAN, default: true }
    }));

    _this._sdk = sdk;
    _this._cacheEnabled = false;
    _this._dirtiness = {};

    _this._sprite = new _engine2.default.Sprite();
    _this._container = new _engine2.default.Container();
    _this._container.addChild(_this._sprite);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when options have been changed. Sets this operation to dirty.
   * @private
   */


  Operation.prototype._onOptionsChange = function _onOptionsChange() {
    this.setDirty(true);
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Applies this operation
   * @param  {PhotoEditorSDK.Engine.RenderTexture} inputTexture
   * @return {Promise}
   * @abstract
   */


  Operation.prototype.render = function render(inputTexture) {
    var _this2 = this;

    if (!this.getEnabled()) {
      _log2.default.info(this.constructor.name, 'Disabled - skipping');
      return _promise2.default.resolve(inputTexture);
    }

    if (!this._renderTexture) {
      var frame = this._sdk.getSprite().getTexture().getFrame();
      this._renderTexture = new _engine2.default.RenderTexture(this._sdk.getRenderer(), frame.width, frame.height);
    }

    var renderer = this._sdk.getRenderer();
    var promise = void 0;
    var perf = void 0;
    if (_log2.default.canLog('info')) {
      perf = new _performanceTest2.default(this.constructor.name, 'Rendering');
    }

    // Handle caching
    if (this.isDirtyForRenderer(renderer)) {
      // Make sure that this Operation's internal sprite has the input texture and that
      // the RenderTexture we're rendering to has the same dimensions
      this._sprite.setTexture(inputTexture);

      var newDimensions = this.getNewDimensions(inputTexture.getDimensions()).floor();
      this._renderTexture.resizeTo(newDimensions);
      this._renderTexture.clear();

      // Let the operation do its work
      promise = this._render(inputTexture).then(function () {
        // Operation has been rendered - not dirty anymore
        _this2.setDirtyForRenderer(false, renderer);
        return _this2._renderTexture;
      });
    } else {
      _log2.default.info(this.constructor.name, 'Rendering from cache');
      promise = _promise2.default.resolve(this._renderTexture);
    }

    return promise.then(function (outputTexture) {
      if (perf) perf.stop();
      return outputTexture;
    });
  };

  /**
   * Renders this operation
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @return {Promise}
   * @private
   */


  Operation.prototype._render = function _render(inputTexture) {
    var renderFn = void 0;
    if (this._sdk.getRenderer().isOfType(_constants.RendererType.WEBGL)) {
      /* istanbul ignore next */
      renderFn = this._renderWebGL.bind(this);
    } else {
      renderFn = this._renderCanvas.bind(this);
    }

    return renderFn(inputTexture);
  };

  /**
   * Applies this operation using WebGL
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @protected
   * @abstract
   */


  Operation.prototype._renderWebGL = function _renderWebGL(inputTexture) {
    throw new Error('Operation#_renderWebGL is abstract and not implemented in inherited class.');
  };

  /**
   * Applies this operation using Canvas2D
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @protected
   * @abstract
   */


  Operation.prototype._renderCanvas = function _renderCanvas(inputTexture) {
    throw new Error('Operation#_renderCanvas is abstract and not implemented in inherited class.');
  };

  /**
   * Returns the dimensions that an image with the given `dimensions`
   * would have after this operation has been applied
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Operation.prototype.getNewDimensions = function getNewDimensions(dimensions) {
    return dimensions.clone();
  };

  /**
   * Resets this operation
   */


  Operation.prototype.reset = function reset() {
    this._dirty = true;
    this._glslPrograms = {};
  };

  // -------------------------------------------------------------------------- DIRTINESS

  /**
   * Checks if this operation is dirty for the given renderer
   * @param  {PhotoEditorSDK.Engine.BaseRenderer}  renderer
   * @return {Boolean}
   */


  Operation.prototype.isDirtyForRenderer = function isDirtyForRenderer(renderer) {
    var dirty = this._dirtiness[renderer.id];
    return typeof dirty === 'undefined' ? true : dirty;
  };

  /**
   * Sets the dirtiness for the given renderer
   * @param {Boolean} dirty
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param {Boolean} dimensionsChanged = false
   */


  Operation.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
    var dimensionsChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    this._dirtiness[renderer.id] = dirty;
  };

  /**
   * Sets the dirtiness for all renderers
   * @param {Boolean} dirty
   * @param {Boolean} dimensionsChanged = false
   */


  Operation.prototype.setDirty = function setDirty(dirty) {
    var dimensionsChanged = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    for (var rendererId in this._dirtiness) {
      this.setDirtyForRenderer(dirty, { id: rendererId }, dimensionsChanged);
    }
  };

  /**
   * Returns the instance of {@link PhotoEditorSDK} that this operation belongs to
   * @return {PhotoEditorSDK}
   */


  Operation.prototype.getSDK = function getSDK() {
    return this._sdk;
  };

  /**
   * Returns the input dimensions for this operation
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Operation.prototype.getInputDimensions = function getInputDimensions() {
    var _this3 = this;

    var dimensions = this._sdk.getInputDimensions();
    var opFound = void 0;
    this._sdk.getOperationsStack().forEach(function (op) {
      if (opFound) return;
      if (op === _this3) {
        opFound = true;
        return;
      }
      dimensions = op.getNewDimensions(dimensions);
    });
    return dimensions.floor();
  };

  /**
   * Disposes the RenderTexture
   */


  Operation.prototype.disposeRenderTextures = function disposeRenderTextures() {
    if (this._renderTexture) {
      this._renderTexture.dispose();
    }
    this._renderTexture = null;
  };

  /**
   * Disposes this operation
   */


  Operation.prototype.dispose = function dispose() {
    this.disposeRenderTextures();
    this._sprite.dispose();
  };

  return Operation;
}(_configurable2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 */


Operation.identifier = null;

exports.default = Operation;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(38);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * Represents a color
 * @class
 * @memberof PhotoEditorSDK
 */
var Color = function () {
  /**
   * Creates a color
   * @param  {Number} r
   * @param  {Number} g
   * @param  {Number} b
   * @param  {Number} [a = 1]
   */
  function Color(r, g, b) {
    var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;
    (0, _classCallCheck3.default)(this, Color);

    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }

  /**
   * Returns an rgba() representation of this color
   * @return {String}
   */


  Color.prototype.toRGBA = function toRGBA() {
    var colors = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255), this.a];
    return 'rgba(' + colors.join(',') + ')';
  };

  /**
   * Returns a hex representation of this color
   * @return {String}
   */


  Color.prototype.toHex = function toHex() {
    var components = [this._componentToHex(Math.round(this.r * 255)), this._componentToHex(Math.round(this.g * 255)), this._componentToHex(Math.round(this.b * 255))];
    return '#' + components.join('');
  };

  /**
   * Returns an array with 4 values (0...1)
   * @return {Number[]}
   */


  Color.prototype.toGLColor = function toGLColor() {
    return [this.r, this.g, this.b, this.a];
  };

  /**
   * Returns an array with 4 values (0...1)
   * @return {Number[]}
   */


  Color.prototype.toArray = function toArray() {
    return this.toGLColor();
  };

  /**
   * Returns an array with 3 values (0...1)
   * @return {Number[]}
   */


  Color.prototype.toRGBGLColor = function toRGBGLColor() {
    return [this.r, this.g, this.b];
  };

  /**
   * Converts the RGB value to HSV
   * @return {Number[]}
   */


  Color.prototype.toHSV = function toHSV() {
    var max = Math.max(this.r, this.g, this.b);
    var min = Math.min(this.r, this.g, this.b);
    var h = void 0;
    var s = void 0;
    var v = max;
    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min) {
      h = 0; // achromatic
    } else {
      switch (max) {
        case this.r:
          h = (this.g - this.b) / d;
          if (this.g < this.b) {
            h += 6;
          }
          break;
        case this.g:
          h = (this.b - this.r) / d + 2;
          break;
        case this.b:
          h = (this.r - this.g) / d + 4;
          break;
      }
      h /= 6;
    }

    return [h, s, v];
  };

  /**
   * Creates an RGBA color from the given HSV and alpha values
   * @param {Number} h
   * @param {Number} s
   * @param {Number} v
   * @param {Number} [a = 1]
   */


  Color.fromHSV = function fromHSV(h, s, v) {
    var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var _ref = [],
        r = _ref[0],
        g = _ref[1],
        b = _ref[2];


    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;
      case 1:
        r = q;
        g = v;
        b = p;
        break;
      case 2:
        r = p;
        g = v;
        b = t;
        break;
      case 3:
        r = p;
        g = q;
        b = v;
        break;
      case 4:
        r = t;
        g = p;
        b = v;
        break;
      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }

    return new Color(r, g, b, a);
  };

  /**
   * Creates a new Color object from the given array of numbers
   * @param  {Number[]} arr
   * @return {PhotoEditorSDK.Color}
   */


  Color.fromArray = function fromArray(arr) {
    return new Color(arr[0], arr[1], arr[2], arr[3]);
  };

  /**
   * Returns a clone of the current color
   * @return {PhotoEditorSDK.Color}
   */


  Color.prototype.clone = function clone() {
    return new Color(this.r, this.g, this.b, this.a);
  };

  /**
   * Checks if this color equals the given one
   * @param  {PhotoEditorSDK.Color} color
   * @return {Boolean}
   */


  Color.prototype.equals = function equals(color) {
    return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
  };

  /**
   * Returns the given number as hex
   * @param  {Number} component
   * @return {String}
   * @private
   */


  Color.prototype._componentToHex = function _componentToHex(component) {
    var hex = component.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  };

  /**
   * Returns the string representation of this color
   * @returns {String}
   */


  Color.prototype.toString = function toString() {
    return 'Color(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.a + ')';
  };

  /**
   * @type {PhotoEditorSDK.Color}
   */


  (0, _createClass3.default)(Color, null, [{
    key: 'TRANSPARENT',
    get: function get() {
      return new Color(0, 0, 0, 0);
    }

    /**
     * @type {PhotoEditorSDK.Color}
     */

  }, {
    key: 'WHITE',
    get: function get() {
      return new Color(1, 1, 1, 1);
    }

    /**
     * @type {PhotoEditorSDK.Color}
     */

  }, {
    key: 'BLACK',
    get: function get() {
      return new Color(0, 0, 0, 1);
    }
  }]);
  return Color;
}();

exports.default = Color;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _canvasRenderer = __webpack_require__(104);

var _canvasRenderer2 = _interopRequireDefault(_canvasRenderer);

var _webglRenderer = __webpack_require__(106);

var _webglRenderer2 = _interopRequireDefault(_webglRenderer);

var _canvasFilterManager = __webpack_require__(46);

var _canvasFilterManager2 = _interopRequireDefault(_canvasFilterManager);

var _webglFilterManager = __webpack_require__(47);

var _webglFilterManager2 = _interopRequireDefault(_webglFilterManager);

var _displayObject = __webpack_require__(44);

var _displayObject2 = _interopRequireDefault(_displayObject);

var _container = __webpack_require__(71);

var _container2 = _interopRequireDefault(_container);

var _baseTexture = __webpack_require__(29);

var _baseTexture2 = _interopRequireDefault(_baseTexture);

var _texture = __webpack_require__(74);

var _texture2 = _interopRequireDefault(_texture);

var _renderTexture = __webpack_require__(109);

var _renderTexture2 = _interopRequireDefault(_renderTexture);

var _webglRenderTarget = __webpack_require__(34);

var _webglRenderTarget2 = _interopRequireDefault(_webglRenderTarget);

var _canvasRenderTarget = __webpack_require__(33);

var _canvasRenderTarget2 = _interopRequireDefault(_canvasRenderTarget);

var _sprite = __webpack_require__(108);

var _sprite2 = _interopRequireDefault(_sprite);

var _shaders = __webpack_require__(107);

var _shaders2 = _interopRequireDefault(_shaders);

var _shader = __webpack_require__(48);

var _shader2 = _interopRequireDefault(_shader);

var _filter = __webpack_require__(45);

var _filter2 = _interopRequireDefault(_filter);

var _filters = __webpack_require__(102);

var Filters = _interopRequireWildcard(_filters);

var _pixelArrayImage = __webpack_require__(76);

var _pixelArrayImage2 = _interopRequireDefault(_pixelArrayImage);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The heart of PhotoEditorSDK. Handles all the rendering in a scene-graph fashion
 * @namespace PhotoEditorSDK.Engine
 */
var Engine = {
  WebGLRenderer: _webglRenderer2.default,
  CanvasRenderer: _canvasRenderer2.default,
  WebGLFilterManager: _webglFilterManager2.default,
  CanvasFilterManager: _canvasFilterManager2.default,
  DisplayObject: _displayObject2.default,
  Container: _container2.default,
  BaseTexture: _baseTexture2.default,
  Texture: _texture2.default,
  RenderTexture: _renderTexture2.default,
  WebGLRenderTarget: _webglRenderTarget2.default,
  CanvasRenderTarget: _canvasRenderTarget2.default,
  Sprite: _sprite2.default,
  Shaders: _shaders2.default,
  Shader: _shader2.default,
  Filter: _filter2.default,
  Filters: Filters,
  PixelArrayImage: _pixelArrayImage2.default,

  /**
   * If WebGL is supported, this returns a WebGLRenderer and falls back to CanvasRenderer
   * @param  {Number} width
   * @param  {Number} height
   * @param  {Object} [options = {} ]
   * @return {(PhotoEditorSDK.Engine.WebGLRenderer|PhotoEditorSDK.Engine.CanvasRenderer)}
   */
  autoDetectRenderer: function autoDetectRenderer(width, height) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (_webglRenderer2.default.isSupported()) {
      return new _webglRenderer2.default(width, height, options);
    } else {
      return new _canvasRenderer2.default(width, height, options);
    }
  }
}; /*
    * This file is part of PhotoEditorSDK.
    *
    * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
    * All rights reserved.
    *
    * Redistribution and use in source and binary forms, without
    * modification, are permitted provided that the following license agreement
    * is approved and a legal/financial contract was signed by the user.
    * The license agreement can be found under following link:
    *
    * https://www.photoeditorsdk.com/LICENSE.txt
    */

exports.default = Engine;

/***/ },
/* 13 */
/***/ function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

var store      = __webpack_require__(58)('wks')
  , uid        = __webpack_require__(42)
  , Symbol     = __webpack_require__(15).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ },
/* 15 */
/***/ function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(24);

var _typeof3 = _interopRequireDefault(_typeof2);

var _defineProperty2 = __webpack_require__(86);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _eventEmitter = __webpack_require__(28);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _vector = __webpack_require__(23);

var _vector2 = _interopRequireDefault(_vector);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

var _utils = __webpack_require__(21);

var _utils2 = _interopRequireDefault(_utils);

var _colorMatrix = __webpack_require__(35);

var _colorMatrix2 = _interopRequireDefault(_colorMatrix);

var _constants = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Image = void 0; /* global HTMLImageElement, WEBPACK */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

if (true) {
  Image = window.Image;
}

/**
 * Adds `set{OptionName}` and `get{OptionName}` methods to an object. Method names
 * are specified via the `availableOptions` object.
 * @class
 * @extends EventEmitter
 * @memberof PhotoEditorSDK
 */

var Configurable = function (_EventEmitter) {
  (0, _inherits3.default)(Configurable, _EventEmitter);

  function Configurable() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var additionalAvailableOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, Configurable);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this.availableOptions = _this.availableOptions || {};
    _this.availableOptions = _utils2.default.extend(_this.availableOptions, additionalAvailableOptions);

    _this._onConfigurableUpdate = _this._onConfigurableUpdate.bind(_this);

    _this._initOptions(options);
    return _this;
  }

  /**
   * Builds an error message from the given string
   * @param  {String} message
   * @return {Error}
   * @private
   */


  Configurable.prototype._buildConfigError = function _buildConfigError(message) {
    var errorMessage = '';
    if (this.constructor.name) {
      errorMessage = this.constructor.name + ': ';
    }
    errorMessage += message;
    return new Error(errorMessage);
  };

  /**
   * Gets called when options have been changed
   * @protected
   */


  Configurable.prototype._onOptionsChange = function _onOptionsChange() {};

  /**
   * Checks whether all required options are specified
   * @return {Promise}
   */


  Configurable.prototype.validateSettings = function validateSettings() {
    var _this2 = this;

    return new _promise2.default(function (resolve, reject) {
      // Check for required options
      for (var optionName in _this2.availableOptions) {
        var optionConfig = _this2.availableOptions[optionName];
        if (optionConfig.required && typeof _this2._options[optionName] === 'undefined') {
          return reject(_this2._buildConfigError('Option `' + optionName + '` is required.'));
        }
      }

      resolve();
    });
  };

  /**
   * Goes through the available options, sets _options defaults
   * @param {Object} userOptions
   * @protected
   */


  Configurable.prototype._initOptions = function _initOptions() {
    var userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._options = {};

    // Set defaults, create getters and setters
    var optionName, option, capitalized;
    var self = this;
    for (optionName in this.availableOptions) {
      capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
      option = this.availableOptions[optionName];

      if ([_constants.OptionType.STRING, _constants.OptionType.NUMBER, _constants.OptionType.BOOLEAN, _constants.OptionType.OBJECT, _constants.OptionType.VECTOR2, _constants.OptionType.COLOR, _constants.OptionType.CONFIGURABLE, _constants.OptionType.COLOR_MATRIX, _constants.OptionType.ARRAY, _constants.OptionType.IMAGE, _constants.OptionType.ALL].indexOf(option.type) === -1) {
        throw this._buildConfigError('Unknown option type: `' + option.type + '`');
      }

      // Create setter and getter
      var fn = function fn(optionName, option) {
        self['set' + capitalized] = function (value, update, initial) {
          self.setOption(optionName, value, update, initial);
        };

        // Default getter
        self['get' + capitalized] = function () {
          return self.getOption(optionName);
        };
      };
      fn(optionName, option);

      // Handle configurable initialization
      if (option.type === _constants.OptionType.CONFIGURABLE) {
        this._options[optionName] = new Configurable(undefined, option.structure || {});
        this._options[optionName].on('update', this._onConfigurableUpdate);
      }

      // Set default if available
      if (typeof option.default !== 'undefined' && !(optionName in userOptions)) {
        var defaultValue = option.default;
        if (typeof option.default === 'function') {
          defaultValue = option.default();
        }
        this['set' + capitalized](defaultValue, false, true);
      }
    }

    // Overwrite options with the ones given by user
    for (optionName in userOptions) {
      // Check if option is available
      if (typeof this.availableOptions[optionName] === 'undefined') {
        throw new Error('Invalid option: ' + optionName);
      }

      if (typeof userOptions[optionName] !== 'undefined') {
        // Call setter
        capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
        this['set' + capitalized](userOptions[optionName], false, true);
      }
    }
  };

  /**
   * Sets the given options
   * @param {Object} options
   */


  Configurable.prototype.set = function set(options) {
    var emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (emitUpdate) {
      this.emit('update', this, options);
    }

    for (var optionName in options) {
      this.setOption(optionName, options[optionName], false);
    }
    this._onOptionsChange();
  };

  /**
   * Returns the value for the given option
   * @param {String} optionName
   * @return {*}
   */


  Configurable.prototype.getOption = function getOption(optionName) {
    return this._options[optionName];
  };

  /**
   * Returns the default value for the given option
   * @param  {String} optionName
   * @return {*}
   */


  Configurable.prototype.getOptionDefault = function getOptionDefault(optionName) {
    var option = this.availableOptions[optionName];
    if (!option) {
      throw new Error('Invalid option: ' + optionName);
    }
    return option.default;
  };

  /**
   * Returns the options
   * @return {Object}
   */


  Configurable.prototype.getOptions = function getOptions() {
    return this._options;
  };

  /**
   * Returns a hash with the default options
   * @return {Object}
   */


  Configurable.prototype.getDefaultOptions = function getDefaultOptions() {
    var options = {};
    for (var optionName in this.availableOptions) {
      var defaultValue = this.availableOptions[optionName].default;
      if (typeof defaultValue === 'undefined') continue;

      options[optionName] = defaultValue;
    }
    return options;
  };

  /**
   * Check if the current options equal the given ones
   * @param  {Object} options
   * @return {Boolean}
   */


  Configurable.prototype.optionsEqual = function optionsEqual(options) {
    for (var optionName in options) {
      var value = options[optionName];
      if (!this._optionEquals(optionName, value)) {
        return false;
      }
    }
    return true;
  };

  /**
   * Checks if the given option has the given value
   * @param  {String} optionName
   * @param  {*} value
   * @return {Boolean}
   * @private
   */


  Configurable.prototype._optionEquals = function _optionEquals(optionName, value) {
    var option = this.availableOptions[optionName];
    if (typeof option === 'undefined') {
      throw new Error('Invalid option: ' + optionName);
    }

    var optionType = this.availableOptions[optionName].type;
    var currentValue = this._options[optionName];

    if (currentValue === value) return true;

    switch (optionType) {
      case _constants.OptionType.STRING:
      case _constants.OptionType.NUMBER:
      case _constants.OptionType.BOOLEAN:
      case _constants.OptionType.OBJECT:
      case '*':
        return currentValue === value;
      case _constants.OptionType.VECTOR2:
        return currentValue.equals(value);
      case _constants.OptionType.COLOR:
      case _constants.OptionType.COLOR_MATRIX:
        return value.equals(currentValue);
      case _constants.OptionType.CONFIGURABLE:
        return currentValue.optionsEqual(value);
      case _constants.OptionType.ARRAY:
        return this._arrayOptionEquals(optionName, value);
      case _constants.OptionType.IMAGE:
        return currentValue.src === value.src;
    }
  };

  /**
   * Checks if the given option of type `array` matches the given value
   * @param  {String} optionName
   * @param  {Array} arr
   * @return {Boolean}
   * @private
   */


  Configurable.prototype._arrayOptionEquals = function _arrayOptionEquals(optionName, arr) {
    var thisArr = this._options[optionName];
    var equal = true;
    for (var i = 0; i < thisArr.length; i++) {
      var thisValue = thisArr[i];
      var value = arr[i];
      if (thisValue instanceof Configurable) {
        if (typeof value === 'undefined' || !thisValue.optionsEqual(value)) {
          equal = false;
          break;
        }
      } else if (value !== thisValue) {
        equal = false;
        break;
      }
    }
    return equal;
  };

  /**
   * Returns a serialized version of this configurable
   * @param {Boolean} toObject = false
   * @return {Object}
   */


  Configurable.prototype.serializeOptions = function serializeOptions() {
    var _this3 = this;

    var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(this._options);
    var toObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var options = {};
    keys.forEach(function (key) {
      options[key] = _this3._serializeOption(key, toObject);
    });
    return options;
  };

  /**
   * Returns a serialized version of the given option
   * @param {String} optionName
   * @param {Boolean} toObject = false
   * @return {*} optionName
   * @protected
   */


  Configurable.prototype._serializeOption = function _serializeOption(optionName) {
    var toObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var optionType = this.availableOptions[optionName].type;
    var value = this._options[optionName];
    if (!value) return value;

    switch (optionType) {
      case _constants.OptionType.STRING:
      case _constants.OptionType.NUMBER:
      case _constants.OptionType.BOOLEAN:
      case _constants.OptionType.OBJECT:
      case _constants.OptionType.ALL:
        return value;
      case _constants.OptionType.VECTOR2:
        return toObject ? value.toObject() : value.clone();
      case _constants.OptionType.COLOR:
      case _constants.OptionType.COLOR_MATRIX:
        return toObject ? value.toArray() : value.clone();
      case _constants.OptionType.CONFIGURABLE:
        return value.serializeOptions(undefined, toObject);
      case _constants.OptionType.ARRAY:
        return value.slice(0);
      case _constants.OptionType.IMAGE:
        return value.src;
    }
  };

  /**
   * Sets the value for the given option, validates it
   * @param {String} optionName
   * @param {*} value
   * @param {Boolean} [update = true] - Should an `update` event be emitted?
   * @param {Boolean} [initial = false] - Is this the first time this option is set?
   */


  Configurable.prototype.setOption = function setOption(optionName, value) {
    var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var initial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (update) {
      this.emit('update', this, (0, _defineProperty3.default)({}, optionName, value));
    }

    var optionConfig = this.availableOptions[optionName];
    if (!optionConfig) {
      throw new Error('Invalid option: ' + optionName);
    }

    if (typeof optionConfig.setter !== 'undefined') {
      value = optionConfig.setter.call(this, value, initial);
    }

    if (typeof optionConfig.validation !== 'undefined') {
      optionConfig.validation(value);
    }

    if (value === null) {
      if (optionConfig.required) {
        throw this._buildConfigError('Option `' + optionName + '` is required.');
      }
      this._options[optionName] = value;
    } else {
      switch (optionConfig.type) {
        // String options
        case _constants.OptionType.STRING:
          if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== _constants.OptionType.STRING) {
            throw this._buildConfigError('Option `' + optionName + '` has to be a string.');
          }

          // String value restrictions
          var available = optionConfig.available;
          if (typeof available !== 'undefined' && available.indexOf(value) === -1) {
            throw this._buildConfigError('Invalid value for `' + optionName + '` (valid values are: ' + optionConfig.available.join(', ') + ')');
          }

          this._options[optionName] = value;
          break;

        // Number options
        case _constants.OptionType.NUMBER:
          if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== _constants.OptionType.NUMBER) {
            throw this._buildConfigError('Option `' + optionName + '` has to be a number.');
          }

          this._options[optionName] = value;
          break;

        // Boolean options
        case _constants.OptionType.BOOLEAN:
          if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== _constants.OptionType.BOOLEAN) {
            throw this._buildConfigError('Option `' + optionName + '` has to be a boolean.');
          }

          this._options[optionName] = value;

          break;

        // Vector2 options
        case _constants.OptionType.VECTOR2:
          if (!(value instanceof _vector2.default) && !((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object' && 'x' in value && 'y' in value)) {
            throw this._buildConfigError('Option `' + optionName + '` has to be an instance of Vector2 or an Object holding x and y values.');
          }

          if (value instanceof _vector2.default) {
            this._options[optionName] = value.clone();
          } else {
            this._options[optionName] = _vector2.default.fromObject(value);
          }

          break;

        // Color options
        case _constants.OptionType.COLOR:
          if (!(value instanceof _color2.default)) {
            throw this._buildConfigError('Option `' + optionName + '` has to be an instance of Color.');
          }

          this._options[optionName] = value;
          break;

        // ColorMatrix options
        case _constants.OptionType.COLOR_MATRIX:
          if (!(value instanceof _colorMatrix2.default)) {
            throw this._buildConfigError('Option `' + optionName + '` has to be an instance of ColorMatrix.');
          }

          this._options[optionName] = value.clone();

          break;

        // Object options
        case _constants.OptionType.OBJECT:
        case '*':
          this._options[optionName] = value;
          break;

        case _constants.OptionType.IMAGE:
          if (typeof value === 'string') {
            var image = new Image();
            image.src = value;
            this._options[optionName] = image;
          } else if (value instanceof Image || typeof HTMLImageElement !== 'undefined' && value instanceof HTMLImageElement) {
            this._options[optionName] = value;
          } else {
            throw this._buildConfigError('Option `' + optionName + '` has to be an Image or String.');
          }
          break;

        // Configurable options
        case _constants.OptionType.CONFIGURABLE:
          this._options[optionName].set(value);
          break;

        // Array options
        case _constants.OptionType.ARRAY:
          if (!(value instanceof Array)) {
            throw this._buildConfigError('Option `' + optionName + '` has to be an Array.');
          }
          this._options[optionName] = value.slice(0);
          break;

        // Unknown option type
        default:
          throw this._buildConfigError('Unknown option type: `' + optionConfig.type + '`');
      }
    }

    if (update) {
      this._onOptionsChange();
      this.emit('update', this, (0, _defineProperty3.default)({}, optionName, value));
    }
  };

  /**
   * Gets called when a `configurable` option has been updated
   * @param  {*} ...args
   * @private
   */


  Configurable.prototype._onConfigurableUpdate = function _onConfigurableUpdate() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.emit.apply(this, ['update'].concat(args));
  };

  return Configurable;
}(_eventEmitter2.default);

exports.default = Configurable;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(39)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ },
/* 18 */
/***/ function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(25)
  , IE8_DOM_DEFINE = __webpack_require__(90)
  , toPrimitive    = __webpack_require__(60)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(17) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(206)
  , defined = __webpack_require__(51);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(24);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _base = __webpack_require__(27);

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Provides utility functions for internal use
 * @class
 * @memberof PhotoEditorSDK
 * @private
 */
var Utils = function () {
  function Utils() {
    (0, _classCallCheck3.default)(this, Utils);
  }

  /**
   * Checks if the given object is an Array
   * @param  {Object}  object
   * @return {Boolean}
   */
  Utils.isArray = function isArray(object) {
    return Object.prototype.toString.call(object) === '[object Array]';
  };

  /**
   * Checks whether the user agent represents a mobile device
   * @return {Boolean}
   */


  Utils.isMobile = function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    /* eslint-disable */
    return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))
    );
    /* eslint-enable */
  };

  /**
   * Returns the given object's values as an array
   * @param {Object} object
   * @returns {Array<*>}
   */


  Utils.values = function values(object) {
    var values = [];
    for (var key in object) {
      values.push(object[key]);
    }
    return values;
  };

  /**
   * Checks if the given object is a DOM element
   * @param  {Object}  o
   * @return {Boolean}
   */
  /* istanbul ignore next */


  Utils.isDOMElement = function isDOMElement(o) {
    return (typeof HTMLElement === 'undefined' ? 'undefined' : (0, _typeof3.default)(HTMLElement)) === 'object' ? o instanceof HTMLElement : o && (typeof o === 'undefined' ? 'undefined' : (0, _typeof3.default)(o)) === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string';
  };

  /**
   * Checks if th given event is a touch event
   * @param  {Event}  e
   * @return {Boolean}
   */


  Utils.isTouchEvent = function isTouchEvent(e) {
    return e.type.indexOf('touch') !== -1;
  };

  /**
   * Resizes the given vector to fit inside the given max size while maintaining
   * the aspect ratio
   * @param  {Vector2} vector
   * @param  {Vector2} max
   * @return {Vector2}
   */


  Utils.resizeVectorToFit = function resizeVectorToFit(vector, max) {
    var scale = Math.min(max.x / vector.x, max.y / vector.y);
    var newSize = vector.clone().multiply(scale);
    return newSize;
  };

  /**
   * Checks if this value is extendable / can have keys
   * @param  {*}  val
   * @return {Boolean}
   */


  Utils.isExtendable = function isExtendable(val) {
    return typeof val !== 'undefined' && val !== null && ((typeof val === 'undefined' ? 'undefined' : (0, _typeof3.default)(val)) === 'object' || typeof val === 'function');
  };

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object for all destination properties that resolve to undefined. Once a
   * property is set, additional values of the same property are ignored.
   * @param  {Object} object
   * @param  {Object} ...sources
   * @return {Object}
   */


  Utils.defaults = function defaults(object) {
    // Shallow clone
    var newObject = {};
    for (var key in object) {
      newObject[key] = object[key];
    }

    // Clone sources

    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    for (var i = 0; i < sources.length; i++) {
      var source = sources[i];
      for (var _key2 in source) {
        if (typeof newObject[_key2] === 'undefined') {
          newObject[_key2] = source[_key2];
        }
      }
    }

    return newObject;
  };

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object for all destination properties and their properties that resolve to
   * undefined. Once a property is set, additional value sof the same property
   * are ignored.
   * @param  {Object} object
   * @param  {Object} ...sources
   * @return {Object}
   */


  Utils.deepDefaults = function deepDefaults(object) {
    // Shallow clone
    var newObject = {};
    for (var key in object) {
      newObject[key] = object[key];
    }

    // Clone sources

    for (var _len2 = arguments.length, sources = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
      sources[_key3 - 1] = arguments[_key3];
    }

    for (var i = 0; i < sources.length; i++) {
      var source = sources[i];
      for (var _key4 in source) {
        if (Utils.isExtendable(newObject[_key4]) && Utils.isExtendable(source[_key4])) {
          newObject[_key4] = Utils.deepDefaults(newObject[_key4], source[_key4]);
        } else if (typeof newObject[_key4] === 'undefined') {
          newObject[_key4] = source[_key4];
        }
      }
    }

    return newObject;
  };

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object. Subsequent sources overwrite property assignments of previous
   * sources.
   * @param {Object} object
   * @param {Object} ...sources
   * @return {Object}
   */


  Utils.extend = function extend(object) {
    // Shallow clone
    var newObject = {};
    for (var key in object) {
      newObject[key] = object[key];
    }

    // Extend sources

    for (var _len3 = arguments.length, sources = Array(_len3 > 1 ? _len3 - 1 : 0), _key5 = 1; _key5 < _len3; _key5++) {
      sources[_key5 - 1] = arguments[_key5];
    }

    for (var i = 0; i < sources.length; i++) {
      var source = sources[i];
      for (var _key6 in source) {
        newObject[_key6] = source[_key6];
      }
    }

    return newObject;
  };

  /**
   * Creates a shallow clone of the given object
   * @param {Object} object
   * @returns {Object}
   */


  Utils.clone = function clone(object) {
    return this.extend({}, object);
  };

  /**
   * Creates a Blob URI from the given Data URI
   * @param {String} data
   */


  Utils.createBlobURIFromDataURI = function createBlobURIFromDataURI(data) {
    if (!window.Blob || !window.URL || !ArrayBuffer || !Uint8Array) {
      return data;
    }

    var rawData = _base2.default.decode(data.split(',')[1]);
    var mimeString = data.split(',')[0].split(':')[1].split(';')[0];

    // write the bytes of the string to an ArrayBuffer
    var arrayBuffer = new ArrayBuffer(rawData.length);
    var intArray = new Uint8Array(arrayBuffer);
    for (var i = 0; i < rawData.length; i++) {
      intArray[i] = rawData[i];
    }

    // write the ArrayBuffer to a blob, and you're done
    var blob = new window.Blob([arrayBuffer], {
      type: mimeString
    });
    return window.URL.createObjectURL(blob);
  };

  /**
   * Vendor proxy for requestAnimationFrame
   * @param  {Function} cb
   * @return {Number}
   */


  Utils.requestAnimationFrame = function requestAnimationFrame(cb) {
    var fallback = function fallback(callback) {
      setTimeout(callback, 1000 / 60);
    };

    if (typeof window === 'undefined') {
      return fallback(cb);
    }

    return (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || fallback)(cb);
  };

  /**
   * Generates a UUID
   * @return {String}
   */


  Utils.getUUID = function getUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0;
      var v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  /**
   * Flattens the given multidimensional array
   * @return {Array}
   */


  Utils.flatten = function flatten(array) {
    return array.reduce(function (flat, toFlatten) {
      return flat.concat(Array.isArray(toFlatten) ? Utils.flatten(toFlatten) : toFlatten);
    }, []);
  };

  /**
   * Creates a canvas DOM element (browser) or a node-canvas canvas (node)
   * @return {Canvas}
   */


  Utils.createCanvas = function createCanvas() {
    return document.createElement('canvas');
  };

  /**
   * Checks if the given dimensions are POT
   * @param  {PhotoEditorSDK.Math.Vector2}  dimensions
   * @return {Boolean}
   */


  Utils.isPowerOfTwo = function isPowerOfTwo(dimensions) {
    return (dimensions.x & dimensions.x - 1) === 0 && (dimensions.y & dimensions.y - 1) === 0;
  };

  /**
   * Returns the next lowest power of two of the given number
   * @param  {Number} x
   * @return {Number}
   */


  Utils.nextLowestPOT = function nextLowestPOT(x) {
    for (var i = 1; i < 32; i <<= 1) {
      x = x | x >> i;
    }
    return x - (x >> 1);
  };

  /**
   * Returns the next highest power of two of the given number
   * @param  {Number} x
   * @return {Number}
   */


  Utils.nextHighestPOT = function nextHighestPOT(x) {
    x--;
    for (var i = 1; i < 32; i <<= 1) {
      x = x | x >> i;
    }
    return x + 1;
  };

  /**
   * Moves the array item at `oldIndex` to `newIndex`
   * @param  {Array} arr
   * @param  {Number} oldIndex
   * @param  {Number} newIndex
   */


  Utils.moveArrayItem = function moveArrayItem(arr, oldIndex, newIndex) {
    if (newIndex >= arr.length) {
      var k = newIndex - arr.length;
      while (k-- + 1) {
        arr.push(undefined);
      }
    }
    arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
  };

  /**
   * Makes sure the given canvas has the given dimensions. If not, it does not change the
   * canvas dimensions.
   * @param  {Canvas} canvas
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   */


  Utils.ensureCanvasDimensions = function ensureCanvasDimensions(canvas, dimensions) {
    if (canvas.width !== dimensions.x || canvas.height !== dimensions.y) {
      canvas.width = dimensions.x;
      canvas.height = dimensions.y;
    }
  };

  /**
   * Converts the given array of bytes to a string
   * @param  {Number[]} byteArray
   * @return {String}
   */


  Utils.byteArrayToString = function byteArrayToString(byteArray) {
    return byteArray.map(function (byte) {
      return String.fromCharCode(byte);
    }).join('');
  };

  return Utils;
}(); /* global HTMLElement, WEBPACK */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.default = Utils;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var maxLogLevel = 'warn';

var LEVELS = [{ type: 'trace', background: '#EEEEEE', color: '#AAAAAA' }, { type: 'info', background: '#BDE5F8', color: '#00529B' }, { type: 'warn', background: '#FEEFB3', color: '#9F6000' }, { type: 'error', background: '#FFBABA', color: '#D8000C' }, { type: 'log', background: '#EEEEEE', color: '#1f4f6b' }];
var LEVEL_TYPES = LEVELS.map(function (l) {
  return l.type;
});

var Log = {};

Log.setLevel = function (_level) {
  maxLogLevel = _level;
};
Log.canLog = function (type) {
  if (maxLogLevel === null) return false;
  var currentLevelIndex = LEVEL_TYPES.indexOf(type);
  var maxLevelIndex = LEVEL_TYPES.indexOf(maxLogLevel);
  if (currentLevelIndex < maxLevelIndex) return false;
  return true;
};
Log.hasColorfulOutput = function () {
  return (!process || process && process.browser) && typeof navigator !== 'undefined' && navigator.userAgent.match(/Gecko|WebKit/i) && !navigator.userAgent.match(/Trident/);
};

Log.printError = function (e) {
  var lines = e.stack.split('\n');
  lines.forEach(function (line) {
    Log.error('Error', line);
  });
};

LEVELS.forEach(function (level) {
  var type = level.type,
      background = level.background,
      color = level.color;

  Log[type] = function (tag) {
    if (!Log.canLog(type)) return;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var output = args.map(function (a) {
      return typeof a === 'string' ? a : a.toString();
    }).join(' ');
    if (!Log.hasColorfulOutput()) {
      return console.log('PhotoEditorSDK | ' + tag + ' | ' + output);
    }
    console.log('%c  %c PhotoEditorSDK %c  %c ' + tag + ' %c  ' + output + '  %c  ', 'background: #43ADEB; line-height: 20px; padding: 4px 0', 'background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0', 'background: #43ADEB; line-height: 20px; padding: 4px 0', 'background: ' + background + '; color: ' + color + '; line-height: 20px; padding: 4px 0; font-weight: bold', 'background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0', 'background: #43ADEB; line-height: 20px; padding: 4px 0');
  };
});

exports.default = Log;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(65)))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(38);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * Represents a 2-dimensional vector while providing math functions to
 * modify / clone the vector. Fully chainable.
 * @class
 * @memberof PhotoEditorSDK.Math
 */
var Vector2 = function () {
  /**
   * Creates a Vector2
   * @param  {Number} x
   * @param  {Number} y
   */
  function Vector2(x, y) {
    (0, _classCallCheck3.default)(this, Vector2);

    this.x = x;
    this.y = y;
    if (typeof this.x === 'undefined') {
      this.x = 0;
    }
    if (typeof this.y === 'undefined') {
      this.y = 0;
    }
  }

  /**
   * Sets the given values
   * @param {Number} x
   * @param {Number} y
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.set = function set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  };

  /**
   * Creates a clone of this vector
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.clone = function clone() {
    return new Vector2(this.x, this.y);
  };

  /**
   * Copies the values of the given vector
   * @param  {PhotoEditorSDK.Math.Vector2} other
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.copy = function copy(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  };

  /**
   * Clamps this vector with the given Vector2 / Number
   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} minimum
   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} maximum
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.clamp = function clamp(minimum, maximum) {
    var minimumSet = minimum !== null && typeof minimum !== 'undefined';
    var maximumSet = maximum !== null && typeof maximum !== 'undefined';

    /* istanbul ignore else  */
    if (!(minimum instanceof Vector2) && minimumSet) {
      minimum = new Vector2(minimum, minimum);
    }
    /* istanbul ignore else  */
    if (!(maximum instanceof Vector2) && maximumSet) {
      maximum = new Vector2(maximum, maximum);
    }

    if (minimumSet) {
      this.x = Math.max(minimum.x, this.x);
      this.y = Math.max(minimum.y, this.y);
    }

    if (maximumSet) {
      this.x = Math.min(maximum.x, this.x);
      this.y = Math.min(maximum.y, this.y);
    }
    return this;
  };

  /**
   * Divides this vector by the given Vector2 / Number
   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} divisor
   * @param  {Number} [y]
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.divide = function divide(divisor, y) {
    if (divisor instanceof Vector2) {
      this.x /= divisor.x;
      this.y /= divisor.y;
    } else {
      this.x /= divisor;
      this.y /= typeof y === 'undefined' ? divisor : y;
    }
    return this;
  };

  /**
   * Subtracts the given Vector2 / Number from this vector
   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} subtrahend
   * @param  {Number} [y]
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.subtract = function subtract(subtrahend, y) {
    if (subtrahend instanceof Vector2) {
      this.x -= subtrahend.x;
      this.y -= subtrahend.y;
    } else {
      this.x -= subtrahend;
      this.y -= typeof y === 'undefined' ? subtrahend : y;
    }
    return this;
  };

  /**
   * Multiplies the given Vector2 / Number with this vector
   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} subtrahend
   * @param  {Number} [y]
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.multiply = function multiply(factor, y) {
    if (factor instanceof Vector2) {
      this.x *= factor.x;
      this.y *= factor.y;
    } else {
      this.x *= factor;
      this.y *= typeof y === 'undefined' ? factor : y;
    }
    return this;
  };

  /**
   * Adds the given Vector2 / Numbers to this vector
   * @param {(Number|PhotoEditorSDK.Math.Vector2)} addend
   * @param {Number} [y]
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.add = function add(addend, y) {
    if (addend instanceof Vector2) {
      this.x += addend.x;
      this.y += addend.y;
    } else {
      this.x += addend;
      this.y += typeof y === 'undefined' ? addend : y;
    }
    return this;
  };

  /**
   * Checks whether the x and y value are the same as the given ones
   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} vec
   * @param  {Number} y
   * @return {Boolean}
   */


  Vector2.prototype.equals = function equals(vec, y) {
    if (vec instanceof Vector2) {
      return vec.x === this.x && vec.y === this.y;
    } else {
      return vec === this.x && y === this.y;
    }
  };

  /**
   * Flips the x and y values of this vector
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.flip = function flip() {
    var tempX = this.x;
    this.x = this.y;
    this.y = tempX;
    return this;
  };

  /**
   * Rounds the values of this vector
   * @returns {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.round = function round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  };

  /**
   * Rounds up the values of this vector
   * @returns {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.ceil = function ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  };

  /**
   * Rounds down the values of this vector
   * @returns {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.floor = function floor() {
    this.x = this.x | 0;
    this.y = this.y | 0;
    return this;
  };

  /**
   * Makes both numbers of this vector positive
   * @returns {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.prototype.abs = function abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    return this;
  };

  /**
   * Returns the euclidean length of this vector
   * @return {Number}
   */


  Vector2.prototype.len = function len() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };

  /**
   * Returns the smallest number in this vector
   * @return {Number}
   */


  Vector2.prototype.min = function min() {
    return Math.min(this.x, this.y);
  };

  /**
   * Returns the largest number in this vector
   * @return {Number}
   */


  Vector2.prototype.max = function max() {
    return Math.max(this.x, this.y);
  };

  /**
   * Returns a POJO of this Vector2
   * @return {Object}
   */


  Vector2.prototype.toObject = function toObject() {
    return { x: this.x, y: this.y };
  };

  /**
   * Returns a string representation of this vector
   * @return {String}
   */


  Vector2.prototype.toString = function toString() {
    return 'Vector2({ x: ' + this.x + ', y: ' + this.y + ' })';
  };

  /**
   * Rounds this vector's values to the given number of decimals
   * @param  {Number} decimals
   * @return {Number}
   */


  Vector2.prototype.roundDecimal = function roundDecimal(decimals) {
    this.x = parseFloat(this.x.toFixed(decimals));
    this.y = parseFloat(this.y.toFixed(decimals));
    return this;
  };

  /**
   * Creates a new Vector2 instance from the given Object
   * @param  {Object} object
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Vector2.fromObject = function fromObject(object) {
    return new Vector2(object.x, object.y);
  };

  /**
   * Returns a null vector
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  (0, _createClass3.default)(Vector2, null, [{
    key: 'NULL',
    get: function get() {
      return new Vector2(0, 0);
    }
  }]);
  return Vector2;
}();

exports.default = Vector2;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _iterator = __webpack_require__(192);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(191);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(31);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(19)
  , createDesc = __webpack_require__(41);
module.exports = __webpack_require__(17) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ },
/* 27 */
/***/ function(module, exports) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Extracted from MinifyJpeg (Copyright (c) 2014 Hiroaki Matoba, MIT License):
 * https://github.com/hMatoba/MinifyJpeg
 * @license
 */

var KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

/**
 * Provides Base64 encode and decode methods
 * @type {Object}
 * @ignore
 */
/* istanbul ignore next */
var Base64 = {
  /**
   * Encodes the given input into a Base64 string
   * @param  {String} input
   * @return {String}
   */
  encode: function encode(input) {
    var output = '';
    var chr1 = void 0,
        chr2 = void 0,
        chr3 = void 0;
    var enc1 = void 0,
        enc2 = void 0,
        enc3 = void 0,
        enc4 = void 0;
    var i = 0;

    do {
      chr1 = input[i++];
      chr2 = input[i++];
      chr3 = input[i++];

      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;

      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }

      output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
      chr1 = chr2 = chr3 = '';
      enc1 = enc2 = enc3 = enc4 = '';
    } while (i < input.length);

    return output;
  },


  /**
   * Decodes the given Base64 string
   * @param  {String} input
   * @return {String}
   */
  decode: function decode(input) {
    var chr1 = void 0,
        chr2 = void 0,
        chr3 = void 0;
    var enc1 = void 0,
        enc2 = void 0,
        enc3 = void 0,
        enc4 = void 0;
    var i = 0;
    var buf = [];

    // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
    var base64test = /[^A-Za-z0-9+/=]/g;
    if (base64test.exec(input)) {
      throw new Error('There were invalid base64 characters in the input text.\n' + 'Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\n' + 'Expect errors in decoding.');
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, '');

    do {
      enc1 = KEY_STR.indexOf(input.charAt(i++));
      enc2 = KEY_STR.indexOf(input.charAt(i++));
      enc3 = KEY_STR.indexOf(input.charAt(i++));
      enc4 = KEY_STR.indexOf(input.charAt(i++));

      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;

      buf.push(chr1);

      if (enc3 !== 64) {
        buf.push(chr2);
      }
      if (enc4 !== 64) {
        buf.push(chr3);
      }

      chr1 = chr2 = chr3 = '';
      enc1 = enc2 = enc3 = enc4 = '';
    } while (i < input.length);

    return buf;
  }
};

exports.default = Base64;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _log = __webpack_require__(22);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_MAX_LISTENERS = 12;

/**
 * Receives and emits events
 * @class
 * @memberof PhotoEditorSDK
 * @ignore
 */
/**
 * EventEmitter (ES6) from:
 * https://gist.github.com/bloodyowl/41b1de3388c626796eca
 */

var EventEmitter = function () {
  /**
   * Creates an EventEmitter
   */
  function EventEmitter() {
    (0, _classCallCheck3.default)(this, EventEmitter);

    this._maxListeners = DEFAULT_MAX_LISTENERS;
    this._events = {};
    this._pipeDestinations = [];
  }

  /**
   * Pipes all events to the given EventEmitter
   * @param  {EventEmitter} destination
   */


  EventEmitter.prototype.pipeEvents = function pipeEvents(destination) {
    this._pipeDestinations.push(destination);
  };

  /**
   * Stops piping events to the given EventEmitter
   * @param  {EventEmitter} destination
   */


  EventEmitter.prototype.unpipeEvents = function unpipeEvents(destination) {
    var i = this._pipeDestinations.indexOf(destination);
    if (i === -1) {
      return;
    }
    this._pipeDestinations.splice(i, 1);
  };

  /**
   * Adds the given listener to the given type of events
   * @param  {String} type
   * @param  {Function} listener
   */


  EventEmitter.prototype.on = function on(type, listener) {
    if (typeof listener !== 'function') {
      throw new TypeError();
    }

    var listeners = this._events[type] || (this._events[type] = []);
    if (listeners.indexOf(listener) !== -1) {
      return this;
    }
    listeners.push(listener);

    if (this._maxListeners && listeners.length > this._maxListeners) {
      _log2.default.warn('EventEmitter', 'Possible memory leak detected, added ' + listeners.length + ' `' + type + '` listeners (current limit is ' + this._maxListeners + ')');
      console.trace();
    }
    return this;
  };

  /**
   * Adds the given listener to the given type of events and removes it
   * once it has been triggered
   * @param  {String} type
   * @param  {Function} listener
   */


  EventEmitter.prototype.once = function once(type, listener) {
    var eventsInstance = this;
    function onceCallback() {
      eventsInstance.off(type, onceCallback);
      listener.apply(null, arguments);
    }
    return this.on(type, onceCallback);
  };

  /**
   * Removes the given listener from the given type of events
   * @param  {String} type
   * @param  {*} ...args
   */


  EventEmitter.prototype.off = function off(type) {
    if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {
      this._events[type] = null;
      return this;
    }

    var listener = arguments.length <= 1 ? undefined : arguments[1];
    if (typeof listener !== 'function') {
      throw new TypeError();
    }

    var listeners = this._events[type];
    if (!listeners || !listeners.length) {
      return this;
    }

    var indexOfListener = listeners.indexOf(listener);
    if (indexOfListener === -1) {
      return this;
    }

    listeners.splice(indexOfListener, 1);
    return this;
  };

  /**
   * Emits an event with the given type and arguments
   * @param  {String} type
   * @param  {*} ...args
   */


  EventEmitter.prototype.emit = function emit(type) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    this._pipeDestinations.forEach(function (dest) {
      dest.emit.apply(dest, [type].concat(args));
    });

    var listeners = this._events[type];
    if (!listeners || !listeners.length) {
      return false;
    }

    listeners.forEach(function (fn) {
      return fn.apply(null, args);
    });

    return true;
  };

  /**
   * Sets the maximum amonut of listeners before a warning is printed
   * @param {Number} newMaxListeners
   */


  EventEmitter.prototype.setMaxListeners = function setMaxListeners(newMaxListeners) {
    if (parseInt(newMaxListeners, 10) !== newMaxListeners) {
      throw new TypeError();
    }

    this._maxListeners = newMaxListeners;
  };

  return EventEmitter;
}();

exports.default = EventEmitter;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A BaseTexture holds and handles the raw source of a texture
 * @class
 * @extends EventEmitter
 * @memberof PhotoEditorSDK.Engine
 */
var BaseTexture = function (_EventEmitter) {
  (0, _inherits3.default)(BaseTexture, _EventEmitter);

  /**
   * Creates a BaseTexture
   * @param  {*} source
   */
  function BaseTexture(source) {
    (0, _classCallCheck3.default)(this, BaseTexture);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this.id = BaseTexture.id++;
    _this._onSourceLoaded = _this._onSourceLoaded.bind(_this);

    _this._renderers = [];
    _this._glTextures = {};
    _this._source = source;
    _this._dirty = true;

    _this._glUnit = 0;
    _this._mipMapping = false;
    _this._magFilter = BaseTexture.DefaultMagFilter;
    _this._minFilter = BaseTexture.DefaultMinFilter;
    _this._repeatX = BaseTexture.ClampToEdge;
    _this._repeatY = BaseTexture.ClampToEdge;

    _this._pixelRatio = 1;
    _this._loaded = false;
    _this._frame = new _globals.Rectangle(0, 0, 100, 100);

    if (source) {
      _this._loadSource();
    }
    return _this;
  }

  /**
   * Resizes this BaseTexture to the given dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   */


  BaseTexture.prototype.resizeTo = function resizeTo(dimensions) {
    if (this._frame.width === dimensions.x && this._frame.height === dimensions.y) {
      return;
    }

    this._frame.width = dimensions.x;
    this._frame.height = dimensions.y;
    this._dirty = true;
  };

  /**
   * Loads the source
   * @private
   */


  BaseTexture.prototype._loadSource = function _loadSource() {
    var source = this._source;

    var sourceLoaded = source.complete;
    var sourceIsCanvas = source.constructor.name === 'Canvas' || source.tagName && source.tagName.toUpperCase() === 'CANVAS';
    if (sourceLoaded || sourceIsCanvas) {
      return this._onSourceLoaded();
    }

    source.addEventListener('load', this._onSourceLoaded);
  };

  /**
   * Gets called when the source of this BaseTexture has been loaded
   * @private
   */


  BaseTexture.prototype._onSourceLoaded = function _onSourceLoaded() {
    this._loaded = true;
    this._updateGLFilters();
    this.emit('loaded');
    this.update();
  };

  /**
   * If mip-mapping is available, update GL filters accordingly
   * @private
   */
  /* istanbul ignore next */


  BaseTexture.prototype._updateGLFilters = function _updateGLFilters() {
    var sourceDimensions = new _globals.Vector2(this._source.width, this._source.height);
    if (_globals.Utils.isPowerOfTwo(sourceDimensions)) {
      _globals.Log.info(this.constructor.name, 'Mip-mapping enabled');
      this._minFilter = BaseTexture.TrilinearFilter;
      this._mipMapping = true;
    }
  };

  /**
   * Updates the cached dimensions of this BaseTexture's source
   */


  BaseTexture.prototype.update = function update() {
    this._frame = new _globals.Rectangle(0, 0, this._source.width, this._source.height);
    this.emit('update');
  };

  /**
   * Returns the filter for the given direction from the given WebGL context
   * @param  {WebGLRenderingContext} gl
   * @param  {String} minOrMag
   * @return {Number}
   */
  /* istanbul ignore next */


  BaseTexture.prototype.getGLFilter = function getGLFilter(gl, minOrMag) {
    switch (minOrMag) {
      case 'min':
        return this.constructor.getGLFilter(gl, this._minFilter);
      case 'mag':
        return this.constructor.getGLFilter(gl, this._magFilter);
    }
  };

  /**
   * Returns the filter for the given enum value from the given WebGL context
   * @param  {WebGLRenderingContext} gl
   * @param  {Number} filterEnum
   * @return {Number}
   */
  /* istanbul ignore next */


  BaseTexture.getGLFilter = function getGLFilter(gl, filterEnum) {
    switch (filterEnum) {
      case BaseTexture.LinearFilter:
        return gl.LINEAR;
      case BaseTexture.NearestFilter:
        return gl.NEAREST;
      case BaseTexture.BilinearFilter:
        return gl.LINEAR_MIPMAP_NEAREST;
      case BaseTexture.TrilinearFilter:
        return gl.LINEAR_MIPMAP_LINEAR;
    }
  };

  /**
   * Checks if this BaseTexture has been loaded
   * @return {Boolean}
   */


  BaseTexture.prototype.isLoaded = function isLoaded() {
    return this._loaded;
  };

  /**
   * Sets the loaded state
   * @param {Boolean} loaded
   */


  BaseTexture.prototype.setLoaded = function setLoaded(loaded) {
    this._loaded = loaded;
  };

  /**
   * Returns the source
   * @return {*} s
   */


  BaseTexture.prototype.getSource = function getSource() {
    return this._source;
  };

  /**
   * Sets the source
   * @param {*} source
   */


  BaseTexture.prototype.setSource = function setSource(source) {
    this._source = source;
  };

  /**
   * Returns the WebGL texture for the given renderer ID
   * @param  {PhotoEditorSDK.Engine.Renderer} renderer
   * @return {WebGLTexture}
   */
  /* istanbul ignore next */


  BaseTexture.prototype.getGLTextureForRenderer = function getGLTextureForRenderer(renderer) {
    return this._glTextures[renderer.id];
  };

  /**
   * Sets the WebGLTexture for the given renderer ID
   * @param {WebGLTexture} texture
   * @param {PhotoEditorSDK.Engine.WebGLRenderer} renderer
   */
  /* istanbul ignore next */


  BaseTexture.prototype.setGLTextureForRenderer = function setGLTextureForRenderer(texture, renderer) {
    this._renderers[renderer.id] = renderer;
    this._glTextures[renderer.id] = texture;
  };

  /**
   * Returns the frame
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  BaseTexture.prototype.getFrame = function getFrame() {
    return this._frame;
  };

  /**
   * Sets the frame
   * @param {PhotoEditorSDK.Math.Rectangle} frame
   */


  BaseTexture.prototype.setFrame = function setFrame(frame) {
    this._frame = frame;
  };

  /**
   * Returns the dimensions
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  BaseTexture.prototype.getDimensions = function getDimensions() {
    return new _globals.Vector2(this._frame.width, this._frame.height);
  };

  /**
   * Returns the pixel ratio
   * @return {Number}
   */


  BaseTexture.prototype.getPixelRatio = function getPixelRatio() {
    return this._pixelRatio;
  };

  /**
   * Sets the pixel ratio
   * @param {Number} pixelRatio
   */


  BaseTexture.prototype.setPixelRatio = function setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
  };

  /**
   * Returns the WebGL texture unit
   * @return {Number}
   */
  /* istanbul ignore next */


  BaseTexture.prototype.getGLUnit = function getGLUnit() {
    return this._glUnit;
  };

  /**
   * Sets the WebGL texture unit
   * @param {Number} glUnit
   */
  /* istanbul ignore next */


  BaseTexture.prototype.setGLUnit = function setGLUnit(glUnit) {
    this._glUnit = glUnit;
  };

  /**
   * Sets the min filter to the given one
   * @param {Number} minFilter
   */
  /* istanbul ignore next */


  BaseTexture.prototype.setMinFilter = function setMinFilter(minFilter) {
    this._minFilter = minFilter;
  };

  /**
   * Returns this texture's min filter
   * @return {Number}
   */
  /* istanbul ignore next */


  BaseTexture.prototype.getMinFilter = function getMinFilter() {
    return this._minFilter;
  };

  /**
   * Sets the mag filter to the given one
   * @param {Number} magFilter
   */
  /* istanbul ignore next */


  BaseTexture.prototype.setMagFilter = function setMagFilter(magFilter) {
    this._magFilter = magFilter;
  };

  /**
   * Returns this texture's mag filter
   * @return {Number}
   */
  /* istanbul ignore next */


  BaseTexture.prototype.getMagFilter = function getMagFilter() {
    return this._magFilter;
  };

  /**
   * Sets the way the texture is repeated on the X axis
   * @param {Number} repeat
   */


  BaseTexture.prototype.setRepeatX = function setRepeatX(repeat) {
    this._repeatX = repeat;
  };

  /**
   * Returns the way the texture is repeated on the X axis
   * @return {Number}
   */


  BaseTexture.prototype.getRepeatX = function getRepeatX() {
    return this._repeatX;
  };

  /**
   * Sets the way the texture is repeated on the Y axis
   * @param {Number} repeat
   */


  BaseTexture.prototype.setRepeatY = function setRepeatY(repeat) {
    this._repeatY = repeat;
  };

  /**
   * Returns the way the texture is repeated on the Y axis
   * @return {Number}
   */


  BaseTexture.prototype.getRepeatY = function getRepeatY() {
    return this._repeatY;
  };

  /**
   * Returns the correct ENUM value for the given repeat direction
   * @param  {WebGLRenderingContext} gl
   * @param  {String} direction
   * @return {Number}
   */


  BaseTexture.prototype.getGLRepeat = function getGLRepeat(gl, direction) {
    var value = direction === 'x' ? this.getRepeatX() : this.getRepeatY();
    switch (value) {
      case BaseTexture.ClampToEdge:
        return gl.CLAMP_TO_EDGE;
      case BaseTexture.Repeat:
        return gl.REPEAT;
      case BaseTexture.MirroredRepeat:
        return gl.MIRRORED_REPEAT;
    }
  };

  /**
   * Checks if this base texture needs to be updated
   * @return {Boolean}
   */
  /* istanbul ignore next */


  BaseTexture.prototype.isDirty = function isDirty() {
    return this._dirty;
  };

  /**
   * Sets the dirtiness of this base texture
   * @param {Boolean} dirty
   */
  /* istanbul ignore next */


  BaseTexture.prototype.setDirty = function setDirty(dirty) {
    this._dirty = dirty;
  };

  /**
   * Disposes the WebGL textures for all renderers
   */
  /* istanbul ignore next */


  BaseTexture.prototype.disposeGLTextures = function disposeGLTextures() {
    for (var rendererId in this._renderers) {
      this.disposeGLTexturesForRenderer(this._renderers[rendererId]);
    }
  };

  /**
   * Disposes the WebGL textures for the given renderer
   * @param {PhotoEditorSDK.Engine.WebGLRenderer} renderer
   */
  /* istanbul ignore next */


  BaseTexture.prototype.disposeGLTexturesForRenderer = function disposeGLTexturesForRenderer(renderer) {
    if (!this._glTextures[renderer.id]) return;

    var gl = renderer.getContext();
    gl.deleteTexture(this._glTextures[renderer.id]);
    delete this._glTextures[renderer.id];

    if (!this._renderers[renderer.id]) {
      delete this._renderers[renderer.id];
    }
  };

  /**
   * Checks if mip-mapping is enabled for this texture
   * @return {Boolean}
   */


  BaseTexture.prototype.isMipMappingEnabled = function isMipMappingEnabled() {
    return this._mipMapping;
  };

  /**
   * Sets the state for mip mapping
   * @param {Boolean} enabled
   */


  BaseTexture.prototype.setMipMappingEnabled = function setMipMappingEnabled(enabled) {
    this._mipMapping = enabled;
  };

  /**
   * Cleans up this object
   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
   */


  BaseTexture.prototype.dispose = function dispose() {
    var renderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    this.disposeGLTextures();
  };

  return BaseTexture;
}(_globals.EventEmitter); /*
                           * This file is part of PhotoEditorSDK.
                           *
                           * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                           * All rights reserved.
                           *
                           * Redistribution and use in source and binary forms, without
                           * modification, are permitted provided that the following license agreement
                           * is approved and a legal/financial contract was signed by the user.
                           * The license agreement can be found under following link:
                           *
                           * https://www.photoeditorsdk.com/LICENSE.txt
                           */

BaseTexture.NearestFilter = 0;
BaseTexture.LinearFilter = 1;
BaseTexture.BilinearFilter = 2;
BaseTexture.TrilinearFilter = 3;

BaseTexture.DefaultMagFilter = BaseTexture.NearestFilter;
BaseTexture.DefaultMinFilter = BaseTexture.LinearFilter;

BaseTexture.ClampToEdge = 0;
BaseTexture.Repeat = 1;
BaseTexture.MirroredRepeat = 2;

BaseTexture.id = 0;

exports.default = BaseTexture;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

var global    = __webpack_require__(15)
  , core      = __webpack_require__(13)
  , ctx       = __webpack_require__(88)
  , hide      = __webpack_require__(26)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ },
/* 31 */
/***/ function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ },
/* 32 */
/***/ function(module, exports) {

module.exports = {};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(6);

var _baseTexture = __webpack_require__(29);

var _baseTexture2 = _interopRequireDefault(_baseTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A canvas render target that you can render to.
 * Canvas equivalent of {@link PhotoEditorSDK.Engine.WebGLRenderTarget}
 * @class
 * @memberof PhotoEditorSDK.Engine
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CanvasRenderTarget = function () {
  /**
   * Creates a CanvasRenderTarget
   * @param  {Number} width
   * @param  {Number} height
   * @param  {Number} pixelRatio
   * @param  {HTMLCanvasElement} canvas
   * @param  {CanvasRenderingContext2D} context
   */
  function CanvasRenderTarget(width, height, pixelRatio, canvas, context) {
    (0, _classCallCheck3.default)(this, CanvasRenderTarget);

    this._width = width;
    this._height = height;
    this._pixelRatio = pixelRatio;

    this._baseTexture = new _baseTexture2.default();
    this._canvas = canvas || this._createCanvas();
    this._context = context || this._canvas.getContext('2d');
    this._baseTexture.setSource(this._canvas);

    this._canvas.width = this._width * this._pixelRatio;
    this._canvas.height = this._height * this._pixelRatio;
    this._filterStack = [{
      renderTarget: this,
      filter: []
    }];
  }

  /**
   * Creates a canvas
   * @return {Canvas}
   * @private
   */


  CanvasRenderTarget.prototype._createCanvas = function _createCanvas() {
    return _globals.Utils.createCanvas();
  };

  /**
   * Clears this CanvasRenderTarget
   */


  CanvasRenderTarget.prototype.clear = function clear() {
    var ctx = this._context;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
  };

  /**
   * Resizes this canvas buffer to the given dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   */


  CanvasRenderTarget.prototype.resizeTo = function resizeTo(dimensions) {
    this._baseTexture.resizeTo(dimensions);

    if (this._width !== dimensions.x) {
      this._width = dimensions.x;
      this._canvas.width = this._width * this._pixelRatio;
    }

    if (this._height !== dimensions.y) {
      this._height = dimensions.y;
      this._canvas.height = this._height * this._pixelRatio;
    }
  };

  /**
   * Returns the canvas
   * @return {HTMLCanvasElement}
   */


  CanvasRenderTarget.prototype.getCanvas = function getCanvas() {
    return this._canvas;
  };

  /**
   * Returns the rendering context
   * @return {CanvasRenderingContext2D} [description]
   */


  CanvasRenderTarget.prototype.getContext = function getContext() {
    return this._context;
  };

  /**
   * Returns the filter stack
   * @return {Object[]}
   */


  CanvasRenderTarget.prototype.getFilterStack = function getFilterStack() {
    return this._filterStack;
  };

  /**
   * Returns the width
   * @return {Number}
   */


  CanvasRenderTarget.prototype.getWidth = function getWidth() {
    return this._width;
  };

  /**
   * Returns the height
   * @return {Number}
   */


  CanvasRenderTarget.prototype.getHeight = function getHeight() {
    return this._height;
  };

  /**
   * Returns the pixel ratio
   * @return {Number}
   */


  CanvasRenderTarget.prototype.getPixelRatio = function getPixelRatio() {
    return this._pixelRatio;
  };

  /**
   * Sets the pixel ratio
   * @param {Number} pixelRatio
   */


  CanvasRenderTarget.prototype.setPixelRatio = function setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
  };

  /**
   * Returns the dimensions
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  CanvasRenderTarget.prototype.getDimensions = function getDimensions() {
    return new _globals.Vector2(this._width, this._height);
  };

  /**
   * Returns the base texture
   * @return {PhotoEditorSDK.Engine.BaseTexture}
   */


  CanvasRenderTarget.prototype.getBaseTexture = function getBaseTexture() {
    return this._baseTexture;
  };

  /**
   * Cleans up this canvas buffer
   */


  CanvasRenderTarget.prototype.dispose = function dispose() {
    this._canvas = null;
    this._context = null;
  };

  return CanvasRenderTarget;
}();

exports.default = CanvasRenderTarget;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(6);

var _baseTexture = __webpack_require__(29);

var _baseTexture2 = _interopRequireDefault(_baseTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An object that you can render to. WebGL equivalent of {@link PhotoEditorSDK.Engine.CanvasRenderTarget}
 * @class
 * @memberof PhotoEditorSDK.Engine
 */
/* istanbul ignore next */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var WebGLRenderTarget = function () {
  /**
   * Creates a WebGLRenderTarget
   * @param  {PhotoEditorSDK.Engine.BaseRenderer}  renderer
   * @param  {Number}  width
   * @param  {Number}  height
   * @param  {Number}  pixelRatio
   * @param  {Boolean} [isRoot = false]
   */
  function WebGLRenderTarget(renderer, width, height, pixelRatio) {
    var isRoot = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    (0, _classCallCheck3.default)(this, WebGLRenderTarget);

    this._renderer = renderer;
    this._gl = renderer.getContext();
    this._width = width;
    this._height = height;
    this._frame = null;
    this._pixelRatio = pixelRatio;
    this._projectionMatrix = new _globals.Matrix();
    this._mipMapping = false;

    this._baseTexture = new _baseTexture2.default();
    var frame = this._baseTexture.getFrame();
    frame.width = width;
    frame.height = height;
    this._baseTexture.setPixelRatio(pixelRatio);
    this._baseTexture.setLoaded(true);

    // `null` means render to canvas directly
    this._framebuffer = null;
    this._isRoot = isRoot;
    this._filterStack = [{
      renderTarget: this,
      filter: []
    }];

    if (!isRoot) {
      this._initFrameBuffer();
    }
  }

  /**
   * Resizes this WebGLRenderTarget to the given dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   */


  WebGLRenderTarget.prototype.resizeTo = function resizeTo(dimensions) {
    this._width = dimensions.x | 0; // rounded
    this._height = dimensions.y | 0; // rounded

    this._baseTexture.resizeTo(dimensions);

    if (!this._isRoot) {
      this._resizeTexture();
    }

    this._baseTexture.setMinFilter(this._getMinFilter());
    this._baseTexture.setMagFilter(this._getMagFilter());

    this._calculateProjectionMatrix();
  };

  /**
   * Returns the downsampling filter
   * @return {Number}
   * @private
   */


  WebGLRenderTarget.prototype._getMinFilter = function _getMinFilter() {
    var minFilter = _baseTexture2.default.DefaultMinFilter;
    if (this._mipMapping) {
      minFilter = _baseTexture2.default.TrilinearFilter;
    }
    return minFilter;
  };

  /**
   * Returns the upsampling filter
   * @return {Number}
   * @private
   */


  WebGLRenderTarget.prototype._getMagFilter = function _getMagFilter() {
    return _baseTexture2.default.DefaultMagFilter;
  };

  /**
   * Resizes the FBO's texture to the current dimensions
   * @private
   */


  WebGLRenderTarget.prototype._resizeTexture = function _resizeTexture() {
    var gl = this._gl;
    gl.bindTexture(gl.TEXTURE_2D, this._texture);

    var realWidth = this._width * this._pixelRatio;
    var realHeight = this._height * this._pixelRatio;
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, realWidth, realHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    var dimensions = new _globals.Vector2(this._width, this._height);
    if (_globals.Utils.isPowerOfTwo(dimensions)) {
      _globals.Log.info('WebGLRenderTarget', 'Mip-mapping enabled');
      this._mipMapping = true;
    }

    this._baseTexture.setMipMappingEnabled(this._mipMapping);
  };

  /**
   * Binds the framebuffer and resizes the viewport
   */


  WebGLRenderTarget.prototype.activate = function activate() {
    var gl = this._gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);

    this._calculateProjectionMatrix();

    gl.viewport(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
    gl.disable(gl.STENCIL_TEST);
  };

  /**
   * Clears the framebuffer
   */


  WebGLRenderTarget.prototype.clear = function clear() {
    var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _globals.Color.TRANSPARENT;

    var gl = this._gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);

    _globals.GLUtils.checkFramebufferStatus('WebGLRenderTarget#clear', gl);

    gl.clearColor.apply(gl, color.toGLColor());
    gl.clear(gl.COLOR_BUFFER_BIT);
  };

  /**
   * Calculates the projection matrix for this render target
   * @private
   */


  WebGLRenderTarget.prototype._calculateProjectionMatrix = function _calculateProjectionMatrix() {
    var projectionMatrix = this._projectionMatrix;
    projectionMatrix.reset();

    var frame = this._frame || new _globals.Rectangle(0, 0, this._width, this._height);

    var x = frame.x,
        y = frame.y;

    if (!this._isRoot) {
      projectionMatrix.a = 1 / this._width * 2;
      projectionMatrix.d = 1 / this._height * 2;

      projectionMatrix.tx = -1 - x * projectionMatrix.a;
      projectionMatrix.ty = -1 - y * projectionMatrix.d;
    } else {
      projectionMatrix.a = 1 / this._width * 2;
      projectionMatrix.d = -1 / this._height * 2;

      projectionMatrix.tx = -1 - x * projectionMatrix.a;
      projectionMatrix.ty = 1 - y * projectionMatrix.d;
    }
  };

  /**
   * Initializes the WebGL FBO and Texture for this WebGLRenderTarget
   * @private
   */


  WebGLRenderTarget.prototype._initFrameBuffer = function _initFrameBuffer() {
    var gl = this._gl;

    // Init the FBO
    this._framebuffer = gl.createFramebuffer();

    // Create the texture
    this._texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._texture);

    // Bind texture to FBO
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture, 0);

    this._baseTexture.setGLTextureForRenderer(this._texture, this._renderer);
    this.resizeTo(new _globals.Vector2(this._width, this._height));

    _globals.GLUtils.checkFramebufferStatus('WebGLRenderTarget#_initFramebuffer', gl);
  };

  /**
   * Returns the projection matrix
   * @return {PhotoEditorSDK.Math.Matrix}
   */


  WebGLRenderTarget.prototype.getProjectionMatrix = function getProjectionMatrix() {
    return this._projectionMatrix;
  };

  /**
   * Returns the texture
   * @return {PhotoEditorSDK.Engine.Texture}
   */


  WebGLRenderTarget.prototype.getTexture = function getTexture() {
    return this._texture;
  };

  /**
   * Returns the frame
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  WebGLRenderTarget.prototype.getFrame = function getFrame() {
    return this._frame;
  };

  /**
   * Sets the frame
   * @param {PhotoEditorSDK.Math.Rectangle} frame
   */


  WebGLRenderTarget.prototype.setFrame = function setFrame(frame) {
    this._frame = frame;
  };

  /**
   * Returns the filter stack
   * @return {Object[]}
   */


  WebGLRenderTarget.prototype.getFilterStack = function getFilterStack() {
    return this._filterStack;
  };

  /**
   * Returns the current pixel ratio
   * @return {Number}
   */


  WebGLRenderTarget.prototype.getPixelRatio = function getPixelRatio() {
    return this._pixelRatio;
  };

  /**
   * Sets the pixel ratio
   * @param {Number} pixelRatio
   */


  WebGLRenderTarget.prototype.setPixelRatio = function setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;

    if (!this._isRoot) {
      this._resizeTexture();
    }
  };

  /**
   * Returns the base texture
   * @return {PhotoEditorSDK.Engine.BaseTexture}
   */


  WebGLRenderTarget.prototype.getBaseTexture = function getBaseTexture() {
    return this._baseTexture;
  };

  /**
   * Disposes this WebGLRenderTarget
   */


  WebGLRenderTarget.prototype.dispose = function dispose() {
    var gl = this._gl;
    this._baseTexture.disposeGLTexturesForRenderer(this._renderer);
    gl.deleteTexture(this._texture);
    gl.deleteFramebuffer(this._framebuffer);
  };

  return WebGLRenderTarget;
}();

exports.default = WebGLRenderTarget;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(38);

var _createClass3 = _interopRequireDefault(_createClass2);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * [ a, b, c, d, e,
 *   f, g, h, i, j,
 *   k, l, m, n, o,
 *   p, q, r, s, t ]
 *
 */

/**
 * Represents a 4 by 5 matrix that is used to preform color manipulations.
 * The members are names a, b, c,..,t. The vector formed by e, j, o, t
 * represents the offset.
 * @class
 * @memberof PhotoEditorSDK.Math
 */
var ColorMatrix = function () {

  /**
   * Creates a color matrix, and defaults the values to the identity.
   * @return {PhotoEditorSDK.Math.ColorMatrix}
   */
  function ColorMatrix() {
    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var f = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var g = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
    var h = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var i = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var j = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    var k = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    var l = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
    var m = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 1;
    var n = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
    var o = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
    var p = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 0;
    var q = arguments.length > 16 && arguments[16] !== undefined ? arguments[16] : 0;
    var r = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : 0;
    var s = arguments.length > 18 && arguments[18] !== undefined ? arguments[18] : 1;
    var t = arguments.length > 19 && arguments[19] !== undefined ? arguments[19] : 0;
    (0, _classCallCheck3.default)(this, ColorMatrix);

    this.set(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t);
  }

  /**
   * Sets the values of the color matrix.
   * @param  {number} a
   * @param  {number} b
   * @param  {number} c
   * @param  {number} d
   * @param  {number} e
   * @param  {number} f
   * @param  {number} g
   * @param  {number} h
   * @param  {number} i
   * @param  {number} j
   * @param  {number} k
   * @param  {number} l
   * @param  {number} m
   * @param  {number} n
   * @param  {number} o
   * @param  {number} p
   * @param  {number} q
   * @param  {number} r
   * @param  {number} s
   * @param  {number} t
   * @return {PhotoEditorSDK.Math.ColorMatrix}
   */


  ColorMatrix.prototype.set = function set(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    this.j = j;
    this.k = k;
    this.l = l;
    this.m = m;
    this.n = n;
    this.o = o;
    this.p = p;
    this.q = q;
    this.r = r;
    this.s = s;
    this.t = t;
  };

  /**
   * Returns an identity color matrix.
   * @return {ColorMatrix}
   */


  ColorMatrix.prototype.reset = function reset() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 0;
    this.e = 0;

    this.f = 0;
    this.g = 1;
    this.h = 0;
    this.i = 0;
    this.j = 0;

    this.k = 0;
    this.l = 0;
    this.m = 1;
    this.n = 0;
    this.o = 0;

    this.p = 0;
    this.q = 0;
    this.r = 0;
    this.s = 1;
    this.t = 0;
  };

  /**
   * Applies the color matrix to the given color, and returns the resulting color.
   * @param  {Color} color
   * @return {Color}
   */


  ColorMatrix.prototype.apply = function apply(color) {
    // we need to multiply the translation by 255 so we can use the same matrix for canvas and gl.
    var r = this.a * color.r + this.b * color.g + this.c * color.b + this.d * color.a + this.e * 255.0;
    var g = this.f * color.r + this.g * color.g + this.h * color.b + this.i * color.a + this.j * 255.0;
    var b = this.k * color.r + this.l * color.g + this.m * color.b + this.n * color.a + this.o * 255.0;
    var a = this.p * color.r + this.q * color.g + this.r * color.b + this.s * color.a + this.t * 255.0;
    return new _color2.default(r, g, b, a);
  };

  /**
  * Multiplies the given matrix with this matrix.
  * @param  {PhotoEditorSDK.Math.ColorMatrix} matrix
  * @return {PhotoEditorSDK.Math.ColorMatrix}
  */


  ColorMatrix.prototype.multiply = function multiply(matrix) {
    var a = void 0,
        b = void 0,
        c = void 0,
        d = void 0,
        e = void 0,
        f = void 0,
        g = void 0,
        h = void 0,
        i = void 0,
        j = void 0,
        k = void 0,
        l = void 0,
        m = void 0,
        n = void 0,
        o = void 0,
        p = void 0,
        q = void 0,
        r = void 0,
        s = void 0,
        t = void 0;
    // store both factors, so we can swap them easily
    var A = matrix;
    var B = this;

    // transformation
    a = A.a * B.a + A.b * B.f + A.c * B.k + A.d * B.p;
    b = A.a * B.b + A.b * B.g + A.c * B.l + A.d * B.q;
    c = A.a * B.c + A.b * B.h + A.c * B.m + A.d * B.r;
    d = A.a * B.d + A.b * B.i + A.c * B.n + A.d * B.s;

    f = A.f * B.a + A.g * B.f + A.h * B.k + A.i * B.p;
    g = A.f * B.b + A.g * B.g + A.h * B.l + A.i * B.q;
    h = A.f * B.c + A.g * B.h + A.h * B.m + A.i * B.r;
    i = A.f * B.d + A.g * B.i + A.h * B.n + A.i * B.s;

    k = A.k * B.a + A.l * B.f + A.m * B.k + A.n * B.p;
    l = A.k * B.b + A.l * B.g + A.m * B.l + A.n * B.q;
    m = A.k * B.c + A.l * B.h + A.m * B.m + A.n * B.r;
    n = A.k * B.d + A.l * B.i + A.m * B.n + A.n * B.s;

    p = A.p * B.a + A.q * B.f + A.r * B.k + A.s * B.p;
    q = A.p * B.b + A.q * B.g + A.r * B.l + A.s * B.q;
    r = A.p * B.c + A.q * B.h + A.r * B.m + A.s * B.r;
    s = A.p * B.d + A.q * B.i + A.r * B.n + A.s * B.s;

    // translation
    e = A.a * B.e + A.b * B.j + A.c * B.o + A.d * B.t + A.e;
    j = A.f * B.e + A.g * B.j + A.h * B.o + A.i * B.t + A.j;
    o = A.k * B.e + A.l * B.j + A.m * B.o + A.n * B.t + A.o;
    t = A.p * B.e + A.q * B.j + A.r * B.o + A.s * B.t + A.t;

    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    this.j = j;
    this.k = k;
    this.l = l;
    this.m = m;
    this.n = n;
    this.o = o;
    this.p = p;
    this.q = q;
    this.r = r;
    this.s = s;
    this.t = t;

    return this;
  };

  /**
   * Retuns a clone of the current matrix/
   * @return {ColorMatrix}
   */


  ColorMatrix.prototype.clone = function clone() {
    var matrix = new ColorMatrix();
    matrix.set(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, this.j, this.k, this.l, this.m, this.n, this.o, this.p, this.q, this.r, this.s, this.t);
    return matrix;
  };

  ColorMatrix.prototype.equals = function equals(matrix) {
    return this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d && this.e === matrix.e && this.f === matrix.f && this.g === matrix.g && this.h === matrix.h && this.i === matrix.i && this.j === matrix.j && this.k === matrix.k && this.l === matrix.l && this.m === matrix.m && this.n === matrix.n && this.o === matrix.o && this.p === matrix.p && this.q === matrix.q && this.r === matrix.r && this.s === matrix.s && this.t === matrix.t;
  };

  /**
   * Returns a string representation of this color matrix
   * @return {String}
   */


  ColorMatrix.prototype.toString = function toString() {
    return 'ColorMatrix( ' + this.a + ', ' + this.b + ', ' + this.c + ', ' + this.d + ', ' + this.e + ',\n      ' + this.f + ', ' + this.g + ', ' + this.h + ', ' + this.i + ', ' + this.j + ',\n      ' + this.k + ', ' + this.l + ', ' + this.m + ', ' + this.n + ', ' + this.o + ',\n      ' + this.p + ', ' + this.q + ', ' + this.r + ', ' + this.s + ', ' + this.t + ' )';
  };

  /**
   * Returns an array of numbers
   * @return {Number[]}
   */


  ColorMatrix.prototype.toArray = function toArray() {
    var _this = this;

    return 'abcdefghijklmnopqrst'.split('').map(function (v) {
      return _this[v];
    });
  };

  /**
   * The identity matrix
   * @static
   * @type {PhotoEditorSDK.Math.Matrix}
   */


  /**
   * Returns a color matrix that can be used to change the brightness.
   * @static
   * @param {Number} brightness
   */
  ColorMatrix.createBrightnessMatrix = function createBrightnessMatrix(brightness) {
    var matrix = new ColorMatrix();
    matrix.e = brightness;
    matrix.j = brightness;
    matrix.o = brightness;
    return matrix;
  };

  /**
   * Returns a color matrix that can be used to change the contrast.
   * @static
   * @param {Number} contrast
   */


  ColorMatrix.createContrastMatrix = function createContrastMatrix(contrast) {
    var matrix = new ColorMatrix();
    var t = (1.0 - contrast) / 2.0;
    matrix.a = matrix.g = matrix.m = contrast;
    matrix.e = matrix.j = matrix.o = t;
    return matrix;
  };

  /**
   * Returns a color matrix that can be used to change the saturation.
   * @static
   * @param {Number} saturation
   */


  ColorMatrix.createSaturationMatrix = function createSaturationMatrix() {
    var saturation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;

    var matrix = new ColorMatrix();
    var invSat = 1 - saturation;
    var r = 0.213 * invSat;
    var g = 0.715 * invSat;
    var b = 0.072 * invSat;

    // first row
    matrix.a = r + saturation;
    matrix.b = g;
    matrix.c = b;
    // second row
    matrix.f = r;
    matrix.g = g + saturation;
    matrix.h = b;
    // third row
    matrix.k = r;
    matrix.l = g;
    matrix.m = b + saturation;
    return matrix;
  };

  /**
   * Returns a color matrix that can be used to apply linear changes.
   * @static
   * @param {Number} slope
   * @param {Number} intercept
   */


  ColorMatrix.createLinearMatrix = function createLinearMatrix() {
    var slope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
    var intercept = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;

    var matrix = new ColorMatrix();
    matrix.a = matrix.g = matrix.m = slope;
    matrix.e = matrix.j = matrix.o = intercept;
    return matrix;
  };

  (0, _createClass3.default)(ColorMatrix, null, [{
    key: 'IDENTITY',
    get: function get() {
      return new ColorMatrix();
    }
  }]);
  return ColorMatrix;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = ColorMatrix;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RendererType = _globals.Constants.RendererType; /*
                                                     * This file is part of PhotoEditorSDK.
                                                     *
                                                     * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                     * All rights reserved.
                                                     *
                                                     * Redistribution and use in source and binary forms, without
                                                     * modification, are permitted provided that the following license agreement
                                                     * is approved and a legal/financial contract was signed by the user.
                                                     * The license agreement can be found under following link:
                                                     *
                                                     * https://www.photoeditorsdk.com/LICENSE.txt
                                                     */

var Sprite = function (_Configurable) {
  (0, _inherits3.default)(Sprite, _Configurable);

  function Sprite(operation, options) {
    (0, _classCallCheck3.default)(this, Sprite);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Configurable.call(this, options));

    _this._operation = operation;
    _this._dirtiness = {};
    _this.id = _globals.Utils.getUUID();

    _this._renderTextures = {};
    _this._identitySprite = new _globals.Engine.Sprite();
    _this._sprite = new _globals.Engine.Sprite();
    _this._renderers = [];
    return _this;
  }

  /**
   * Applies a rotation with the given degrees
   * @param  {Number} degrees
   */


  Sprite.prototype.applyRotation = function applyRotation(degrees) {
    var inputDimensions = this._operation.getInputDimensions();

    // Update sprite rotation
    var spriteDegrees = this.getRotation() * 180 / Math.PI;
    spriteDegrees += degrees;
    this.setRotation(spriteDegrees * Math.PI / 180);

    var actualDegrees = (degrees + 360) % 360;
    var radians = actualDegrees * Math.PI / 180;

    var cos = Math.cos(radians);
    var sin = Math.sin(radians);

    var relativePosition = this._options.position.clone().subtract(0.5).multiply(inputDimensions);

    var newRelativePosition = new _globals.Vector2(relativePosition.x * cos - relativePosition.y * sin, relativePosition.x * sin + relativePosition.y * cos).divide(inputDimensions.clone().flip());

    this.setPosition(new _globals.Vector2(0.5, 0.5).add(newRelativePosition));
  };

  /**
   * Applies a flip in the given direction
   * @param  {String} direction
   */


  Sprite.prototype.applyFlip = function applyFlip(direction) {
    var position = this.getPosition().clone();
    switch (direction) {
      case 'horizontal':
        position.x = 1 - this._options.position.x;
        break;
      case 'vertical':
        position.y = 1 - this._options.position.y;
        break;
    }

    this.setPosition(position);
  };

  /**
   * Applies a crop with the given options
   * @param  {PhotoEditorSDK.Operations.CropOperation} cropOperation
   * @param  {Object} options
   */


  Sprite.prototype.applyCrop = function applyCrop(cropOperation, options) {
    var inputDimensions = cropOperation.getInputDimensions();
    var rotationDelta = options.rotation - cropOperation.getRotation();

    var oldAbsoluteSize = cropOperation.getEnd().clone().subtract(cropOperation.getStart()).multiply(inputDimensions);
    var newAbsoluteSize = options.end.clone().subtract(options.start).multiply(inputDimensions);
    var absoluteStartDiff = cropOperation.getStart().clone().subtract(options.start).multiply(inputDimensions);
    var scaleRatio = options.scale / cropOperation.getScale();
    var absoluteStart = cropOperation.getStart().clone().multiply(inputDimensions);

    // Calculate the absolute position on input image
    var absolutePositionOnImage = this.getPosition().clone().multiply(oldAbsoluteSize) // Compensate crop size
    .add(absoluteStart); // Compensate crop start / offset

    // Reposition sprite
    // Calculate distance from input image's center (in pixels)
    var deltaToCenter = absolutePositionOnImage.clone().subtract(inputDimensions.clone().multiply(0.5));

    // Rotate delta around center
    var cos = Math.cos(rotationDelta);
    var sin = Math.sin(rotationDelta);
    var newDeltaToCenter = new _globals.Vector2(deltaToCenter.x * cos - deltaToCenter.y * sin, deltaToCenter.x * sin + deltaToCenter.y * cos);

    // Apply scale change to delta
    newDeltaToCenter.multiply(scaleRatio);

    // Calculate new position
    // image center + delta to center - old start + new start
    var position = inputDimensions.clone().multiply(0.5).add(newDeltaToCenter).subtract(absoluteStart).add(absoluteStartDiff).divide(newAbsoluteSize);

    // Compensate scale
    if (this._options.dimensions) {
      var dimensions = this.getDimensions().clone().multiply(scaleRatio);
      if (options.textureScale) {
        dimensions.multiply(options.textureScale / cropOperation.getTextureScale());
      }
      this.set({ dimensions: dimensions }, false);
    }

    // Compensate rotation
    var inverseCropDegrees = rotationDelta * 180 / Math.PI;
    var spriteDegrees = this.getRotation() * 180 / Math.PI + inverseCropDegrees;

    this.set({
      rotation: spriteDegrees * Math.PI / 180,
      position: position
    }, false);
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Returns the DisplayObject of this Sprite
   * @return {PhotoEditorSDK.Engine.Sprite}
   */


  Sprite.prototype.getDisplayObject = function getDisplayObject() {
    return this._sprite;
  };

  /**
   * Returns the texture for the sprite that should be rendered
   * @return {PhotoEditorSDK.Engine.Texture}
   * @private
   * @abstract
   */


  Sprite.prototype._getTexture = function _getTexture() {
    throw new Error('Sprite#_getTexture is abstract and not implemented in child class.');
  };

  /**
   * Prepares for rendering this sprite to a render texture
   * @param {PhotoEditorSDK} sdk
   * @private
   */


  Sprite.prototype._prepareRenderTexture = function _prepareRenderTexture(sdk) {
    if (!this._renderTexture) {
      var texture = this._getTexture();
      this._renderTextureContainer = new _globals.Engine.Container();
      this._renderTextureSprite = new _globals.Engine.Sprite(texture);
      this._renderTextureContainer.addChild(this._renderTextureSprite);
      this._renderTexture = this._getRenderTexture(sdk.getRenderer(), texture.getDimensions());
    } else {
      this._renderTexture.clear();
    }
  };

  /**
   * Checks if this sprite should be rendered to a render texture
   * @param  {PhotoEditorSDK} sdk
   * @return {Boolean}
   * @private
   */


  Sprite.prototype._rendersToRenderTexture = function _rendersToRenderTexture(sdk) {
    return sdk.getOptions().smoothDownscaling && sdk.getRenderer().isOfType(RendererType.WEBGL);
  };

  /**
   * Updates this sprite
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Promise}
   */


  Sprite.prototype.update = function update(sdk, inputDimensions) {
    if (this._rendersToRenderTexture(sdk)) {
      this._prepareRenderTexture(sdk);
    }

    this._updateSprite(inputDimensions);

    if (this._rendersToRenderTexture(sdk)) {
      this._renderToRenderTexture(sdk);
    }

    return _globals.Promise.resolve();
  };

  /**
   * Updates the sprite's properties according to the options
   * @param {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @private
   */


  Sprite.prototype._updateSprite = function _updateSprite(inputDimensions) {
    this._sprite.setAnchor(this._options.anchor);
    this._sprite.setPosition(this._options.position.clone().multiply(inputDimensions));

    var dimensions = this._options.dimensions;

    if (dimensions) {
      dimensions = dimensions.clone().multiply(this._operation.getSDK().getTextureScale());
      this._sprite.setWidth(dimensions.x);
      this._sprite.setHeight(dimensions.y);
    }
    this._sprite.updateTransform();

    var frame = this._sprite.getTexture().getFrame();
    var spriteDimensions = new _globals.Vector2(frame.width, frame.height);

    this._sprite.setPivot(this._options.pivot.clone().multiply(spriteDimensions));
    this._sprite.setRotation(this._options.rotation);
    this._sprite.updateTransform();
  };

  /**
   * Renders this sprite to the render texture. If power-of-two textures are enforced,
   * it automatically resizes the texture and updates its UV coordinates accordingly.
   * @param  {PhotoEditorSDK} sdk
   * @private
   */


  Sprite.prototype._renderToRenderTexture = function _renderToRenderTexture(sdk) {
    var textureDimensions = this._getTexture().getDimensions();
    var renderTexture = this._getRenderTexture(sdk.getRenderer(), textureDimensions);

    var finalDimensions = textureDimensions.clone();
    if (this._options.smoothDownscaling) {
      finalDimensions.x = _globals.Utils.nextHighestPOT(finalDimensions.x);
      finalDimensions.y = _globals.Utils.nextHighestPOT(finalDimensions.y);
    }

    this._renderTexture.resizeTo(finalDimensions);
    this._renderTexture.render(this._renderTextureContainer);

    if (this._options.smoothDownscaling) {
      var relativeDifference = finalDimensions.clone().subtract(textureDimensions.x, textureDimensions.y).divide(finalDimensions);

      var uvs = renderTexture.getUVs().getUVs();
      uvs[0].x = uvs[3].x = 0;
      uvs[1].x = uvs[2].x = 1 - relativeDifference.x;
      uvs[0].y = uvs[1].y = 0;
      uvs[2].y = uvs[3].y = 1 - relativeDifference.y;
    }

    this._sprite.setTexture(renderTexture);
  };

  /**
   * Checks if this operation is dirty for the given renderer
   * @param  {PhotoEditorSDK.Engine.BaseRenderer}  renderer
   * @return {Boolean}
   */


  Sprite.prototype.isDirtyForRenderer = function isDirtyForRenderer(renderer) {
    if (!(renderer.id in this._dirtiness)) {
      this._dirtiness[renderer.id] = true;
    }
    return this._dirtiness[renderer.id];
  };

  /**
   * Sets the dirtiness for the given renderer
   * @param {Boolean} dirty
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   */


  Sprite.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
    this._renderers[renderer.id] = renderer;
    this._dirtiness[renderer.id] = dirty;
  };

  /**
   * Sets the dirtiness for all renderers
   * @param {Boolean} dirty
   */


  Sprite.prototype.setDirty = function setDirty(dirty) {
    for (var rendererId in this._dirtiness) {
      this.setDirtyForRenderer(dirty, this._renderers[rendererId]);
    }
  };

  /**
   * Creates and/or returns a RenderTexture
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param {PhotoEditorSDK.Math.Vector2} dimensions = new Vector(100, 100)
   * @return {PhotoEditorSDK.Engine.RenderTexture}
   * @private
   */


  Sprite.prototype._getRenderTexture = function _getRenderTexture(renderer) {
    var dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _globals.Vector2(100, 100);

    if (!this._renderTextures[renderer.id]) {
      this._renderTextures[renderer.id] = new _globals.Engine.RenderTexture(renderer, dimensions.x, dimensions.y, 1);
    }
    return this._renderTextures[renderer.id];
  };

  /**
   * Cleans up this Sprite
   */


  Sprite.prototype.dispose = function dispose() {
    for (var rendererId in this._renderTextures) {
      this._renderTextures[rendererId].dispose();
    }
  };

  return Sprite;
}(_globals.Configurable);

exports.default = Sprite;

/***/ },
/* 37 */
/***/ function(module, exports) {

"use strict";
/* eslint-disable */
"use strict";
/*!
StackBlur - a fast almost Gaussian Blur For Canvas

Version:  0.5
Author:   Mario Klingemann
Contact:  mario@quasimondo.com
Website:  http://www.quasimondo.com/StackBlurForCanvas
Twitter:  @quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr:
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
@license
*/

var mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];

var shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];

function stackBlurCanvasRGBA(imageData, top_x, top_y, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;

  var pixels = imageData.data;

  var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;

  var div = radius + radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

  var stackStart = new BlurStack();
  var stackEnd;
  var stack = stackStart;
  for (i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();
    if (i == radiusPlus1) stackEnd = stack;
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;

  yw = yi = 0;

  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];

  for (y = 0; y < height; y++) {
    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    for (i = 1; i < radiusPlus1; i++) {
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
      a_sum += (stack.a = pa = pixels[p + 3]) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;

      stack = stack.next;
    }

    stackIn = stackStart;
    stackOut = stackEnd;
    for (x = 0; x < width; x++) {
      pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa !== 0) {
        pa = 255 / pa;
        pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;

      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;

      r_in_sum += stackIn.r = pixels[p];
      g_in_sum += stackIn.g = pixels[p + 1];
      b_in_sum += stackIn.b = pixels[p + 2];
      a_in_sum += stackIn.a = pixels[p + 3];

      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      a_sum += a_in_sum;

      stackIn = stackIn.next;

      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;

      stackOut = stackOut.next;

      yi += 4;
    }
    yw += width;
  }

  for (x = 0; x < width; x++) {
    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;

    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    yp = width;

    for (i = 1; i <= radius; i++) {
      yi = yp + x << 2;

      r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
      a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;

      stack = stack.next;

      if (i < heightMinus1) {
        yp += width;
      }
    }

    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (y = 0; y < height; y++) {
      p = yi << 2;
      pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa > 0) {
        pa = 255 / pa;
        pixels[p] = (r_sum * mul_sum >> shg_sum) * pa;
        pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa;
        pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa;
      } else {
        pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
      }

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;

      p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;

      r_sum += r_in_sum += stackIn.r = pixels[p];
      g_sum += g_in_sum += stackIn.g = pixels[p + 1];
      b_sum += b_in_sum += stackIn.b = pixels[p + 2];
      a_sum += a_in_sum += stackIn.a = pixels[p + 3];

      stackIn = stackIn.next;

      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;

      stackOut = stackOut.next;

      yi += width;
    }
  }
}

function BlurStack() {
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
}

module.exports = {
  stackBlurCanvasRGBA: stackBlurCanvasRGBA
};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _defineProperty = __webpack_require__(85);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ },
/* 39 */
/***/ function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(95)
  , enumBugKeys = __webpack_require__(52);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ },
/* 41 */
/***/ function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ },
/* 42 */
/***/ function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _base = __webpack_require__(27);

var _base2 = _interopRequireDefault(_base);

var _arrayStream = __webpack_require__(114);

var _arrayStream2 = _interopRequireDefault(_arrayStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EXIF_TAGS = {
  0x0100: 'ImageWidth',
  0x0101: 'ImageHeight',
  0x8769: 'ExifIFDPointer',
  0x8825: 'GPSInfoIFDPointer',
  0xA005: 'InteroperabilityIFDPointer',
  0x0102: 'BitsPerSample',
  0x0103: 'Compression',
  0x0106: 'PhotometricInterpretation',
  0x0112: 'Orientation',
  0x0115: 'SamplesPerPixel',
  0x011C: 'PlanarConfiguration',
  0x0212: 'YCbCrSubSampling',
  0x0213: 'YCbCrPositioning',
  0x011A: 'XResolution',
  0x011B: 'YResolution',
  0x0128: 'ResolutionUnit',
  0x0111: 'StripOffsets',
  0x0116: 'RowsPerStrip',
  0x0117: 'StripByteCounts',
  0x0201: 'JPEGInterchangeFormat',
  0x0202: 'JPEGInterchangeFormatLength',
  0x012D: 'TransferFunction',
  0x013E: 'WhitePoint',
  0x013F: 'PrimaryChromaticities',
  0x0211: 'YCbCrCoefficients',
  0x0214: 'ReferenceBlackWhite',
  0x0132: 'DateTime',
  0x010E: 'ImageDescription',
  0x010F: 'Make',
  0x0110: 'Model',
  0x0131: 'Software',
  0x013B: 'Artist',
  0x8298: 'Copyright'
}; /*
    * Based on https://github.com/exif-js/exif-js by Jacob Seidelin
    * Licensed under MIT
    * @license
    */

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var DATA_JPEG_PREFIX = 'data:image/jpeg;base64,';
var JPEG_REGEX = new RegExp('^' + DATA_JPEG_PREFIX, 'i');

/**
 * Reads EXIF tags from the given byte array and restores them
 * @class
 * @memberof PhotoEditorSDK
 * @ignore
 */
var EXIF = function () {
  /**
   * Creates an EXIF object
   * @param  {Array} buf
   */
  function EXIF(buf) {
    (0, _classCallCheck3.default)(this, EXIF);

    this._buf = buf;
    this._stream = new _arrayStream2.default(this._buf);
    this._stream.setHead(0);

    this._segments = this._sliceIntoSegments(this._buf);
    this._exifBuffer = this._getExifBuffer();
    this._exifStream = new _arrayStream2.default(this._exifBuffer);
    this._parseExif();
  }

  /**
   * Restores the exif tags into the given data url
   * @return {String} base64String
   */


  EXIF.prototype.restoreExifTags = function restoreExifTags(base64String) {
    // First, make the given string a data array
    var raw = base64String.replace(DATA_JPEG_PREFIX, '');
    var data = _base2.default.decode(raw);

    var segments = this._sliceIntoSegments(data);
    var segmentStart = segments[1][0];
    var dataBefore = data.slice(0, segmentStart);
    var dataAfter = data.slice(segmentStart);

    var newData = dataBefore.concat(this._exifBuffer);
    newData = newData.concat(dataAfter);

    // Make it a base64 string again
    return DATA_JPEG_PREFIX + _base2.default.encode(newData);
  };

  /**
   * Overwrites the orientation with the given 16 bit integer
   * @param {Number} orientation
   */


  EXIF.prototype.setOrientation = function setOrientation(orientation) {
    if (this._tagData.Orientation) {
      var entryOffset = this._tagData.Orientation.entryOffset;
      // Replace value in buffer

      this._exifStream.setHead(entryOffset + 8);
      this._exifStream.writeInt16(orientation);
    }
  };

  /**
   * Checks whether the given base64 data url is a jpeg image
   * @param  {String}  base64String
   * @return {Boolean}
   */


  EXIF.isJPEG = function isJPEG(base64String) {
    return JPEG_REGEX.test(base64String);
  };

  /**
   * Creates a new instance of Exif from the given base64-encoded
   * string
   * @param  {String} base64String
   * @return {PhotoEditorSDK.Exif}
   */


  EXIF.fromBase64String = function fromBase64String(base64String) {
    var raw = base64String.replace(DATA_JPEG_PREFIX, '');
    var data = _base2.default.decode(raw);
    return new EXIF(data);
  };

  /**
   * Parses the exif tags
   * @return {Object}
   * @private
   */


  EXIF.prototype._parseExif = function _parseExif() {
    this._exifStream.setHead(0);
    // Skip marker
    this._exifStream.readInt16();
    // Skip length
    this._exifStream.readInt16();

    var header = this._exifStream.readString(4);
    if (header !== 'Exif') {
      return;
    }

    // Skip 2 bytes
    this._exifStream.readInt16();

    var tiffOffset = this._exifStream.getHead();

    // Find endian type
    var bigEndian = false;
    var endian = this._exifStream.readInt16();
    if (endian === 0x4949) {
      bigEndian = false;
    } else if (endian === 0x4d4d) {
      bigEndian = true;
    } else {
      throw new Error('Invalid TIFF data: No endian type found');
    }

    if (this._exifStream.readInt16(!bigEndian) !== 0x002A) {
      throw new Error('Invalid TIFF data: No 0x002A');
    }

    var firstIFDOffset = this._exifStream.readInt32(!bigEndian);
    if (firstIFDOffset < 8) {
      throw new Error('Invalid TIFF data: First IFD offset < 8');
    }

    var ifdOffset = tiffOffset + firstIFDOffset;
    var tags = this._readTags(this._exifStream, tiffOffset, ifdOffset, bigEndian);
    this._tags = tags.tags;
    this._tagData = tags.tagData;
  };

  /**
   * Reads the TIFF tags from the stream
   * @param  {ArrayBuffer} stream
   * @param  {Number} tiffStart The position where tiff data starts
   * @param  {Number} ifdStart  The position where the IFD starts
   * @param  {Boolean} bigEndian
   * @return {Object}
   * @private
   */


  EXIF.prototype._readTags = function _readTags(stream, tiffStart, ifdStart, bigEndian) {
    stream.setHead(ifdStart);
    var entriesCount = stream.readInt16(!bigEndian);
    var tags = {};
    var tagData = [];

    for (var i = 0; i < entriesCount; i++) {
      var entryOffset = ifdStart + i * 12 + 2;
      stream.setHead(entryOffset);
      var tag = stream.readInt16(!bigEndian);
      var type = void 0;
      var numValues = void 0;
      var valueOffset = void 0;
      if (EXIF_TAGS[tag]) {
        tag = EXIF_TAGS[tag];
        type = stream.readInt16(!bigEndian);
        numValues = stream.readInt32(!bigEndian);
        valueOffset = stream.readInt32(!bigEndian) + tiffStart;
        var value = null;

        switch (type) {
          case 1: // byte, 8-bit unsigned int
          case 7:
            // undefined, 8-bit byte, value depending on field
            if (numValues === 1) {
              value = stream.readInt8(!bigEndian);
            } else {
              value = [];
              for (var _i = 0; _i < numValues; _i++) {
                value.push(stream.readInt8(!bigEndian));
              }
            }
            break;
          case 2:
            // 8-bit ascii char
            stream.setHead(numValues > 4 ? valueOffset : entryOffset + 8);
            value = stream.readString(numValues);
            break;
          case 3:
            // short
            stream.setHead(numValues > 2 ? valueOffset : entryOffset + 8);
            if (numValues === 1) {
              value = stream.readInt16(!bigEndian);
            } else {
              value = [];
              for (var _i2 = 0; _i2 < numValues; _i2++) {
                value.push(stream.readInt16(!bigEndian));
              }
            }
            break;
          case 4: // long
          case 9:
            // slong
            stream.setHead(numValues > 1 ? valueOffset : entryOffset + 8);
            if (numValues === 1) {
              value = stream.readInt32(!bigEndian);
            } else {
              value = [];
              for (var _i3 = 0; _i3 < numValues; _i3++) {
                value.push(stream.readInt32(!bigEndian));
              }
            }
            break;
          case 5: // rational (two long values, first numerator, second denominator)
          case 10:
            // rational (two slongs)
            stream.setHead(valueOffset);
            if (numValues === 1) {
              var numerator = stream.readInt32(!bigEndian);
              var denominator = stream.readInt32(!bigEndian);
              value = numerator / denominator;
            } else {
              value = [];
              for (var _i4 = 0; _i4 < numValues; _i4++) {
                var _numerator = stream.readInt32(!bigEndian);
                var _denominator = stream.readInt32(!bigEndian);
                var val = _numerator / _denominator;
                value.push(val);
              }
            }
            break;
        }

        tags[tag] = value;
        tagData[tag] = {
          value: value,
          numValues: numValues,
          entryOffset: entryOffset,
          valueOffset: valueOffset,
          type: type
        };
      }
    }

    return { tags: tags, tagData: tagData };
  };

  /**
   * Returns a new buffer containing the Exif segment
   * @return {Array}
   * @private
   */


  EXIF.prototype._getExifBuffer = function _getExifBuffer() {
    var segments = this._segments;
    for (var i = 0; i < segments.length; i++) {
      var offset = segments[i][0];
      var end = segments[i][1];
      this._stream.setHead(offset);
      var marker = this._stream.peekInt16();
      if (marker === 0xffe1) {
        return this._buf.slice(offset, end);
      }
    }
    return false;
  };

  /**
   * Slices the array into segments
   * @param  {Array.<Number>} buf
   * @return {Array}
   * @private
   */


  EXIF.prototype._sliceIntoSegments = function _sliceIntoSegments(buf) {
    var stream = new _arrayStream2.default(buf);
    var segments = [];
    while (stream.getHead() < buf.length) {
      var marker = stream.readInt16();
      if (marker === 0xffd8) {
        continue;
      } // SOI
      if (marker === 0xffda) {
        break;
      } // SOS Marker

      if (marker >= 0xff00 && marker <= 0xffff) {
        // Marker (FF-XX-HL-LL)
        var length = stream.readInt16();
        var end = stream.getHead() + length - 2;
        segments.push([stream.getHead() - 4, end]);
        stream.setHead(end);
      } else {
        throw new Error('Invalid marker: 0x' + marker.toString(16));
      }
    }

    this._stream.setHead(0);

    return segments;
  };

  /**
   * Returns the tags
   * @return {Object}
   */


  EXIF.prototype.getTags = function getTags() {
    return this._tags;
  };

  /**
   * Returns the tag data (key, value, byte position etc.)
   * @return {Object[]}
   */


  EXIF.prototype.getTagData = function getTagData() {
    return this._tagData;
  };

  /**
   * Disposes this EXIF object
   */


  EXIF.prototype.dispose = function dispose() {
    this._buf = [];
    this._exifBuffer = [];
    this._segments = [];
  };

  return EXIF;
}();

exports.default = EXIF;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base class for all objects that can be displayed
 * on the screen
 * @class
 * @memberof PhotoEditorSDK.Engine
 */
var DisplayObject = function () {
  /**
   * Creates a DisplayObject
   */
  function DisplayObject() {
    (0, _classCallCheck3.default)(this, DisplayObject);

    this._position = new _globals.Vector2(0, 0);
    this._scale = new _globals.Vector2(1, 1);
    this._pivot = new _globals.Vector2(0, 0);
    this._rotation = 0;
    this._lastRotation = null;
    this._alpha = 1;
    this._visible = true;
    this._worldTransform = new _globals.Matrix();
    this._parent = null;
    this._shaders = [];
    this._boundsNeedUpdate = true;
    this._bounds = new _globals.Rectangle(0, 0, 1, 1);
    this._localBoundsNeedUpdate = true;
    this._localBounds = new _globals.Rectangle(0, 0, 1, 1);
    this._tint = 0xffffff;
    this._filterRectangle = new _globals.Rectangle(0, 0, 0, 0);
  }

  /**
   * Renders this DisplayObject using the given WebGLRenderer
   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
   * @abstract
   */


  DisplayObject.prototype.renderWebGL = function renderWebGL(renderer) {
    _globals.Log.warn(this.constructor.name, '`renderWebGL` is abstract and not implemented in inherited class');
  };

  /**
   * Renders this DisplayObject using the given CanvasRenderer
   * @param  {PhotoEditorSDK.Engine.CanvasRenderer} renderer
   * @abstract
   */


  DisplayObject.prototype.renderCanvas = function renderCanvas(renderer) {
    _globals.Log.warn(this.constructor.name, '`renderCanvas` is abstract and not implemented in inherited class');
  };

  /**
   * Updates the world transform for this DisplayObject
   */


  DisplayObject.prototype.updateTransform = function updateTransform() {
    var parentTransform = this._parent ? this._parent.getWorldTransform() : _globals.Matrix.IDENTITY;
    var worldTransform = this._worldTransform;

    // Only build rotation matrix if rotation has changed since last update
    var rotationChanged = this._rotation !== this._lastRotation;
    if (rotationChanged) {
      this._sinRotation = Math.sin(this._rotation);
      this._cosRotation = Math.cos(this._rotation);
      this._lastRotation = this._rotation;
    }

    worldTransform.a = this._cosRotation * this._scale.x;
    worldTransform.b = this._sinRotation * this._scale.x;
    worldTransform.c = -this._sinRotation * this._scale.y;
    worldTransform.d = this._cosRotation * this._scale.y;
    worldTransform.tx = this._position.x;
    worldTransform.ty = this._position.y;

    if (this._pivot.x || this._pivot.y) {
      worldTransform.tx -= this._pivot.x * worldTransform.a + this._pivot.y * worldTransform.c;
      worldTransform.ty -= this._pivot.x * worldTransform.b + this._pivot.y * worldTransform.d;
    }

    // Floor
    worldTransform.tx |= 0;
    worldTransform.ty |= 0;

    worldTransform.multiply(parentTransform);

    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  };

  // -------------------------------------------------------------------------- SHADERS

  /**
   * Pushes the given shader to the list of shaders
   * @param {PhotoEditorSDK.Engine.Shader} shader
   */


  DisplayObject.prototype.addShader = function addShader(shader) {
    this._shaders.push(shader);
  };

  /**
   * Removes the given shader from the list of shaders
   * @param  {PhotoEditorSDK.Engine.Shader} shader
   * @return {Boolean}
   */


  DisplayObject.prototype.removeShader = function removeShader(shader) {
    var index = this._shaders.indexOf(shader);
    if (index !== -1) {
      this._shaders.splice(index, 1);
      return true;
    }
    return false;
  };

  /**
   * Removes the shader at the given index from the list of shaders
   * @param  {Number} index
   * @return {Boolean}
   */


  DisplayObject.prototype.removeShaderAt = function removeShaderAt(index) {
    if (!this._shaders[index]) {
      return false;
    }
    this._shaders.splice(index, 1);
    return true;
  };

  /**
   * Returns the bounds for this DisplayObject
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  DisplayObject.prototype.getBounds = function getBounds() {
    return this._bounds.clone();
  };

  // -------------------------------------------------------------------------- GETTERS / SETTERS

  /**
   * Returns the current position
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  DisplayObject.prototype.getPosition = function getPosition() {
    return this._position;
  };

  /**
   * Sets the position to the given one
   * @param {PhotoEditorSDK.Math.Vector2|Number} x
   * @param {Number} [y]
   */


  DisplayObject.prototype.setPosition = function setPosition(position, y) {
    if (position instanceof _globals.Vector2) {
      this._position.copy(position);
    } else {
      this._position.set(position, y);
    }
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  };

  /**
   * Returns the current scale
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  DisplayObject.prototype.getScale = function getScale() {
    return this._scale;
  };

  /**
   * Sets the scale to the given one
   * @param {PhotoEditorSDK.Math.Vector2|Number} x
   * @param {Number} [y]
   */


  DisplayObject.prototype.setScale = function setScale(scale, y) {
    if (scale instanceof _globals.Vector2) {
      this._scale.copy(scale);
    } else {
      this._scale.set(scale, y);
    }
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  };

  /**
   * Returns the current pivot (The point that this Displayobject rotates around)
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  DisplayObject.prototype.getPivot = function getPivot() {
    return this._pivot;
  };

  /**
   * Sets the pivot (The point that this DisplayObject rotates around)
   * @param {PhotoEditorSDK.Math.Vector2|Number} pivot
   * @param {Number} [y]
   */


  DisplayObject.prototype.setPivot = function setPivot(pivot, y) {
    if (pivot instanceof _globals.Vector2) {
      this._pivot.copy(pivot);
    } else {
      this._pivot.set(pivot, y);
    }
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  };

  /**
   * Returns the current rotation in radians
   * @return {Number}
   */


  DisplayObject.prototype.getRotation = function getRotation() {
    return this._rotation;
  };

  /**
   * Sets this object's rotation (in radians)
   * @param {Number} rotation
   */


  DisplayObject.prototype.setRotation = function setRotation(rotation) {
    this._rotation = rotation;
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  };

  /**
   * Returns the current alpha (0...1)
   * @return {Number}
   */


  DisplayObject.prototype.getAlpha = function getAlpha() {
    return this._alpha;
  };

  /**
   * Sets the alpha (0...1)
   * @param {Number} alpha
   */


  DisplayObject.prototype.setAlpha = function setAlpha(alpha) {
    this._alpha = alpha;
  };

  /**
   * Returns the computed alpha of this DisplayObject
   * @return {Number}
   */


  DisplayObject.prototype.getWorldAlpha = function getWorldAlpha() {
    if (this._parent) {
      return this._parent.getAlpha() * this._alpha;
    } else {
      return this._alpha;
    }
  };

  /**
   * Returns the current world transformation matrix
   * @return {PhotoEditorSDK.Math.Matrix}
   */


  DisplayObject.prototype.getWorldTransform = function getWorldTransform() {
    return this._worldTransform;
  };

  /**
   * Returns the parent object
   * @return {PhotoEditorSDK.Engine.DisplayObject}
   */


  DisplayObject.prototype.getParent = function getParent() {
    return this._parent;
  };

  /**
   * Sets this object's parent object
   * @param {PhotoEditorSDK.Engine.DisplayObject} parent
   */


  DisplayObject.prototype.setParent = function setParent(parent) {
    this._parent = parent;
  };

  /**
   * Returns the filter rectangle
   * @return {PhotoEditorSDK.Math.Rectangle} rectangle
   */


  DisplayObject.prototype.getFilterRectangle = function getFilterRectangle() {
    return this._filterRectangle;
  };

  /**
   * Sets the filter rectangle
   * @param {PhotoEditorSDK.Math.Rectangle} rectangle
   */


  DisplayObject.prototype.setFilterRectangle = function setFilterRectangle(rectangle) {
    this._filterRectangle.copy(rectangle);
  };

  /**
   * Returns the current tint color
   * @return {Number}
   */


  DisplayObject.prototype.getTint = function getTint() {
    return this._tint;
  };

  /**
   * Sets the tint color
   * @param {Number} tint
   */


  DisplayObject.prototype.setTint = function setTint(tint) {
    this._tint = tint;
  };

  /**
   * Checks whether this object is currently visible
   * @return {Boolean} [description]
   */


  DisplayObject.prototype.isVisible = function isVisible() {
    return this._visible;
  };

  /**
   * Sets this object's visibility
   * @param {Boolean} visible
   */


  DisplayObject.prototype.setVisible = function setVisible(visible) {
    this._visible = visible;
  };

  return DisplayObject;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = DisplayObject;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _configurable = __webpack_require__(16);

var _configurable2 = _interopRequireDefault(_configurable);

var _shader = __webpack_require__(48);

var _shader2 = _interopRequireDefault(_shader);

var _textureShader = __webpack_require__(49);

var _textureShader2 = _interopRequireDefault(_textureShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType,
    RendererType = _globals.Constants.RendererType;

/**
 * A filter can be attached to a DisplayObject and affects the way it is displayed.
 * @class
 * @extends PhotoEditorSDK.Configurable
 * @memberof PhotoEditorSDK.Engine
 */

var Filter = function (_Configurable) {
  (0, _inherits3.default)(Filter, _Configurable);

  function Filter() {
    (0, _classCallCheck3.default)(this, Filter);
    return (0, _possibleConstructorReturn3.default)(this, _Configurable.apply(this, arguments));
  }

  /**
   * Goes through the available options, sets _options defaults
   * @param {Object} userOptions
   * @override
   * @protected
   */
  Filter.prototype._initOptions = function _initOptions() {
    var userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._shaders = [];
    this._availableUniforms = _textureShader2.default.defaultUniforms;
    this._attributes = _textureShader2.default.defaultAttributes;
    this._vertexSource = _textureShader2.default.defaultVertexSource;
    this._fragmentSource = _textureShader2.default.defaultFragmentSource;

    this._initUniforms();
    _Configurable.prototype._initOptions.call(this, userOptions);
  };

  /**
   * Initializes the uniforms
   * @private
   */


  Filter.prototype._initUniforms = function _initUniforms() {
    this._uniforms = {};
    for (var name in this._availableUniforms) {
      var uniform = this._availableUniforms[name];
      this._uniforms[name] = {
        type: uniform.type,
        value: uniform.default || null
      };
    }

    // Options are also turned into uniforms
    for (var optionName in this.availableOptions) {
      var optionConfig = this.availableOptions[optionName];

      if (!optionConfig.uniformType) {
        _globals.Log.trace(this.constructor.name, 'Option `' + optionName + '` is missing a `uniformType`!');
      } else {
        this._uniforms['u_' + optionName] = {
          type: optionConfig.uniformType,
          value: optionConfig.default || null
        };
      }
    }
  };

  /**
   * Sets the value for the given option, validates it
   * @param {String} optionName
   * @param {*} value
   * @param {Boolean} update = true
   * @override
   */


  Filter.prototype.setOption = function setOption(optionName, value) {
    var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    _Configurable.prototype.setOption.call(this, optionName, value, update);

    var uniformValue = value;
    var optionConfig = this.availableOptions[optionName];

    if (!optionConfig.uniformType) {
      return;
    }

    var uniformName = 'u_' + optionName;

    switch (optionConfig.type) {
      case OptionType.COLOR:
        if (optionConfig.uniformType === UniformType.FLOAT4) {
          uniformValue = value.toGLColor();
        } else if (optionConfig.uniformType === UniformType.FLOAT3) {
          uniformValue = value.toRGBGLColor();
        }
        break;
      case OptionType.VECTOR2:
        uniformValue = [value.x, value.y];
        break;
      case OptionType.COLOR_MATRIX:
        // a color matrix splits into 4x4 matrix and tranlation vector
        uniformValue = [value.a, value.b, value.c, value.d, value.f, value.g, value.h, value.i, value.k, value.l, value.m, value.n, value.p, value.q, value.r, value.s];
        var vectorValue = [value.e, value.j, value.o, value.t];
        this._uniforms[uniformName + '_vec'] = {
          value: vectorValue,
          type: UniformType.FLOAT4
        };
    }

    this.setUniform(uniformName, uniformValue);
  };

  /**
   * Sets the given uniform to the given value
   * @param {String} name
   * @param {*} value
   * @param {Boolean} sync = false
   */


  Filter.prototype.setUniform = function setUniform(name, value) {
    var sync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    this._uniforms[name].value = value;
  };

  /**
   * Sets the given uniforms to their values
   * @param {Object}  uniforms
   * @param {Boolean} sync = false
   */
  /* istanbul ignore next */


  Filter.prototype.setUniforms = function setUniforms(uniforms) {
    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    for (var name in uniforms) {
      this._uniforms[name].value = uniforms[name];
      if (sync) {
        this.syncUniform(name);
      }
    }
  };

  /**
   * Synchronizes the uniform with the given name
   * @param  {String} name
   */
  /* istanbul ignore next */


  Filter.prototype.syncUniform = function syncUniform(name) {
    this._shaders.forEach(function (shader) {
      shader.syncUniform(name);
    });
  };

  /**
   * Synchronizes all uniforms with WebGL
   */
  /* istanbul ignore next */


  Filter.prototype.syncUniforms = function syncUniforms() {
    this._shaders.forEach(function (shader) {
      shader.syncUniforms();
    });
  };

  /**
   * Returns the shader for the given renderer
   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
   * @return {PhotoEditorSDK.Engine.Shader}
   */
  /* istanbul ignore next */


  Filter.prototype.getShaderForRenderer = function getShaderForRenderer(renderer) {
    var gl = renderer.getContext();
    var shader = this._shaders[gl.id];

    if (!shader) {
      shader = new _shader2.default(renderer, this._vertexSource, this._fragmentSource, this._uniforms, this._attributes);

      this._shaders[gl.id] = shader;
    }

    return shader;
  };

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget
   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param  {PhotoEditorSDK.Engine.RenderTarget} inputTarget
   * @param  {PhotoEditorSDK.Engine.RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   */


  Filter.prototype.apply = function apply(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    /* istanbul ignore if */
    if (renderer.isOfType(RendererType.WEBGL)) {
      this._applyWebGL(renderer, inputTarget, outputTarget, clear);
    } else if (renderer.isOfType(RendererType.CANVAS)) {
      this._applyCanvas(renderer, inputTarget, outputTarget, clear);
    }
  };

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the WebGLRenderer
   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
   * @param  {PhotoEditorSDK.Engine.WebGLRenderTarget} inputTarget
   * @param  {PhotoEditorSDK.Engine.WebGLRenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */
  /* istanbul ignore next */


  Filter.prototype._applyWebGL = function _applyWebGL(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var gl = renderer.getContext();
    var shader = this.getShaderForRenderer(renderer);

    renderer.setRenderTarget(outputTarget);
    if (clear) {
      outputTarget.clear();
    }

    renderer.setShader(shader);

    var projectionMatrix = renderer.getCurrentRenderTarget().getProjectionMatrix().toArray();
    shader.setUniform('u_projMatrix', projectionMatrix);
    shader.syncUniforms();

    // Render!
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, inputTarget.getTexture());
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
  };

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {PhotoEditorSDK.Engine.CanvasRenderer} renderer
   * @param  {PhotoEditorSDK.Engine.RenderTarget} inputTarget
   * @param  {PhotoEditorSDK.Engine.RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  Filter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var outputContext = outputTarget.getContext();

    _globals.Log.warn(this.constructor.name, '`_applyCanvas` is not implemented. Just copying image data from `inputTarget` to `outputTarget`.');

    outputContext.clearRect(0, 0, canvas.width, canvas.height);
    outputContext.drawImage(canvas, 0, 0);
  };

  /**
   * Disposes this Filter
   */


  Filter.prototype.dispose = function dispose() {
    this._shaders.forEach(function (shader) {
      return shader.dispose();
    });
    this._shaders = [];
  };

  return Filter;
}(_configurable2.default);

exports.default = Filter;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(6);

var _canvasRenderTarget = __webpack_require__(33);

var _canvasRenderTarget2 = _interopRequireDefault(_canvasRenderTarget);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Manages the filters for a {@link PhotoEditorSDK.Engine.CanvasRenderer}
 * @class
 * @memberof PhotoEditorSDK.Engine
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CanvasFilterManager = function () {
  function CanvasFilterManager(renderer) {
    (0, _classCallCheck3.default)(this, CanvasFilterManager);

    this._renderer = renderer;
    this._filterStack = [{
      renderTarget: renderer.getCurrentRenderTarget(),
      filters: []
    }];

    this._currentFrame = null;
    this._textures = [];
    this._textureFrame = new _globals.Rectangle(0, 0, renderer.getWidth(), renderer.getHeight());
  }

  /**
   * Resizes this FilterManager and its textures to the given dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   */


  CanvasFilterManager.prototype.resizeTo = function resizeTo(dimensions) {
    this._textureFrame.width = dimensions.x;
    this._textureFrame.height = dimensions.y;

    this._textures.forEach(function (texture) {
      return texture.resizeTo(dimensions);
    });
  };

  /**
   * Pushes the given filters to the
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   * @param  {Array.<Filter>} filters
   */


  CanvasFilterManager.prototype.pushFilters = function pushFilters(displayObject, filters) {
    var bounds = displayObject.getBounds();
    this._currentFrame = bounds;

    var renderTarget = this._getOrCreateRenderTarget();
    this._renderer.setRenderTarget(renderTarget);
    this._filterStack.push({ renderTarget: renderTarget, filters: filters });
  };

  /**
   * Removes, applies and returns the last filters from the stack
   * @return {Object}
   */


  CanvasFilterManager.prototype.popFilters = function popFilters() {
    var _filterStack$pop = this._filterStack.pop(),
        filters = _filterStack$pop.filters,
        renderTarget = _filterStack$pop.renderTarget;

    var lastFilter = this._filterStack[this._filterStack.length - 1];

    var inputRenderTarget = renderTarget;
    var outputRenderTarget = lastFilter.renderTarget;

    if (filters.length === 1) {
      filters[0].apply(this._renderer, inputRenderTarget, outputRenderTarget);
      this._textures.push(inputRenderTarget);
    } else {
      this._applyFilters(filters, inputRenderTarget, outputRenderTarget);
    }
    return filters;
  };

  /**
   * Applies the given filters to the given inputRenderTarget and outputs
   * the filtered content to the outputRenderTarget
   * @param  {PhotoEditorSDK.Engine.Filter[]} filters
   * @param  {PhotoEditorSDK.Engine.CanvasRenderTarget} inputRenderTarget
   * @param  {PhotoEditorSDK.Engine.CanvasRenderTarget} outputRenderTarget
   * @private
   */


  CanvasFilterManager.prototype._applyFilters = function _applyFilters(filters, inputRenderTarget, outputRenderTarget) {
    var _this = this;

    var flipRenderTarget = inputRenderTarget;
    var flopRenderTarget = this._getOrCreateRenderTarget(true);

    var lastFilter = filters[filters.length - 1];
    filters.forEach(function (filter, i) {
      var isLastFilter = filter === lastFilter;

      if (!isLastFilter) {
        // Render from flip to flop with filter
        filter.apply(_this._renderer, flipRenderTarget, flopRenderTarget);

        // Flip the render buffers
        var temp = flipRenderTarget;
        flipRenderTarget = flopRenderTarget;
        flopRenderTarget = temp;
      } else {
        // Render to output
        filter.apply(_this._renderer, flipRenderTarget, outputRenderTarget);
      }
    });

    // Push the textures back into the texture pool to use them again later
    this._textures.push(flipRenderTarget);
    this._textures.push(flopRenderTarget);
  };

  /**
   * Returns a render buffer from the pool or creates a new one
   * @param  {Boolean} clear
   * @return {PhotoEditorSDK.Engine.RenderTexture}
   * @private
   */


  CanvasFilterManager.prototype._getOrCreateRenderTarget = function _getOrCreateRenderTarget(clear) {
    var renderTarget = this._textures.pop();
    if (!renderTarget) {
      renderTarget = new _canvasRenderTarget2.default(this._textureFrame.width, this._textureFrame.height, 1);
    }

    if (clear) {
      renderTarget.clear();
    }

    return renderTarget;
  };

  /**
   * Sets the filter stack to the given stack
   * @param {Object[]} filterStack
   */


  CanvasFilterManager.prototype.setFilterStack = function setFilterStack(filterStack) {
    this._filterStack = filterStack;
  };

  /**
   * Disposes this CanvasFilterManager
   */


  CanvasFilterManager.prototype.dispose = function dispose() {};

  return CanvasFilterManager;
}();

exports.default = CanvasFilterManager;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(6);

var _webglRenderTarget = __webpack_require__(34);

var _webglRenderTarget2 = _interopRequireDefault(_webglRenderTarget);

var _quad = __webpack_require__(110);

var _quad2 = _interopRequireDefault(_quad);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RendererType = _globals.Constants.RendererType; /*
                                                     * This file is part of PhotoEditorSDK.
                                                     *
                                                     * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                     * All rights reserved.
                                                     *
                                                     * Redistribution and use in source and binary forms, without
                                                     * modification, are permitted provided that the following license agreement
                                                     * is approved and a legal/financial contract was signed by the user.
                                                     * The license agreement can be found under following link:
                                                     *
                                                     * https://www.photoeditorsdk.com/LICENSE.txt
                                                     */

/**
 * Manages the filters for a {@link PhotoEditorSDK.Engine.WebGLRenderer}
 * @class
 * @memberof PhotoEditorSDK.Engine
 */
/* istanbul ignore next */
var WebGLFilterManager = function () {
  function WebGLFilterManager(renderer) {
    (0, _classCallCheck3.default)(this, WebGLFilterManager);

    this._renderer = renderer;
    this._filterStack = [{
      filters: []
    }];

    this._currentFrame = null;
    this._renderTargets = [];
    this._textureFrame = new _globals.Rectangle(0, 0, renderer.getWidth(), renderer.getHeight());

    this._onContextChange = this._onContextChange.bind(this);
    this._renderer.on('context', this._onContextChange);

    // Initial context
    this._onContextChange();
  }

  /**
   * Resizes this FilterManager and its textures to the given dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   */


  WebGLFilterManager.prototype.resizeTo = function resizeTo(dimensions) {
    this._textureFrame.width = dimensions.x;
    this._textureFrame.height = dimensions.y;

    this._renderTargets.forEach(function (texture) {
      return texture.resizeTo(dimensions);
    });
  };

  /**
   * Returns the filter stack
   * @return {Object[]}
   */


  WebGLFilterManager.prototype.getFilterStack = function getFilterStack() {
    return this._filterStack;
  };

  /**
   * Sets the filter stack to the given stack
   * @param {Object[]} filterStack
   */


  WebGLFilterManager.prototype.setFilterStack = function setFilterStack(filterStack) {
    this._filterStack = filterStack;
  };

  /**
   * Returns a render target from the pool or creates a new one
   * @param  {Boolean} clear
   * @return {PhotoEditorSDK.Engine.WebGLRenderTarget}
   * @private
   */


  WebGLFilterManager.prototype._getOrCreateRenderTarget = function _getOrCreateRenderTarget(clear) {
    var renderTarget = this._renderTargets.pop();
    if (!renderTarget) {
      renderTarget = new _webglRenderTarget2.default(this._renderer, this._textureFrame.width, this._textureFrame.height, 1);
    }
    renderTarget.setFrame(this._currentFrame);

    if (clear) {
      renderTarget.clear();
    }

    return renderTarget;
  };

  /**
   * Pushes the given filters to the
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   * @param  {PhotoEditorSDK.Engine.Filter[]} filters
   */


  WebGLFilterManager.prototype.pushFilters = function pushFilters(displayObject, filters) {
    var bounds = displayObject.getBounds();
    this._currentFrame = bounds;

    var filterRectangle = displayObject.getFilterRectangle();
    if (filterRectangle.width > 0 && filterRectangle.height > 0) {
      this._currentFrame = filterRectangle;
    }

    var renderTarget = this._getOrCreateRenderTarget();
    this._renderer.setRenderTarget(renderTarget);
    renderTarget.clear();

    this._filterStack.push({ renderTarget: renderTarget, filters: filters });
  };

  /**
   * Removes, applies and returns the last filters from the stack
   * @return {Object}
   */


  WebGLFilterManager.prototype.popFilters = function popFilters() {
    var _filterStack$pop = this._filterStack.pop(),
        filters = _filterStack$pop.filters,
        renderTarget = _filterStack$pop.renderTarget;

    var lastFilter = this._filterStack[this._filterStack.length - 1];

    var inputRenderTarget = renderTarget;
    var outputRenderTarget = lastFilter.renderTarget;

    // Update the Quad's buffers
    this._quad.map(this._textureFrame, inputRenderTarget.getFrame());

    var shader = filters[0].getShaderForRenderer(this._renderer);
    var vertexBuffer = this._quad.getVertexBuffer();
    var indexBuffer = this._quad.getIndexBuffer();

    var gl = this._renderer.getContext();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

    var attributeLocations = shader.getAttributeLocations();
    gl.vertexAttribPointer(attributeLocations.a_position, 2, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(attributeLocations.a_texCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
    gl.vertexAttribPointer(attributeLocations.a_color, 4, gl.FLOAT, false, 0, 4 * 4 * 4);

    this._renderer.updateTexture(inputRenderTarget.getBaseTexture(), false);

    if (filters.length === 1) {
      filters[0].apply(this._renderer, inputRenderTarget, outputRenderTarget);
      this._renderTargets.push(inputRenderTarget);
    } else {
      this._applyFilters(filters, inputRenderTarget, outputRenderTarget);
    }

    return filters;
  };

  /**
   * Applies the given filters to the given inputRenderTarget and outputs
   * the filtered content to the outputRenderTarget
   * @param  {PhotoEditorSDK.Engine.Filter[]} filters
   * @param  {PhotoEditorSDK.Engine.WebGLRenderTarget} inputRenderTarget
   * @param  {PhotoEditorSDK.Engine.WebGLRenderTarget} outputRenderTarget
   */


  WebGLFilterManager.prototype._applyFilters = function _applyFilters(filters, inputRenderTarget, outputRenderTarget) {
    var _this = this;

    var flipRenderTarget = inputRenderTarget;
    var flopRenderTarget = this._getOrCreateRenderTarget(true);

    this._renderer.updateTexture(flopRenderTarget.getBaseTexture(), false);

    var lastFilter = filters[filters.length - 1];
    filters.forEach(function (filter, i) {
      var isLastFilter = filter === lastFilter;

      if (!isLastFilter) {
        // Render from flip to flop with filter
        filter.apply(_this._renderer, flipRenderTarget, flopRenderTarget);

        // Flip the render targets
        var temp = flipRenderTarget;
        flipRenderTarget = flopRenderTarget;
        flopRenderTarget = temp;
      } else {
        // Render to output
        filter.apply(_this._renderer, flipRenderTarget, outputRenderTarget);
      }
    });

    // Push the textures back into the texture pool to use them again later
    this._renderTargets.push(flipRenderTarget);
    this._renderTargets.push(flopRenderTarget);
  };

  /**
   * Gets called when the WebGL context has been changed
   * @private
   */


  WebGLFilterManager.prototype._onContextChange = function _onContextChange() {
    this._renderTargets.length = 0;
    /* istanbul ignore next */
    if (this._renderer.isOfType(RendererType.WEBGL)) {
      if (this._quad) {
        this._quad.dispose();
      }
      this._quad = new _quad2.default(this._renderer);
    }
  };

  /**
   * Disposes this WebGLFilterManager
   */


  WebGLFilterManager.prototype.dispose = function dispose() {
    this._renderer.off('context', this._onContextChange);
    if (this._quad) {
      this._quad.dispose();
    }
    this._renderTargets.forEach(function (target) {
      target.dispose();
    });
  };

  return WebGLFilterManager;
}();

exports.default = WebGLFilterManager;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(6);

var _globals2 = _interopRequireDefault(_globals);

var _constants = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Log = _globals2.default.Log,
    Utils = _globals2.default.Utils;

/**
 * Represents a WebGL shader with a vertex shader, a fragment shader, uniforms and attributes
 * @class
 * @memberof PhotoEditorSDK.Engine
 */
/* istanbul ignore next */

var Shader = function () {
  /**
   * Creates a Shader
   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param  {String} vertexSource
   * @param  {String} fragmentSource
   * @param  {Object} uniforms
   * @param  {String[]} attributes
   */
  function Shader(renderer, vertexSource, fragmentSource, uniforms, attributes) {
    (0, _classCallCheck3.default)(this, Shader);

    this._renderer = renderer;
    this._vertexSource = vertexSource;
    this._fragmentSource = fragmentSource;
    this._uniforms = uniforms || {};
    this._uniformLocations = {};
    this._attributes = attributes || [];
    this._attributeLocations = {};

    this._onContextChange = this._onContextChange.bind(this);
    this._renderer.on('context', this._onContextChange);

    this._init();
  }

  /**
   * Compiles this shader and caches the uniform locations
   * @private
   */


  Shader.prototype._init = function _init() {
    this._compile();

    var gl = this._renderer.getContext();
    gl.useProgram(this._program);

    this._cacheUniformLocations();
    this._cacheAttributeLocations();
  };

  /**
   * Gets called when the attached Renderer changes its context
   * @private
   */


  Shader.prototype._onContextChange = function _onContextChange() {
    this._init();
  };

  /**
   * Binds the given buffers for this shader
   * @param {WebGLBuffer} vertexBuffer
   * @param {WebGLBuffer} indexBuffer
   */


  Shader.prototype.setupBuffers = function setupBuffers(vertexBuffer, indexBuffer) {
    var gl = this._renderer.getContext();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

    gl.vertexAttribPointer(this._attributeLocations.a_position, 2, gl.FLOAT, false, _globals2.default.VERTEX_BYTE_SIZE, 0);
    gl.vertexAttribPointer(this._attributeLocations.a_texCoord, 2, gl.FLOAT, false, _globals2.default.VERTEX_BYTE_SIZE, 2 * 4);
    gl.vertexAttribPointer(this._attributeLocations.a_color, 4, gl.UNSIGNED_BYTE, true, _globals2.default.VERTEX_BYTE_SIZE, 4 * 4);
  };

  /**
   * Synchronizes all uniforms with WebGL
   */


  Shader.prototype.syncUniforms = function syncUniforms() {
    var _this = this;

    Object.keys(this._uniforms).forEach(function (key) {
      _this.syncUniform(key);
    });
  };

  /**
   * Synchronizes the uniform with the given name
   * @param  {String} name
   */


  Shader.prototype.syncUniform = function syncUniform(name) {
    var gl = this._renderer.getContext();
    var uniform = this._uniforms[name];
    var location = this._uniformLocations[name];
    switch (uniform.type) {
      case _constants.UniformType.SAMPLER2D:
      case _constants.UniformType.INT:
      case _constants.UniformType.INT1:
        gl.uniform1i(location, uniform.value);
        break;
      case _constants.UniformType.FLOAT:
      case _constants.UniformType.FLOAT1:
        gl.uniform1f(location, uniform.value);
        break;
      case _constants.UniformType.FLOAT2:
        gl.uniform2f(location, uniform.value[0], uniform.value[1]);
        break;
      case _constants.UniformType.FLOAT3:
        gl.uniform3f(location, uniform.value[0], uniform.value[1], uniform.value[2]);
        break;
      case _constants.UniformType.FLOAT4:
        gl.uniform4f(location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);
        break;
      case _constants.UniformType.FLOAT_VECTOR2:
        gl.uniform2fv(location, uniform.value);
        break;
      case _constants.UniformType.MAT3:
      case _constants.UniformType.MAT3FV:
        gl.uniformMatrix3fv(location, false, uniform.value);
        break;
      case _constants.UniformType.MAT4:
        gl.uniformMatrix4fv(location, false, uniform.value);
        break;
      default:
        Log.warn(this.constructor.name, 'Unknown uniform type: ' + uniform.type);
    }
  };

  /**
   * Caches the locations for all attributes
   * @private
   */


  Shader.prototype._cacheAttributeLocations = function _cacheAttributeLocations() {
    var _this2 = this;

    var gl = this._renderer.getContext();
    this._attributes.forEach(function (name) {
      _this2._attributeLocations[name] = gl.getAttribLocation(_this2._program, name);
    });
  };

  /**
   * Caches the locations for all uniforms
   * @private
   */


  Shader.prototype._cacheUniformLocations = function _cacheUniformLocations() {
    var _this3 = this;

    var gl = this._renderer.getContext();
    var keys = Object.keys(this._uniforms);
    keys.forEach(function (key) {
      _this3._uniformLocations[key] = gl.getUniformLocation(_this3._program, key);
    });
  };

  /**
   * Adds the preferred precision for the current device to the given shader source
   * @param  {String} source
   * @return {String}
   */


  Shader.prototype._addPrecisionToSource = function _addPrecisionToSource(source) {
    var maxFloatPrecision = this._renderer.getMaxFloatPrecision();

    var precision = 'mediump';
    if (Utils.isMobile() && maxFloatPrecision === 'highp') {
      precision = 'highp';
    }

    return 'precision ' + precision + ' float;\n' + source;
  };

  /**
   * Compiles the vertex and fragment sources of this shader
   * @private
   */


  Shader.prototype._compile = function _compile() {
    var gl = this._renderer.getContext();

    var vertexShader = this._compileShader(gl.VERTEX_SHADER, this._vertexSource);
    this._vertexShader = vertexShader;

    var fragmentSource = this._addPrecisionToSource(this._fragmentSource);
    var fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, fragmentSource);
    this._fragmentShader = fragmentShader;

    // Create the WebGL program and attach the shaders
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);

    // Link the program
    gl.linkProgram(program);

    // Check linking status
    // Check linking status
    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      var errorMessage = gl.getProgramInfoLog(program);
      if (gl.isContextLost()) errorMessage = 'WebGL context lost';
      gl.deleteProgram(program);
      Log.error(this.constructor.name, 'WebGL program linking error: ' + errorMessage);
    }

    this._program = program;
  };

  /**
   * Creates and compiles a shader with the given type and source
   * @param  {Number} shaderType
   * @param  {String} shaderSource
   * @return {WebGLShader}
   * @private
   */


  Shader.prototype._compileShader = function _compileShader(shaderType, shaderSource) {
    var gl = this._renderer.getContext();

    // Create the shader and compile it
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);

    // Check compilation status
    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!compiled) {
      var errorMessage = gl.getShaderInfoLog(shader);
      if (gl.isContextLost()) errorMessage = 'WebGL context lost';
      gl.deleteShader(shader);
      Log.error(this.constructor.name, 'WebGL shader compilation error: ' + errorMessage);
    }

    return shader;
  };

  /**
   * Sets the given uniform to the given value
   * @param {String} name
   * @param {*} value
   * @param {Boolean} sync = false
   */


  Shader.prototype.setUniform = function setUniform(name, value) {
    var sync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    this._uniforms[name].value = value;
    if (sync) {
      this.syncUniform(name);
    }
  };

  /**
   * Sets the given uniforms to their values
   * @param {Object}  uniforms
   * @param {Boolean} sync = false
   */


  Shader.prototype.setUniforms = function setUniforms(uniforms) {
    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    for (var name in uniforms) {
      this._uniforms[name].value = uniforms[name];
      if (sync) {
        this.syncUniform(name);
      }
    }
  };

  /**
   * Returns the uniforms
   * @return {Object}
   */


  Shader.prototype.getUniforms = function getUniforms() {
    return this._uniforms;
  };

  /**
   * Returns the attributes
   * @return {String[]}
   */


  Shader.prototype.getAttributes = function getAttributes() {
    return this._attributes;
  };

  /**
   * Returns the attribute locations
   * @return {Object}
   */


  Shader.prototype.getAttributeLocations = function getAttributeLocations() {
    return this._attributeLocations;
  };

  /**
   * Returns this shader's WebGL program
   * @return {WebGLProgram}
   */


  Shader.prototype.getProgram = function getProgram() {
    return this._program;
  };

  /**
   * Cleans up this shader
   */


  Shader.prototype.dispose = function dispose() {
    var gl = this._renderer.getContext();
    gl.deleteProgram(this._program);

    gl.deleteShader(this._vertexShader);
    gl.deleteShader(this._fragmentShader);

    this._uniforms = null;
    this._uniformLocations = null;
    this._attributes = null;
    this._attributeLocations = null;

    this._renderer.off('context', this._onContextChange);
  };

  return Shader;
}();

exports.default = Shader;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _shader = __webpack_require__(48);

var _shader2 = _interopRequireDefault(_shader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UniformType = _globals.Constants.UniformType; /*
                                                   * This file is part of PhotoEditorSDK.
                                                   *
                                                   * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                   * All rights reserved.
                                                   *
                                                   * Redistribution and use in source and binary forms, without
                                                   * modification, are permitted provided that the following license agreement
                                                   * is approved and a legal/financial contract was signed by the user.
                                                   * The license agreement can be found under following link:
                                                   *
                                                   * https://www.photoeditorsdk.com/LICENSE.txt
                                                   */

/**
 * The default texture shader
 * @class
 * @extends PhotoEditorSDK.Engine.Shader
 * @memberof PhotoEditorSDK.Engine
 */
/* istanbul ignore next */
var TextureShader = function (_Shader) {
  (0, _inherits3.default)(TextureShader, _Shader);

  /**
   * Creates a TextureShader
   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param  {String} vertexSource
   * @param  {String} fragmentSource
   */
  function TextureShader(renderer, vertexSource, fragmentSource) {
    (0, _classCallCheck3.default)(this, TextureShader);

    vertexSource = vertexSource || TextureShader.defaultVertexSource;
    fragmentSource = fragmentSource || TextureShader.defaultFragmentSource;

    return (0, _possibleConstructorReturn3.default)(this, _Shader.call(this, renderer, vertexSource, fragmentSource, TextureShader.defaultUniforms, TextureShader.defaultAttributes));
  }

  return TextureShader;
}(_shader2.default);

/**
 * The default vertex shader source code
 * @type {String}
 */


TextureShader.defaultVertexSource = __webpack_require__(234);

/**
 * The default fragment shader source code
 * @type {String}
 */
TextureShader.defaultFragmentSource = __webpack_require__(233);

var matrix = new _globals.Matrix();

/**
 * The default uniforms
 * @type {Object}
 */
TextureShader.defaultUniforms = {
  u_image: {
    type: UniformType.SAMPLER2D,
    value: 0
  },
  u_projMatrix: {
    type: UniformType.MAT3,
    value: matrix.toArray()
  }
};

/**
 * The default WebGL attributes
 * @type {String[]}
 */
TextureShader.defaultAttributes = ['a_position', 'a_texCoord', 'a_color'];

exports.default = TextureShader;

/***/ },
/* 50 */
/***/ function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ },
/* 51 */
/***/ function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ },
/* 52 */
/***/ function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ },
/* 53 */
/***/ function(module, exports) {

module.exports = true;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(25)
  , dPs         = __webpack_require__(212)
  , enumBugKeys = __webpack_require__(52)
  , IE_PROTO    = __webpack_require__(57)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(89)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(205).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ },
/* 55 */
/***/ function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

var def = __webpack_require__(19).f
  , has = __webpack_require__(18)
  , TAG = __webpack_require__(14)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

var shared = __webpack_require__(58)('keys')
  , uid    = __webpack_require__(42);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

var global = __webpack_require__(15)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ },
/* 59 */
/***/ function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(31);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

var global         = __webpack_require__(15)
  , core           = __webpack_require__(13)
  , LIBRARY        = __webpack_require__(53)
  , wksExt         = __webpack_require__(62)
  , defineProperty = __webpack_require__(19).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(14);

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var $at  = __webpack_require__(216)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(91)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(223);
var global        = __webpack_require__(15)
  , hide          = __webpack_require__(26)
  , Iterators     = __webpack_require__(32)
  , TO_STRING_TAG = __webpack_require__(14)('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ },
/* 65 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(65).nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66).setImmediate, __webpack_require__(66).clearImmediate))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorMatrix = exports.Matrix = exports.Rectangle = exports.Vector2 = undefined;

var _vector = __webpack_require__(23);

var _vector2 = _interopRequireDefault(_vector);

var _rectangle = __webpack_require__(79);

var _rectangle2 = _interopRequireDefault(_rectangle);

var _matrix = __webpack_require__(78);

var _matrix2 = _interopRequireDefault(_matrix);

var _colorMatrix = __webpack_require__(35);

var _colorMatrix2 = _interopRequireDefault(_colorMatrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Some classes that help us do the math
 * @namespace PhotoEditorSDK.Math
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

exports.Vector2 = _vector2.default;
exports.Rectangle = _rectangle2.default;
exports.Matrix = _matrix2.default;
exports.ColorMatrix = _colorMatrix2.default;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _eventEmitter = __webpack_require__(28);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Holds an array of {@link PhotoEditorSDK.Operation} instances and handles their dirtiness
 * @class
 * @memberof PhotoEditorSDK
 */
var OperationsStack = function (_EventEmitter) {
  (0, _inherits3.default)(OperationsStack, _EventEmitter);

  /**
   * Creates an OperationsStack
   * @param  {PhotoEditorSDK.Operation[]} [operations = []]
   */
  function OperationsStack() {
    var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    (0, _classCallCheck3.default)(this, OperationsStack);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._onOperationUpdate = _this._onOperationUpdate.bind(_this);

    _this._cacheEnabled = true;
    _this._stack = operations;
    _this._stack.forEach(function (operation) {
      operation.on('update', _this._onOperationUpdate);
    });
    return _this;
  }

  /**
   * Clears this operations stack
   */


  OperationsStack.prototype.clear = function clear() {
    var _this2 = this;

    this.forEach(function (operation) {
      return _this2.remove(operation);
    });
    this._stack = [];
  };

  /**
   * Gets called when an operation is about to be updated
   * @param  {PhotoEditorSDK.Operation} operation
   * @param  {Object} options
   * @private
   */


  OperationsStack.prototype._onOperationUpdate = function _onOperationUpdate(operation, options) {
    this.emit(_globals.Constants.Events.OPERATION_UPDATED, operation, options);
  };

  /**
   * Enables the cache on all operations
   */


  OperationsStack.prototype.enableCache = function enableCache() {
    this._cacheEnabled = true;
  };

  /**
   * Disables the cache on all operations
   */


  OperationsStack.prototype.disableCache = function disableCache() {
    this._cacheEnabled = false;
  };

  /**
   * Passes Array#forEach
   * @param  {Function} iterator
   * @return {Array}
   */


  OperationsStack.prototype.forEach = function forEach(iterator) {
    return this._stack.filter(function (op) {
      return !!op;
    }).forEach(iterator);
  };

  /**
   * Renders all operations
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @return {Promise}
   */


  OperationsStack.prototype.render = function render(sdk, inputTexture) {
    var _this3 = this;

    var currentTexture = inputTexture;
    var operations = this._stack.filter(function (op) {
      return !!op;
    }).filter(function (op) {
      return op.getEnabled();
    });

    // Find first operation from end of array that is not dirty
    operations.reverse();
    var firstUndirtyOperation = operations.filter(function (o) {
      return !o.isDirtyForRenderer(sdk.getRenderer());
    })[0];
    var firstUndirtyIndex = operations.indexOf(firstUndirtyOperation);

    operations.reverse();

    // Skip operations that would be overwritten by succeeding operations
    var startIndex = 0;
    if (firstUndirtyIndex !== -1) {
      startIndex = operations.length - firstUndirtyIndex - 1;
    }

    for (var index = 0; index < startIndex; index++) {
      _globals.Log.info(this.constructor.name, 'Skipping ' + operations[index].constructor.name);
    }

    var promise = _promise2.default.resolve(currentTexture);

    var _loop = function _loop(_index) {
      var operation = operations[_index];
      promise = promise.then(function (inputTexture) {
        return operation.render(inputTexture).then(function (operationOutput) {
          // If cache is disabled, flush textures of previous operation
          if (_index > 0 && !_this3._cacheEnabled) {
            operations[_index - 1].disposeRenderTextures();
          }
          return operationOutput;
        });
      });
    };

    for (var _index = startIndex; _index < operations.length; _index++) {
      _loop(_index);
    }

    return promise;
  };

  /**
   * Validates the settings of all operations
   * @return {Promise}
   */


  OperationsStack.prototype.validateSettings = function validateSettings() {
    return _promise2.default.all(this._stack.filter(function (op) {
      return !!op;
    }).map(function (op) {
      return op.validateSettings();
    }));
  };

  /**
   * Sets all operations to dirty
   * @param {Boolean} dimensionsChanged = falses
   */


  OperationsStack.prototype.setAllToDirty = function setAllToDirty() {
    var dimensionsChanged = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this.forEach(function (op) {
      return op.setDirty(true, dimensionsChanged);
    });
  };

  /**
   * Finds the first dirty operation and sets all following operations to dirty
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   */


  OperationsStack.prototype.updateDirtinessForRenderer = function updateDirtinessForRenderer(renderer) {
    var dirtyFound = false;
    for (var i = 0; i < this._stack.length; i++) {
      var _operation = this._stack[i];
      if (!_operation) continue;
      if (_operation.isDirtyForRenderer(renderer)) {
        dirtyFound = true;
      }

      if (dirtyFound) {
        _operation.setDirtyForRenderer(true, renderer);
      }
    }
  };

  /**
   * Adds the given operation to this stack
   * @param {PhotoEditorSDK.Operation} operation
   */


  OperationsStack.prototype.push = function push(operation) {
    this._stack.push(operation);
    operation.on('update', this._onOperationUpdate);
  };

  /**
   * Adds the given operation before all existing operations
   * @param  {PhotoEditorSDK.Operation} operation
   */


  OperationsStack.prototype.unshift = function unshift(operation) {
    this._stack.unshift(operation);
    operation.on('update', this._onOperationUpdate);
  };

  /**
   * Returns a cloned instance of this stack
   * @return {PhotoEditorSDK.OperationsStack}
   */


  OperationsStack.prototype.clone = function clone() {
    return new OperationsStack(this._stack.slice(0));
  };

  /**
   * Returns the operation at the given index
   * @param  {Number} index
   * @return {PhotoEditorSDK.Operation}
   */


  OperationsStack.prototype.get = function get(index) {
    return this._stack[index];
  };

  /**
   * Sets the operation at the given index to the given one
   * @param  {Number} index
   * @param  {PhotoEditorSDK.Operation} operation
   */


  OperationsStack.prototype.set = function set(index, operation) {
    if (this._stack[index]) {
      this._stack[index].off('update', this._onOperationUpdate);
      this._stack[index].dispose();
    }
    this._stack[index] = operation;
    operation.on('update', this._onOperationUpdate);
  };

  /**
   * Removes the given operation
   * @param  {PhotoEditorSDK.Operation} operation
   */


  OperationsStack.prototype.remove = function remove(operation) {
    var index = this._stack.indexOf(operation);
    if (index === -1) {
      return;
    }
    if (this._stack[index]) {
      this._stack[index].off('update', this._onOperationUpdate);
      this._stack[index].dispose();
    }
    this._stack.splice(index, 1);
  };

  /**
   * Removes the operation at the given index
   * @param  {Number} index
   */


  OperationsStack.prototype.removeAt = function removeAt(index) {
    if (this._stack[index]) {
      this._stack[index].off('update', this._onOperationUpdate);
      this._stack[index].dispose();
    }
    delete this._stack[index];
  };

  /**
   * Returns the stack
   * @return {PhotoEditorSDK.Operation[]}
   */


  OperationsStack.prototype.getStack = function getStack() {
    return this._stack;
  };

  OperationsStack.prototype.dispose = function dispose() {
    this.forEach(function (operation) {
      operation.dispose();
    });
  };

  return OperationsStack;
}(_eventEmitter2.default); /*
                            * This file is part of PhotoEditorSDK.
                            *
                            * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                            * All rights reserved.
                            *
                            * Redistribution and use in source and binary forms, without
                            * modification, are permitted provided that the following license agreement
                            * is approved and a legal/financial contract was signed by the user.
                            * The license agreement can be found under following link:
                            *
                            * https://www.photoeditorsdk.com/LICENSE.txt
                            */

exports.default = OperationsStack;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _filterOperation = __webpack_require__(124);

Object.defineProperty(exports, 'FilterOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_filterOperation).default;
  }
});

var _cropOperation = __webpack_require__(122);

Object.defineProperty(exports, 'CropOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_cropOperation).default;
  }
});

var _orientationOperation = __webpack_require__(173);

Object.defineProperty(exports, 'OrientationOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_orientationOperation).default;
  }
});

var _adjustmentsOperation = __webpack_require__(120);

Object.defineProperty(exports, 'AdjustmentsOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_adjustmentsOperation).default;
  }
});

var _linearFocusOperation = __webpack_require__(172);

Object.defineProperty(exports, 'LinearFocusOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_linearFocusOperation).default;
  }
});

var _radialFocusOperation = __webpack_require__(174);

Object.defineProperty(exports, 'RadialFocusOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_radialFocusOperation).default;
  }
});

var _frameOperation = __webpack_require__(171);

Object.defineProperty(exports, 'FrameOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_frameOperation).default;
  }
});

var _spriteOperation = __webpack_require__(178);

Object.defineProperty(exports, 'SpriteOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_spriteOperation).default;
  }
});

var _watermarkOperation = __webpack_require__(185);

Object.defineProperty(exports, 'WatermarkOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_watermarkOperation).default;
  }
});

var _exifOrientationOperation = __webpack_require__(123);

Object.defineProperty(exports, 'ExifOrientationOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_exifOrientationOperation).default;
  }
});

var _selectiveBlurOperation = __webpack_require__(175);

Object.defineProperty(exports, 'SelectiveBlurOperation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_selectiveBlurOperation).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 70 */
/***/ function(module, exports) {

module.exports = {
	"name": "photoeditorsdk",
	"version": "3.6.9",
	"description": "The most comprehensive photo editor SDK for HTML5",
	"repository": "http://github.com/imgly/pesdk-html5",
	"author": "Photo Editor SDK <contact@photoeditorsdk.com>",
	"license": "SEE LICENSE IN LICENSE.md",
	"scripts": {
		"render-filter-previews": "babel-node scripts/render-filter-previews",
		"release": "ENV=production node_modules/.bin/gulp release",
		"release:test": "ENV=test node_modules/.bin/gulp release",
		"release:dev": "ENV=development node_modules/.bin/gulp release",
		"test": "ENV=test node_modules/.bin/mocha --require test/support/node test/sdk test/ui",
		"test:client": "ENV=test REMOTE=true gulp test:client",
		"test:client:local": "ENV=test node --stack-size=65500 node_modules/.bin/gulp test:client",
		"test:webgl": "node_modules/.bin/mocha test-webgl",
		"coveralls": "npm run coverage && cat ./coverage/lcov.info | node_modules/.bin/coveralls && rm -rf ./coverage",
		"coverage": "NODE_ENV=test node_modules/.bin/istanbul cover node_modules/.bin/_mocha --require test/support/node test/sdk test/ui"
	},
	"devDependencies": {
		"ajv": "^4.4.0",
		"babel-core": "^6.23.1",
		"babel-loader": "^6.3.2",
		"babel-plugin-external-helpers-2": "^6.3.13",
		"babel-plugin-transform-es2015-classes": "^6.6.4",
		"babel-plugin-transform-runtime": "^6.6.0",
		"babel-preset-es2015": "^6.6.0",
		"babel-preset-react": "^6.5.0",
		"babel-register": "^6.6.0",
		"babel-runtime": "^6.6.1",
		"babili": "^0.0.11",
		"chai": "^3.4.0",
		"chai-as-promised": "^5.1.0",
		"chromedriver": "^2.23.1",
		"classnames": "^2.1.3",
		"compass-mixins": "^0.12.8",
		"coveralls": "^2.11.2",
		"del": "^2.0.0",
		"gulp": "^3.8.10",
		"gulp-9e-sass-lint": "0.0.8",
		"gulp-babel": "^6.1.2",
		"gulp-changed": "^1.3.0",
		"gulp-jsdoc3": "^0.2.0",
		"gulp-mocha": "^2.2.0",
		"gulp-notify": "^1.3.1",
		"gulp-rename": "~1.2.0",
		"gulp-sass": "^2.0.4",
		"gulp-sequence": "^0.4.1",
		"gulp-sourcemaps": "^1.5.2",
		"gulp-standard": "^8.0.2",
		"gulp-util": "~2.2.16",
		"gulp-watch": "^4.3.5",
		"gulp-webserver": "^0.9.1",
		"gulp-yuicompressor": "0.0.3",
		"inquirer": "^0.11.4",
		"inquirer-path": "^1.0.0-alpha5",
		"istanbul": "^1.1.0-alpha.1",
		"jaguarjs-jsdoc": "git://github.com/imgly/jaguarjs-jsdoc.git#master",
		"jsdoc": "git://github.com/jsdoc3/jsdoc.git#master",
		"json-loader": "^0.5.2",
		"mocha": "^2.3.3",
		"mocha-lcov-reporter": "0.0.1",
		"nightwatch": "git://github.com/saschagehlich/nightwatch.git#feature/upload-file",
		"performance-now": "^0.2.0",
		"preprocess-loader": "^0.2.0",
		"pretty-error": "^2.0.0",
		"prompt": "^1.0.0",
		"raw-loader": "^0.5.1",
		"react": "^15.1.0",
		"react-dom": "^15.1.0",
		"rembrandt": "^0.0.8",
		"require-dir": "^0.3.0",
		"run-sequence": "~0.3.6",
		"selenium-server-standalone-jar": "^2.53.1",
		"should": "^4.3.0",
		"sinon": "^1.17.3",
		"sinon-chai": "^2.8.0",
		"stats.js": "^0.16.0",
		"term-img2": "^2.0.1",
		"transform-loader": "^0.2.2",
		"vinyl-source-stream": "0.1.1",
		"webpack": "2.1.0-beta.25",
		"webpack-notifier": "^1.2.1"
	},
	"standard": {
		"globals": [
			"describe",
			"context",
			"before",
			"beforeEach",
			"after",
			"afterEach",
			"it",
			"expect"
		]
	},
	"dependencies": {
		"canvas": "^1.3.12",
		"gl": "^4.0.3",
		"request": "^2.79.0"
	}
};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _displayObject = __webpack_require__(44);

var _displayObject2 = _interopRequireDefault(_displayObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A container for DisplayObject instances
 * @class
 * @extends PhotoEditorSDK.Engine.DisplayObject
 * @memberof PhotoEditorSDK.Engine
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Container = function (_DisplayObject) {
  (0, _inherits3.default)(Container, _DisplayObject);

  /**
   * Creates a Container
   * @override
   */
  function Container() {
    (0, _classCallCheck3.default)(this, Container);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _DisplayObject.call.apply(_DisplayObject, [this].concat(args)));

    _this._children = [];
    _this._filters = [];
    return _this;
  }

  /**
   * Adds the given filter to the filter stack
   * @param {PhotoEditorSDK.Engine.Filter} filter
   */


  Container.prototype.addFilter = function addFilter(filter) {
    this._filters.push(filter);
  };

  /**
   * Removes the given filter from the filter stack
   * @param  {PhotoEditorSDK.Engine.Filter} filter
   * @return {Boolean} - Whether the filter has been removed
   */


  Container.prototype.removeFilter = function removeFilter(filter) {
    var index = this._filters.indexOf(filter);
    if (index !== -1) {
      this._filters.splice(index, 1);
      return true;
    }
    return false;
  };

  /**
   * Sets the filters
   * @param {Array.<PhotoEditorSDK.Engine.Filter>} filters
   */


  Container.prototype.setFilters = function setFilters(filters) {
    this._filters = filters;
  };

  /**
   * Adds the given DisplayObject to the list of children
   * @param {PhotoEditorSDK.Engine.DisplayObject} child
   */


  Container.prototype.addChild = function addChild(child) {
    // Remove from previous parent
    var originalParent = child.getParent();
    if (originalParent !== null) {
      originalParent.removeChild(child);
    }
    child.setParent(this);

    this._children.push(child);
  };

  /**
   * Prepends the given DisplayObject to the list of children
   * @param  {PhotoEditorSDK.Engine.DisplayObject} child
   */


  Container.prototype.prependChild = function prependChild(child) {
    // Remove from previous parent
    var originalParent = child.getParent();
    if (originalParent !== null) {
      originalParent.removeChild(child);
    }
    child.setParent(this);

    this._children.unshift(child);
  };

  /**
   * Checks whether this container has the given child
   * @param  {PhotoEditorSDK.Engine.DisplayObject}  child
   * @return {Boolean}
   */


  Container.prototype.hasChild = function hasChild(child) {
    var index = this._children.indexOf(child);
    return index !== -1;
  };

  /**
   * Removes the given object from the list of children
   * @param  {PhotoEditorSDK.Engine.DisplayObject} child
   */


  Container.prototype.removeChild = function removeChild(child) {
    var index = this._children.indexOf(child);
    if (index !== -1) {
      this._children.splice(index, 1);
      child.setParent(null);
    } else {
      _globals.Log.info(this.constructor.name, 'Tried to remove a child that does not exist');
    }
  };

  /**
   * Removes all children
   */


  Container.prototype.clearChildren = function clearChildren() {
    this._children = [];
  };

  /**
   * Renders this DisplayObject using the given WebGLRenderer
   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
   * @override
   */


  Container.prototype.renderWebGL = function renderWebGL(renderer) {
    if (!this._visible) {
      return;
    }

    var filterManager = renderer.getFilterManager();
    if (this._filters && this._filters.length) {
      filterManager.pushFilters(this, this._filters);
    }

    renderer.getCurrentObjectRenderer().start();

    this._renderWebGL(renderer);

    this._children.forEach(function (child) {
      child.renderWebGL(renderer);
    });

    renderer.getCurrentObjectRenderer().flush();

    if (this._filters && this._filters.length) {
      filterManager.popFilters();
    }
    renderer.getCurrentObjectRenderer().start();
  };

  /**
   * Renders the contents of this container
   * @param {PhotoEditorSDK.Engine.WebGLRenderer} renderer
   * @protected
   */


  Container.prototype._renderWebGL = function _renderWebGL(renderer) {};

  /**
   * Renders this DisplayObject using the given CanvasRenderer
   * @param  {PhotoEditorSDK.Engine.CanvasRenderer} renderer
   * @override
   */


  Container.prototype.renderCanvas = function renderCanvas(renderer) {
    if (!this._visible) {
      return;
    }

    var filterManager = renderer.getFilterManager();
    if (this._filters && this._filters.length) {
      filterManager.pushFilters(this, this._filters);
    }

    this._renderCanvas(renderer);
    this._children.forEach(function (child) {
      child.renderCanvas(renderer);
    });

    if (this._filters && this._filters.length) {
      filterManager.popFilters();
    }
  };

  /**
   * Renders the contents of this container
   * @param {PhotoEditorSDK.Engine.CanvasRenderer} renderer
   * @protected
   */


  Container.prototype._renderCanvas = function _renderCanvas(renderer) {};

  /**
   * Updates the world transform for this DisplayObject
   */


  Container.prototype.updateTransform = function updateTransform() {
    _DisplayObject.prototype.updateTransform.call(this);
    this._children.forEach(function (child) {
      child.updateTransform();
    });
  };

  /**
   * Returns the non-global bounds of this DisplayObject
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  Container.prototype.getLocalBounds = function getLocalBounds() {
    if (this._localBoundsNeedUpdate) {
      // @TODO Calculate bounds by looking at children
      this._localBoundsNeedUpdate = false;
    }
    return this._localBounds.clone();
  };

  /**
   * Returns the bounds for this DisplayObject
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  Container.prototype.getBounds = function getBounds() {
    if (this._boundsNeedUpdate) {
      // @TODO Calculate bounds by looking at children
      this._boundsNeedUpdate = false;
    }
    return this._bounds.clone();
  };

  /**
   * Returns this Container's children
   * @return {PhotoEditorSDK.Engine.DisplayObject[]}
   */


  Container.prototype.getChildren = function getChildren() {
    return this._children;
  };

  /**
   * Returns this Container's filters
   * @return {PhotoEditorSDK.Engine.Filter[]}
   */


  Container.prototype.getFilters = function getFilters() {
    return this._filters;
  };

  /**
   * Disposes this Container
   */


  Container.prototype.dispose = function dispose() {};

  return Container;
}(_displayObject2.default);

exports.default = Container;

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _utils = __webpack_require__(112);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base class for all renderers
 * @class
 * @memberof PhotoEditorSDK.Engine
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BaseRenderer = function (_EventEmitter) {
  (0, _inherits3.default)(BaseRenderer, _EventEmitter);

  /**
   * Create a BaseRenderer instance
   * @param  {Number} width
   * @param  {Number} height
   * @param  {Object} options = {}
   * @param  {Number} [options.pixelRatio = 1]
   * @param  {PhotoEditorSDK.Color} [options.clearColor = PhotoEditorSDK.Color.TRANSPARENT]
   * @param  {Boolean} [options.debug = false]
   */
  function BaseRenderer(width, height) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck3.default)(this, BaseRenderer);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._options = _utils2.default.defaults(options, {
      pixelRatio: 1,
      transparent: false,
      clearColor: _globals.Color.BLACK,
      debug: false
    });

    _this.setMaxListeners(0);
    _this._width = width || 800;
    _this._height = height || 600;
    _this._dimensions = new _globals.Vector2(_this._width, _this._height);
    _this._maxTextureSize = null;
    _this._pixelRatio = _this._options.pixelRatio;
    _this._clearColor = _this._options.transparent ? _globals.Color.TRANSPARENT : _this._options.clearColor || _globals.Color.BLACK;
    return _this;
  }

  /**
   * Sets the canvas to the given one
   * @param {HTMLCanvasElement} canvas
   */


  BaseRenderer.prototype.setCanvas = function setCanvas(canvas) {
    var previousCanvas = this._canvas;
    this._canvas = canvas;

    if (previousCanvas !== canvas) {
      this._createContext();
      this._onBeforeContext();
      this._setupContext();
    }

    this.resizeTo(new _globals.Vector2(this._width, this._height));
  };

  /**
   * Returns the current canvas
   * @return {HTMLCanvasElement}
   */


  BaseRenderer.prototype.getCanvas = function getCanvas() {
    return this._canvas;
  };

  /**
   * Gets called before the context has been set up
   * @protected
   */


  BaseRenderer.prototype._onBeforeContext = function _onBeforeContext() {};

  /**
   * Resizes the context and view to the given size
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   * @param  {Boolean} resizeCanvas = true
   */


  BaseRenderer.prototype.resizeTo = function resizeTo(dimensions) {
    var resizeCanvas = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    this._width = dimensions.x * this._pixelRatio;
    this._height = dimensions.y * this._pixelRatio;

    if (resizeCanvas) {
      this._canvas.width = this._width;
      this._canvas.height = this._height;

      if (this._canvas.style) {
        this._canvas.style.width = this._width / this._pixelRatio + 'px';
        this._canvas.style.height = this._height / this._pixelRatio + 'px';
      }
    }

    this._dimensions = dimensions.clone();
  };

  /**
   * Gets the rendering context for this renderer
   * @returns {Object}
   * @protected
   * @abstract
   */
  /* istanbul ignore next */


  BaseRenderer.prototype._createContext = function _createContext() {
    _globals.Log.warn(this.constructor.name, '`_createContext` is abstract and not implemented in inherited class');
  };

  /**
   * Sets up the rendering context for this renderer
   * @protected
   * @abstract
   */
  /* istanbul ignore next */


  BaseRenderer.prototype._setupContext = function _setupContext() {
    _globals.Log.warn(this.constructor.name, '`_setupContext` is abstract and not implemented in inherited class');
  };

  /**
   * Renders the given displayObject
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   * @abstract
   */
  /* istanbul ignore next */


  BaseRenderer.prototype.render = function render(displayObject) {
    _globals.Log.warn(this.constructor.name, '`render` is abstract and not implemented in inherited class');
  };

  /**
   * Returns the maximum dimensions
   * @return {Number}
   */
  /* istanbul ignore next */


  BaseRenderer.prototype.getMaxDimensions = function getMaxDimensions() {
    return null;
  };

  /**
   * Returns the current rendering context
   * @return {RenderingContext}
   */


  BaseRenderer.prototype.getContext = function getContext() {
    return this._context;
  };

  /**
   * Returns the current width
   * @return {Number}
   */


  BaseRenderer.prototype.getWidth = function getWidth() {
    return this._dimensions.x;
  };

  /**
   * Returns the current height
   * @return {Number}
   */


  BaseRenderer.prototype.getHeight = function getHeight() {
    return this._dimensions.y;
  };

  /**
   * Returns the current dimensions
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  BaseRenderer.prototype.getDimensions = function getDimensions() {
    return this._dimensions;
  };

  /**
   * Returns the current pixel ratio
   * @return {Number}
   */


  BaseRenderer.prototype.getPixelRatio = function getPixelRatio() {
    return this._pixelRatio;
  };

  /**
   * Sets the pixel ratio
   * @return {Number}
   */


  BaseRenderer.prototype.setPixelRatio = function setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    if (this._defaultRenderTarget) {
      this._defaultRenderTarget.setPixelRatio(pixelRatio);
    }
  };

  /**
   * Returns the maximum texture size
   * @return {Number}
   */


  BaseRenderer.prototype.getMaxTextureSize = function getMaxTextureSize() {
    return this._maxTextureSize;
  };

  /**
   * Returns the current filter manager
   * @return {PhotoEditorSDK.Engine.FilterManager}
   */


  BaseRenderer.prototype.getFilterManager = function getFilterManager() {
    return this._filterManager;
  };

  /**
   * Sets the filter manager
   * @param {PhotoEditorSDK.Engine.FilterManager} filterManager
   */


  BaseRenderer.prototype.setFilterManager = function setFilterManager(filterManager) {
    this._filterManager = filterManager;
  };

  /**
   * Checks if this renderer is supported on the current device and browser
   * @return {Boolean}
   */


  BaseRenderer.isSupported = function isSupported() {
    return true;
  };

  /**
   * Checks if this renderer's type is equal to the given one
   * @param  {String}  type
   * @return {Boolean}
   */


  BaseRenderer.prototype.isOfType = function isOfType(type) {
    return this._type === type;
  };

  /**
   * Disposes this Renderer
   * @abstract
   */
  /* istanbul ignore next */


  BaseRenderer.prototype.dispose = function dispose() {
    _globals.Log.warn(this.constructor.name, '`dispose` is abstract and not implemented in inherited class');
  };

  return BaseRenderer;
}(_globals.EventEmitter);

exports.default = BaseRenderer;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * The base class for all ObjectRenderer classes
 * @class
 * @memberof PhotoEditorSDK.Engine
 */
/* istanbul ignore next */
var ObjectRenderer = function () {
  /**
   * Creates an ObjectRenderer
   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
   */
  function ObjectRenderer(renderer) {
    (0, _classCallCheck3.default)(this, ObjectRenderer);

    this._renderer = renderer;

    this._onContextChange = this._onContextChange.bind(this);
    this._renderer.on('context', this._onContextChange);
  }

  /**
   * Gets called when the rendering context changes
   * @private
   */


  ObjectRenderer.prototype._onContextChange = function _onContextChange() {};

  /**
   * Gets called when this object renderer is activated
   */


  ObjectRenderer.prototype.start = function start() {};

  /**
   * Gets called when this object renderer is deactivated
   */


  ObjectRenderer.prototype.stop = function stop() {
    this.flush();
  };

  /**
   * Renders whatever has been queued
   */


  ObjectRenderer.prototype.flush = function flush() {};

  /**
   * Disposes this ObjectRenderer
   */


  ObjectRenderer.prototype.dispose = function dispose() {
    this._renderer.off('context', this._onContextChange);
    this._renderer = null;
  };

  return ObjectRenderer;
}();

exports.default = ObjectRenderer;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _baseTexture = __webpack_require__(29);

var _baseTexture2 = _interopRequireDefault(_baseTexture);

var _textureUvs = __webpack_require__(111);

var _textureUvs2 = _interopRequireDefault(_textureUvs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A texture that can be applied to a {@link PhotoEditorSDK.Engine.Sprite}
 * @class
 * @extends EventEmitter
 * @memberof PhotoEditorSDK.Engine
 */
var Texture = function (_EventEmitter) {
  (0, _inherits3.default)(Texture, _EventEmitter);

  function Texture(baseTexture, frame) {
    (0, _classCallCheck3.default)(this, Texture);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    if (!(baseTexture instanceof _baseTexture2.default)) {
      throw new Error('`baseTexture` should be an instance of BaseTexture');
    }

    _this._uvs = new _textureUvs2.default();
    _this._frame = frame ? frame.clone() : null;
    _this._frameLocked = !!frame;

    // Bind event handlers
    _this._onBaseTextureLoaded = _this._onBaseTextureLoaded.bind(_this);
    _this._onBaseTextureUpdated = _this._onBaseTextureUpdated.bind(_this);

    // A texture NEEDS to have a frame
    if (!_this._frame) {
      _this._frame = new _globals.Rectangle(0, 0, 1, 1);
    }
    _this.setBaseTexture(baseTexture);
    return _this;
  }

  /**
   * Creates a texture from the given image
   * @param  {Image} image
   */


  Texture.fromImage = function fromImage(image) {
    var baseTexture = new _baseTexture2.default(image);
    return new Texture(baseTexture);
  };

  /**
   * Creates a texture from the given canvas
   * @param  {HTMLCanvasElement} canvas
   */


  Texture.fromCanvas = function fromCanvas(canvas) {
    var baseTexture = new _baseTexture2.default(canvas);
    return new Texture(baseTexture);
  };

  /**
   * Gets called when the base texture has been loaded
   * @private
   */


  Texture.prototype._onBaseTextureLoaded = function _onBaseTextureLoaded() {
    if (!this._frameLocked) {
      var frame = this._baseTexture.getFrame().clone();
      this.setFrame(frame);
    }

    this._baseTexture.on('update', this._onBaseTextureUpdated);
  };

  /**
   * Gets called when the base texture has been updated
   * @private
   */


  Texture.prototype._onBaseTextureUpdated = function _onBaseTextureUpdated() {
    var _baseTexture$getFrame = this._baseTexture.getFrame(),
        width = _baseTexture$getFrame.width,
        height = _baseTexture$getFrame.height;

    this._frame.width = width;
    this._frame.height = height;
    this.emit('update');
  };

  /**
   * Updates the UV coordinates of this texture
   * @private
   */


  Texture.prototype._updateUVs = function _updateUVs() {
    this._uvs.update(this._frame, this._baseTexture.getFrame());
  };

  /**
   * Returns the base texture
   * @return {PhotoEditorSDK.Engine.BaseTexture}
   */


  Texture.prototype.getBaseTexture = function getBaseTexture() {
    return this._baseTexture;
  };

  /**
   * Sets the base texture
   * @param {PhotoEditorSDK.Engine.BaseTexture} baseTexture
   */


  Texture.prototype.setBaseTexture = function setBaseTexture(baseTexture) {
    this._baseTexture = baseTexture;

    if (!this._baseTexture.isLoaded()) {
      this._baseTexture.once('loaded', this._onBaseTextureLoaded);
    } else {
      var _baseTexture$getFrame2 = baseTexture.getFrame(),
          width = _baseTexture$getFrame2.width,
          height = _baseTexture$getFrame2.height;

      if (!this._frameLocked) {
        this._frame = new _globals.Rectangle(0, 0, width, height);
      }
      this._onBaseTextureLoaded();
    }
  };

  /**
   * Returns the frame
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  Texture.prototype.getFrame = function getFrame() {
    return this._frame;
  };

  /**
   * Sets the frame
   * @param {PhotoEditorSDK.Math.Rectangle} frame
   */


  Texture.prototype.setFrame = function setFrame(frame) {
    this._frame = frame;
    this._updateUVs();
  };

  /**
   * Returns the width
   * @return {Number}
   */


  Texture.prototype.getWidth = function getWidth() {
    return this._frame.width;
  };

  /**
   * Returns the height
   * @return {Number}
   */


  Texture.prototype.getHeight = function getHeight() {
    return this._frame.height;
  };

  /**
   * Returns the texture UVs
   * @return {PhotoEditorSDK.Engine.TextureUVs}
   */


  Texture.prototype.getUVs = function getUVs() {
    return this._uvs;
  };

  /**
   * Returns the dimensions of this texture
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Texture.prototype.getDimensions = function getDimensions() {
    return new _globals.Vector2(this._frame.width, this._frame.height);
  };

  /**
   * Disposes this texture
   * @param  {Boolean} baseTexture
   */


  Texture.prototype.dispose = function dispose() {
    var baseTexture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    baseTexture && this._baseTexture.dispose();
  };

  return Texture;
}(_globals.EventEmitter); /*
                           * This file is part of PhotoEditorSDK.
                           *
                           * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                           * All rights reserved.
                           *
                           * Redistribution and use in source and binary forms, without
                           * modification, are permitted provided that the following license agreement
                           * is approved and a legal/financial contract was signed by the user.
                           * The license agreement can be found under following link:
                           *
                           * https://www.photoeditorsdk.com/LICENSE.txt
                           */

exports.default = Texture;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var now = typeof window !== 'undefined' && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : __webpack_require__(97);

/**
 * Hooks into a rendering context (WebGLRenderingContext or CanvasRenderingContext2D),
 * mocks its methods and measures the time consumed by the method calls. When `endFrame`
 * is called, it prints a performance report
 * @class
 * @memberof PhotoEditorSDK.Engine
 * @ignore
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ContextPerformanceHook = function () {
  function ContextPerformanceHook(context) {
    var _this = this;

    (0, _classCallCheck3.default)(this, ContextPerformanceHook);

    this._context = context;
    this._tracking = false;

    var self = this;

    var _loop = function _loop(key) {
      var value = context[key];
      if (typeof value === 'function') {
        _this[key] = function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var fn = context[key];
          if (!self._tracking) {
            return fn.apply(context, args);
          }

          var start = now();
          var result = fn.apply(context, args);
          var time = now() - start;

          var call = {
            functionName: key,
            arguments: args,
            duration: time
          };
          self._trackedCalls.push(call);

          return result;
        };
      } else {
        _this._makePropertyWrapper(key);
      }
    };

    for (var key in context) {
      _loop(key);
    }
  }

  /**
   * Creates the getter and setter for the given property
   * @param  {String} property
   * @private
   */


  ContextPerformanceHook.prototype._makePropertyWrapper = function _makePropertyWrapper(property) {
    var insecureProperties = ['_context', '_trackedCalls', '_tracking'];
    if (insecureProperties.indexOf(property) !== -1) return;

    var context = this._context;

    this.__defineGetter__(property, function () {
      return context[property];
    });

    this.__defineSetter__(property, function (value) {
      context[property] = value;
    });
  };

  /**
   * Starts tracking a frame
   */


  ContextPerformanceHook.prototype.startFrame = function startFrame() {
    this._tracking = true;
    this._trackedCalls = [];
  };

  /**
   * Stops tracking a frame and prints a performance report
   */


  ContextPerformanceHook.prototype.endFrame = function endFrame() {
    var tag = 'Rendering';
    _globals.Log.log(tag, 'Frame rendering results:');
    _globals.Log.log(tag, 'Context calls: ' + this._trackedCalls.length);

    var groupedCalls = {};
    this._trackedCalls.forEach(function (_ref) {
      var functionName = _ref.functionName,
          duration = _ref.duration;

      groupedCalls[functionName] = groupedCalls[functionName] || {
        totalDuration: 0,
        calls: 0
      };

      groupedCalls[functionName].totalDuration += duration;
      groupedCalls[functionName].calls++;
    });

    var callsArray = [];
    for (var key in groupedCalls) {
      var data = groupedCalls[key];
      data.averageDuration = data.totalDuration / data.calls;

      callsArray.push({ functionName: key, data: data });
    }

    callsArray.sort(function (a, b) {
      return b.data.totalDuration - a.data.totalDuration;
    });
    callsArray = callsArray.slice(0, 3);

    callsArray.forEach(function (item) {
      _globals.Log.log(tag, item.functionName + ': ' + item.data.calls + ' calls, ' + item.data.totalDuration.toFixed(2) + 'ms');
    });
  };

  return ContextPerformanceHook;
}();

exports.default = ContextPerformanceHook;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * This class represents an image in pixel array form.
 */
var PixelArrayImage = function () {
  /**
   * @param  {Number} width
   * @param  {Number} height
   * @param  {UInt8Array} data
   * @constructor
   */
  function PixelArrayImage(width, height, data) {
    (0, _classCallCheck3.default)(this, PixelArrayImage);

    this.width = width;
    this.height = height;
    this.data = data;
  }

  /**
   * Creates a PixelArrayImage from the given `node-canvas` Image object by rendering the image
   * to a canvas and reading the pixel data
   * @param  {Canvas.Image} image
   * @return {PixelArrayImage}
   */


  PixelArrayImage.fromNodeCanvasImage = function fromNodeCanvasImage(image) {
    var canvas = new Canvas(image.width, image.height);
    var context = canvas.getContext('2d');

    context.drawImage(image, 0, 0);
    var imageData = context.getImageData(0, 0, image.width, image.height);
    return new PixelArrayImage(image.width, image.height, imageData.data);
  };

  return PixelArrayImage;
}();

exports.default = PixelArrayImage;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(86);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _log = __webpack_require__(22);

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
exports.default = {
  /**
   * Checks if the currently bound framebuffer is complete
   * @param  {String} tag
   * @param  {WebGLRenderingContext} gl
   */
  checkFramebufferStatus: function checkFramebufferStatus(tag, gl) {
    var _possibleStatuses;

    var fboStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    var possibleStatuses = (_possibleStatuses = {}, (0, _defineProperty3.default)(_possibleStatuses, gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT, 'Incomplete attachment'), (0, _defineProperty3.default)(_possibleStatuses, gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT, 'Missing attachment'), (0, _defineProperty3.default)(_possibleStatuses, gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS, 'Incomplete dimensions'), (0, _defineProperty3.default)(_possibleStatuses, gl.FRAMEBUFFER_UNSUPPORTED, 'Framebuffer unsupported'), _possibleStatuses);

    if (fboStatus !== gl.FRAMEBUFFER_COMPLETE) {
      _log2.default.warn(tag, 'Framebuffer incomplete: ' + possibleStatuses[fboStatus]);
    }
  }
}; /*
    * This file is part of PhotoEditorSDK.
    *
    * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
    * All rights reserved.
    *
    * Redistribution and use in source and binary forms, without
    * modification, are permitted provided that the following license agreement
    * is approved and a legal/financial contract was signed by the user.
    * The license agreement can be found under following link:
    *
    * https://www.photoeditorsdk.com/LICENSE.txt
    */

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(38);

var _createClass3 = _interopRequireDefault(_createClass2);

var _vector = __webpack_require__(23);

var _vector2 = _interopRequireDefault(_vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Represents a 3-dimensional matrix
 * @class
 * @memberof PhotoEditorSDK.Math
 */
var Matrix = function () {
  /**
   * Creates a Matrix
   */
  function Matrix() {
    (0, _classCallCheck3.default)(this, Matrix);

    this.reset();
  }

  /**
   * Multiplies this matrix with the given one
   * @param  {PhotoEditorSDK.Math.Matrix} matrix
   * @return {PhotoEditorSDK.Math.Matrix}
   */


  Matrix.prototype.multiply = function multiply(matrix) {
    var a = void 0,
        b = void 0,
        c = void 0,
        d = void 0,
        tx = void 0,
        ty = void 0;
    a = this.a * matrix.a + this.b * matrix.c;
    b = this.a * matrix.b + this.b * matrix.d;
    c = this.c * matrix.a + this.d * matrix.c;
    d = this.c * matrix.b + this.d * matrix.d;
    tx = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
    ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;

    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  };

  /**
   * Applies this matrix to the given vector
   * @param  {PhotoEditorSDK.Math.Vector2} position
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Matrix.prototype.applyToVector = function applyToVector(position) {
    var _position = position,
        x = _position.x,
        y = _position.y;

    position = position.clone();
    position.x = this.a * x + this.c * y + this.tx;
    position.y = this.b * x + this.d * y + this.tx;
    return position;
  };

  /**
   * Applies the inverse of this matrix to the given vector
   * @param  {PhotoEditorSDK.Math.Vector2} position
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Matrix.prototype.applyInverseToVector = function applyInverseToVector(position) {
    var determinant = 1 / (this.a * this.d + this.c * -this.b);

    var _position2 = position,
        x = _position2.x,
        y = _position2.y;

    position = position.clone();
    position.x = this.d * determinant * x + -this.c * determinant * y + (this.ty * this.c - this.tx * this.d) * determinant;
    position.y = this.a * determinant * y + -this.b * determinant * x + (-this.ty * this.a + this.tx * this.b) * determinant;

    return position;
  };

  /**
   * Turns the given rectangle into vector coordinates by applying this Matrix
   * @param  {PhotoEditorSDK.Math.Rectangle} rectangle
   * @param  {PhotoEditorSDK.Math.Vector2} anchor
   * @return {PhotoEditorSDK.Math.Vector2[]}
   */


  Matrix.prototype.rectangleToCoordinates = function rectangleToCoordinates(rectangle) {
    var anchor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _vector2.default(0, 0);

    // Anchor offsets (w0 = right, w1 = left, h0 = up, h1 = down)
    var w0 = rectangle.width * (1 - anchor.x);
    var w1 = rectangle.width * -anchor.x;
    var h0 = rectangle.height * (1 - anchor.y);
    var h1 = rectangle.height * -anchor.y;

    var positions = [];

    // Bottom Left
    positions.push(new _vector2.default(this.a * w1 + this.c * h1 + this.tx, this.d * h1 + this.b * w1 + this.ty));

    // Bottom Right
    positions.push(new _vector2.default(this.a * w0 + this.c * h1 + this.tx, this.d * h1 + this.b * w0 + this.ty));

    // Top Right
    positions.push(new _vector2.default(this.a * w0 + this.c * h0 + this.tx, this.d * h0 + this.b * w0 + this.ty));

    // Top Left
    positions.push(new _vector2.default(this.a * w1 + this.c * h0 + this.tx, this.d * h0 + this.b * w1 + this.ty));

    return positions;
  };

  /**
   * Resets this matrix to the identity matrix
   */


  Matrix.prototype.reset = function reset() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
  };

  /**
   * Returns an array representation of this matrix
   * @return {Float32Array}
   */


  Matrix.prototype.toArray = function toArray() {
    var arr = [this.a, this.b, 0, this.c, this.d, 0, this.tx, this.ty, 1];
    /* istanbul ignore next */
    if (typeof Float32Array === 'undefined') {
      return arr;
    }
    return new Float32Array(arr);
  };

  /**
   * Returns a string representation of this matrix
   * @return {String}
   */


  Matrix.prototype.toString = function toString() {
    return 'Matrix({ a: ' + this.a + ', b: ' + this.b + ', c: ' + this.c + ', d: ' + this.d + ', tx: ' + this.tx + ', ty: ' + this.ty + ' })';
  };

  /**
   * The identity matrix
   * @static
   * @type {PhotoEditorSDK.Math.Matrix}
   */


  (0, _createClass3.default)(Matrix, null, [{
    key: 'IDENTITY',
    get: function get() {
      return new Matrix();
    }
  }]);
  return Matrix;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = Matrix;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * Represents a Rectangle
 * @class
 * @memberof PhotoEditorSDK.Math
 */
var Rectangle = function () {
  /**
   * Creartes a Rectangle
   * @param {Number} [x = 0]
   * @param {Number} [y = 0]
   * @param {Number} [width  = 0]
   * @param {Number} [height = 0]
   */
  function Rectangle() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    (0, _classCallCheck3.default)(this, Rectangle);

    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  /**
   * Sets the given values
   * @param {Number} x
   * @param {Number} y
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  Rectangle.prototype.set = function set(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    return this;
  };

  /**
   * Creates a clone of this rectangle
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  Rectangle.prototype.clone = function clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  };

  /**
   * Copies the values of the given rectangle
   * @param  {PhotoEditorSDK.Math.Rectangle} other
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  Rectangle.prototype.copy = function copy(other) {
    this.x = other.x;
    this.y = other.y;
    this.width = other.width;
    this.height = other.height;
    return this;
  };

  /**
   * Checks whether this rectangle's values are the same as the given ones
   * @param  {(Number|PhotoEditorSDK.Math.Rectangle)} rect
   * @param  {Number} y
   * @param  {Number} width
   * @param  {Number} height
   * @return {Boolean}
   */


  Rectangle.prototype.equals = function equals(rect, y, width, height) {
    if (rect instanceof Rectangle) {
      return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
    } else {
      var x = rect;
      return x === this.x && y === this.y && width === this.width && height === this.height;
    }
  };

  /**
   * Rounds this rectangle's values
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  Rectangle.prototype.round = function round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.width = Math.round(this.width);
    this.height = Math.round(this.height);
    return this;
  };

  /**
   * Returns a string representation of this rectangle
   * @return {String}
   */


  Rectangle.prototype.toString = function toString() {
    return "Rectangle({ x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + " })";
  };

  return Rectangle;
}();

exports.default = Rectangle;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
var now = typeof window !== 'undefined' && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : __webpack_require__(97);

/**
 * A simple class that tracks the time between start and end and renders it as FPS
 * @class
 * @memberof PhotoEditorSDK
 * @ignore
 */
/* istanbul ignore next */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var PerformanceTest = function () {
  /**
   * Creates a PerformanceTest
   * @param  {String} tag
   * @param  {String} name
   */
  function PerformanceTest(tag, name) {
    (0, _classCallCheck3.default)(this, PerformanceTest);

    this._tag = tag;
    this._name = name;
    this._start = now();
  }

  /**
   * Stops the performance test and prints the result
   */


  PerformanceTest.prototype.stop = function stop() {
    var end = now();
    var ms = end - this._start;
    var fps = Math.round(1000 / ms);
    _globals.Log.info(this._tag, this._name + ' took ' + ms.toFixed(2) + 'ms (' + fps + ' FPS)');
  };

  return PerformanceTest;
}();

exports.default = PerformanceTest;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UniformType = _globals.Constants.UniformType,
    OptionType = _globals.Constants.OptionType; /*
                                                 * This file is part of PhotoEditorSDK.
                                                 *
                                                 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                 * All rights reserved.
                                                 *
                                                 * Redistribution and use in source and binary forms, without
                                                 * modification, are permitted provided that the following license agreement
                                                 * is approved and a legal/financial contract was signed by the user.
                                                 * The license agreement can be found under following link:
                                                 *
                                                 * https://www.photoeditorsdk.com/LICENSE.txt
                                                 */

var AdjustmentsFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(AdjustmentsFilter, _Engine$Filter);

  function AdjustmentsFilter() {
    (0, _classCallCheck3.default)(this, AdjustmentsFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(237);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  AdjustmentsFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    var _options = this._options,
        brightness = _options.brightness,
        saturation = _options.saturation,
        contrast = _options.contrast,
        gamma = _options.gamma,
        exposure = _options.exposure,
        shadows = _options.shadows,
        highlights = _options.highlights;


    var applyBrightness = brightness !== 0;
    var applySaturation = saturation !== 1;
    var applyContrast = contrast !== 1;
    var applyExposure = exposure !== 0;
    var applyGamma = gamma !== 1;
    var applyShadowsAndHighlights = shadows !== 0 || highlights !== 1;

    var exposureFactor = Math.pow(2.0, exposure);

    brightness = brightness * 255;

    for (var i = 0; i < canvas.width * canvas.height; i++) {
      var index = i * 4;
      var r = imageData.data[index];
      var g = imageData.data[index + 1];
      var b = imageData.data[index + 2];

      // Gamma
      if (applyGamma) {
        r = Math.pow(r / 255, 1.0 / gamma) * 255;
        g = Math.pow(g / 255, 1.0 / gamma) * 255;
        b = Math.pow(b / 255, 1.0 / gamma) * 255;
      }

      // Normalize color
      if (applyExposure || applyShadowsAndHighlights) {
        r /= 255.0;
        g /= 255.0;
        b /= 255.0;
      }

      // Apply Exposure
      if (applyExposure) {
        r *= exposureFactor;
        g *= exposureFactor;
        b *= exposureFactor;
      }

      // Apply shadows and highlights
      if (applyShadowsAndHighlights) {
        var luminance = r * 0.2125 + g * 0.7154 + b * 0.0721;
        var shadow = Math.pow(luminance, 1.0 / (shadows + 1.0)) + -0.76 * Math.pow(luminance, 2.0 / (shadows + 1.0)) - luminance;
        shadow = Math.max(shadow, 0.0);
        shadow = Math.min(shadow, 1.0);
        var highlight = 1.0 - (Math.pow(1.0 - luminance, 1.0 / (2.0 - highlights)) + -0.8 * Math.pow(1.0 - luminance, 2.0 / (2.0 - highlights))) - luminance;
        highlight = Math.max(highlight, -1.0);
        highlight = Math.min(highlight, 0.0);
        var offset = luminance + shadow + highlight;
        r = offset * r / luminance;
        g = offset * g / luminance;
        b = offset * b / luminance;
      }

      // Denormalize color
      if (applyExposure || applyShadowsAndHighlights) {
        r *= 255.0;
        g *= 255.0;
        b *= 255.0;
      }

      // Brightness
      if (applyBrightness) {
        r = r + brightness;
        g = g + brightness;
        b = b + brightness;
      }

      // Saturation
      if (applySaturation) {
        var _luminance = r * 0.2125 + g * 0.7154 + b * 0.0721;
        r = _luminance * (1 - saturation) + r * saturation;
        g = _luminance * (1 - saturation) + g * saturation;
        b = _luminance * (1 - saturation) + b * saturation;
      }

      // Contrast
      if (applyContrast) {
        r = (r - 127) * contrast + 127;
        g = (g - 127) * contrast + 127;
        b = (b - 127) * contrast + 127;
      }

      imageData.data[index] = r;
      imageData.data[index + 1] = g;
      imageData.data[index + 2] = b;
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return AdjustmentsFilter;
}(_globals.Engine.Filter);

AdjustmentsFilter.prototype.availableOptions = {
  brightness: { type: OptionType.NUMBER, default: 0, uniformType: UniformType.FLOAT },
  saturation: { type: OptionType.NUMBER, default: 1, uniformType: UniformType.FLOAT },
  contrast: { type: OptionType.NUMBER, default: 1, uniformType: UniformType.FLOAT },
  gamma: { type: OptionType.NUMBER, default: 1, uniformType: UniformType.FLOAT },
  exposure: { type: OptionType.NUMBER, default: 0, uniformType: UniformType.FLOAT },
  shadows: { type: OptionType.NUMBER, default: 0, uniformType: UniformType.FLOAT },
  highlights: { type: OptionType.NUMBER, default: 1, uniformType: UniformType.FLOAT }
};

exports.default = AdjustmentsFilter;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Identity Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var IdentityFilter = function (_Filter) {
  (0, _inherits3.default)(IdentityFilter, _Filter);

  function IdentityFilter() {
    (0, _classCallCheck3.default)(this, IdentityFilter);
    return (0, _possibleConstructorReturn3.default)(this, _Filter.apply(this, arguments));
  }

  /**
   * Renders the filter
   * @param  {PhotoEditorSDK} sdk
   * @param  {Engine.RenderTexture}
   * @return {Promise}
   */
  IdentityFilter.prototype.render = function render(sdk, renderTexture) {
    return _globals.Promise.resolve();
  };

  return IdentityFilter;
}(_filter2.default);

IdentityFilter.isIdentity = true;
IdentityFilter.displayName = 'Original';

/**
 * This filter's identifier
 * @type {String}
 * @default
 */
IdentityFilter.identifier = 'identity';

exports.default = IdentityFilter;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

var _constants = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TEXTURE_GL_UNIT = 3;

var LookupTableFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(LookupTableFilter, _Engine$Filter);

  function LookupTableFilter() {
    (0, _classCallCheck3.default)(this, LookupTableFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(251);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  LookupTableFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    var table = this._options.lookupTableData;
    for (var i = 0; i < canvas.width * canvas.height; i++) {
      var index = i * 4;

      var r = imageData.data[index];
      imageData.data[index] = table[r * 4];
      var g = imageData.data[index + 1];
      imageData.data[index + 1] = table[1 + g * 4];
      var b = imageData.data[index + 2];
      imageData.data[index + 2] = table[2 + b * 4];
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return LookupTableFilter;
}(_engine2.default.Filter);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */


LookupTableFilter.prototype.availableOptions = {
  lookupTable: { type: _constants.OptionType.NUMBER, default: TEXTURE_GL_UNIT, uniformType: _constants.UniformType.INT },
  lookupTableData: { type: _constants.OptionType.ARRAY, default: [] }
};

/**
 * Stores a 256 byte long lookup table in a 2d texture which will be
 * used to look up the corresponding value for each channel.
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var LookupTable = function (_Primitive) {
  (0, _inherits3.default)(LookupTable, _Primitive);

  function LookupTable() {
    (0, _classCallCheck3.default)(this, LookupTable);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new LookupTableFilter();
    _this2._textures = {};
    _this2._renderers = {};
    return _this2;
  }

  /**
   * Gets called before this primitive's filter is being applied
   * @param {PhotoEditorSDK} sdk
   */


  LookupTable.prototype.update = function update(sdk) {
    var renderer = sdk.getRenderer();
    /* istanbul ignore if */
    if (renderer.isOfType(_constants.RendererType.WEBGL)) {
      this._updateWebGLTexture(sdk);
    } else if (renderer.isOfType(_constants.RendererType.CANVAS)) {
      this._filter.setLookupTableData(this._options.data);
    }
  };

  /**
   * Updates the lookup table texture (WebGL only)
   * @param {PhotoEditorSDK} sdk
   * @private
   */
  /* istanbul ignore next */


  LookupTable.prototype._updateWebGLTexture = function _updateWebGLTexture(sdk) {
    if (typeof this._options.data === 'undefined') {
      throw new Error('LookupTable: No data specified.');
    }

    var data = new Uint8Array(this._options.data);

    var renderer = sdk.getRenderer();
    var id = renderer.id;

    this._renderers[id] = renderer;
    if (!this._textures[id]) {
      this._textures[id] = new _engine2.default.BaseTexture();
    }

    var texture = this._textures[id];
    var pixelArrayImage = new _engine2.default.PixelArrayImage(256, 1, data);
    texture.setSource(pixelArrayImage);
    texture.setGLUnit(TEXTURE_GL_UNIT);

    /* istanbul ignore next */
    if (renderer.isOfType(_constants.RendererType.WEBGL)) {
      renderer.updateTexture(texture);
    }
  };

  /**
   * Cleans up this primitive
   */


  LookupTable.prototype.dispose = function dispose() {
    _Primitive.prototype.dispose.call(this);
    for (var id in this._textures) {
      this._textures[id].dispose();
      delete this._textures[id];
    }
    delete this._options.data;
  };

  return LookupTable;
}(_primitive2.default);

exports.default = LookupTable;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _path = __webpack_require__(180);

var _path2 = _interopRequireDefault(_path);

var _sprite = __webpack_require__(36);

var _sprite2 = _interopRequireDefault(_sprite);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    RendererType = _globals.Constants.RendererType; /*
                                                     * This file is part of PhotoEditorSDK.
                                                     *
                                                     * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                     * All rights reserved.
                                                     *
                                                     * Redistribution and use in source and binary forms, without
                                                     * modification, are permitted provided that the following license agreement
                                                     * is approved and a legal/financial contract was signed by the user.
                                                     * The license agreement can be found under following link:
                                                     *
                                                     * https://www.photoeditorsdk.com/LICENSE.txt
                                                     */

/**
 * A Brush that can be drawn by SpriteOperation. Should only be created via {@link PhotoEditorSDK.Operations.SpriteOperation#createBrush}
 * @class
 * @memberof PhotoEditorSDK.Operations.SpriteOperation
 */
var Brush = function (_Sprite) {
  (0, _inherits3.default)(Brush, _Sprite);

  /**
   * Creates a new Sticker
   * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
   * @param  {Object} [options]
   */
  function Brush() {
    (0, _classCallCheck3.default)(this, Brush);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Sprite.call.apply(_Sprite, [this].concat(args)));

    _this._persistedPaths = [];
    _this._outputCanvasDirty = true;
    _this._outputCanvas = _globals.Utils.createCanvas();
    _this._outputContext = _this._outputCanvas.getContext('2d');
    _this._persistCanvas = _globals.Utils.createCanvas();
    _this._persistContext = _this._persistCanvas.getContext('2d');
    _this._nextCanvas = _globals.Utils.createCanvas();

    _this._texture = _globals.Engine.Texture.fromCanvas(_this._outputCanvas);
    _this._sprite.setTexture(_this._texture);

    _this._onPathUpdate = _this._onPathUpdate.bind(_this);
    return _this;
  }

  /**
   * Applies a flip in the given direction
   * @param  {String} direction
   */


  Brush.prototype.applyFlip = function applyFlip(direction) {
    this._options.paths.forEach(function (path) {
      path.forEachControlPoint(function (controlPoint) {
        var position = controlPoint.getPosition().clone();
        switch (direction) {
          case 'horizontal':
            position.x = 1 - position.x;
            break;
          case 'vertical':
            position.y = 1 - position.y;
            break;
        }
        controlPoint.setPosition(position);
      });
      path.setDirty(true);
    });

    this._reset();
  };

  /**
   * Applies a rotation with the given degrees
   * @param  {Number} degrees
   */


  Brush.prototype.applyRotation = function applyRotation(degrees) {
    this._options.paths.forEach(function (path) {
      path.forEachControlPoint(function (controlPoint) {
        var position = controlPoint.getPosition().clone();
        if (degrees === 90) {
          position.flip();
          position.x = 1 - position.x;
        } else if (degrees === -90) {
          position.flip();
          position.y = 1 - position.y;
        }
        controlPoint.setPosition(position);
      });

      path.setDirty(true);
    });

    this._reset();
  };

  /**
   * Applies the given crop change
   * @param  {PhotoEditorSDK.Operations.CropOperation} cropOperation
   * @param  {Object} options
   * @private
   */


  Brush.prototype.applyCrop = function applyCrop(cropOperation, options) {
    this._reset();

    var inputDimensions = cropOperation.getInputDimensions();
    var rotationDelta = options.rotation - cropOperation.getRotation();

    var oldAbsoluteSize = cropOperation.getEnd().clone().subtract(cropOperation.getStart()).multiply(inputDimensions);
    var newAbsoluteSize = options.end.clone().subtract(options.start).multiply(inputDimensions);
    var absoluteStartDiff = cropOperation.getStart().clone().subtract(options.start).multiply(inputDimensions);
    var scaleRatio = options.scale / cropOperation.getScale();
    var absoluteStart = cropOperation.getStart().clone().multiply(inputDimensions);

    this._options.paths.forEach(function (path) {
      path.forEachControlPoint(function (controlPoint) {
        // Calculate the absolute position on input image
        var absolutePositionOnImage = controlPoint.getPosition().clone().multiply(oldAbsoluteSize) // Compensate crop size
        .add(absoluteStart); // Compensate crop start / offset

        // Reposition sprite
        // Calculate distance from input image's center (in pixels)
        var deltaToCenter = absolutePositionOnImage.clone().subtract(inputDimensions.clone().multiply(0.5));

        // Rotate delta around center
        var cos = Math.cos(rotationDelta);
        var sin = Math.sin(rotationDelta);
        var newDeltaToCenter = new _globals.Vector2(deltaToCenter.x * cos - deltaToCenter.y * sin, deltaToCenter.x * sin + deltaToCenter.y * cos);

        // Apply scale change to delta
        newDeltaToCenter.multiply(scaleRatio);

        // Calculate new position
        // image center + delta to center - old start + new start
        var position = inputDimensions.clone().multiply(0.5).add(newDeltaToCenter).subtract(absoluteStart).add(absoluteStartDiff).divide(newAbsoluteSize);

        controlPoint.setPosition(position);
      });

      var newRelativeThickness = path.getThickness() * oldAbsoluteSize.min() / newAbsoluteSize.min();
      path.setThickness(newRelativeThickness * scaleRatio);
      path.setDirty(true);
    });

    // Update
    this._reset();
  };

  /**
   * Clears the canvas
   */


  Brush.prototype.clearCanvas = function clearCanvas() {
    if (!this._outputCanvas) {
      // `clearCanvas` is called when paths are set in Sprite's constructor. At this
      // point, `this._outputCanvas` does not exist yet.
      return;
    }

    this._outputCanvasDirty = true;

    var _outputCanvas = this._outputCanvas,
        width = _outputCanvas.width,
        height = _outputCanvas.height;

    this._outputContext.clearRect(0, 0, width, height);
  };

  /**
   * Clears the persist canvas
   */


  Brush.prototype.clearPersistCanvas = function clearPersistCanvas() {
    if (!this._persistCanvas) {
      // `clearCanvas` is called when paths are set in Sprite's constructor. At this
      // point, `this._persistCanvas` does not exist yet.
      return;
    }

    var _persistCanvas = this._persistCanvas,
        width = _persistCanvas.width,
        height = _persistCanvas.height;

    this._persistContext.clearRect(0, 0, width, height);
  };

  /**
   * Returns a serialized version of this configurable
   * @param {String[]} keys
   * @param {Boolean} toObject = false
   * @return {Object}
   */


  Brush.prototype.serializeOptions = function serializeOptions(keys) {
    var toObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var options = _Sprite.prototype.serializeOptions.call(this, keys, toObject);
    if (!keys) options.type = 'brush';
    return options;
  };

  /**
   * Creates and adds a new path
   * @param {Number} thickness
   * @param {Number} hardness
   * @param {Color} color
   * @return {PhotoEditorSDK.Operations.BrushOperation.Path}
   */


  Brush.prototype.createPath = function createPath(thickness, hardness, color) {
    var path = new _path2.default(this._operation, { thickness: thickness, hardness: hardness, color: color }, this._nextCanvas);
    path.on('update', this._onPathUpdate);
    this._options.paths.push(path);
    this.setDirty(true);
    return path;
  };

  /**
   * Gets called when a path has been updated
   * @private
   */


  Brush.prototype._onPathUpdate = function _onPathUpdate() {
    this._operation.setDirty(true);
    this.setDirty(true);
  };

  /**
   * Gets called when a path has been closed / persisted
   * @param  {PhotoEditorSDK.Operations.SpriteOperation.Brush.Path} path
   * @private
   */


  Brush.prototype._onPathPersist = function _onPathPersist(path) {
    path.renderToCanvas(this._persistCanvas);
    this._nextCanvas = path.getCanvas();

    var context = this._nextCanvas.getContext('2d');
    context.clearRect(0, 0, this._nextCanvas.width, this._nextCanvas.height);

    this._persistedPaths.push(path);
  };

  /**
   * Returns the Texture for the sprite that should be rendered
   * @return {PhotoEditorSDK.Engine.Texture}
   * @private
   * @abstract
   */


  Brush.prototype._getTexture = function _getTexture() {
    return this._texture;
  };

  /**
   * Sets the dirtiness for the given renderer
   * @param {Boolean} dirty
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param {Boolean} dimensionsChanged = false
   */


  Brush.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
    var dimensionsChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    _Sprite.prototype.setDirtyForRenderer.call(this, dirty, renderer, dimensionsChanged);
    if (dirty && dimensionsChanged) {
      this._persistedPaths = [];
      this._options.paths.forEach(function (path) {
        path.setDirty(true);
      });
    }
  };

  /**
   * Sets this brush to dirty
   * @param {Boolean} dirty
   * @param {Boolean} dimensionsChanged = false
   */


  Brush.prototype.setDirty = function setDirty(dirty) {
    var dimensionsChanged = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    for (var rendererId in this._dirtiness) {
      this.setDirtyForRenderer(dirty, this._renderers[rendererId], dimensionsChanged);
    }
  };

  /**
   * Renders all paths to the canvas
   * @param {PhotoEditorSDK.Math.Vector2} inputDimensions
   */


  Brush.prototype.render = function render(inputDimensions) {
    var _this2 = this;

    var renderer = this._operation.getSDK().getRenderer();

    if (!this.isDirtyForRenderer(renderer)) {
      return;
    }

    _globals.Utils.ensureCanvasDimensions(this._outputCanvas, inputDimensions);
    _globals.Utils.ensureCanvasDimensions(this._persistCanvas, inputDimensions);

    // Make sure all paths are rendered to their canvases
    this._options.paths.forEach(function (path) {
      path.render(inputDimensions);

      if (path.getClosed() && _this2._persistedPaths.indexOf(path) === -1) {
        _this2._onPathPersist(path);
      }
    });

    // Render persisted paths to output in one go
    this.clearCanvas();
    this._outputContext.drawImage(this._persistCanvas, 0, 0);

    // Render unpersisted paths to output
    this._options.paths.forEach(function (path) {
      if (!path.getClosed()) {
        path.renderToCanvas(_this2._outputCanvas);
      }
    });

    this.setDirtyForRenderer(false, renderer);
  };

  /**
   * Updates this sprite
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Promise}
   */


  Brush.prototype.update = function update(sdk, inputDimensions) {
    if (inputDimensions) {
      _globals.Utils.ensureCanvasDimensions(this._outputCanvas, inputDimensions);
      _globals.Utils.ensureCanvasDimensions(this._persistCanvas, inputDimensions);

      // Update texture dimensions
      this._texture.getBaseTexture().update();
    }

    // Render paths and control points
    this.render(inputDimensions);

    // Upload canvas to texture
    var renderer = sdk.getRenderer();
    /* istanbul ignore next */
    if (renderer.isOfType(RendererType.WEBGL)) {
      renderer.updateTexture(this._texture.getBaseTexture());
    }

    return _Sprite.prototype.update.call(this, sdk, inputDimensions);
  };

  /**
   * Resets this brush so that it can be re-rendered
   * @private
   */


  Brush.prototype._reset = function _reset() {
    this._persistedPaths = [];
    if (this._operation) {
      this._operation.setDirty(true);
    }
    this.setDirty(true);
    this.clearCanvas();
    this.clearPersistCanvas();
  };

  // -------------------------------------------------------------------------- GETTERS / SETTERS

  /**
   * Returns the canvas we're rendering brushes to
   * @return {CanvasElement}
   */


  Brush.prototype.getCanvas = function getCanvas() {
    return this._outputCanvas;
  };

  // -------------------------------------------------------------------------- DISPOSAL

  /**
   * Disposes this Brush
   */


  Brush.prototype.dispose = function dispose() {
    _Sprite.prototype.dispose.call(this);
    this._texture.getBaseTexture().dispose();
  };

  return Brush;
}(_sprite2.default);

Brush.prototype.availableOptions = {
  id: { type: OptionType.STRING, default: function _default() {
      return _globals.Utils.getUUID();
    } },
  position: { type: OptionType.VECTOR2, default: new _globals.Vector2(0, 0) },
  scale: { type: OptionType.VECTOR2, default: new _globals.Vector2(1.0, 1.0) },
  anchor: { type: OptionType.VECTOR2, default: new _globals.Vector2(0.0, 0.0) },
  pivot: { type: OptionType.VECTOR2, default: new _globals.Vector2(0.0, 0.0) },
  rotation: { type: OptionType.NUMBER, default: 0 },
  paths: {
    type: OptionType.ARRAY,
    default: [],
    setter: function setter(paths) {
      paths.forEach(function (path) {
        path.setDirty(true);
      });

      this._reset();
      return paths;
    }
  }
};

exports.default = Brush;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(197), __esModule: true };

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _defineProperty = __webpack_require__(85);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(50)
  , TAG = __webpack_require__(14)('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(201);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(31)
  , document = __webpack_require__(15).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(17) && !__webpack_require__(39)(function(){
  return Object.defineProperty(__webpack_require__(89)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var LIBRARY        = __webpack_require__(53)
  , $export        = __webpack_require__(30)
  , redefine       = __webpack_require__(96)
  , hide           = __webpack_require__(26)
  , has            = __webpack_require__(18)
  , Iterators      = __webpack_require__(32)
  , $iterCreate    = __webpack_require__(208)
  , setToStringTag = __webpack_require__(56)
  , getPrototypeOf = __webpack_require__(214)
  , ITERATOR       = __webpack_require__(14)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(55)
  , createDesc     = __webpack_require__(41)
  , toIObject      = __webpack_require__(20)
  , toPrimitive    = __webpack_require__(60)
  , has            = __webpack_require__(18)
  , IE8_DOM_DEFINE = __webpack_require__(90)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(17) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(95)
  , hiddenKeys = __webpack_require__(52).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ },
/* 94 */
/***/ function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

var has          = __webpack_require__(18)
  , toIObject    = __webpack_require__(20)
  , arrayIndexOf = __webpack_require__(203)(false)
  , IE_PROTO     = __webpack_require__(57)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(26);

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(65)))

/***/ },
/* 98 */
/***/ function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _identityFilter = __webpack_require__(82);

Object.defineProperty(exports, 'IdentityFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_identityFilter).default;
  }
});

var _a15Filter = __webpack_require__(125);

Object.defineProperty(exports, 'A15Filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_a15Filter).default;
  }
});

var _breezeFilter = __webpack_require__(126);

Object.defineProperty(exports, 'BreezeFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_breezeFilter).default;
  }
});

var _bwFilter = __webpack_require__(127);

Object.defineProperty(exports, 'BWFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_bwFilter).default;
  }
});

var _bwhardFilter = __webpack_require__(128);

Object.defineProperty(exports, 'BWHardFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_bwhardFilter).default;
  }
});

var _celsiusFilter = __webpack_require__(129);

Object.defineProperty(exports, 'CelsiusFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_celsiusFilter).default;
  }
});

var _chestFilter = __webpack_require__(130);

Object.defineProperty(exports, 'ChestFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_chestFilter).default;
  }
});

var _fixieFilter = __webpack_require__(131);

Object.defineProperty(exports, 'FixieFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_fixieFilter).default;
  }
});

var _foodFilter = __webpack_require__(132);

Object.defineProperty(exports, 'FoodFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_foodFilter).default;
  }
});

var _fridgeFilter = __webpack_require__(133);

Object.defineProperty(exports, 'FridgeFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_fridgeFilter).default;
  }
});

var _frontFilter = __webpack_require__(134);

Object.defineProperty(exports, 'FrontFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_frontFilter).default;
  }
});

var _glamFilter = __webpack_require__(135);

Object.defineProperty(exports, 'GlamFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_glamFilter).default;
  }
});

var _gobblinFilter = __webpack_require__(136);

Object.defineProperty(exports, 'GobblinFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_gobblinFilter).default;
  }
});

var _k1Filter = __webpack_require__(137);

Object.defineProperty(exports, 'K1Filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_k1Filter).default;
  }
});

var _k2Filter = __webpack_require__(138);

Object.defineProperty(exports, 'K2Filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_k2Filter).default;
  }
});

var _k6Filter = __webpack_require__(139);

Object.defineProperty(exports, 'K6Filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_k6Filter).default;
  }
});

var _kdynamicFilter = __webpack_require__(140);

Object.defineProperty(exports, 'KDynamicFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_kdynamicFilter).default;
  }
});

var _leninFilter = __webpack_require__(141);

Object.defineProperty(exports, 'LeninFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_leninFilter).default;
  }
});

var _lomoFilter = __webpack_require__(142);

Object.defineProperty(exports, 'LomoFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_lomoFilter).default;
  }
});

var _mellowFilter = __webpack_require__(144);

Object.defineProperty(exports, 'MellowFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_mellowFilter).default;
  }
});

var _metalFilter = __webpack_require__(145);

Object.defineProperty(exports, 'MetalFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_metalFilter).default;
  }
});

var _morningFilter = __webpack_require__(146);

Object.defineProperty(exports, 'MorningFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_morningFilter).default;
  }
});

var _orchidFilter = __webpack_require__(147);

Object.defineProperty(exports, 'OrchidFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_orchidFilter).default;
  }
});

var _polaFilter = __webpack_require__(148);

Object.defineProperty(exports, 'PolaFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_polaFilter).default;
  }
});

var _pola669Filter = __webpack_require__(149);

Object.defineProperty(exports, 'Pola669Filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_pola669Filter).default;
  }
});

var _quoziFilter = __webpack_require__(164);

Object.defineProperty(exports, 'QuoziFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_quoziFilter).default;
  }
});

var _semiredFilter = __webpack_require__(165);

Object.defineProperty(exports, 'SemiredFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_semiredFilter).default;
  }
});

var _sunnyFilter = __webpack_require__(166);

Object.defineProperty(exports, 'SunnyFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sunnyFilter).default;
  }
});

var _texasFilter = __webpack_require__(167);

Object.defineProperty(exports, 'TexasFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_texasFilter).default;
  }
});

var _x400Filter = __webpack_require__(168);

Object.defineProperty(exports, 'X400Filter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_x400Filter).default;
  }
});

var _lutFilter = __webpack_require__(143);

Object.defineProperty(exports, 'LUTFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_lutFilter).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var globals = _interopRequireWildcard(_globals);

var _operations = __webpack_require__(69);

var Operations = _interopRequireWildcard(_operations);

var _operationsStack = __webpack_require__(68);

var _operationsStack2 = _interopRequireDefault(_operationsStack);

var _versionChecker = __webpack_require__(119);

var _versionChecker2 = _interopRequireDefault(_versionChecker);

var _exif = __webpack_require__(43);

var _exif2 = _interopRequireDefault(_exif);

var _imageExporter = __webpack_require__(115);

var _imageExporter2 = _interopRequireDefault(_imageExporter);

var _performanceTest = __webpack_require__(80);

var _performanceTest2 = _interopRequireDefault(_performanceTest);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Rectangle = globals.Rectangle,
    Constants = globals.Constants,
    Engine = globals.Engine,
    Utils = globals.Utils,
    EventEmitter = globals.EventEmitter,
    Vector2 = globals.Vector2,
    Log = globals.Log,
    Base64 = globals.Base64; /*
                              * This file is part of PhotoEditorSDK.
                              *
                              * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                              * All rights reserved.
                              *
                              * Redistribution and use in source and binary forms, without
                              * modification, are permitted provided that the following license agreement
                              * is approved and a legal/financial contract was signed by the user.
                              * The license agreement can be found under following link:
                              *
                              * https://www.photoeditorsdk.com/LICENSE.txt
                              * @license
                              */

var bd = function bd(str) {
  return Utils.byteArrayToString(Base64.decode(str));
};

var RenderType = Constants.RenderType,
    ImageFormat = Constants.ImageFormat,
    Events = Constants.Events,
    RendererType = Constants.RendererType;

/**
 * The main SDK class which handles rendering and manages
 * operations.
 * @class
 * @alias PhotoEditorSDK
 */

var PhotoEditorSDK = function (_EventEmitter) {
  (0, _inherits3.default)(PhotoEditorSDK, _EventEmitter);

  /**
   * Creates a PhotoEditorSDK instance
   * @param  {String} [preferredRenderer = webgl] - `webgl` or `canvas`
   * @param  {Object} options
   * @param  {String} options.apiKey - Your API key
   * @param  {Image} [options.image] - The image that should be rendered
   * @param  {String} [options.renderMode = dynamic] - `dynamic` or `export`
   * @param  {Boolean} [options.versionCheck = true] - Should a version check be performed?
   * @param  {Boolean} [options.displayWelcomeMessage = true] - Should a welcome message be printed
   *   in the console?
   * @param  {Boolean} [options.transparent = false] - Should the canvas background be transparent?
   * @param  {HTMLCanvasElement} [options.canvas] - The canvas element the SDK should render to
   * @param  {Number} [options.zoom = 1] - The zoom level. Only available in `dynamic` mode
   * @param  {Number} [options.spriteScale = 1] - The output sprite's scale. Only available in `dynamic` mode
   * @param  {String} [options.logLevel = warn] - `trace`, `info`, `warn`, `error` or `log`
   * @param  {Number} [options.pixelRatio = 1] - If none is given, PhotoEditorSDK automatically
   *   detects the current device's pixel ratio
   * @param  {Boolean} [options.smoothDownscaling = false] - Toggles smooth downscaling
   * @param  {Boolean} [options.smoothUpscaling = false] - Toggles smooth upscaling
   */
  function PhotoEditorSDK(preferredRenderer) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, PhotoEditorSDK);

    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

    _this._onOperationUpdate = _this._onOperationUpdate.bind(_this);
    _this._onContextRestored = _this._onContextRestored.bind(_this);

    var _require = __webpack_require__(70),
        version = _require.version;

    _this.version = version;

    _this[bd('VG04Z1lHRndhVXRsZVdBZ2IzQjBhVzl1SUdkcGRtVnU=')] = true;
    _this._preferredRenderer = preferredRenderer;
    _this._options = Utils.defaults(options, {
      extensions: {},
      renderMode: 'dynamic',
      versionCheck: true,
      displayWelcomeMessage: true,
      image: null,
      canvas: null,
      transparent: false,
      textureQuality: 1,
      zoom: 1,
      spriteScale: 1,
      rotation: 0,
      smoothDownscaling: false,
      smoothUpscaling: false,
      logLevel: 'warn',
      pixelRatio: typeof window !== 'undefined' && window.devicePixelRatio || 1
    });

    if (_this._options.smoothUpscaling) {
      Engine.BaseTexture.DefaultMagFilter = Engine.BaseTexture.LinearFilter;
    }

    _this._options.extensions = Utils.defaults(_this._options.extensions, {
      operations: [],
      controls: [],
      languages: []
    });

    Log.setLevel(_this._options.logLevel);

    if (!_this._v()) return (0, _possibleConstructorReturn3.default)(_this);

    _this._defaultRenderMode = _this._options.renderMode;
    _this._renderMode = _this._options.renderMode;

    _this._textureQuality = _this._options.textureQuality;
    _this._offset = new Vector2();
    _this._zoom = _this._options.zoom;
    _this._spriteScale = _this._options.spriteScale;
    _this._rotation = _this._options.rotation;
    _this._operations = {};
    _this._operationsStack = null;
    _this.setOperationsStack(new _operationsStack2.default());

    // Engine stuff
    _this._container = new Engine.Container();
    _this._sprite = new Engine.Sprite();
    _this._container.addChild(_this._sprite);

    _this._inputBaseTexture = null;
    _this._inputTexture = null;
    _this._currentInputTexture = null;
    _this._currentTexture = null;

    _this._resizedTexture = null;
    _this._resizedContainer = new Engine.Container();
    _this._resizedSprite = new Engine.Sprite();
    _this._resizedContainer.addChild(_this._resizedSprite);

    _this.setSmoothDownscaling(_this._options.smoothDownscaling);

    _this._checkForUpdates();
    _this._registerOperations();
    _this._initRenderer();

    var renderer = _this._renderer.constructor.type;
    if (_this._options.displayWelcomeMessage) {
      Log.log('Yo!', 'Version: ' + _this.version + ' (' + renderer + ') - https://www.photoeditorsdk.com');
    }

    // Async image handling
    if (_this._options.image) {
      _this.setImage(_this._options.image);
    }
    return _this;
  }

  /**
   * Validates presence of the API key, initializes the `License` class and checks for a valid
   * license. In case the license is invalid, the `Tm8gYGFwaUtleWAgb3B0aW9uIGdpdmVu` property is set to false and
   * subsequent exports will fail.
   * @return {Boolean}
   * @private
   */


  PhotoEditorSDK.prototype._v = function _v() {
    var _this2 = this;

    // this._options.apiKey
    if (!this[bd('X29wdGlvbnM=')][bd('YXBpS2V5')]) {
      // Log.error('apiKey', 'No `apiKey` option given.')
      Log.error(bd('YXBpS2V5'), bd('Tm8gYGFwaUtleWAgb3B0aW9uIGdpdmVuLg=='));
      Log.error(bd('YXBpS2V5'), bd('SW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhbiBBUEkga2V5IHlldCwgcGxlYXNlIGNvbnRhY3Qgb3VyIHNhbGVzIHN0YWZmIGF0IHNhbGVzQHBob3RvZWRpdG9yc2RrLmNvbSB0byBvYnRhaW4gYSBsaWNlbnNlIG9yIGxvZyBpbiB0byB5b3VyIGN1c3RvbWVyIGRhc2hib2FyZC4='));
      return false;
    }
    // const L = globals.Licensing
    var L = globals[bd('TGljZW5zaW5n')];
    // thius._lic = new Licensing(this._options.apiKey)
    this._lic = new L(this[bd('X29wdGlvbnM=')][bd('YXBpS2V5')]);
    this._lic.c().catch(function (e) {
      _this2[bd('VG04Z1lHRndhVXRsZVdBZ2IzQjBhVzl1SUdkcGRtVnU=')] = false;
      // Log.error('Licensing', 'Invalid API key')
      Log.error(bd('TGljZW5zaW5n'), bd('SW52YWxpZCBsaWNlbnNlIGtleQ=='));
      Log.error(bd('TGljZW5zaW5n'), bd('SW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhbiBBUEkga2V5IHlldCwgcGxlYXNlIGNvbnRhY3Qgb3VyIHNhbGVzIHN0YWZmIGF0IHNhbGVzQHBob3RvZWRpdG9yc2RrLmNvbSB0byBvYnRhaW4gYSBsaWNlbnNlIG9yIGxvZyBpbiB0byB5b3VyIGN1c3RvbWVyIGRhc2hib2FyZC4='));
    });
    return true;
  };

  /**
   * Checks for valid license
   * @return {Promise}
   * @private
   */


  PhotoEditorSDK.prototype._cv = function _cv() {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      // !this.Tm8gYGFwaUtleWAgb3B0aW9uIGdpdmVu
      if (!_this3[bd('VG04Z1lHRndhVXRsZVdBZ2IzQjBhVzl1SUdkcGRtVnU=')]) {
        // new Error('Invalid license key')
        return reject(new Error(bd('SW52YWxpZCBsaWNlbnNlIGtleQ==')));
      }
      resolve();
    });
  };

  /**
   * Tracks an export / edit
   * @private
   */


  PhotoEditorSDK.prototype._t = function _t() {
    this._lic.t();
  };

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when an operation is updated. Delegates the event.
   * @private
   */


  PhotoEditorSDK.prototype._onOperationUpdate = function _onOperationUpdate() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.emit.apply(this, [Events.OPERATION_UPDATED].concat(args));
  };

  /**
   * Gets called when the WebGL context has been restored. Re-triggers a render.
   * @private
   */
  /* istanbul ignore next */


  PhotoEditorSDK.prototype._onContextRestored = function _onContextRestored() {
    Log.warn(this.constructor.name, 'Trying to re-render after WebGL context has been restored.');
    this.setAllOperationsToDirty();
    this._operationsStack.forEach(function (operation) {
      operation.disposeRenderTextures();
    });
    this.render();
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Exports the image with the given options. Result of the Promise is the exported image or data url.
   * @param  {PhotoEditorSDK.RenderType} [renderType=PhotoEditorSDK.RenderType.DATAURL] - The output type
   * @param  {PhotoEditorSDK.ImageFormat} [imageFormat=PhotoEditorSDK.ImageFormat.PNG] - The output image format
   * @param  {Number} [quality=0.8] - The image quality, between 0 and 1
   * @return {Promise}
   */


  PhotoEditorSDK.prototype.export = function _export() {
    var renderType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RenderType.DATAURL;

    var _this4 = this;

    var imageFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ImageFormat.PNG;
    var quality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.8;

    return this._cv().then(function () {
      _this4._t();
      var imageExporter = new _imageExporter2.default(_this4, {
        renderType: renderType, imageFormat: imageFormat, quality: quality
      });
      return imageExporter.export();
    });
  };

  /**
   * Renders the current image to the canvas
   * @return {Promise}
   */


  PhotoEditorSDK.prototype.render = function render() {
    var _this5 = this;

    if (!this._image) {
      throw new Error('You need to set an image before calling PhotoEditorSDK#render.');
    }

    var context = this._renderer.getContext();
    if (context.startFrame) {
      context.startFrame();
    }

    var perfTest = void 0;
    if (Log.canLog('info')) {
      perfTest = new _performanceTest2.default('', 'Frame rendering');
    }
    Log.info('', 'Rendering starts');

    var stack = this._operationsStack;
    stack.updateDirtinessForRenderer(this._renderer);

    return this._prepareTexture().then(function (texture) {
      if (_this5._renderMode === 'export') {
        texture = _this5._inputTexture;
      }

      _this5._currentTexture = texture;
      _this5._sprite.setTexture(texture);
      _this5._container.updateTransform();
    }).then(function () {
      return stack.validateSettings();
    }).then(function () {
      return stack.render(_this5, _this5._currentTexture);
    }).then(function (outputTexture) {
      // Input texture has been passed through all operations which return
      // a new RenderTexture. Use this texture for the Sprite and render it
      // to the output canvas.
      _this5._currentTexture = outputTexture;
      _this5._sprite.setTexture(_this5._currentTexture);

      switch (_this5._renderMode) {
        case 'dynamic':
          // Always center image, set scale to zoom level
          var center = _this5._renderer.getDimensions().clone().divide(2).add(_this5._offset);

          _this5._container.setScale(_this5._zoom / _this5.getTextureScale(), _this5._zoom / _this5.getTextureScale());
          _this5._container.setPosition(center);
          _this5._sprite.setAnchor(0.5, 0.5);
          _this5._sprite.setScale(_this5._spriteScale, _this5._spriteScale);
          _this5._sprite.setRotation(_this5._rotation);
          break;
        case 'export':
          // Move sprite to upper left hand corner, render at full scale
          _this5._container.setScale(1, 1);
          _this5._container.setPosition(0, 0);
          _this5._sprite.setAnchor(0, 0);
          _this5._sprite.setPosition(0, 0);
          _this5._sprite.setScale(_this5._spriteScale, _this5._spriteScale);
          _this5._sprite.setRotation(0);
          break;
      }

      // This renders to the output
      _this5._renderer.render(_this5._container);

      return outputTexture;
    }).then(function (texture) {
      if (perfTest) {
        perfTest.stop();
      }
      if (context.endFrame) {
        context.endFrame();
      }
      return texture;
    });
  };

  PhotoEditorSDK.prototype.getTextureScale = function getTextureScale() {
    return Math.min(1, this._textureQuality * this._options.pixelRatio);
  };

  /**
   * Prepares the input texture for the current zoom level
   * @private
   */


  PhotoEditorSDK.prototype._prepareTexture = function _prepareTexture() {
    var _this6 = this;

    return new Promise(function (resolve, reject) {
      var textureScale = _this6.getTextureScale();
      if (_this6._textureQuality === 1) {
        return resolve(_this6._inputTexture);
      }

      var dimensions = _this6.getInputDimensions().multiply(textureScale).floor();

      var needsRerender = void 0;
      if (!_this6._resizedTexture) {
        _this6._resizedTexture = new Engine.RenderTexture(_this6._renderer, dimensions.x, dimensions.y);
        needsRerender = true;
      } else if (!_this6._resizedTexture.getDimensions().equals(dimensions)) {
        _this6._resizedTexture.resizeTo(dimensions);
        needsRerender = true;
      }

      if (needsRerender) {
        _this6._resizedSprite.setScale(textureScale, textureScale);
        _this6._resizedSprite.setTexture(_this6._inputTexture);
        _this6._resizedTexture.render(_this6._resizedContainer);
      }

      resolve(_this6._resizedTexture);
    });
  };

  // -------------------------------------------------------------------------- OPERATIONS

  /**
   * Registers all default operations
   * @private
   */


  PhotoEditorSDK.prototype._registerOperations = function _registerOperations() {
    this._operations = {};

    for (var operationName in Operations) {
      var operation = Operations[operationName];
      this._operations[operation.identifier] = operation;
    }

    this._operations = Utils.extend(this._operations, this._options.extensions.operations);
  };

  /**
   * Sets all operations in the stack to dirty
   * @param {Boolean} dimensionsChanged = false
   */


  PhotoEditorSDK.prototype.setAllOperationsToDirty = function setAllOperationsToDirty() {
    var dimensionsChanged = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this._operationsStack.setAllToDirty(dimensionsChanged);
  };

  /**
   * Creates an operation with the given identifier
   * @param {String} identifier
   * @param {Object} [options = {}]
   * @param {Boolean} [addToStack = true]
   * @returns {PhotoEditorSDK.Operation}
   */


  PhotoEditorSDK.prototype.createOperation = function createOperation(identifier) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var addToStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var Operation = this._operations[identifier];
    if (!Operation) {
      throw new Error('No operation with identifier `' + identifier + '` found.');
    }

    var operation = new Operation(this, options);
    if (addToStack) {
      this.addOperation(operation);
    }
    return operation;
  };

  /**
   * Adds the given operation to the operations stack
   * @param {PhotoEditorSDK.Operation} operation
   */


  PhotoEditorSDK.prototype.addOperation = function addOperation(operation) {
    this._operationsStack.push(operation);
  };

  /**
   * Removes the given operation from the operations stack
   * @param  {PhotoEditorSDK.Operation} operation
   */


  PhotoEditorSDK.prototype.removeOperation = function removeOperation(operation) {
    this._operationsStack.remove(operation);
  };

  // -------------------------------------------------------------------------- DIMENSIONS

  /**
   * Returns the initial image dimensions
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  PhotoEditorSDK.prototype.getInputDimensions = function getInputDimensions() {
    var frame = this._inputTexture.getFrame();
    return new Vector2(frame.width, frame.height);
  };

  /**
   * Returns the final dimensions that the input image would have
   * after all existing operations have been applied
   * @param {Boolean} incorporateSpriteScale = false
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  PhotoEditorSDK.prototype.getFinalDimensions = function getFinalDimensions() {
    var incorporateSpriteScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var dimensions = this.getInputDimensions();
    var operationsStack = this._operationsStack;

    operationsStack.forEach(function (operation) {
      if (!operation.getEnabled()) return;
      dimensions = operation.getNewDimensions(dimensions);
    });

    if (incorporateSpriteScale) {
      dimensions.multiply(this._spriteScale);
    }

    return dimensions.floor();
  };

  /**
   * Returns the current sprite dimensions
   * @param {Boolean} incorporateSpriteScale = false
   * @return {Vector2}
   */


  PhotoEditorSDK.prototype.getOutputDimensions = function getOutputDimensions() {
    var incorporateSpriteScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    return this.getFinalDimensions(incorporateSpriteScale).clone().multiply(this._zoom).floor();
  };

  /**
   * Returns the dimensions of the output texture
   * @param  {Boolean} incorporateSpriteScale = false
   * @return {Vector2}
   */


  PhotoEditorSDK.prototype.getOutputTextureDimensions = function getOutputTextureDimensions() {
    var incorporateSpriteScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var textureScale = this.getTextureScale();
    var dimensions = this.getInputDimensions().multiply(textureScale).floor();
    this._operationsStack.forEach(function (op) {
      dimensions = op.getNewDimensions(dimensions);
    });
    return dimensions;
  };

  // -------------------------------------------------------------------------- MISC

  /**
   * Checks for version updates
   * @private
   */


  PhotoEditorSDK.prototype._checkForUpdates = function _checkForUpdates() {
    if (this._options.versionCheck) {
      this._versionChecker = new _versionChecker2.default(this.version);
    }
  };

  /**
   * Initializes the renderer
   * @private
   */


  PhotoEditorSDK.prototype._initRenderer = function _initRenderer() {
    var rendererOptions = {
      canvas: this._options.canvas,
      pixelRatio: this._options.pixelRatio,
      debug: this._options.debug,
      transparent: this._options.transparent
    };

    var width = void 0,
        height = void 0;
    if (this._renderMode === 'dynamic' && this._options.canvas) {
      var canvas = this._options.canvas;

      width = canvas.width;
      height = canvas.height;
    } else if (this._image) {
      var dimensions = this.getFinalDimensions();
      width = dimensions.x;
      height = dimensions.y;
    }

    switch (this._preferredRenderer) {
      /* istanbul ignore next */
      case RendererType.WEBGL:
        this._renderer = Engine.autoDetectRenderer(width, height, rendererOptions);
        this._renderer.on('context-restored', this._onContextRestored);
        break;
      case RendererType.CANVAS:
        this._renderer = new Engine.CanvasRenderer(width, height, rendererOptions);
        this._renderer.on('context-restored', this._onContextRestored);
        break;
      default:
        Log.warn('PhotoEditorSDK', 'PhotoEditorSDK Error: Renderer `' + this._preferredRenderer + '` not supported. Falling back to automatically detected renderer.');
        this._renderer = Engine.autoDetectRenderer(width, height, rendererOptions);
    }
  };

  /**
   * Resizes the renderer to the given dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   */


  PhotoEditorSDK.prototype.resizeTo = function resizeTo(dimensions) {
    this._renderer.resizeTo(dimensions, true);
  };

  /**
   * Resets all custom and selected operations
   */


  PhotoEditorSDK.prototype.reset = function reset() {
    this._operationsStack.clear();
  };

  // -------------------------------------------------------------------------- EXIF

  /**
   * Parses the exif data and fixes the orientation if necessary
   * @param {Image} image
   * @private
   * @TODO Move this somewhere else
   */


  PhotoEditorSDK.prototype.parseExif = function parseExif(image) {
    if (!image) {
      return;
    }
    var src = image.src;

    /* istanbul ignore else */

    if (_exif2.default.isJPEG(src)) {
      var exif = null;
      try {
        exif = _exif2.default.fromBase64String(src);
      } catch (e) {}
      if (!exif) {
        return;
      }

      return exif;
    }
  };

  /**
   * Reads the EXIF orientation tag and fixes it with the OrientationOperation
   * @private
   */


  PhotoEditorSDK.prototype._handleExifOrientation = function _handleExifOrientation() {
    var exifTags = this._exif.getTags();

    if (exifTags && exifTags.Orientation) {
      var rotationNeedsChange = exifTags.Orientation !== 1 && exifTags.Orientation !== 2;
      var flipNeedsChange = [2, 4, 5, 7].indexOf(exifTags.Orientation) !== -1;

      if (rotationNeedsChange || flipNeedsChange) {
        if (!this._exifOperation) {
          this._exifOperation = this.createOperation('exif-orientation');
        }
        this._exifOperation.setTags(exifTags);

        // We fixed the orientation, new EXIF orientation is 1
        this._exif.setOrientation(1);
      }
    }
  };

  // -------------------------------------------------------------------------- GETTERS / SETTERS

  /**
   * Checks if an image is provided
   * @return {Boolean} [description]
   */


  PhotoEditorSDK.prototype.hasImage = function hasImage() {
    return this._image !== null && typeof this._image !== 'undefined';
  };

  /**
   * Returns the image
   * @return {Image}
   */


  PhotoEditorSDK.prototype.getImage = function getImage() {
    return this._image;
  };

  /**
   * Sets the image and parses the exif data
   * @param {Image} image
   * @param {PhotoEditorSDK.Exif} [exif = null]
   * @param {PhotoEditorSDK.Math.Vector2} [dimensions]
   */


  PhotoEditorSDK.prototype.setImage = function setImage(image) {
    var exif = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var dimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    // Reset exif orientation compensation
    if (this._exifOperation) {
      this.removeOperation(this._exifOperation);
      this._exifOperation = null;
    }

    this._options.image = image;
    this._image = image;

    this._exif = exif || this.parseExif(image);
    if (this._exif) {
      this._handleExifOrientation();
    }

    var baseTexture = new Engine.BaseTexture(this._image);
    var frame = new Rectangle(0, 0, this._image.width, this._image.height);
    if (dimensions) {
      frame.width = dimensions.x;
      frame.height = dimensions.y;
    }

    if (this._resizedTexture) {
      this._resizedTexture.dispose();
    }
    this._resizedTexture = null;

    if (this._inputTexture) {
      this._inputTexture.getBaseTexture().dispose();
    }
    this._inputTexture = new Engine.Texture(baseTexture, frame);
    this._currentTexture = this._inputTexture;
    this._sprite.setTexture(this._inputTexture);

    this.setAllOperationsToDirty(true);
  };

  /**
   * Returns the canvas
   * @return {HTMLCanvasElement}
   */


  PhotoEditorSDK.prototype.getCanvas = function getCanvas() {
    return this._renderer.getCanvas();
  };

  /**
   * Sets the canvas
   * @param {HTMLCanvasElement} canvas
   */


  PhotoEditorSDK.prototype.setCanvas = function setCanvas(canvas) {
    this._renderer.setCanvas(canvas);
  };

  /**
   * Returns the sprite
   * @return {PhotoEditorSDK.Engine.Sprite}
   */


  PhotoEditorSDK.prototype.getSprite = function getSprite() {
    return this._sprite;
  };

  /**
   * Returns the container
   * @return {PhotoEditorSDK.Engine.Container}
   */


  PhotoEditorSDK.prototype.getContainer = function getContainer() {
    return this._container;
  };

  /**
   * Returns the operation stack
   * @return {PhotoEditorSDK.OperationsStack}
   */


  PhotoEditorSDK.prototype.getOperationsStack = function getOperationsStack() {
    return this._operationsStack;
  };

  /**
   * Sets the operations stack
   * @param {PhotoEditorSDK.OperationsStack} operationsStack
   */


  PhotoEditorSDK.prototype.setOperationsStack = function setOperationsStack(operationsStack) {
    if (this._operationsStack) {
      this._operationsStack.off(Events.OPERATION_UPDATED, this._onOperationUpdate);
    }

    this._operationsStack = operationsStack;
    this._operationsStack.on(Events.OPERATION_UPDATED, this._onOperationUpdate);
  };

  /**
   * Returns the available operations
   * @return {Operation[]}
   */


  PhotoEditorSDK.prototype.getOperations = function getOperations() {
    return this._operations;
  };

  /**
   * Returns the renderer
   * @return {PhotoEditorSDK.Engine.BaseRenderer}
   */


  PhotoEditorSDK.prototype.getRenderer = function getRenderer() {
    return this._renderer;
  };

  /**
   * Returns the rendering offset
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  PhotoEditorSDK.prototype.getOffset = function getOffset() {
    return this._offset;
  };

  /**
   * Sets the rendering offset
   * @param {PhotoEditorSDK.Math.Vector2|Number} offset
   * @param {Number} y
   */


  PhotoEditorSDK.prototype.setOffset = function setOffset(offset, y) {
    if (offset instanceof Vector2) {
      this._offset.copy(offset);
    } else {
      this._offset.set(offset, y);
    }
  };

  /**
   * Returns the current render mode
   * @return {String}
   */


  PhotoEditorSDK.prototype.getRenderMode = function getRenderMode() {
    return this._renderMode;
  };

  /**
   * Sets the render mode
   * @param {String} renderMode
   */


  PhotoEditorSDK.prototype.setRenderMode = function setRenderMode(renderMode) {
    this._renderMode = renderMode;
  };

  /**
   * Returns the zoom level
   * @return {Number}
   */


  PhotoEditorSDK.prototype.getZoom = function getZoom() {
    return this._zoom;
  };

  /**
   * Sets the zoom level
   * @param {Number} zoom
   */


  PhotoEditorSDK.prototype.setZoom = function setZoom(zoom) {
    this._zoom = zoom;
    this._container.setScale(this._zoom, this._zoom);
    this._container.updateTransform();
  };

  /**
   * Returns the texture quality
   * @return {Number}
   */


  PhotoEditorSDK.prototype.getTextureQuality = function getTextureQuality() {
    if (this._renderMode === 'export') {
      return 1;
    }

    return this._textureQuality;
  };

  /**
   * Sets the texture quality
   * @param {Number} textureQuality
   */


  PhotoEditorSDK.prototype.setTextureQuality = function setTextureQuality(textureQuality) {
    if (textureQuality !== this._textureQuality) {
      this.setAllOperationsToDirty(true);
    }
    this._textureQuality = Math.min(1, textureQuality);

    // Clean up resized texture, not needed right now
    if (this._textureQuality === 1 && this._resizedTexture) {
      this._resizedTexture.dispose();
      this._resizedTexture = null;
    }
  };

  /**
   * Returns the output sprite's scale
   * @return {Number}
   */


  PhotoEditorSDK.prototype.getSpriteScale = function getSpriteScale() {
    return this._spriteScale;
  };

  /**
   * Sets the sprite scale to the given value
   * @param {Number} spriteScale
   */


  PhotoEditorSDK.prototype.setSpriteScale = function setSpriteScale(spriteScale) {
    this._spriteScale = spriteScale;
    this._sprite.setScale(spriteScale, spriteScale);
    this._sprite.updateTransform();
  };

  /**
   * Returns the pixel ratio
   * @return {Number}
   */


  PhotoEditorSDK.prototype.getPixelRatio = function getPixelRatio() {
    return this._options.pixelRatio;
  };

  /**
   * Returns the Exif instance
   * @return {PhotoEditorSDK.Exif} [description]
   */


  PhotoEditorSDK.prototype.getExif = function getExif() {
    return this._exif;
  };

  /**
   * Returns the options
   * @return {Object}
   */


  PhotoEditorSDK.prototype.getOptions = function getOptions() {
    return this._options;
  };

  /**
   * Returns the input texture
   * @return {PhotoEditorSDK.Engine.Texture}
   */


  PhotoEditorSDK.prototype.getInputTexture = function getInputTexture() {
    return this._inputTexture;
  };

  /**
   * Sets the smooth downscaling flag for the output sprite
   * @param {Boolean} smoothDownscaling
   */


  PhotoEditorSDK.prototype.setSmoothDownscaling = function setSmoothDownscaling(smoothDownscaling) {
    this._options.smoothDownscaling = smoothDownscaling;
    this._sprite.setSmoothDownscaling(smoothDownscaling);
    this._resizedSprite.setSmoothDownscaling(smoothDownscaling);
  };

  /**
   * Sets the rotation to the given value
   * @param {Number} rotation
   */


  PhotoEditorSDK.prototype.setRotation = function setRotation(rotation) {
    this._rotation = rotation;
  };

  /**
   * Returns the current rotation
   */


  PhotoEditorSDK.prototype.getRotation = function getRotation() {
    return this._rotation;
  };

  // -------------------------------------------------------------------------- DISPOSAL

  /**
   * Disposes the SDK
   */


  PhotoEditorSDK.prototype.dispose = function dispose() {
    this._operationsStack.dispose();
    this._renderer.dispose();
    if (this._exif) {
      this._exif.dispose();
    }
    if (this._resizedTexture) {
      this._resizedTexture.dispose();
    }
  };

  return PhotoEditorSDK;
}(EventEmitter);

exports.default = PhotoEditorSDK;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _filter = __webpack_require__(45);

var _filter2 = _interopRequireDefault(_filter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType; /*
                                                   * This file is part of PhotoEditorSDK.
                                                   *
                                                   * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                   * All rights reserved.
                                                   *
                                                   * Redistribution and use in source and binary forms, without
                                                   * modification, are permitted provided that the following license agreement
                                                   * is approved and a legal/financial contract was signed by the user.
                                                   * The license agreement can be found under following link:
                                                   *
                                                   * https://www.photoeditorsdk.com/LICENSE.txt
                                                   */

/* istanbul ignore next */
var ColorOverlayFilter = function (_Filter) {
  (0, _inherits3.default)(ColorOverlayFilter, _Filter);

  function ColorOverlayFilter() {
    (0, _classCallCheck3.default)(this, ColorOverlayFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._fragmentSource = __webpack_require__(231);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  ColorOverlayFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var outputContext = outputTarget.getContext();

    outputContext.drawImage(canvas, 0, 0);
  };

  return ColorOverlayFilter;
}(_filter2.default);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */


ColorOverlayFilter.prototype.availableOptions = {
  color: { type: OptionType.COLOR, default: _globals.Color.WHITE, uniformType: UniformType.FLOAT4 }
};

exports.default = ColorOverlayFilter;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _unpremultiplyFilter = __webpack_require__(103);

Object.defineProperty(exports, 'UnpremultiplyFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_unpremultiplyFilter).default;
  }
});

var _colorOverlayFilter = __webpack_require__(101);

Object.defineProperty(exports, 'ColorOverlayFilter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_colorOverlayFilter).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(45);

var _filter2 = _interopRequireDefault(_filter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
var UnpremultiplyFilter = function (_Filter) {
  (0, _inherits3.default)(UnpremultiplyFilter, _Filter);

  function UnpremultiplyFilter() {
    (0, _classCallCheck3.default)(this, UnpremultiplyFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call(this));

    _this._fragmentSource = __webpack_require__(232);
    return _this;
  }

  return UnpremultiplyFilter;
}(_filter2.default); /*
                      * This file is part of PhotoEditorSDK.
                      *
                      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                      * All rights reserved.
                      *
                      * Redistribution and use in source and binary forms, without
                      * modification, are permitted provided that the following license agreement
                      * is approved and a legal/financial contract was signed by the user.
                      * The license agreement can be found under following link:
                      *
                      * https://www.photoeditorsdk.com/LICENSE.txt
                      */

exports.default = UnpremultiplyFilter;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _contextPerformanceHook = __webpack_require__(75);

var _contextPerformanceHook2 = _interopRequireDefault(_contextPerformanceHook);

var _baseRenderer = __webpack_require__(72);

var _baseRenderer2 = _interopRequireDefault(_baseRenderer);

var _canvasRenderTarget = __webpack_require__(33);

var _canvasRenderTarget2 = _interopRequireDefault(_canvasRenderTarget);

var _canvasFilterManager = __webpack_require__(46);

var _canvasFilterManager2 = _interopRequireDefault(_canvasFilterManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RendererType = _globals.Constants.RendererType; /*
                                                     * This file is part of PhotoEditorSDK.
                                                     *
                                                     * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                     * All rights reserved.
                                                     *
                                                     * Redistribution and use in source and binary forms, without
                                                     * modification, are permitted provided that the following license agreement
                                                     * is approved and a legal/financial contract was signed by the user.
                                                     * The license agreement can be found under following link:
                                                     *
                                                     * https://www.photoeditorsdk.com/LICENSE.txt
                                                     */

/**
 * The renderer that is used for Canvas2D rendering
 * @class
 * @extends PhotoEditorSDK.Engine.BaseRenderer
 * @memberof PhotoEditorSDK.Engine
 */
var CanvasRenderer = function (_BaseRenderer) {
  (0, _inherits3.default)(CanvasRenderer, _BaseRenderer);

  /**
   * Creates a CanvasRenderer
   * @override
   */
  function CanvasRenderer() {
    (0, _classCallCheck3.default)(this, CanvasRenderer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseRenderer.call.apply(_BaseRenderer, [this].concat(args)));

    _this._type = RendererType.CANVAS;

    _this.setCanvas(_this._options.canvas || _this._createCanvas());
    return _this;
  }

  /**
   * Creates a canvas element
   * @return {Canvas}
   * @private
   */


  CanvasRenderer.prototype._createCanvas = function _createCanvas() {
    return _globals.Utils.createCanvas();
  };

  /**
   * Gets the rendering context for this renderer
   * @returns {Object}
   * @private
   */


  CanvasRenderer.prototype._createContext = function _createContext() {
    var canvas = this._canvas;
    var ctx = canvas.getContext('2d');

    if (this._options.debug) {
      ctx = new _contextPerformanceHook2.default(ctx);
    }

    this.id = ctx.id = CanvasRenderer.contextId++;
    this._context = ctx;
    ctx.renderer = this;

    this.emit('context', ctx);

    return ctx;
  };

  /**
   * Sets up the rendering context for this renderer
   * @private
   */


  CanvasRenderer.prototype._setupContext = function _setupContext() {
    var ctx = this._context;

    // Enable image smoothing if available
    if (!('imageSmoothingEnabled' in ctx)) {
      ['moz', 'webkit', 'ms'].forEach(function (prop) {
        if (ctx[prop]) {
          ctx[prop] = true;
        }
      });
    } else {
      ctx.imageSmoothingEnabled = true;
    }

    this._defaultRenderTarget = new _canvasRenderTarget2.default(this._width, this._height, this._pixelRatio, this._canvas, this._context);
    this.setRenderTarget(this._defaultRenderTarget);

    this._filterManager = new _canvasFilterManager2.default(this);
  };

  /**
   * Renders the given DisplayObject
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   */


  CanvasRenderer.prototype.render = function render(displayObject) {
    var ctx = this._renderTarget.getContext();

    // Since the given displayObject is the "root" object
    // right now, we need to give it a dummy / fake object
    // as parent with the default world transform and alpha
    var originalParent = displayObject.getParent();
    displayObject.setParent(this._fakeObject);

    // Update transforms and render this object
    displayObject.updateTransform();

    // Reset parent
    displayObject.setParent(originalParent);

    // Reset transform
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // Reset alpha
    ctx.globalAlpha = 1;

    // Clear the view
    var _canvas = this._canvas,
        width = _canvas.width,
        height = _canvas.height;

    ctx.clearRect(0, 0, width, height);
    if (this._clearColor.a !== 0) {
      ctx.save();
      ctx.fillStyle = this._clearColor.toRGBA();
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }

    this.renderDisplayObject(displayObject, this._renderTarget);
  };

  /**
   * Renders the given DisplayObject
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   * @param  {PhotoEditorSDK.Engine.RenderTarget} renderTarget
   */


  CanvasRenderer.prototype.renderDisplayObject = function renderDisplayObject(displayObject, renderTarget) {
    var originalRenderTarget = this._renderTarget;
    this._filterManager.setFilterStack(renderTarget.getFilterStack());
    this.setRenderTarget(renderTarget);
    displayObject.renderCanvas(this);
    this.setRenderTarget(originalRenderTarget);
  };

  /**
   * Returns the current render target
   * @return {PhotoEditorSDK.Engine.RenderTarget}
   */


  CanvasRenderer.prototype.getCurrentRenderTarget = function getCurrentRenderTarget() {
    return this._renderTarget;
  };

  /**
   * Sets the render target
   * @param {PhotoEditorSDK.Engine.RenderTarget} renderTarget
   */


  CanvasRenderer.prototype.setRenderTarget = function setRenderTarget(renderTarget) {
    this._renderTarget = renderTarget;
  };

  /**
   * Returns the current rendering context
   * @return {RenderingContext}
   */


  CanvasRenderer.prototype.getContext = function getContext() {
    return this._renderTarget.getContext();
  };

  /**
   * Disposes this Renderer
   */


  CanvasRenderer.prototype.dispose = function dispose() {
    this._filterManager.dispose();
  };

  return CanvasRenderer;
}(_baseRenderer2.default);

CanvasRenderer.contextId = 0;
CanvasRenderer.type = 'Canvas2D';

exports.default = CanvasRenderer;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _globals2 = _interopRequireDefault(_globals);

var _objectRenderer = __webpack_require__(73);

var _objectRenderer2 = _interopRequireDefault(_objectRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The ObjectRenderer that is responsible for rendering Sprite instances
 * @class
 * @extends PhotoEditorSDK.Engine.ObjectRenderer
 * @memberof PhotoEditorSDK.Engine
 */
/* istanbul ignore next */
/* eslint constructor-super: 0 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SpriteRenderer = function (_ObjectRenderer) {
  (0, _inherits3.default)(SpriteRenderer, _ObjectRenderer);

  /**
   * Creates a SpriteRenderer
   * @override
   */
  function SpriteRenderer() {
    (0, _classCallCheck3.default)(this, SpriteRenderer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _ObjectRenderer.call.apply(_ObjectRenderer, [this].concat(args)));

    _this._maxBatchSize = _globals2.default.BATCH_SIZE;
    _this._vertices = new ArrayBuffer(_globals2.default.BATCH_SIZE * 4 * _globals2.default.VERTEX_BYTE_SIZE);
    _this._positions = new Float32Array(_this._vertices);
    _this._colors = new Uint32Array(_this._vertices);
    _this._indices = new Uint16Array(_globals2.default.BATCH_SIZE * 6);

    // Fill vertex position indices
    for (var i = 0, j = 0; i < _globals2.default.BATCH_SIZE * 6; i += 6, j += 4) {
      _this._indices[i + 0] = j + 0;
      _this._indices[i + 1] = j + 1;
      _this._indices[i + 2] = j + 2;
      _this._indices[i + 3] = j + 0;
      _this._indices[i + 4] = j + 2;
      _this._indices[i + 5] = j + 3;
    }

    _this._shaders = [];
    _this._sprites = [];

    _this._currentBatchSize = 0;
    _this._currentBaseTexture = null;

    _this._onContextChange();
    return _this;
  }

  /**
   * Adds the given sprite to the batch
   * @param  {PhotoEditorSDK.Engine.Sprite} sprite
   */


  SpriteRenderer.prototype.render = function render(sprite) {
    var texture = sprite.getTexture();
    var textureFrame = texture.getFrame();
    var baseTexture = texture.getBaseTexture();

    // Has the maximum batch size been reached? Flush!
    if (this._currentBatchSize >= this._maxBatchSize) {
      this.flush();
      this._currentBaseTexture = baseTexture;
    }

    // No updated UVs => No rendering
    var uvs = texture.getUVs();
    if (!uvs) {
      return;
    }

    // Fill positions array
    var index = this._currentBatchSize * _globals2.default.VERTEX_BYTE_SIZE;
    this._addVertexCoordinates(sprite, index, textureFrame);
    this._addTextureUVs(sprite, index, uvs);
    this._addColors(sprite, index);

    // Add the sprite to the list of sprites
    this._sprites[this._currentBatchSize] = sprite;
    this._currentBatchSize++;
  };

  /**
   * Adds the color to the positions array for the given sprite
   * @param {PhotoEditorSDK.Engine.Sprite} sprite
   * @param {Number} index
   * @private
   */


  SpriteRenderer.prototype._addColors = function _addColors(sprite, index) {
    var colors = this._colors;
    var tint = sprite.getTint();
    var color = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.getWorldAlpha() * 255 << 24);
    colors[index + 4] = colors[index + 9] = colors[index + 14] = colors[index + 19] = color;
  };

  /**
   * Adds the texture UV coordinates to the positions array for the given sprite
   * @param {PhotoEditorSDK.Engine.Sprite} sprite
   * @param {Number} index
   * @param {PhotoEditorSDK.Engine.TextureUVs} uvs
   * @private
   */


  SpriteRenderer.prototype._addTextureUVs = function _addTextureUVs(sprite, index, uvs) {
    var positions = this._positions;

    // Add UVs
    var uvCoords = uvs.getUVsAt(0);
    positions[index + 2] = uvCoords.x;
    positions[index + 3] = uvCoords.y;

    uvCoords = uvs.getUVsAt(1);
    positions[index + 7] = uvCoords.x;
    positions[index + 8] = uvCoords.y;

    uvCoords = uvs.getUVsAt(2);
    positions[index + 12] = uvCoords.x;
    positions[index + 13] = uvCoords.y;

    uvCoords = uvs.getUVsAt(3);
    positions[index + 17] = uvCoords.x;
    positions[index + 18] = uvCoords.y;
  };

  /**
   * Adds the vertex coordinates to the positions array for the given
   * sprite and texture frame
   * @param {PhotoEditorSDK.Engine.Sprite} sprite
   * @param {Number} index
   * @param {PhotoEditorSDK.Math.Rectangle} textureFrame
   * @private
   */


  SpriteRenderer.prototype._addVertexCoordinates = function _addVertexCoordinates(sprite, index, textureFrame) {
    var positions = this._positions;
    var worldTransform = sprite.getWorldTransform();

    // Transform sprite coords with anchor in mind
    var anchor = sprite.getAnchor();
    var rectPositions = worldTransform.rectangleToCoordinates(textureFrame, anchor);

    var stride = 5;
    for (var i = 0; i < 4; i++) {
      positions[index + i * stride] = rectPositions[i].x;
      positions[index + i * stride + 1] = rectPositions[i].y;
    }
  };

  /**
   * Gets called when the rendering context changes
   * @private
   */


  SpriteRenderer.prototype._onContextChange = function _onContextChange() {
    var gl = this._renderer.getContext();

    this._shader = this._renderer.shaders.default;

    this._vertexBuffer = gl.createBuffer();
    this._indexBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
  };

  /**
   * Gets called when this object renderer is activated
   */


  SpriteRenderer.prototype.start = function start() {
    this._shader.setupBuffers(this._vertexBuffer, this._indexBuffer);
  };

  /**
   * Renders the queued sprites in batches, every time the base texture has changed,
   * it flushes the current batch to the graphics card
   */


  SpriteRenderer.prototype.flush = function flush() {
    var renderer = this._renderer;
    var gl = renderer.getContext();

    if (this._currentBatchSize === 0) {
      return;
    }

    if (this._currentBatchSize > _globals2.default.BATCH_SIZE * 0.5) {
      // Upload whole ArrayBuffer
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
    } else {
      // Only upload sub array
      var subArray = this._positions.subarray(0, this._currentBatchSize * _globals2.default.VERTEX_BYTE_SIZE);
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, subArray);
    }

    // Init variables
    var currentBatchSize = 0;
    var currentBaseTexture = null;
    var nextBaseTexture = null;
    var currentShader = null;
    var nextShader = null;
    var shaderChanged = false;
    var textureChanged = false;
    var sprite = null;
    var batchStartIndex = 0;

    for (var i = 0, j = this._currentBatchSize; i < j; i++) {
      sprite = this._sprites[i];

      nextBaseTexture = sprite.getTexture().getBaseTexture();
      nextShader = sprite.getShader() || this._shader;
      shaderChanged = currentShader !== nextShader;
      textureChanged = currentBaseTexture !== nextBaseTexture;

      if (textureChanged || shaderChanged) {
        this._renderBatch(currentBaseTexture, currentBatchSize, batchStartIndex);

        batchStartIndex = i;
        currentBatchSize = 0;
        currentBaseTexture = nextBaseTexture;

        // Shader has changed, set it
        if (shaderChanged) {
          currentShader = nextShader;
          renderer.setShader(currentShader);

          var renderTarget = renderer.getCurrentRenderTarget();
          var projectionMatrix = renderTarget.getProjectionMatrix().toArray();
          currentShader.setUniform('u_projMatrix', projectionMatrix);
          currentShader.syncUniforms();

          gl.activeTexture(gl.TEXTURE0);
        }
      }

      currentBatchSize++;
    }

    this._renderBatch(currentBaseTexture, currentBatchSize, batchStartIndex);

    // Reset the batch
    this._currentBatchSize = 0;
    this._sprites = [];
  };

  /**
   * Renders the current batch
   * @param  {PhotoEditorSDK.Engine.BaseTexture} baseTexture
   * @param  {Number} batchSize
   * @param  {Number} batchStartIndex
   * @private
   */


  SpriteRenderer.prototype._renderBatch = function _renderBatch(baseTexture, batchSize, batchStartIndex) {
    if (batchSize === 0) {
      return;
    }

    var renderer = this._renderer;
    var gl = renderer.getContext();

    var glTexture = baseTexture.getGLTextureForRenderer(renderer);
    if (!glTexture) {
      glTexture = renderer.getOrCreateGLTexture(baseTexture);
    }

    if (baseTexture.isDirty()) {
      renderer.updateTexture(baseTexture);
      baseTexture.setDirty(false);
    }

    gl.activeTexture(gl.TEXTURE0 + baseTexture.getGLUnit());
    gl.bindTexture(gl.TEXTURE_2D, glTexture);

    var verticesCount = batchSize * 6;
    var vertexOffset = batchStartIndex * 6 * 2;
    gl.drawElements(gl.TRIANGLES, verticesCount, gl.UNSIGNED_SHORT, vertexOffset);
  };

  /**
   * Disposes this ObjectRenderer
   */


  SpriteRenderer.prototype.dispose = function dispose() {
    var renderer = this._renderer;
    var gl = renderer.getContext();

    gl.deleteBuffer(this._vertexBuffer);
    gl.deleteBuffer(this._indexBuffer);

    this._vertices = null;
    this._positions = null;
    this._colors = null;
    this._indices = null;

    _ObjectRenderer.prototype.dispose.call(this);
  };

  return SpriteRenderer;
}(_objectRenderer2.default);

exports.default = SpriteRenderer;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _baseRenderer = __webpack_require__(72);

var _baseRenderer2 = _interopRequireDefault(_baseRenderer);

var _webglRenderTarget = __webpack_require__(34);

var _webglRenderTarget2 = _interopRequireDefault(_webglRenderTarget);

var _objectRenderer = __webpack_require__(73);

var _objectRenderer2 = _interopRequireDefault(_objectRenderer);

var _spriteRenderer = __webpack_require__(105);

var _spriteRenderer2 = _interopRequireDefault(_spriteRenderer);

var _textureShader = __webpack_require__(49);

var _textureShader2 = _interopRequireDefault(_textureShader);

var _displayObject = __webpack_require__(44);

var _displayObject2 = _interopRequireDefault(_displayObject);

var _webglFilterManager = __webpack_require__(47);

var _webglFilterManager2 = _interopRequireDefault(_webglFilterManager);

var _contextPerformanceHook = __webpack_require__(75);

var _contextPerformanceHook2 = _interopRequireDefault(_contextPerformanceHook);

var _webglMemoryManager = __webpack_require__(113);

var _webglMemoryManager2 = _interopRequireDefault(_webglMemoryManager);

var _pixelArrayImage = __webpack_require__(76);

var _pixelArrayImage2 = _interopRequireDefault(_pixelArrayImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RendererType = _globals.Constants.RendererType; /* global Image, HTMLImageElement, WEBPACK */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

// For server-side environments

/**
 * The renderer that is used for WebGL rendering
 * @class
 * @extends PhotoEditorSDK.Engine.BaseRenderer
 * @memberof PhotoEditorSDK.Engine
 */
/* istanbul ignore next */
var WebGLRenderer = function (_BaseRenderer) {
  (0, _inherits3.default)(WebGLRenderer, _BaseRenderer);

  /**
   * Creates a WebGLRenderer
   * @override
   */
  function WebGLRenderer() {
    (0, _classCallCheck3.default)(this, WebGLRenderer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseRenderer.call.apply(_BaseRenderer, [this].concat(args)));

    _this._type = RendererType.WEBGL;

    _this._textures = [];
    _this._fakeObject = new _displayObject2.default();
    _this._onContextLost = _this._onContextLost.bind(_this);
    _this._onContextRestored = _this._onContextRestored.bind(_this);

    _this.setCanvas(_this._options.canvas || _globals.Utils.createCanvas());

    _this.shaders = _this._initShaders();
    _this.renderers = _this._initRenderers();
    return _this;
  }

  // -------------------------------------------------------------------------- CONTEXT LOSS

  /**
   * Gets called when the WebGL context has been lost
   * @param  {Event} e
   * @private
   */


  WebGLRenderer.prototype._onContextLost = function _onContextLost(e) {
    e.preventDefault();
    _globals.Log.warn(this.constructor.name, 'WebGL context has been lost - trying to restore.');
  };

  /**
   * Gets called when the WebGL context could not be created
   * @param  {Object} e
   * @private
   */


  WebGLRenderer.prototype._onContextCreationError = function _onContextCreationError(e) {
    e.preventDefault();
    _globals.Log.warn(this.constructor.name, 'Failed to create WebGL context: ' + (e.statusMessage || 'Unknown error'));
  };

  /**
   * Gets called when the WebGL context has been restored. Cleans up and resets everything.
   * @private
   */


  WebGLRenderer.prototype._onContextRestored = function _onContextRestored() {
    var _this2 = this;

    _globals.Log.warn(this.constructor.name, 'WebGL context has been restored. Clearing all textures.');

    this._textures.forEach(function (texture) {
      texture.disposeGLTexturesForRenderer(_this2);
    });

    this._createContext();
    this._setupContext();
    this.emit('context-restored');
  };

  /**
   * Gets called before the context has been set up
   * @private
   */


  WebGLRenderer.prototype._onBeforeContext = function _onBeforeContext() {
    if (this._filterManager) {
      this._filterManager.dispose();
    }
    this._filterManager = new _webglFilterManager2.default(this);
    this._currentObjectRenderer = new _objectRenderer2.default(this);
  };

  /**
   * Sets the given shader to active
   * @param {PhotoEditorSDK.Engine.Shader} shader
   */


  WebGLRenderer.prototype.setShader = function setShader(shader) {
    this._currentShader = shader;
    this._context.useProgram(shader.getProgram());
    this._setAttributesForShader(shader);
  };

  /**
   * Sets the canvas to the given one
   * @param {HTMLCanvasElement} canvas
   */


  WebGLRenderer.prototype.setCanvas = function setCanvas(canvas) {
    if (this._canvas) {
      this._canvas.removeEventListener('webglcontextlost', this._onContextLost);
      this._canvas.removeEventListener('webglcontextrestored', this._onContextRestored);
      this._canvas.removeEventListener('webglcontextcreationerror', this._onContextCreationError);
    }

    if (canvas.addEventListener) {
      // node-canvas doesn't have events
      canvas.addEventListener('webglcontextlost', this._onContextLost);
      canvas.addEventListener('webglcontextrestored', this._onContextRestored);
      canvas.addEventListener('webglcontextcreationerror', this._onContextCreationError);
    }

    _BaseRenderer.prototype.setCanvas.call(this, canvas);
  };

  /**
   * Uploads the given shader's attributes to the GPU
   * @param {PhotoEditorSDK.Engine.Shader} shader
   */


  WebGLRenderer.prototype._setAttributesForShader = function _setAttributesForShader(shader) {
    var gl = this._context;
    var attributes = shader.getAttributes();
    var attributeLocations = shader.getAttributeLocations();

    attributes.forEach(function (attributeName) {
      var attributeLocation = attributeLocations[attributeName];
      gl.enableVertexAttribArray(attributeLocation);
    });
  };

  /**
   * Initializes the default shaders
   * @return {Object}
   * @private
   */


  WebGLRenderer.prototype._initShaders = function _initShaders() {
    return {
      default: new _textureShader2.default(this)
    };
  };

  /**
   * Initializes the available object renderers
   * @return {Object}
   * @private
   */


  WebGLRenderer.prototype._initRenderers = function _initRenderers() {
    return {
      sprite: new _spriteRenderer2.default(this)
    };
  };

  /**
   * Gets the rendering context for this renderer
   * @returns {Object}
   * @private
   */


  WebGLRenderer.prototype._createContext = function _createContext() {
    var canvas = this._canvas;
    var gl = null;

    var contextOptions = {
      preserveDrawingBuffer: true
    };

    if (true) {
      gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
    }

    // Hook up WebGLDebugUtils if present
    if (typeof window !== 'undefined' && window.WebGLDebugUtils && this._options.debug) {
      var logGL = function logGL(functionName, args) {
        console.error('gl.' + functionName + '(' + window.WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ')');
      };
      gl = window.WebGLDebugUtils.makeDebugContext(gl, null, logGL);
    }

    // Hook up ContextPerformanceHook if debug is enabled
    if (this._options.debug) {
      gl = new _contextPerformanceHook2.default(gl);
      gl = new _webglMemoryManager2.default(gl);
    }

    this.id = gl.id = WebGLRenderer.contextId++;
    this._context = gl;
    gl.renderer = this;

    this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);

    this.emit('context', gl);

    return gl;
  };

  /**
   * Sets up the rendering context for this renderer
   * @private
   */


  WebGLRenderer.prototype._setupContext = function _setupContext() {
    var gl = this._context;

    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    this._defaultRenderTarget = new _webglRenderTarget2.default(this, this._width, this._height, this._pixelRatio, true);
    this.setRenderTarget(this._defaultRenderTarget);
    this._getMaxPrecision();
  };

  /**
   * Finds the maximum int / float precision for this device
   * @private
   */


  WebGLRenderer.prototype._getMaxPrecision = function _getMaxPrecision() {
    var gl = this._context;
    var highFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
    this._maxFloatPrecision = highFloat.precision !== 0 ? 'highp' : 'mediump';

    var highInt = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT);
    this._maxIntPrecision = highInt.rangeMax !== 0 ? 'highp' : 'lowp';
  };

  /**
   * Resizes the context and view to the given size
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   * @param  {Boolean} resizeCanvas = true
   */


  WebGLRenderer.prototype.resizeTo = function resizeTo(dimensions) {
    var resizeCanvas = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    _BaseRenderer.prototype.resizeTo.call(this, dimensions, resizeCanvas);

    if (this._currentRenderTarget) {
      this._currentRenderTarget.resizeTo(dimensions);
    }
  };

  /**
   * Sets the current render target to the passed one and activates
   * it for rendering
   * @param {PhotoEditorSDK.Engine.RenderTarget} renderTarget
   */


  WebGLRenderer.prototype.setRenderTarget = function setRenderTarget() {
    var renderTarget = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._defaultRenderTarget;

    this._currentRenderTarget = renderTarget;
    this._currentRenderTarget.activate();
  };

  /**
   * Sets the current object renderer to the given one
   * @param {PhotoEditorSDK.Engine.ObjectRenderer} objectRenderer
   */


  WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {
    this._currentObjectRenderer.stop();
    this._currentObjectRenderer = objectRenderer;
    this._currentObjectRenderer.start();
  };

  /**
   * Renders the given DisplayObject
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   */


  WebGLRenderer.prototype.render = function render(displayObject) {
    this.setRenderTarget(this._defaultRenderTarget);
    this._defaultRenderTarget.clear(this._clearColor);

    // Since the given displayObject is the "root" object
    // right now, we need to give it a dummy / fake object
    // as parent with the default world transform and alpha
    var originalParent = displayObject.getParent();
    displayObject.setParent(this._fakeObject);

    // Update transforms and render this object
    displayObject.updateTransform();

    // Reset parent
    displayObject.setParent(originalParent);

    this.renderDisplayObject(displayObject, this._defaultRenderTarget);
  };

  /**
   * Renders the given DisplayObject
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   * @param  {PhotoEditorSDK.Engine.RenderTarget} renderTarget
   */


  WebGLRenderer.prototype.renderDisplayObject = function renderDisplayObject(displayObject, renderTarget) {
    this.setRenderTarget(renderTarget);
    this._filterManager.setFilterStack(renderTarget.getFilterStack());
    displayObject.renderWebGL(this);
    this._currentObjectRenderer.flush();
  };

  /**
   * Clears the context
   */


  WebGLRenderer.prototype.clear = function clear() {
    var gl = this._context;

    gl.clearColor.apply(gl, this._clearColor.toGLColor());
    gl.clear(gl.COLOR_BUFFER_BIT);
  };

  /**
   * Saves the renderer state and returns the state object
   * @return {Object}
   */


  WebGLRenderer.prototype.save = function save() {
    return {
      renderTarget: this._currentRenderTarget,
      objectRenderer: this._currentObjectRenderer,
      filterStack: this._filterManager.getFilterStack()
    };
  };

  /**
   * Restores the given renderer state
   * @param  {Object} save
   */


  WebGLRenderer.prototype.restore = function restore(save) {
    this.setRenderTarget(save.renderTarget);
    this._filterManager.setFilterStack(save.filterStack);
    this._currentObjectRenderer = save.objectRenderer;
  };

  /**
   * Returns and/or creates a WebGLTexture for the given BaseTexture object
   * @param  {PhotoEditorSDK.Engine.BaseTexture} texture
   * @return {PhotoEditorSDK.Engine.WebGLTexture}
   */


  WebGLRenderer.prototype.getOrCreateGLTexture = function getOrCreateGLTexture(texture) {
    var gl = this._context;

    var glTexture = texture.getGLTextureForRenderer(this);
    if (!glTexture) {
      glTexture = gl.createTexture();
      texture.setGLTextureForRenderer(glTexture, this);

      // Hold reference to texture for easier disposal
      this._textures.push(texture);
    }

    return glTexture;
  };

  /**
   * Updates the given texture
   * @param  {PhotoEditorSDK.Engine.BaseTexture} texture
   * @param  {Boolean} [upload = true]
   */


  WebGLRenderer.prototype.updateTexture = function updateTexture(texture) {
    var upload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var source = texture.getSource();
    var hasSource = !!source;

    var gl = this._context;
    var glUnit = texture.getGLUnit();
    var glTexture = this.getOrCreateGLTexture(texture);

    gl.activeTexture(gl.TEXTURE0 + glUnit);
    gl.bindTexture(gl.TEXTURE_2D, glTexture);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

    if (upload && hasSource) {
      if (typeof Image !== 'undefined' && source instanceof Image || typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement || source.constructor.name === 'Canvas' || source.tagName && source.tagName.toUpperCase() === 'CANVAS' || source.tagName && source.tagName.toUpperCase() === 'IMG') {
        // Default client-side behavior: Upload the `source` image
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
      } else {
        // In case we're on the server side, convert a `node-canvas` Image object
        // into a PixelArrayImage
        if (typeof NodeCanvasImage !== 'undefined' && source instanceof NodeCanvasImage) {
          source = _pixelArrayImage2.default.fromNodeCanvasImage(source);
        }

        // Upload the PixelArrayImage's data (a Uint8Array)
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.width, source.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, source.data);
      }
    }

    if (texture.isMipMappingEnabled()) {
      gl.generateMipmap(gl.TEXTURE_2D);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texture.getGLRepeat(gl, 'x'));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texture.getGLRepeat(gl, 'y'));
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.getGLFilter(gl, 'min'));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.getGLFilter(gl, 'mag'));
    gl.activeTexture(gl.TEXTURE0);
  };

  /**
   * Returns the maximum dimensions
   * @return {Number}
   */


  WebGLRenderer.prototype.getMaxDimensions = function getMaxDimensions() {
    // node-gl support
    var canvas = _globals.Utils.createCanvas();
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
      return null;
    } else {
      var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      var loseContextExtension = gl.getExtension('WEBGL_lose_context');
      if (loseContextExtension) {
        loseContextExtension.loseContext();
      }
      return maxTextureSize;
    }
  };

  /**
   * Returns the current render target
   * @return {PhotoEditorSDK.Engine.RenderTarget}
   */


  WebGLRenderer.prototype.getCurrentRenderTarget = function getCurrentRenderTarget() {
    return this._currentRenderTarget;
  };

  /**
   * Returns the current object renderer
   * @return {PhotoEditorSDK.Engine.ObjectRenderer}
   */


  WebGLRenderer.prototype.getCurrentObjectRenderer = function getCurrentObjectRenderer() {
    return this._currentObjectRenderer;
  };

  /**
   * Checks if this renderer is supported on the current device and browser
   * @return {Boolean}
   */


  WebGLRenderer.isSupported = function isSupported() {
    var canvas = _globals.Utils.createCanvas();
    canvas.addEventListener('webglcontextcreationerror', this._onContextCreationError);
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    canvas.removeEventListener('webglcontextcreationerror', this._onContextCreationError);
    return !!gl;
  };

  /**
   * Returns the maximum float precision for this device (lowp/mediump/highp)
   * @return {String}
   */


  WebGLRenderer.prototype.getMaxFloatPrecision = function getMaxFloatPrecision() {
    return this._maxFloatPrecision;
  };

  /**
   * Returns the maximum int precision for this device (lowp/mediump/highp)
   * @return {String}
   */


  WebGLRenderer.prototype.getMaxIntPrecision = function getMaxIntPrecision() {
    return this._maxIntPrecision;
  };

  /**
   * Disposes this Renderer
   */


  WebGLRenderer.prototype.dispose = function dispose() {
    var _this3 = this;

    this._filterManager.dispose();
    this._currentObjectRenderer.dispose();
    this._defaultRenderTarget.dispose();
    this._textures.forEach(function (texture) {
      texture.disposeGLTexturesForRenderer(_this3);
    });
    for (var shader in this.shaders) {
      this.shaders[shader].dispose();
      delete this.shaders[shader];
    }
  };

  return WebGLRenderer;
}(_baseRenderer2.default);

WebGLRenderer.contextId = 0;
WebGLRenderer.type = 'WebGL';

exports.default = WebGLRenderer;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _textureShader = __webpack_require__(49);

var _textureShader2 = _interopRequireDefault(_textureShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  TextureShader: _textureShader2.default
}; /*
    * This file is part of PhotoEditorSDK.
    *
    * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
    * All rights reserved.
    *
    * Redistribution and use in source and binary forms, without
    * modification, are permitted provided that the following license agreement
    * is approved and a legal/financial contract was signed by the user.
    * The license agreement can be found under following link:
    *
    * https://www.photoeditorsdk.com/LICENSE.txt
    */

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _container = __webpack_require__(71);

var _container2 = _interopRequireDefault(_container);

var _potRenderer = __webpack_require__(118);

var _potRenderer2 = _interopRequireDefault(_potRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A drawable rectangle with a texture
 * @class
 * @extends PhotoEditorSDK.Engine.Container
 * @memberof PhotoEditorSDK.Engine
 */
var Sprite = function (_Container) {
  (0, _inherits3.default)(Sprite, _Container);

  /**
   * Creates a Sprite
   * @param  {PhotoEditorSDK.Engine.Texture} texture
   */
  function Sprite(texture) {
    (0, _classCallCheck3.default)(this, Sprite);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Container.call(this));

    _this._onTextureUpdate = _this._onTextureUpdate.bind(_this);

    _this._texture = texture;
    _this._shader = null;

    // Cached dimensions
    _this._width = 0;
    _this._height = 0;

    _this._anchor = new _globals.Vector2(0, 0);

    _this.setTexture(texture);
    return _this;
  }

  // -------------------------------------------------------------------------- EVENTS

  /**
   * Gets called when this sprite's texture has been updated
   * @private
   */


  Sprite.prototype._onTextureUpdate = function _onTextureUpdate() {
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  };

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Renders the contents of this container
   * @param {WebGLRenderer} renderer
   * @private
   */
  /* istanbul ignore next */


  Sprite.prototype._renderWebGL = function _renderWebGL(renderer) {
    var save = renderer.save();
    if (this._smoothDownscaling) {
      if (!this._potRenderer) {
        this._potRenderer = new _potRenderer2.default();
      }

      this._potRenderer.render(renderer, this, this._texture);
    }
    renderer.restore(save);

    renderer.setObjectRenderer(renderer.renderers.sprite);
    renderer.renderers.sprite.render(this);
  };

  /**
   * Renders the contents of this container
   * @param  {CanvasRenderer} renderer
   * @private
   */


  Sprite.prototype._renderCanvas = function _renderCanvas(renderer) {
    // @TODO Move this to SpriteRenderer
    var transform = this._worldTransform;
    var textureFrame = this._texture.getFrame();

    var width = textureFrame.width,
        height = textureFrame.height;

    var pixelRatio = renderer.getCurrentRenderTarget().getPixelRatio();

    // Apply transform
    var dx = this._anchor.x * -width | 0;
    var dy = this._anchor.y * -height | 0;
    var ctx = renderer.getContext();
    ctx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx * pixelRatio, transform.ty * pixelRatio);

    ctx.globalAlpha = this.getWorldAlpha();

    var baseTexture = this._texture.getBaseTexture();
    var texturePixelRatio = baseTexture.getPixelRatio();
    var source = baseTexture.getSource();
    ctx.drawImage(this._texture.getBaseTexture().getSource(),

    // Source x, y, width, height
    0, 0, (source.naturalWidth || width) * texturePixelRatio, (source.naturalHeight || height) * texturePixelRatio,

    // Destination x, y, width, height
    dx * pixelRatio, dy * pixelRatio, width * pixelRatio, height * pixelRatio);
  };

  // -------------------------------------------------------------------------- PUBLIC API

  /**
   * Checks if this sprite is located at the given position
   * @param  {PhotoEditorSDK.Math.Vector2}  position
   * @return {Boolean}
   */


  Sprite.prototype.isAtPosition = function isAtPosition(position) {
    var localPosition = this._worldTransform.applyInverseToVector(position);
    var textureFrame = this._texture.getFrame();
    var width = textureFrame.width,
        height = textureFrame.height;


    var upperLeft = new _globals.Vector2(-width, -height);
    upperLeft.multiply(this._anchor);
    var lowerRight = upperLeft.clone().add(width, height);

    if (localPosition.x < upperLeft.x || localPosition.x > lowerRight.x || localPosition.y < upperLeft.y || localPosition.y > lowerRight.y) {
      return false;
    }

    return true;
  };

  /**
   * Returns the non-global bounds of this DisplayObject
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  Sprite.prototype.getLocalBounds = function getLocalBounds() {
    if (this._localBoundsNeedUpdate) {
      var bounds = this._localBounds;
      var textureFrame = this._texture.getFrame();

      bounds.x = -textureFrame.width * this._anchor.x;
      bounds.y = -textureFrame.height * this._anchor.y;
      bounds.width = textureFrame.width;
      bounds.height = textureFrame.height;

      this._localBoundsNeedUpdate = false;
    }
    return this._localBounds.clone();
  };

  /**
   * Returns the bounds for this DisplayObject
   * @return {PhotoEditorSDK.Math.Rectangle}
   */


  Sprite.prototype.getBounds = function getBounds() {
    if (this._boundsNeedUpdate) {
      var bounds = this._bounds;
      var textureFrame = this._texture.getFrame();

      // @TODO Optimize this (if necessary). We could skip matrix application
      //       when there's no rotation
      var worldTransform = this._worldTransform;
      var anchor = this._anchor;
      var positions = worldTransform.rectangleToCoordinates(textureFrame, anchor);

      var minX = positions[0].x;
      var minY = positions[0].y;
      var maxX = minX;
      var maxY = minY;

      positions.forEach(function (_ref) {
        var x = _ref.x,
            y = _ref.y;

        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      });

      bounds.x = minX;
      bounds.width = Math.abs(maxX - minX);
      bounds.y = minY;
      bounds.height = Math.abs(maxY - minY);

      this._boundsNeedUpdate = false;
    }
    return this._bounds.clone();
  };

  // -------------------------------------------------------------------------- GETTERS / SETTERS

  /**
   * Returns the current texture
   * @return {PhotoEditorSDK.Engine.Texture} [description]
   */


  Sprite.prototype.getTexture = function getTexture() {
    return this._texture;
  };

  /**
   * Sets the texture
   * @param {PhotoEditorSDK.Engine.Texture} texture
   */


  Sprite.prototype.setTexture = function setTexture(texture) {
    if (!texture) {
      return;
    }

    if (this._texture) {
      this._texture.off('update', this._onTextureUpdate);
    }

    this._texture = texture;
    if (texture.getBaseTexture().isLoaded()) {
      this._onTextureUpdate();
    }
    texture.on('update', this._onTextureUpdate);
  };

  /**
   * Returns the shader
   * @return {PhotoEditorSDK.Engine.Shader}
   */


  Sprite.prototype.getShader = function getShader() {
    return this._shader;
  };

  /**
   * Sets the shader
   * @param {PhotoEditorSDK.Engine.Shader} shader
   */


  Sprite.prototype.setShader = function setShader(shader) {
    this._shader = shader;
  };

  /**
   * Returns the width
   * @return {Number}
   */


  Sprite.prototype.getWidth = function getWidth() {
    return this._width;
  };

  /**
   * Sets the width
   * @param {Number} width
   */


  Sprite.prototype.setWidth = function setWidth(width) {
    this._scale.x = width / this._texture.getFrame().width;
    this._width = width;
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  };

  /**
   * Returns the height
   * @return {Number}
   */


  Sprite.prototype.getHeight = function getHeight() {
    return this._height;
  };

  /**
   * Sets the height
   * @param {Number} height
   */


  Sprite.prototype.setHeight = function setHeight(height) {
    this._scale.y = height / this._texture.getFrame().height;
    this._height = height;
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  };

  /**
   * Returns the current width and height of this sprite
   * @return {PhotoEditor.Math.Vector2}
   */


  Sprite.prototype.getDimensions = function getDimensions() {
    return new _globals.Vector2(this._width, this._height);
  };

  /**
   * Returns the anchor
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Sprite.prototype.getAnchor = function getAnchor() {
    return this._anchor;
  };

  /**
   * Sets the anchor
   * @param {PhotoEditorSDK.Math.Vector2} anchor
   */


  Sprite.prototype.setAnchor = function setAnchor(anchor, y) {
    if (anchor instanceof _globals.Vector2) {
      this._anchor.copy(anchor);
    } else {
      this._anchor.set(anchor, y);
    }
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  };

  /**
   * Returns whether smooth downscaling is enabled
   * @return {Boolean}
   */


  Sprite.prototype.isSmoothDownscaling = function isSmoothDownscaling() {
    return this._smoothDownscaling;
  };

  /**
   * Sets the smooth downscaling flag
   * @param {Boolean} smoothDownscaling
   */


  Sprite.prototype.setSmoothDownscaling = function setSmoothDownscaling(smoothDownscaling) {
    this._smoothDownscaling = smoothDownscaling;
  };

  /**
   * Disposes this Sprite
   * @param {Boolean} texture = false - Should the texture be disposed?
   * @param {Boolean} baseTexture = false - Should the base texture be disposed?
   */


  Sprite.prototype.dispose = function dispose() {
    var texture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var baseTexture = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (this._texture) {
      this._texture.off('update', this._onTextureUpdate);
    }
    (texture || baseTexture) && this._texture.dispose(baseTexture);
    if (this._potRenderer) {
      this._potRenderer.dispose();
    }
  };

  return Sprite;
}(_container2.default); /*
                         * This file is part of PhotoEditorSDK.
                         *
                         * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                         * All rights reserved.
                         *
                         * Redistribution and use in source and binary forms, without
                         * modification, are permitted provided that the following license agreement
                         * is approved and a legal/financial contract was signed by the user.
                         * The license agreement can be found under following link:
                         *
                         * https://www.photoeditorsdk.com/LICENSE.txt
                         */

exports.default = Sprite;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(6);

var _texture = __webpack_require__(74);

var _texture2 = _interopRequireDefault(_texture);

var _baseTexture = __webpack_require__(29);

var _baseTexture2 = _interopRequireDefault(_baseTexture);

var _webglRenderTarget = __webpack_require__(34);

var _webglRenderTarget2 = _interopRequireDefault(_webglRenderTarget);

var _canvasRenderTarget = __webpack_require__(33);

var _canvasRenderTarget2 = _interopRequireDefault(_canvasRenderTarget);

var _webglFilterManager = __webpack_require__(47);

var _webglFilterManager2 = _interopRequireDefault(_webglFilterManager);

var _canvasFilterManager = __webpack_require__(46);

var _canvasFilterManager2 = _interopRequireDefault(_canvasFilterManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RendererType = _globals.Constants.RendererType; /*
                                                     * This file is part of PhotoEditorSDK.
                                                     *
                                                     * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                     * All rights reserved.
                                                     *
                                                     * Redistribution and use in source and binary forms, without
                                                     * modification, are permitted provided that the following license agreement
                                                     * is approved and a legal/financial contract was signed by the user.
                                                     * The license agreement can be found under following link:
                                                     *
                                                     * https://www.photoeditorsdk.com/LICENSE.txt
                                                     */

/**
 * A texture that you can render to
 * @class
 * @extends PhotoEditorSDK.Engine.Texture
 * @memberof PhotoEditorSDK.Engine
 */
var RenderTexture = function (_Texture) {
  (0, _inherits3.default)(RenderTexture, _Texture);

  /**
   * Creates a RenderTexture
   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param  {Number} [width = 100]
   * @param  {Number} [height = 100]
   * @param  {Number} [pixelRatio = 1]
   */
  function RenderTexture(renderer) {
    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    (0, _classCallCheck3.default)(this, RenderTexture);

    // RenderTexture is always loaded!
    var _this = (0, _possibleConstructorReturn3.default)(this, _Texture.call(this, new _baseTexture2.default(), new _globals.Rectangle(0, 0, width, height)));

    _this._loaded = true;
    _this._width = width;
    _this._height = height;
    _this._pixelRatio = pixelRatio;
    _this._renderer = renderer;

    _this._setupFilterManager();
    _this._setupBuffer();

    _this.setBaseTexture(_this._renderTarget.getBaseTexture());

    _this._updateUVs();
    return _this;
  }

  /**
   * Sets up the filter manager
   * @private
   */


  RenderTexture.prototype._setupFilterManager = function _setupFilterManager() {
    /* istanbul ignore if */
    if (this._renderer.isOfType(RendererType.WEBGL)) {
      this._filterManager = new _webglFilterManager2.default(this._renderer);
    } else if (this._renderer.isOfType(RendererType.CANVAS)) {
      this._filterManager = new _canvasFilterManager2.default(this._renderer);
    }

    this._filterManager.resizeTo(new _globals.Vector2(this._width, this._height));
  };

  /**
   * Sets up the buffer that we're rendering to
   * @private
   */


  RenderTexture.prototype._setupBuffer = function _setupBuffer() {
    /* istanbul ignore if */
    if (this._renderer.isOfType(RendererType.WEBGL)) {
      this._setupWebGLRenderTarget();
    } else if (this._renderer.isOfType(RendererType.CANVAS)) {
      this._setupCanvasRenderTarget();
    }
  };

  /**
   * Sets up the WebGLRenderTarget for this RenderTexture
   * @private
   */
  /* istanbul ignore next */


  RenderTexture.prototype._setupWebGLRenderTarget = function _setupWebGLRenderTarget() {
    this._renderTarget = new _webglRenderTarget2.default(this._renderer, this._width, this._height, this._pixelRatio);
  };

  /**
   * Sets up the CanvasRenderTarget for this RenderTexture
   * @private
   */


  RenderTexture.prototype._setupCanvasRenderTarget = function _setupCanvasRenderTarget() {
    this._renderTarget = new _canvasRenderTarget2.default(this._width, this._height, this._pixelRatio);
  };

  /**
   * Clears this texture's render buffer
   * @param {PhotoEditorSDK.Color} color
   */


  RenderTexture.prototype.clear = function clear(color) {
    this._renderTarget.clear(color);
  };

  /**
   * Resizes this RenderTexture to the given dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   */


  RenderTexture.prototype.resizeTo = function resizeTo(dimensions) {
    if (this._width === dimensions.x && this._height === dimensions.y) {
      return;
    }

    this._width = dimensions.x;
    this._height = dimensions.y;
    this._frame.width = dimensions.x;
    this._frame.height = dimensions.y;

    this._renderTarget.resizeTo(dimensions);
    this._filterManager.resizeTo(dimensions);
  };

  /**
   * Renders the given DisplayObject
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   */


  RenderTexture.prototype.render = function render(displayObject) {
    /* istanbul ignore if */
    if (this._renderer.isOfType(RendererType.WEBGL)) {
      this._renderWebGL(displayObject);
    } else if (this._renderer.isOfType(RendererType.CANVAS)) {
      this._renderCanvas(displayObject);
    } else {
      throw new Error('RenderTexture does not support rendering via ' + this._renderer.constructor.name);
    }
  };

  /**
   * Renders the given DisplayObject using WebGL
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   * @private
   */
  /* istanbul ignore next */


  RenderTexture.prototype._renderWebGL = function _renderWebGL(displayObject) {
    this._renderTarget.activate();

    displayObject.getWorldTransform().reset();
    displayObject.getChildren().forEach(function (child) {
      child.updateTransform();
    });

    var tempFilterManager = this._renderer.getFilterManager();
    this._renderer.setFilterManager(this._filterManager);
    this._renderer.renderDisplayObject(displayObject, this._renderTarget);
    // this._renderTarget.updateMipMap()
    this._renderer.setFilterManager(tempFilterManager);
  };

  /**
   * Renders the given DisplayObject using Canvas2D
   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
   * @private
   */


  RenderTexture.prototype._renderCanvas = function _renderCanvas(displayObject) {
    displayObject.getWorldTransform().reset();
    displayObject.getChildren().forEach(function (child) {
      child.updateTransform();
    });

    var tempFilterManager = this._renderer.getFilterManager();
    this._renderer.setFilterManager(this._filterManager);
    this._renderer.renderDisplayObject(displayObject, this._renderTarget);
    this._renderer.setFilterManager(tempFilterManager);
  };

  /**
   * Returns the render target
   * @return {PhotoEditorSDK.Engine.WebGLRenderTarget}
   */


  RenderTexture.prototype.getRenderTarget = function getRenderTarget() {
    return this._renderTarget;
  };

  /**
   * Disposes this RenderTexture
   */


  RenderTexture.prototype.dispose = function dispose() {
    this._renderTarget.dispose();
    this._filterManager.dispose();
  };

  return RenderTexture;
}(_texture2.default);

exports.default = RenderTexture;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * Represents a rectangle that is rendered using WebGL
 * @class
 * @memberof PhotoEditorSDK.Engine
 * @ignore
 */
/* istanbul ignore next */
var Quad = function () {
  function Quad(renderer) {
    (0, _classCallCheck3.default)(this, Quad);

    this._renderer = renderer;
    this._context = this._renderer.getContext();

    this._vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);

    this._uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);

    this._indices = new Uint16Array([0, 1, 2, 0, 3, 2]);

    this._colors = new Float32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);

    this._initBuffers();
    this._uploadBuffers();
  }

  /**
   * Maps the given rectangles to the quad
   * @param  {Rectangle} rect1
   * @param  {Rectangle} rect2
   */


  Quad.prototype.map = function map(rect1, rect2) {
    var x = rect2.x,
        y = rect2.y;

    // Update the UVs
    // We don't have any translation, so these four
    // values are all we need

    this._uvs[2] = rect2.width / rect1.width;
    this._uvs[4] = this._uvs[2];
    this._uvs[5] = rect2.height / rect1.height;
    this._uvs[7] = this._uvs[5];

    // Update the vertices
    this._vertices[0] = x;
    this._vertices[1] = y;

    this._vertices[2] = x + rect2.width;
    this._vertices[3] = y;

    this._vertices[4] = this._vertices[2];
    this._vertices[5] = y + rect2.height;

    this._vertices[6] = x;
    this._vertices[7] = this._vertices[5];

    this._uploadBuffers();
  };

  /**
   * Initializes the buffers
   * @private
   */


  Quad.prototype._initBuffers = function _initBuffers() {
    var gl = this._context;

    // Init vertex buffer
    this._vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);

    this._indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
  };

  /**
   * Uploads the buffers
   * @private
   */


  Quad.prototype._uploadBuffers = function _uploadBuffers() {
    var gl = this._context;

    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
    gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this._uvs);
    gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this._colors);
  };

  Quad.prototype.getVertexBuffer = function getVertexBuffer() {
    return this._vertexBuffer;
  };

  Quad.prototype.getIndexBuffer = function getIndexBuffer() {
    return this._indexBuffer;
  };

  /**
   * Cleans up this Quad's buffers
   */


  Quad.prototype.dispose = function dispose() {
    var gl = this._context;
    gl.deleteBuffer(this._vertexBuffer);
    gl.deleteBuffer(this._indexBuffer);
  };

  return Quad;
}();

exports.default = Quad;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Represents the UV coordinates of a texture
 * @class
 * @memberof PhotoEditorSDK.Engine
 */
var TextureUVs = function () {
  /**
   * Creates a TextureUVs instance
   */
  function TextureUVs() {
    (0, _classCallCheck3.default)(this, TextureUVs);

    this._uvs = [new _globals.Vector2(0, 0), new _globals.Vector2(1, 0), new _globals.Vector2(1, 1), new _globals.Vector2(0, 1)];
  }

  /**
   * Updates the UVs based on the given baseframe
   * @param  {Rectangle} frame
   * @param  {Rectangle} baseFrame
   */


  TextureUVs.prototype.update = function update(frame, baseFrame) {
    // Upper left
    var uv = this._uvs[0];
    uv.x = frame.x / baseFrame.width;
    uv.y = frame.y / baseFrame.height;

    // Upper right
    uv = this._uvs[1];
    uv.x = (frame.x + frame.width) / baseFrame.width;
    uv.y = frame.y / baseFrame.height;

    // Lower right
    uv = this._uvs[2];
    uv.x = (frame.x + frame.width) / baseFrame.width;
    uv.y = (frame.y + frame.height) / baseFrame.height;

    // Lower left
    uv = this._uvs[3];
    uv.x = frame.x / baseFrame.width;
    uv.y = (frame.y + frame.height) / baseFrame.height;
  };

  /**
   * Returns the UV coordinates for the given index
   * @param  {Number} index
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  TextureUVs.prototype.getUVsAt = function getUVsAt(index) {
    return this._uvs[index];
  };

  /**
   * Returns the UV coordinates
   * @return {Array.<PhotoEditorSDK.Math.Vector2>}
   */


  TextureUVs.prototype.getUVs = function getUVs() {
    return this._uvs;
  };

  return TextureUVs;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = TextureUVs;

/***/ },
/* 112 */
/***/ function(module, exports) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * A couple of utility functions
 * @type {Object}
 */
var Utils = {
  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object for all destination properties that resolve to undefined. Once a
   * property is set, additional values of the same property are ignored.
   * @param  {Object} object
   * @param  {Object} ...sources
   * @return {Object}
   */
  defaults: function defaults(object) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    // Shallow clone
    var newObject = {};
    for (var key in object) {
      newObject[key] = object[key];
    }

    // Clone sources
    for (var i = 0; i < sources.length; i++) {
      var source = sources[i];
      for (var _key2 in source) {
        if (typeof newObject[_key2] === 'undefined') {
          newObject[_key2] = source[_key2];
        }
      }
    }

    return newObject;
  },

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object. Subsequent sources overwrite property assignments of previous
   * sources.
   * @param {Object} object
   * @param {Object} ...sources
   * @return {Object}
   */
  extend: function extend(object) {
    for (var _len2 = arguments.length, sources = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
      sources[_key3 - 1] = arguments[_key3];
    }

    // Shallow clone
    var newObject = {};
    for (var key in object) {
      newObject[key] = object[key];
    }

    // Extend sources
    for (var i = 0; i < sources.length; i++) {
      var source = sources[i];
      for (var _key4 in source) {
        newObject[_key4] = source[_key4];
      }
    }

    return newObject;
  }
};

exports.default = Utils;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(193);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _stats = __webpack_require__(255);

var _stats2 = _interopRequireDefault(_stats);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This class hooks into WebGL calls and tracks the creation and
 * disposal of WebGL textures, shaders etc.
 */
var WebGLMemoryManager = function () {
  function WebGLMemoryManager(context) {
    (0, _classCallCheck3.default)(this, WebGLMemoryManager);

    this._context = context;
    this._hookIntoContext();
    this._textures = {};
    this._framebuffers = {};
    this._programs = {};
    this._shaders = {};
    this._buffers = {};
    this._boundTexture = null;
    this._id = 0;

    this._setupStats();

    this._updateMemoryStats = this._updateMemoryStats.bind(this);
    this._updateMemoryStats();
  }

  /**
   * Sets up stats.js
   * @private
   */


  WebGLMemoryManager.prototype._setupStats = function _setupStats() {
    this._stats = new _stats2.default();
    this._stats.showPanel(3);
    this._memPanel = this._stats.addPanel(new _stats2.default.Panel('MB [WebGL]', '#43ADEB', '#282828'));
    this._texPanel = this._stats.addPanel(new _stats2.default.Panel('Textures', '#43ADEB', '#282828'));
    this._bufPanel = this._stats.addPanel(new _stats2.default.Panel('Buffers', '#43ADEB', '#282828'));
    this._fboPanel = this._stats.addPanel(new _stats2.default.Panel('FBOs', '#43ADEB', '#282828'));
    this._prgPanel = this._stats.addPanel(new _stats2.default.Panel('Programs', '#43ADEB', '#282828'));
    this._shdPanel = this._stats.addPanel(new _stats2.default.Panel('Shaders', '#43ADEB', '#282828'));

    document.body.appendChild(this._stats.dom);
    this._stats.dom.style.top = '80px';
  };

  /**
   * Updates the given panel
   * @param  {String} panel
   * @private
   */


  WebGLMemoryManager.prototype._updatePanel = function _updatePanel(panel) {
    this._stats.begin();
    switch (panel) {
      case 'tex':
        this._texPanel.update(this.getTexturesCount(), 50);
        break;
      case 'buf':
        this._bufPanel.update(this.getBuffersCount(), 50);
        break;
      case 'fbo':
        this._fboPanel.update(this.getFBOCount(), 50);
        break;
      case 'prg':
        this._prgPanel.update(this.getProgramCount(), 50);
        break;
      case 'shd':
        this._shdPanel.update(this.getShaderCount(), 50);
        break;
    }
    this._stats.end();
  };

  WebGLMemoryManager.prototype.getTexturesCount = function getTexturesCount() {
    return Object.keys(this._textures).length;
  };

  WebGLMemoryManager.prototype.getBuffersCount = function getBuffersCount() {
    return Object.keys(this._buffers).length;
  };

  WebGLMemoryManager.prototype.getFBOCount = function getFBOCount() {
    return Object.keys(this._framebuffers).length;
  };

  WebGLMemoryManager.prototype.getProgramCount = function getProgramCount() {
    return Object.keys(this._programs).length;
  };

  WebGLMemoryManager.prototype.getShaderCount = function getShaderCount() {
    return Object.keys(this._shaders).length;
  };

  /**
   * Updates the memory chart
   * @private
   */


  WebGLMemoryManager.prototype._updateMemoryStats = function _updateMemoryStats() {
    var memory = this._getMemoryUsage() / 1000 / 1000;
    this._memPanel.update(memory, 400);

    setTimeout(this._updateMemoryStats, 1000);
  };

  /**
   * Returns the estimated memory usage in bytes
   * @return {Number}
   * @private
   */


  WebGLMemoryManager.prototype._getMemoryUsage = function _getMemoryUsage() {
    var bytes = 0;
    for (var name in this._textures) {
      bytes += this._textures[name].memory;
    }
    for (var _name in this._buffers) {
      bytes += this._buffers[_name].memory;
    }
    return bytes;
  };

  /**
   * Replaces all WebGL functions with spy functions in order to track texture
   * creation and disposal
   * @private
   */


  WebGLMemoryManager.prototype._hookIntoContext = function _hookIntoContext() {
    var _this = this;

    var _loop = function _loop(key) {
      var value = _this._context[key];
      if (typeof value === 'function') {
        _this[key] = function () {
          var fn = this._context[key];

          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return this._trackGLCall(fn, key, args);
        };
      } else {
        _this._makePropertyWrapper(key);
      }
    };

    for (var key in this._context) {
      _loop(key);
    }
  };

  /**
   * Creates the getter and setter for the given property
   * @param  {String} property
   * @private
   */


  WebGLMemoryManager.prototype._makePropertyWrapper = function _makePropertyWrapper(property) {
    var insecureProperties = ['_context'];
    if (insecureProperties.indexOf(property) !== -1) return;

    var context = this._context;

    this.__defineGetter__(property, function () {
      return context[property];
    });

    this.__defineSetter__(property, function (value) {
      context[property] = value;
    });
  };

  /**
   * Gets called when a WebGL function is called
   * @param  {Function} fn
   * @param  {String} functionName
   * @param  {Array} args
   * @private
   */


  WebGLMemoryManager.prototype._trackGLCall = function _trackGLCall(fn, functionName, args) {
    var overrideFunctions = ['texImage2D', 'bindTexture', 'createTexture', 'deleteTexture', 'createBuffer', 'bindBuffer', 'bufferData', 'deleteBuffer', 'createFramebuffer', 'deleteFramebuffer', 'createProgram', 'deleteProgram', 'createShader', 'deleteShader'];

    if (overrideFunctions.indexOf(functionName) !== -1) {
      return this['_' + functionName](args);
    }

    return fn.apply(this._context, args);
  };

  /**
   * Gets called when `createProgram` is called on the WebGL context
   * @private
   */


  WebGLMemoryManager.prototype._createProgram = function _createProgram() {
    var program = this._context.createProgram();
    program._wmmId = this._id++;

    this._programs[program._wmmId] = program;

    this._updatePanel('prg');

    return program;
  };

  /**
   * Deletes the given program
   * @param  {WebGLProgram} program
   * @private
   */


  WebGLMemoryManager.prototype._deleteProgram = function _deleteProgram(_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 1),
        program = _ref2[0];

    if (!program || !this._programs[program._wmmId]) return;

    delete this._programs[program._wmmId];
    this._context.deleteProgram(program);

    this._updatePanel('prg');
  };

  /**
   * Gets called when `createShader` is called on the WebGL context
   * @param {GLenum} type
   * @private
   */


  WebGLMemoryManager.prototype._createShader = function _createShader(_ref3) {
    var _ref4 = (0, _slicedToArray3.default)(_ref3, 1),
        type = _ref4[0];

    var shader = this._context.createShader(type);
    shader._wmmId = this._id++;

    this._shaders[shader._wmmId] = shader;

    this._updatePanel('shd');

    return shader;
  };

  /**
   * Deletes the given shader
   * @param  {WebGLShader} shader
   * @private
   */


  WebGLMemoryManager.prototype._deleteShader = function _deleteShader(_ref5) {
    var _ref6 = (0, _slicedToArray3.default)(_ref5, 1),
        shader = _ref6[0];

    if (!shader || !this._shaders[shader._wmmId]) return;

    delete this._shaders[shader._wmmId];
    this._context.deleteShader(shader);

    this._updatePanel('shd');
  };

  /**
   * Gets called when `createFramebuffer` is called on the WebGL context
   * @private
   */


  WebGLMemoryManager.prototype._createFramebuffer = function _createFramebuffer() {
    var framebuffer = this._context.createFramebuffer();
    framebuffer._wmmId = this._id++;

    this._framebuffers[framebuffer._wmmId] = framebuffer;

    this._updatePanel('fbo');

    return framebuffer;
  };

  /**
   * Deletes the given framebuffer
   * @param  {WebGLFramebuffer} framebuffer
   * @private
   */


  WebGLMemoryManager.prototype._deleteFramebuffer = function _deleteFramebuffer(_ref7) {
    var _ref8 = (0, _slicedToArray3.default)(_ref7, 1),
        framebuffer = _ref8[0];

    if (!framebuffer || !this._framebuffers[framebuffer._wmmId]) return;

    delete this._framebuffers[framebuffer._wmmId];
    this._context.deleteFramebuffer(framebuffer);

    this._updatePanel('fbo');
  };

  /**
   * Gets called when `createBuffer` is called on the WebGL context
   * @private
   */


  WebGLMemoryManager.prototype._createBuffer = function _createBuffer() {
    var buffer = this._context.createBuffer();
    buffer._wmmId = this._id++;

    this._buffers[buffer._wmmId] = {
      buffer: buffer,
      memory: 0
    };

    this._updatePanel('buf');

    return buffer;
  };

  /**
   * Binds the given buffer
   * @param  {GLenum} target
   * @param  {WebGLBuffer} buffer
   * @private
   */


  WebGLMemoryManager.prototype._bindBuffer = function _bindBuffer(_ref9) {
    var _ref10 = (0, _slicedToArray3.default)(_ref9, 2),
        target = _ref10[0],
        buffer = _ref10[1];

    this._context.bindBuffer(target, buffer);

    this._boundBuffer = buffer._wmmId;
  };

  /**
   * Initializes the buffer's data store
   * @param  {GLenum} target
   * @param  {GLsizeiptr|ArrayBuffer} sizeOrData
   * @param  {GLenum} usage
   * @private
   */


  WebGLMemoryManager.prototype._bufferData = function _bufferData(_ref11) {
    var _ref12 = (0, _slicedToArray3.default)(_ref11, 3),
        target = _ref12[0],
        sizeOrData = _ref12[1],
        usage = _ref12[2];

    this._context.bufferData(target, sizeOrData, usage);

    var size = void 0;
    if (typeof sizeOrData === 'number') {
      size = sizeOrData; // size
    } else if ('byteLength' in sizeOrData) {
      size = sizeOrData.byteLength; // data
    } else if ('length' in sizeOrData) {
      size = sizeOrData.length; // data
    }

    this._buffers[this._boundBuffer].memory = size;
  };

  /**
   * Deletes the given buffer
   * @param  {WebGLBuffer} buffer
   * @private
   */


  WebGLMemoryManager.prototype._deleteBuffer = function _deleteBuffer(_ref13) {
    var _ref14 = (0, _slicedToArray3.default)(_ref13, 1),
        buffer = _ref14[0];

    if (!buffer || !this._buffers[buffer._wmmId]) return;

    delete this._buffers[buffer._wmmId];
    this._context.deleteBuffer(buffer);

    this._updatePanel('buf');
  };

  /**
   * Gets called when `createTexture` is called on the WebGL context
   * @private
   */


  WebGLMemoryManager.prototype._createTexture = function _createTexture() {
    var texture = this._context.createTexture();
    texture._wmmId = this._id++;

    console.log('created', texture._wmmId);

    this._textures[texture._wmmId] = {
      texture: texture,
      memory: 0
    };

    this._updatePanel('tex');

    return texture;
  };

  /**
   * Deletes the given texture
   * @param  {WebGLTexture} texture
   * @private
   */


  WebGLMemoryManager.prototype._deleteTexture = function _deleteTexture(_ref15) {
    var _ref16 = (0, _slicedToArray3.default)(_ref15, 1),
        texture = _ref16[0];

    if (!texture || !this._textures[texture._wmmId]) return;

    delete this._textures[texture._wmmId];
    this._context.deleteTexture(texture);

    this._updatePanel('tex');
  };

  /**
   * Gets called when `bindTexture` is called on the WebGL context
   * @param  {GLenum} target
   * @param  {WebGLTexture} texture
   * @private
   */


  WebGLMemoryManager.prototype._bindTexture = function _bindTexture(_ref17) {
    var _ref18 = (0, _slicedToArray3.default)(_ref17, 2),
        target = _ref18[0],
        texture = _ref18[1];

    this._context.bindTexture(target, texture);

    this._boundTexture = texture._wmmId;
  };

  /**
   * Gets called when `texImage2D` is called on the WebGL context
   * @param  {GLEnum} target
   * @param  {GLint} level
   * @param  {GLint} internalformat
   * @param  {GLsizei} width
   * @param  {Glsizei} height
   * @param  {GLint} border
   * @param  {GLenum} format
   * @param  {GLenum} type
   * @param  {*} pixels
   */


  WebGLMemoryManager.prototype._texImage2D = function _texImage2D(args) {
    var _args = (0, _slicedToArray3.default)(args, 9),
        internalformat = _args[2],
        width = _args[3],
        height = _args[4],
        border = _args[5],
        pixels = _args[8];

    if (typeof pixels === 'undefined') {
      pixels = border;
    }

    // Create texture
    this._context.texImage2D.apply(this._context, args);

    var byteCount = this._calculateByteCountForTexture(internalformat, width, height, pixels);
    this._textures[this._boundTexture].memory = byteCount;
  };

  /**
   * Calculates the byte count for the given texture information
   * @param  {GLint} format
   * @param  {GLsizei} width
   * @param  {GLsizei} height
   * @param  {*} pixels
   * @return {Number}
   * @private
   */


  WebGLMemoryManager.prototype._calculateByteCountForTexture = function _calculateByteCountForTexture(format, width, height, pixels) {
    if (pixels !== null) {
      if ('width' in pixels) {
        width = pixels.width;
        height = pixels.height;
      } else {
        return pixels.length;
      }
    }

    var bytesPerPixel = 1;
    switch (format) {
      case this._context.ALPHA:
        bytesPerPixel = 1;
        break;
      case this._context.RGB:
        bytesPerPixel = 3;
        break;
      case this._context.RGBA:
        bytesPerPixel = 4;
        break;
    }

    return width * height * bytesPerPixel;
  };

  return WebGLMemoryManager;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */


exports.default = WebGLMemoryManager;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/**
 * An ArrayStream provides methods for working with a byte array
 * @class
 * @memberof PhotoEditorSDK
 * @ignore
 */
/* istanbul ignore next */
var ArrayStream = function () {
  /**
   * Creates an ArrayStream
   * @param  {Array} buf
   */
  function ArrayStream(buf) {
    (0, _classCallCheck3.default)(this, ArrayStream);

    this._head = 0;
    this._buf = buf;
  }

  /**
   * Returns the value of the following 8 bit integer
   * @return {Number}
   */


  ArrayStream.prototype.peekInt8 = function peekInt8() {
    return this._buf[this._head];
  };

  /**
   * Returns the value of the following 16 bit integer
   * @param  {Boolean} [littleEndian = false]
   * @return {Number}
   */


  ArrayStream.prototype.peekInt16 = function peekInt16() {
    var littleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var a = this._buf[this._head];
    var b = this._buf[this._head + 1];
    if (!littleEndian) {
      return (a << 8) + b;
    } else {
      return (b << 8) + a;
    }
  };

  /**
   * Returns the value of the following 24 bit integer
   * @param  {Boolean} [littleEndian = false]
   * @return {Number}
   */


  ArrayStream.prototype.peekInt24 = function peekInt24() {
    var littleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var a = this._buf[this._head];
    var b = this._buf[this._head + 1];
    var c = this._buf[this._head + 2];
    if (!littleEndian) {
      return (a << 16) + (b << 8) + c;
    } else {
      return (c << 16) + (b << 8) + a;
    }
  };

  /**
   * Returns the value of the following 32 bit integer
   * @param  {Boolean} [littleEndian = false]
   * @return {Number}
   */


  ArrayStream.prototype.peekInt32 = function peekInt32() {
    var littleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var a = this._buf[this._head];
    var b = this._buf[this._head + 1];
    var c = this._buf[this._head + 2];
    var d = this._buf[this._head + 3];
    if (!littleEndian) {
      return (a << 32) + (b << 16) + (c << 8) + d;
    } else {
      return (d << 32) + (c << 16) + (b << 8) + a;
    }
  };

  /**
   * Writes the given 16 bit integer at the current head position
   * @param  {Number} num
   */


  ArrayStream.prototype.writeInt16 = function writeInt16(num) {
    this._buf[this._head] = num >> 8; // upper
    this._buf[this._head + 1] = num & 0xff; // lower
  };

  /**
   * Returns the value of the following 8 bit integer and moves the head by 1 byte
   * @return {Number}
   */


  ArrayStream.prototype.readInt8 = function readInt8() {
    var num = this.peekInt8();
    this._head += 1;
    return num;
  };

  /**
   * Returns the value of the following 16 bit integer and moves the head by 2 bytes
   * @param  {Boolean} [littleEndian = false]
   * @return {Number}
   */


  ArrayStream.prototype.readInt16 = function readInt16() {
    var littleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var num = this.peekInt16(littleEndian);
    this._head += 2;
    return num;
  };

  /**
   * Returns the value of the following 24 bit integer and moves the head by 3 bytes
   * @param  {Boolean} [littleEndian = false]
   * @return {Number}
   */


  ArrayStream.prototype.readInt24 = function readInt24() {
    var littleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var num = this.peekInt24(littleEndian);
    this._head += 3;
    return num;
  };

  /**
   * Returns the value of the following 32 bit integer and moves the head by 4 bytes
   * @param  {Boolean} [littleEndian = false]
   * @return {Number}
   */


  ArrayStream.prototype.readInt32 = function readInt32() {
    var littleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var num = this.peekInt32(littleEndian);
    this._head += 4;
    return num;
  };

  /**
   * Reads a string with the given length
   * @param  {Number} length
   * @return {String}
   */


  ArrayStream.prototype.readString = function readString(length) {
    var str = '';
    for (var i = 0; i < length; i++) {
      var character = this.readInt8();
      str += String.fromCharCode(character);
    }
    return str;
  };

  /**
   * Returns the current head position
   * @return {Number}
   */


  ArrayStream.prototype.getHead = function getHead() {
    return this._head;
  };

  /**
   * Sets the head position
   * @param {Number} head
   */


  ArrayStream.prototype.setHead = function setHead(head) {
    this._head = head;
  };

  return ArrayStream;
}();

exports.default = ArrayStream;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _constants = __webpack_require__(9);

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _utils = __webpack_require__(21);

var _utils2 = _interopRequireDefault(_utils);

var _exif = __webpack_require__(43);

var _exif2 = _interopRequireDefault(_exif);

var _nodeGlExporter = __webpack_require__(117);

var _nodeGlExporter2 = _interopRequireDefault(_nodeGlExporter);

var _configurable = __webpack_require__(16);

var _configurable2 = _interopRequireDefault(_configurable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * @alias PhotoEditorSDK.ImageExporter
 * @private
 */
/* global Image, WEBPACK */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ImageExporter = function (_Configurable) {
  (0, _inherits3.default)(ImageExporter, _Configurable);

  function ImageExporter(sdk) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, ImageExporter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Configurable.call(this, options));

    _this._sdk = sdk;
    return _this;
  }

  /**
   * Exports the image from the given canvas with the given options
   * @return {Promise}
   */


  ImageExporter.prototype.export = function _export() {
    var _this2 = this;

    var renderer = this._sdk.getRenderer();
    var _options = this._options,
        renderType = _options.renderType,
        imageFormat = _options.imageFormat,
        quality = _options.quality;


    return this.validateSettings().then(function () {
      return _this2._prepareSDK();
    }).then(function (texture) {
      var canvas = renderer.getCanvas();
      if (renderer.isOfType(_constants.RendererType.WEBGL)) {
        canvas = _this2._createCanvasFromTexture(texture);
      }

      var result = void 0;
      if (renderType === _constants.RenderType.IMAGE || renderType === _constants.RenderType.DATAURL) {
        if (typeof window === 'undefined') {
          // Quality not supported in node environment / node-canvas
          result = canvas.toDataURL(imageFormat);
        } else {
          result = canvas.toDataURL(imageFormat, quality);
        }

        // When image's `src` attribute is a jpeg data url, we can restore
        // the exif information
        var image = _this2._sdk.getImage();
        if (_exif2.default.isJPEG(image.src) && _exif2.default.isJPEG(result)) {
          var exif = _this2._sdk.getExif();
          if (exif) {
            result = exif.restoreExifTags(result);
          }
        }
      }

      if (renderer.isOfType(_constants.RendererType.WEBGL) && typeof Canvas !== 'undefined' && canvas instanceof Canvas) {
        _nodeGlExporter2.default.renderContextToCanvas(renderer.getContext(), canvas);
      }

      if (renderType === _constants.RenderType.IMAGE) {
        var outputImage = void 0;

        if (true) {
          outputImage = new Image();
        }

        outputImage.src = result;
        return outputImage;
      } else if (renderType === _constants.RenderType.DATAURL) {
        return result;
      } else if (renderType === _constants.RenderType.BUFFER) {
        return canvas.toBuffer();
      } else if (renderType === _constants.RenderType.MSBLOB) {
        return canvas.msToBlob();
      } else if (renderType === _constants.RenderType.BLOB) {
        return new Promise(function (resolve, reject) {
          canvas.toBlob(function (blob) {
            resolve(blob);
          }, imageFormat, quality);
        });
      }
    }).then(function (result) {
      return _this2._restoreSDK().then(function () {
        return result;
      });
    });
  };

  /**
   * Prepares the SDK for exporting
   * @private
   */


  ImageExporter.prototype._prepareSDK = function _prepareSDK() {
    var renderer = this._sdk.getRenderer();

    this._sdkSettings = {
      dimensions: renderer.getDimensions().clone(),
      textureQuality: this._sdk.getTextureQuality(),
      pixelRatio: this._sdk.getPixelRatio(),
      renderMode: this._sdk.getRenderMode()
    };

    this._sdk.setRenderMode('export');
    this._sdk.setTextureQuality(1);

    var resizeCanvas = renderer.isOfType(_constants.RendererType.CANVAS);
    renderer.setPixelRatio(1);
    renderer.resizeTo(this._sdk.getFinalDimensions(), resizeCanvas);

    this._sdk.setAllOperationsToDirty(true);

    var stack = this._sdk.getOperationsStack();
    stack.forEach(function (operation) {
      operation.disposeRenderTextures();
    });
    stack.disableCache();

    return this._sdk.render();
  };

  /**
   * Restores the previous SDK options
   * @private
   */


  ImageExporter.prototype._restoreSDK = function _restoreSDK() {
    var stack = this._sdk.getOperationsStack();
    stack.enableCache();

    this._sdk.setRenderMode(this._sdkSettings.renderMode);
    var renderer = this._sdk.getRenderer();

    var resizeCanvas = renderer.isOfType(_constants.RendererType.CANVAS);
    renderer.setPixelRatio(this._sdkSettings.pixelRatio);
    renderer.resizeTo(this._sdkSettings.dimensions, resizeCanvas);

    this._sdk.setTextureQuality(this._sdkSettings.pixelRatio);
    this._sdk.setAllOperationsToDirty(true);
    return this._sdk.render();
  };

  /**
   * Creates a canvas from the given Texture by attaching it to an FBO and using
   * gl.readPixels() to read the pixels. It then writes the pixel data to a new
   * 2D (not hardware-accelerated) canvas and calls .toDataURL() on it.
   * @param  {PhotoEditorSDK.Engine.Texture} texture
   * @return {HTMLCanvasElement}
   * @private
   */


  ImageExporter.prototype._createCanvasFromTexture = function _createCanvasFromTexture(texture) {
    var renderer = this._sdk.getRenderer();
    var finalDimensions = this._sdk.getFinalDimensions();

    var gl = this._sdk.getRenderer().getContext();

    // Create temporary framebuffer
    var fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

    // Attach output texture to FBO
    var glTexture = texture.getBaseTexture().getGLTextureForRenderer(renderer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);

    // Read pixels from FBO
    var pixels = new Uint8Array(finalDimensions.x * finalDimensions.y * 4);
    gl.readPixels(0, 0, finalDimensions.x, finalDimensions.y, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

    // Check if we have any semi-transparent pixels
    var hasTransparency = this._checkPixelsForTransparency(pixels);

    var renderTexture = void 0;
    if (hasTransparency) {
      // Since our textures have premultiplied RGB values, we need to un-premultiply the
      // values before reading them from the texture and passing them to a canvas
      var sprite = new _engine2.default.Sprite(texture);
      sprite.setFilters([new _engine2.default.Filters.UnpremultiplyFilter()]);
      var container = new _engine2.default.Container();
      container.addChild(sprite);
      renderTexture = new _engine2.default.RenderTexture(renderer, finalDimensions.x, finalDimensions.y);
      renderTexture.render(container);

      // Attach the new texture
      var _glTexture = renderTexture.getBaseTexture().getGLTextureForRenderer(renderer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, _glTexture, 0);

      // Read pixels from FBO
      gl.readPixels(0, 0, finalDimensions.x, finalDimensions.y, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

      // Switch back to default render target, dispose the texture
      renderer.setRenderTarget();
      renderTexture.dispose();
    }

    // Create canvas with dimensions of output texture
    var canvas = _utils2.default.createCanvas();
    canvas.width = finalDimensions.x;
    canvas.height = finalDimensions.y;

    // Copy pixel data over
    var context = canvas.getContext('2d');
    var imageData = context.createImageData(finalDimensions.x, finalDimensions.y);

    imageData.data.set(pixels);

    // Render to canvas
    context.putImageData(imageData, 0, 0);

    // Delete FBO
    gl.deleteFramebuffer(fbo);

    return canvas;
  };

  /**
   * Checks if any of the given RGBA pixels has transparency
   * @param  {Uint8Array} pixels
   * @return {Boolean}
   */


  ImageExporter.prototype._checkPixelsForTransparency = function _checkPixelsForTransparency(pixels) {
    var finalDimensions = this._sdk.getFinalDimensions();
    var maxIndex = finalDimensions.x * finalDimensions.y * 4;
    var value = void 0;
    for (var i = 3; i < maxIndex; i += 4) {
      value = pixels[i];
      if (value !== 255) {
        return true;
      }
    }
    return false;
  };

  return ImageExporter;
}(_configurable2.default);

ImageExporter.prototype.availableOptions = {
  renderType: { type: _constants.OptionType.STRING, available: _utils2.default.values(_constants.RenderType), default: _constants.RenderType.IMAGE },
  imageFormat: { type: _constants.OptionType.STRING, available: _utils2.default.values(_constants.ImageFormat), default: _constants.ImageFormat.PNG },
  quality: { type: _constants.OptionType.NUMBER, default: 0.8 }
};

exports.default = ImageExporter;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _base = __webpack_require__(27);

var _base2 = _interopRequireDefault(_base);

var _utils = __webpack_require__(21);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var bd = function bd(str) {
  return _utils2.default.byteArrayToString(_base2.default.decode(str));
};

var HOST = {
  // https://staging.api.photoeditorsdk.com
  development: 'aHR0cHM6Ly9zdGFnaW5nLmFwaS5waG90b2VkaXRvcnNkay5jb20=',
  // https://api.photoeditorsdk.com
  production: 'aHR0cHM6Ly9hcGkucGhvdG9lZGl0b3JzZGsuY29t',
  // https://staging.api.photoeditorsdk.com
  test: 'aHR0cHM6Ly9zdGFnaW5nLmFwaS5waG90b2VkaXRvcnNkay5jb20='
};
// /auth?apiKey= (hashed twice)
var AUTH_PATH = 'TDJGMWRHZy9ZWEJwUzJWNVBRPT0=';
// &callback= (hashed twice)
var CB_SUFFIX = 'Sm1OaGJHeGlZV05yUFE9PQ==';
// /track?apiKey= (hashed twice)
var TRACK_PATH = 'TDNSeVlXTnJQMkZ3YVV0bGVUMD0=';
// authorized
var AUTHORIZED = 'YXV0aG9yaXplZA==';
// error
var ERROR = 'ZXJyb3I=';

/**
 * @ignore
 */

var L = function () {
  function L(apiKey) {
    (0, _classCallCheck3.default)(this, L);

    this._YXBpS2V5 = apiKey;
  }

  /**
   * Loads the given URL using `request` module on node and JSONP in browsers
   * @param  {String} url
   * @return {Promise}
   * @private
   */


  L.prototype._loadJSON = function _loadJSON(url) {
    if (true) {
      return this._loadJSONBrowser(url);
    } else {
      return this._loadJSONNode(url);
    }
  };

  /**
   * Loads the given JSON url using JSONP
   * @param  {String} url
   * @return {Promise}
   * @private
   */


  L.prototype._loadJSONBrowser = function _loadJSONBrowser(url) {
    return new Promise(function (resolve, reject) {
      var script = document.createElement('script');
      var fn = 'pesdk' + Math.floor(Math.random() * 999999);
      window[fn] = function (response) {
        script.parentNode.removeChild(script);
        resolve(response);
        delete window[fn];
      };

      script.src = url + bd(bd(CB_SUFFIX)) + fn;
      script.async = true;
      document.getElementsByTagName('head')[0].appendChild(script);
    });
  };

  /**
   * Loads the given JSON url using the `request` module
   * @param  {String} url
   * @return {Promise}
   * @private
   */


  L.prototype._loadJSONNode = function _loadJSONNode(url) {
    return new Promise(function (resolve, reject) {});
  };

  /**
   * Validates the apiKey against our backend
   * @return {Promise}
   * @ignore
   */


  L.prototype.c = function c() {
    return this._loadJSON(bd(HOST["test"]) + bd(bd(AUTH_PATH)) + this._YXBpS2V5).then(function (response) {
      if (!response[bd(AUTHORIZED)]) {
        throw new Error(response[bd(ERROR)]);
      }
    });
  };

  /**
   * Tracks an edit
   * @return {Promise}
   * @ignore
   */


  L.prototype.t = function t() {
    return this._loadJSON(bd(HOST["test"]) + bd(bd(TRACK_PATH)) + this._YXBpS2V5).then(function (response) {
      if (!response[bd(AUTHORIZED)]) {
        throw new Error(response[bd(ERROR)]);
      }
    });
  };

  return L;
}();

exports.default = L;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

/* istanbul ignore next */
var NodeGLExporter = function () {
  function NodeGLExporter() {
    (0, _classCallCheck3.default)(this, NodeGLExporter);
  }

  /**
   * Creates a new `node-canvas` Canvas and renders the image from the `gl` context onto it
   * @param  {WebGLRenderingContext2D} gl
   * @param  {Canvas} canvas
   */
  NodeGLExporter.renderContextToCanvas = function renderContextToCanvas(gl, canvas) {
    var width = canvas.width,
        height = canvas.height;

    var pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

    var context = canvas.getContext('2d');
    var imageData = new Canvas.ImageData(width, height);

    var i = 0;
    pixels.forEach(function () {
      imageData.data[i] = pixels[i];
      i++;
    });

    context.putImageData(imageData, 0, 0);
  };

  return NodeGLExporter;
}();

exports.default = NodeGLExporter;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* istanbul ignore next */
var POTRenderer = function () {
  function POTRenderer() {
    (0, _classCallCheck3.default)(this, POTRenderer);

    this._container = new _globals.Engine.Container();
    this._sprite = new _globals.Engine.Sprite();
    this._container.addChild(this._sprite);
  }

  /**
   * Renders the given input texture to a POT texture
   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param  {PhotoEditorSDK.Engine.Sprite} inputSprite
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   */


  POTRenderer.prototype.render = function render(renderer, inputSprite, inputTexture) {
    var textureDimensions = inputTexture.getDimensions();
    var nextPOT = this._getNextHighestPOT(textureDimensions);

    if (!this._renderTexture) {
      this._renderTexture = new _globals.Engine.RenderTexture(renderer, nextPOT.x, nextPOT.y);
    } else {
      this._renderTexture.resizeTo(nextPOT);
    }

    var newDimensions = this._renderTexture.getDimensions();
    this._sprite.setTexture(inputTexture);
    this._sprite.updateTransform();
    this._renderTexture.render(this._container);

    this._updateSprite(renderer, inputSprite, textureDimensions, newDimensions);
  };

  /**
   * Sets the input sprite's texture and makes sure only the relevant part of the
   * render texture is rendered
   * @param  {PhotoEditorSDK.Engine.Sprite} inputSprite
   * @param  {PhotoEditorSDK.Math.Vector2} initialDimensions
   * @param  {PhotoEditorSDK.Math.Vector2} newDimensions
   * @private
   */


  POTRenderer.prototype._updateSprite = function _updateSprite(renderer, inputSprite, initialDimensions, newDimensions) {
    inputSprite.setTexture(this._renderTexture);

    this._renderTexture.setFrame(new _globals.Rectangle(0, 0, initialDimensions.x, initialDimensions.y));
  };

  /**
   * Returns the next highest POT dimensions for the given dimensions
   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
   * @private
   */


  POTRenderer.prototype._getNextHighestPOT = function _getNextHighestPOT(dimensions) {
    return new _globals.Vector2(_globals.Utils.nextHighestPOT(dimensions.x), _globals.Utils.nextHighestPOT(dimensions.y));
  };

  /**
   * Disposes this POT renderers
   */


  POTRenderer.prototype.dispose = function dispose() {
    this._renderTexture.dispose();
  };

  return POTRenderer;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = POTRenderer;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VERSION_CHECK_FN = 'imglySDKVersionCallback'; /*
                                                   * This file is part of PhotoEditorSDK.
                                                   *
                                                   * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                   * All rights reserved.
                                                   *
                                                   * Redistribution and use in source and binary forms, without
                                                   * modification, are permitted provided that the following license agreement
                                                   * is approved and a legal/financial contract was signed by the user.
                                                   * The license agreement can be found under following link:
                                                   *
                                                   * https://www.photoeditorsdk.com/LICENSE.txt
                                                   */

var VERSION_CHECK_URL = 'https://www.photoeditorsdk.com/version.json?sdk=html5&jsoncallback=' + VERSION_CHECK_FN;

/**
 * Checks whether there is a new version of the SDK available
 * @class
 * @memberof PhotoEditorSDK
 * @ignore
 */
/* istanbul ignore next */

var VersionChecker = function () {
  /**
   * Creates a new VersionChecker
   * @param  {String} version
   */
  function VersionChecker(version) {
    (0, _classCallCheck3.default)(this, VersionChecker);

    this._version = version;
    this._check();
  }

  /**
   * Checks if this version of the SDK is outdated
   * @private
   */


  VersionChecker.prototype._check = function _check() {
    var _this = this;

    if (typeof document === 'undefined') {
      return _globals.Log.info(this.constructor.name, 'Not in browser environment. Version check skipped.');
    }

    var self = this;
    window[VERSION_CHECK_FN] = function (response) {
      if (response.outdated) {
        _globals.Log.warn(_this.constructor.name, 'Your Version ' + self._version + ' is outdated. Current version is ' + response.version + '.');
      }
    };

    var script = document.createElement('script');
    script.src = VERSION_CHECK_URL + '&version=' + this._version;
    script.async = true;
    document.getElementsByTagName('head')[0].appendChild(script);
  };

  return VersionChecker;
}();

exports.default = VersionChecker;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

var _adjustmentsFilter = __webpack_require__(81);

var _adjustmentsFilter2 = _interopRequireDefault(_adjustmentsFilter);

var _clarityFilter = __webpack_require__(121);

var _clarityFilter2 = _interopRequireDefault(_clarityFilter);

var _constants = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Applies adjustments (brightness, saturation, contrast) to the image
 * @class
 * @alias Operations.AdjustmentsOperation
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK
 */
var AdjustmentsOperation = function (_Operation) {
  (0, _inherits3.default)(AdjustmentsOperation, _Operation);

  /**
   * Creates a new AdjustmentsOperation
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} [options]
   * @param  {Number} [options.brightness = 0]
   * @param  {Number} [options.saturation = 1]
   * @param  {Number} [options.exposure = 0]
   * @param  {Number} [options.contrast = 1]
   * @param  {Number} [options.shadows = 0]
   * @param  {Number} [options.highlights = 1]
   */
  function AdjustmentsOperation() {
    (0, _classCallCheck3.default)(this, AdjustmentsOperation);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));

    _this._clarityFilter = new _clarityFilter2.default();
    _this._filter = new _adjustmentsFilter2.default();
    _this._sprite.setFilters([_this._clarityFilter, _this._filter]);
    return _this;
  }

  /**
   * Applies this operation
   * @param  {PhotoEditorSDK} sdk
   * @return {Promise} renderer
   * @private
   */


  AdjustmentsOperation.prototype._render = function _render(sdk) {
    var dimensions = sdk.getDimensions();
    dimensions.x = 1.0 / dimensions.x;
    dimensions.y = 1.0 / dimensions.y;
    this._clarityFilter.set({
      clarity: this._options.clarity,
      texSize: dimensions
    });

    this._filter.set({
      brightness: this._options.brightness,
      saturation: this._options.saturation,
      contrast: this._options.contrast,
      gamma: this._options.gamma,
      exposure: this._options.exposure,
      shadows: this._options.shadows,
      highlights: this._options.highlights
    });

    if (this._options.clarity !== 0) {
      this._sprite.setFilters([this._clarityFilter, this._filter]);
    } else {
      this._sprite.setFilters([this._filter]);
    }

    this._renderTexture.render(this._container);

    return _promise2.default.resolve();
  };

  /**
   * Disposes this operation
   */


  AdjustmentsOperation.prototype.dispose = function dispose() {
    _Operation.prototype.dispose.call(this);
    this._filter.dispose();
    this._clarityFilter.dispose();
  };

  return AdjustmentsOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

AdjustmentsOperation.identifier = 'adjustments';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
AdjustmentsOperation.prototype.availableOptions = {
  brightness: { type: _constants.OptionType.NUMBER, default: 0 },
  saturation: { type: _constants.OptionType.NUMBER, default: 1.0 },
  contrast: { type: _constants.OptionType.NUMBER, default: 1.0 },
  gamma: { type: _constants.OptionType.NUMBER, default: 1.0 },
  exposure: { type: _constants.OptionType.NUMBER, default: 0.0 },
  shadows: { type: _constants.OptionType.NUMBER, default: 0.0 },
  highlights: { type: _constants.OptionType.NUMBER, default: 1.0 },
  clarity: { type: _constants.OptionType.NUMBER, default: 0.0 }
};

exports.default = AdjustmentsOperation;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _stackBlur = __webpack_require__(37);

var _stackBlur2 = _interopRequireDefault(_stackBlur);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType; /*
                                                   * This file is part of PhotoEditorSDK.
                                                   *
                                                   * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                   * All rights reserved.
                                                   *
                                                   * Redistribution and use in source and binary forms, without
                                                   * modification, are permitted provided that the following license agreement
                                                   * is approved and a legal/financial contract was signed by the user.
                                                   * The license agreement can be found under following link:
                                                   *
                                                   * https://www.photoeditorsdk.com/LICENSE.txt
                                                   */

var ClarityFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(ClarityFilter, _Engine$Filter);

  function ClarityFilter() {
    (0, _classCallCheck3.default)(this, ClarityFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(240);

    _this._lastClarity = null;

    _this._blurredRenderTarget = new _globals.Engine.CanvasRenderTarget(100, 100, 1);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer.
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  ClarityFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var inputDimensions = inputTarget.getDimensions();
    var dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);

    this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());

    if (!this._outputRenderTexture) {
      this._outputRenderTexture = new _globals.Engine.RenderTexture(renderer, inputTarget.getWidth(), inputTarget.getHeight(), inputTarget.getPixelRatio());
    }

    if (dimensionsChanged) {
      this._blurImage(inputTarget);
    }

    this._applyClarity(inputTarget, outputTarget);
  };

  /**
   * Creates a blurred copy of the image.
   * @param  {CanvasRenderTarget} inputTarget
   * @return {Canvas}
   * @private
   */


  ClarityFilter.prototype._blurImage = function _blurImage(inputTarget) {
    var inputCanvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();

    var blurryImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    _stackBlur2.default.stackBlurCanvasRGBA(blurryImageData, 0, 0, inputCanvas.width, inputCanvas.height, 1);

    var blurryContext = this._blurredRenderTarget.getContext();
    blurryContext.putImageData(blurryImageData, 0, 0);
  };

  /**
   * Applies the final clarity filter to the input canvas
   * @param {CanvasRenderTarget} inputTarget
   * @param {CanvasRenderTarget} outputTarget
   * @private
   */


  ClarityFilter.prototype._applyClarity = function _applyClarity(inputTarget, outputTarget) {
    var outputContext = outputTarget.getContext();
    var inputCanvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var blurredContext = this._blurredRenderTarget.getContext();
    var clarity = this._options.clarity;
    var inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    var pixels = inputImageData.data;
    var blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    // Due to speed we precalculate alot
    var saturation = Math.max(0.2 * this._options.clarity, 0.0);
    var inverseSaturation = 1 - saturation;
    var factor = 1.0 + clarity;
    var inverseFactor = 1 - (1.0 + clarity);
    // Here we calculate the unsharp mask by substracting the blured image from the
    // unblurred, and the stronger the effect is the less saturated the colors will be.
    // That enhances the visual effect.
    for (var i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
      var r = blurredPixels[i] * inverseFactor + pixels[i] * factor;
      var g = blurredPixels[i + 1] * inverseFactor + pixels[i + 1] * factor;
      var b = blurredPixels[i + 2] * inverseFactor + pixels[i + 2] * factor;
      var luminance = r * 0.2125 + g * 0.7154 + b * 0.0721;
      var luminanceSaturation = luminance * saturation;
      pixels[i] = r * inverseSaturation + luminanceSaturation;
      pixels[i + 1] = g * inverseSaturation + luminanceSaturation;
      pixels[i + 2] = b * inverseSaturation + luminanceSaturation;
    }

    outputContext.putImageData(inputImageData, 0, 0);
  };

  return ClarityFilter;
}(_globals.Engine.Filter);

ClarityFilter.prototype.availableOptions = {
  clarity: { type: OptionType.NUMBER, default: 0, uniformType: UniformType.FLOAT },
  texSize: { type: OptionType.VECTOR2, default: new _globals.Vector2(100, 100), uniformType: UniformType.FLOAT2 }
};

exports.default = ClarityFilter;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType;

/**
 * An operation that can crop out a part of the image
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CropOperation = function (_Operation) {
  (0, _inherits3.default)(CropOperation, _Operation);

  function CropOperation() {
    (0, _classCallCheck3.default)(this, CropOperation);
    return (0, _possibleConstructorReturn3.default)(this, _Operation.apply(this, arguments));
  }

  // -------------------------------------------------------------------------- RENDERING

  /**
   * Crops the image
   * @param {PhotoEditorSDK.Engine.RenderTexture} inputTexture
   * @returns {Promise}
   * @override
   * @private
   */
  CropOperation.prototype._render = function _render(inputTexture) {
    this._sprite.setRotation(0);

    var inputDimensions = inputTexture.getDimensions();
    var _options = this._options,
        start = _options.start,
        rotation = _options.rotation,
        scale = _options.scale,
        textureScale = _options.textureScale;

    var finalScale = scale * textureScale;
    var scaledInputDimensions = inputDimensions.clone().multiply(textureScale);

    this._sprite.setAnchor(0.5, 0.5);
    this._sprite.setRotation(rotation);
    this._sprite.setScale(finalScale, finalScale);
    this._sprite.setPosition(scaledInputDimensions.clone().divide(2).subtract(start.clone().multiply(scaledInputDimensions)));

    // Render the container to this Operation's RenderTexture
    this._renderTexture.render(this._container);

    return _promise2.default.resolve();
  };

  /**
   * Returns the dimensions the given dimensions will have after this operation
   * has been applied
   * @param {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {PhotoEditorSDK.Math.Vector2}
   * @override
   */


  CropOperation.prototype.getNewDimensions = function getNewDimensions(inputDimensions) {
    var _options2 = this._options,
        start = _options2.start,
        end = _options2.end,
        textureScale = _options2.textureScale;


    return inputDimensions.clone().multiply(textureScale).multiply(end.clone().subtract(start)).ceil();
  };

  /**
   * Flips this operation into the given direction
   * @param  {String} direction
   */


  CropOperation.prototype.flip = function flip(direction) {
    var _options3 = this._options,
        start = _options3.start,
        end = _options3.end;

    var tmpStart = start.clone();

    if (direction === 'horizontal') {
      start.set(1.0 - end.x, start.y);
      end.set(1.0 - tmpStart.x, end.y);
    } else if (direction === 'vertical') {
      start.set(start.x, 1.0 - end.y);
      end.set(end.x, 1.0 - tmpStart.y);
    }
  };

  /**
   * Rotates this operation with the given degrees
   * @param {Number} degrees
   */


  CropOperation.prototype.rotate = function rotate(degrees) {
    var _options4 = this._options,
        start = _options4.start,
        end = _options4.end;

    var degreesDifference = (degrees + 360) % 360;

    var tempStart = start.clone();
    if (degreesDifference === 90) {
      start.set(1.0 - end.y, tempStart.x);
      end.set(1.0 - tempStart.y, end.x);
    } else if (degreesDifference === 270) {
      start.set(tempStart.y, 1.0 - end.x);
      end.set(end.y, 1.0 - tempStart.x);
    }
  };

  return CropOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */


CropOperation.identifier = 'crop';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
CropOperation.prototype.availableOptions = {
  start: { type: OptionType.VECTOR2, default: new _globals.Vector2(0, 0) },
  end: { type: OptionType.VECTOR2, default: new _globals.Vector2(1, 1) },
  scale: { type: OptionType.NUMBER, default: 1 },
  textureScale: { type: OptionType.NUMBER, default: 1 },
  rotation: { type: OptionType.NUMBER, default: 0 }
};

exports.default = CropOperation;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _vector = __webpack_require__(23);

var _vector2 = _interopRequireDefault(_vector);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType;

/**
 * An operation that can rotate and flip an image depending on the given EXIF information
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */

var ExifOrientationOperation = function (_Operation) {
  (0, _inherits3.default)(ExifOrientationOperation, _Operation);

  function ExifOrientationOperation() {
    (0, _classCallCheck3.default)(this, ExifOrientationOperation);
    return (0, _possibleConstructorReturn3.default)(this, _Operation.apply(this, arguments));
  }

  /**
   * Returns the rotation
   * @return {Number}
   * @private
   */
  ExifOrientationOperation.prototype._getRotation = function _getRotation() {
    var degrees = 0;
    switch (this.getTags().Orientation) {
      case 7:
      case 8:
        degrees = -90;
        break;
      case 3:
      case 4:
        degrees = -180;
        break;
      case 5:
      case 6:
        degrees = 90;
        break;
    }
    return degrees;
  };

  /**
   * Checks if the image needs to be flipped vertically
   * @return {Boolean}
   * @private
   */


  ExifOrientationOperation.prototype._getFlipVertically = function _getFlipVertically() {
    var _getTags = this.getTags(),
        Orientation = _getTags.Orientation;

    return [5, 7].indexOf(Orientation) !== -1;
  };

  /**
   * Checks if the image needs to be flipped horizontally
   * @return {Boolean}
   * @private
   */


  ExifOrientationOperation.prototype._getFlipHorizontally = function _getFlipHorizontally() {
    var _getTags2 = this.getTags(),
        Orientation = _getTags2.Orientation;

    return [2, 4].indexOf(Orientation) !== -1;
  };

  /**
   * Returns the options based on the EXIF orientation
   * @return {Object}
   * @private
   */


  ExifOrientationOperation.prototype._getFinalOptions = function _getFinalOptions() {
    return {
      rotation: this._getRotation(),
      flipVertically: this._getFlipVertically(),
      flipHorizontally: this._getFlipHorizontally()
    };
  };

  /**
   * Rotates and/or flips the image
   * @param  {PhotoEditorSDK} sdk
   * @returns {Promise}
   * @override
   * @private
   */


  ExifOrientationOperation.prototype._render = function _render(sdk) {
    var options = this._getFinalOptions();
    var actualDegrees = options.rotation % 360;
    var radians = actualDegrees * (Math.PI / 180);

    this._sprite.setScale(options.flipHorizontally ? -1 : 1, options.flipVertically ? -1 : 1);
    this._sprite.setRotation(radians);
    this._sprite.setAnchor(0.5, 0.5);
    this._sprite.updateTransform();

    var bounds = this._sprite.getBounds();
    this._renderTexture.resizeTo(new _vector2.default(bounds.width, bounds.height));

    // Make sure we're rendering to top left corner
    this._sprite.setPosition(this._renderTexture.getDimensions().divide(2));

    // Draw
    this._renderTexture.render(this._container);

    return _promise2.default.resolve();
  };

  /**
   * Returns the dimensions the given dimensions will have after this operation
   * has been applied
   * @param {PhotoEditorSDK.Math.Vector2} dimensions
   * @return {PhotoEditorSDK.Math.Vector2}
   * @override
   */


  ExifOrientationOperation.prototype.getNewDimensions = function getNewDimensions(dimensions) {
    var options = this._getFinalOptions();
    dimensions = dimensions.clone();
    if (options.rotation % 180) {
      dimensions.flip();
    }
    return dimensions;
  };

  return ExifOrientationOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */


ExifOrientationOperation.identifier = 'exif-orientation';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
ExifOrientationOperation.prototype.availableOptions = {
  tags: { type: OptionType.OBJECT, default: {} }
};

exports.default = ExifOrientationOperation;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

var _identityFilter = __webpack_require__(82);

var _identityFilter2 = _interopRequireDefault(_identityFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType;

/**
 * An operation that can apply a selected filter
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FilterOperation = function (_Operation) {
  (0, _inherits3.default)(FilterOperation, _Operation);

  function FilterOperation() {
    (0, _classCallCheck3.default)(this, FilterOperation);
    return (0, _possibleConstructorReturn3.default)(this, _Operation.apply(this, arguments));
  }

  /**
   * Renders this operation
   * @param {PhotoEditorSDK.Engine.Texture} inputTexture
   * @return {Promise}
   * @private
   */
  FilterOperation.prototype._render = function _render(inputTexture) {
    return this._selectedFilter.render(this._sdk, inputTexture, this._renderTexture);
  };

  /**
   * Applies this operation
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @return {Promise}
   * @override
   */


  FilterOperation.prototype.render = function render(inputTexture) {
    if (this._selectedFilter.getDirty()) {
      this.setDirty(true);
    }

    if (!this.getEnabled() || this._selectedFilter.constructor.isIdentity) {
      return _globals.Promise.resolve(inputTexture);
    }

    return _Operation.prototype.render.call(this, inputTexture);
  };

  /**
   * Sets the dirtiness for the given renderer
   * @param {Boolean} dirty
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @override
   */


  FilterOperation.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
    _Operation.prototype.setDirtyForRenderer.call(this, dirty, renderer);
    this._selectedFilter.setDirtyForRenderer(dirty, renderer);
  };

  /**
   * Frees the memory
   */


  FilterOperation.prototype.disposeRenderTextures = function disposeRenderTextures() {
    _Operation.prototype.disposeRenderTextures.call(this);
    if (this._selectedFilter) {
      this._selectedFilter.disposeRenderTextures();
    }
  };

  /**
   * Disposes this operation
   */


  FilterOperation.prototype.dispose = function dispose() {
    _Operation.prototype.dispose.call(this);
    if (this._selectedFilter) {
      this._selectedFilter.dispose();
    }
  };

  return FilterOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */


FilterOperation.identifier = 'filter';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
FilterOperation.prototype.availableOptions = {
  intensity: {
    type: OptionType.NUMBER,
    default: 1,
    setter: function setter(intensity) {
      this._selectedFilter && this._selectedFilter.setIntensity(intensity);
      return intensity;
    }
  },
  filter: {
    type: OptionType.OBJECT,
    default: new _identityFilter2.default(),
    setter: function setter(Filter) {
      if (this._selectedFilter) {
        this._selectedFilter.dispose();
        this._selectedFilter = null;
      }

      this._selectedFilter = Filter;
      if (typeof this._options.intensity !== 'undefined') {
        this._selectedFilter.set({
          intensity: this._options.intensity
        });
      }
      return Filter;
    }
  }
};

exports.default = FilterOperation;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A15 Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var A15Filter = function (_Filter) {
  (0, _inherits3.default)(A15Filter, _Filter);

  function A15Filter() {
    (0, _classCallCheck3.default)(this, A15Filter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Contrast({
      contrast: 0.63
    }));

    _this._stack.push(new FilterPrimitives.Brightness({
      brightness: 0.12
    }));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 38], [94, 94], [148, 142], [175, 187], [255, 255]],
        green: [[0, 0], [77, 53], [171, 190], [255, 255]],
        blue: [[0, 10], [48, 85], [174, 228], [255, 255]]
      }
    }));
    return _this;
  }

  return A15Filter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


A15Filter.identifier = 'a15';

A15Filter.displayName = '15';

exports.default = A15Filter;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Breeze Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BreezeFilter = function (_Filter) {
  (0, _inherits3.default)(BreezeFilter, _Filter);

  function BreezeFilter() {
    (0, _classCallCheck3.default)(this, BreezeFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Desaturation
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Desaturation({
      desaturation: 0.5
    }));

    // Tone curve
    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 0], [170, 170], [212, 219], [234, 242], [255, 255]],
        green: [[0, 0], [170, 168], [234, 231], [255, 255]],
        blue: [[0, 0], [170, 170], [212, 208], [255, 255]]
      }
    }));
    return _this;
  }

  return BreezeFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


BreezeFilter.identifier = 'breeze';

BreezeFilter.displayName = 'Breeze';

exports.default = BreezeFilter;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * BW Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BWFilter = function (_Filter) {
  (0, _inherits3.default)(BWFilter, _Filter);

  function BWFilter() {
    (0, _classCallCheck3.default)(this, BWFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Grayscale());
    return _this;
  }

  return BWFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


BWFilter.identifier = 'bw';

BWFilter.displayName = 'B&W';

exports.default = BWFilter;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * BWHard Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var BWHardFilter = function (_Filter) {
  (0, _inherits3.default)(BWHardFilter, _Filter);

  function BWHardFilter() {
    (0, _classCallCheck3.default)(this, BWHardFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Grayscale());
    _this._stack.push(new FilterPrimitives.Contrast({
      contrast: 1.5
    }));
    return _this;
  }

  return BWHardFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


BWHardFilter.identifier = 'bwhard';

BWHardFilter.displayName = '1920';

exports.default = BWHardFilter;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Celsius Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var CelsiusFilter = function (_Filter) {
  (0, _inherits3.default)(CelsiusFilter, _Filter);

  function CelsiusFilter() {
    (0, _classCallCheck3.default)(this, CelsiusFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 69], [55, 110], [202, 230], [255, 255]],
        green: [[0, 44], [89, 93], [185, 141], [255, 189]],
        blue: [[0, 76], [39, 82], [218, 138], [255, 171]]
      }
    }));
    return _this;
  }

  return CelsiusFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


CelsiusFilter.identifier = 'celsius';

CelsiusFilter.displayName = 'Celsius';

exports.default = CelsiusFilter;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Chest Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var ChestFilter = function (_Filter) {
  (0, _inherits3.default)(ChestFilter, _Filter);

  function ChestFilter() {
    (0, _classCallCheck3.default)(this, ChestFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Tone curve
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 0], [44, 44], [124, 143], [221, 204], [255, 255]],
        green: [[0, 0], [130, 127], [213, 199], [255, 255]],
        blue: [[0, 0], [51, 52], [219, 204], [255, 255]]
      }
    }));
    return _this;
  }

  return ChestFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


ChestFilter.identifier = 'chest';

ChestFilter.displayName = 'Chest';

exports.default = ChestFilter;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Fixie Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FixieFilter = function (_Filter) {
  (0, _inherits3.default)(FixieFilter, _Filter);

  function FixieFilter() {
    (0, _classCallCheck3.default)(this, FixieFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Tone curve
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 0], [44, 28], [63, 48], [128, 132], [235, 248], [255, 255]],
        green: [[0, 0], [20, 10], [60, 45], [190, 209], [211, 231], [255, 255]],
        blue: [[0, 31], [41, 62], [150, 142], [234, 212], [255, 224]]
      }
    }));
    return _this;
  }

  return FixieFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


FixieFilter.identifier = 'fixie';

FixieFilter.displayName = 'Fixie';

exports.default = FixieFilter;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Food Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FoodFilter = function (_Filter) {
  (0, _inherits3.default)(FoodFilter, _Filter);

  function FoodFilter() {
    (0, _classCallCheck3.default)(this, FoodFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Saturation({
      saturation: 1.35
    }));

    _this._stack.push(new FilterPrimitives.Contrast({
      contrast: 1.1
    }));
    return _this;
  }

  return FoodFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


FoodFilter.identifier = 'food';

FoodFilter.displayName = 'Food';

exports.default = FoodFilter;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Fridge Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FridgeFilter = function (_Filter) {
  (0, _inherits3.default)(FridgeFilter, _Filter);

  function FridgeFilter() {
    (0, _classCallCheck3.default)(this, FridgeFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Tone curve
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 9], [21, 11], [45, 24], [255, 220]],
        green: [[0, 12], [21, 21], [42, 42], [150, 150], [170, 173], [255, 210]],
        blue: [[0, 28], [43, 72], [128, 185], [255, 220]]
      }
    }));
    return _this;
  }

  return FridgeFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


FridgeFilter.identifier = 'fridge';

FridgeFilter.displayName = 'Fridge';

exports.default = FridgeFilter;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Front Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var FrontFilter = function (_Filter) {
  (0, _inherits3.default)(FrontFilter, _Filter);

  function FrontFilter() {
    (0, _classCallCheck3.default)(this, FrontFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Tone curve
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 65], [28, 67], [67, 113], [125, 183], [187, 217], [255, 229]],
        green: [[0, 52], [42, 59], [104, 134], [169, 209], [255, 240]],
        blue: [[0, 52], [65, 68], [93, 104], [150, 153], [255, 198]]
      }
    }));
    return _this;
  }

  return FrontFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


FrontFilter.identifier = 'front';

FrontFilter.displayName = 'Front';

exports.default = FrontFilter;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Glam Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var GlamFilter = function (_Filter) {
  (0, _inherits3.default)(GlamFilter, _Filter);

  function GlamFilter() {
    (0, _classCallCheck3.default)(this, GlamFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Contrast({
      contrast: 1.1
    }));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 0], [94, 74], [181, 205], [255, 255]],
        green: [[0, 0], [127, 127], [255, 255]],
        blue: [[0, 0], [102, 73], [227, 213], [255, 255]]
      }
    }));
    return _this;
  }

  return GlamFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


GlamFilter.identifier = 'glam';

GlamFilter.displayName = 'Glam';

exports.default = GlamFilter;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gobblin Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var GobblinFilter = function (_Filter) {
  (0, _inherits3.default)(GobblinFilter, _Filter);

  function GobblinFilter() {
    (0, _classCallCheck3.default)(this, GobblinFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Gobblin());
    return _this;
  }

  return GobblinFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


GobblinFilter.identifier = 'gobblin';

GobblinFilter.displayName = 'Gobblin';

exports.default = GobblinFilter;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * K1 Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var K1Filter = function (_Filter) {
  (0, _inherits3.default)(K1Filter, _Filter);

  function K1Filter() {
    (0, _classCallCheck3.default)(this, K1Filter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Tone curve
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      controlPoints: [[0, 0], [53, 32], [91, 80], [176, 205], [255, 255]]
    }));

    // Saturation
    _this._stack.push(new FilterPrimitives.Saturation({
      saturation: 0.9
    }));
    return _this;
  }

  return K1Filter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


K1Filter.identifier = 'k1';

K1Filter.displayName = 'K1';

exports.default = K1Filter;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * K2 Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
var K2Filter = function (_Filter) {
  (0, _inherits3.default)(K2Filter, _Filter);

  function K2Filter() {
    (0, _classCallCheck3.default)(this, K2Filter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Tone curve
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      controlPoints: [[0, 0], [54, 33], [77, 82], [94, 103], [122, 126], [177, 193], [229, 232], [255, 255]]
    }));

    // Soft color overlay
    _this._stack.push(new FilterPrimitives.SoftColorOverlay({
      color: new _color2.default(40 / 255, 40 / 255, 40 / 255)
    }));
    return _this;
  }

  return K2Filter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

K2Filter.identifier = 'k2';

K2Filter.displayName = 'K2';

exports.default = K2Filter;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * K6 Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var K6Filter = function (_Filter) {
  (0, _inherits3.default)(K6Filter, _Filter);

  function K6Filter() {
    (0, _classCallCheck3.default)(this, K6Filter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Saturation
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Saturation({
      saturation: 0.5
    }));
    return _this;
  }

  return K6Filter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


K6Filter.identifier = 'k6';

K6Filter.displayName = 'K6';

exports.default = K6Filter;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * KDynamic Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var KDynamicFilter = function (_Filter) {
  (0, _inherits3.default)(KDynamicFilter, _Filter);

  function KDynamicFilter() {
    (0, _classCallCheck3.default)(this, KDynamicFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Tone curve
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      controlPoints: [[0, 0], [17, 27], [46, 69], [90, 112], [156, 200], [203, 243], [255, 255]]
    }));

    // Saturation
    _this._stack.push(new FilterPrimitives.Saturation({
      saturation: 0.7
    }));
    return _this;
  }

  return KDynamicFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


KDynamicFilter.identifier = 'kdynamic';

KDynamicFilter.displayName = 'KDynamic';

exports.default = KDynamicFilter;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Lenin Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var LeninFilter = function (_Filter) {
  (0, _inherits3.default)(LeninFilter, _Filter);

  function LeninFilter() {
    (0, _classCallCheck3.default)(this, LeninFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Desaturation
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Desaturation({
      desaturation: 0.4
    }));

    // Tone curve
    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 20], [40, 20], [106, 111], [129, 153], [190, 223], [255, 255]],
        green: [[0, 20], [40, 20], [62, 41], [106, 108], [132, 159], [203, 237], [255, 255]],
        blue: [[0, 40], [40, 40], [73, 60], [133, 160], [191, 297], [203, 237], [237, 239], [255, 255]]
      }
    }));
    return _this;
  }

  return LeninFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


LeninFilter.identifier = 'lenin';

LeninFilter.displayName = 'Lenin';

exports.default = LeninFilter;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Lomo Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var LomoFilter = function (_Filter) {
  (0, _inherits3.default)(LomoFilter, _Filter);

  function LomoFilter() {
    (0, _classCallCheck3.default)(this, LomoFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      controlPoints: [[0, 0], [87, 20], [131, 156], [183, 205], [255, 200]]
    }));
    return _this;
  }

  return LomoFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


LomoFilter.identifier = 'lomo';

LomoFilter.displayName = 'Lomo';

exports.default = LomoFilter;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType; /*
                                                 * This file is part of PhotoEditorSDK.
                                                 *
                                                 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                 * All rights reserved.
                                                 *
                                                 * Redistribution and use in source and binary forms, without
                                                 * modification, are permitted provided that the following license agreement
                                                 * is approved and a legal/financial contract was signed by the user.
                                                 * The license agreement can be found under following link:
                                                 *
                                                 * https://www.photoeditorsdk.com/LICENSE.txt
                                                 */

/**
 * Lomo Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
var LUTFilter = function (_Filter) {
  (0, _inherits3.default)(LUTFilter, _Filter);

  function LUTFilter() {
    (0, _classCallCheck3.default)(this, LUTFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._lutPrimitive = new FilterPrimitives.LookupTableImage({
      image: _this._options.image
    });
    _this._stack.push(_this._lutPrimitive);
    return _this;
  }

  return LUTFilter;
}(_filter2.default);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */


LUTFilter.prototype.availableOptions = {
  image: {
    type: OptionType.IMAGE,
    required: true,
    setter: function setter(image) {
      if (this._lutPrimitive) {
        this._lutPrimitive.setImage(image);
      }
      this.setDirty(true);
      return image;
    }
  }
};

/**
 * This filter's identifier
 * @type {String}
 * @default
 */
LUTFilter.identifier = 'lut';

LUTFilter.displayName = 'Lookup Table';

exports.default = LUTFilter;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Mellow Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var MellowFilter = function (_Filter) {
  (0, _inherits3.default)(MellowFilter, _Filter);

  function MellowFilter() {
    (0, _classCallCheck3.default)(this, MellowFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 0], [41, 84], [87, 134], [255, 255]],
        green: [[0, 0], [255, 216]],
        blue: [[0, 0], [255, 131]]
      }
    }));
    return _this;
  }

  return MellowFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


MellowFilter.identifier = 'mellow';

MellowFilter.displayName = 'Mellow';

exports.default = MellowFilter;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

var _colorMatrix = __webpack_require__(35);

var _colorMatrix2 = _interopRequireDefault(_colorMatrix);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Metal Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var MetalFilter = function (_Filter) {
  (0, _inherits3.default)(MetalFilter, _Filter);

  function MetalFilter() {
    (0, _classCallCheck3.default)(this, MetalFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    var matrix1 = new _colorMatrix2.default(0.8158218291630716, 0, 0, 0, -0.01779810181190647, 0, 0.8098360655737704, 0, 0, 0.0916393442622953, 0, 0, 0.4596336773932402, 0, 0.12760574782432707, 0, 0, 0, 1, 0);
    _this._stack.push(new FilterPrimitives.ColorMatrixPrimitive({
      colormatrix: matrix1
    }));
    var gammaColor = new _color2.default(0.8, 0.6, 0.9);
    _this._stack.push(new FilterPrimitives.Gamma({
      gamma: gammaColor
    }));
    return _this;
  }

  return MetalFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


MetalFilter.identifier = 'metal';

MetalFilter.displayName = 'Metal';

exports.default = MetalFilter;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Morning Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var MorningFilter = function (_Filter) {
  (0, _inherits3.default)(MorningFilter, _Filter);

  function MorningFilter() {
    (0, _classCallCheck3.default)(this, MorningFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 40], [255, 230]],
        green: [[0, 10], [255, 225]],
        blue: [[0, 20], [255, 181]]
      }
    }));

    _this._stack.push(new FilterPrimitives.Glow());
    return _this;
  }

  return MorningFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


MorningFilter.identifier = 'morning';

MorningFilter.displayName = 'Morning';

exports.default = MorningFilter;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Orchid Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OrchidFilter = function (_Filter) {
  (0, _inherits3.default)(OrchidFilter, _Filter);

  function OrchidFilter() {
    (0, _classCallCheck3.default)(this, OrchidFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Tone curve
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 0], [115, 130], [195, 215], [255, 255]],
        green: [[0, 0], [148, 153], [172, 215], [255, 255]],
        blue: [[0, 46], [58, 75], [178, 205], [255, 255]]
      }
    }));

    // Tone curve
    _this._stack.push(new FilterPrimitives.ToneCurve({
      controlPoints: [[0, 0], [117, 151], [189, 217], [255, 255]]
    }));

    // Desaturation
    _this._stack.push(new FilterPrimitives.Desaturation({
      desaturation: 0.65
    }));
    return _this;
  }

  return OrchidFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


OrchidFilter.identifier = 'orchid';

OrchidFilter.displayName = 'Orchid';

exports.default = OrchidFilter;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Pola Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var PolaFilter = function (_Filter) {
  (0, _inherits3.default)(PolaFilter, _Filter);

  function PolaFilter() {
    (0, _classCallCheck3.default)(this, PolaFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 0], [94, 74], [181, 205], [255, 255]],
        green: [[0, 0], [34, 34], [99, 76], [176, 190], [255, 255]],
        blue: [[0, 0], [102, 73], [227, 213], [255, 255]]
      }
    }));

    _this._stack.push(new FilterPrimitives.Saturation({
      saturation: 0.8
    }));

    _this._stack.push(new FilterPrimitives.Contrast({
      contrast: 1.5
    }));
    return _this;
  }

  return PolaFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


PolaFilter.identifier = 'pola';

PolaFilter.displayName = 'Pola SX';

exports.default = PolaFilter;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Pola669 Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var Pola669Filter = function (_Filter) {
  (0, _inherits3.default)(Pola669Filter, _Filter);

  function Pola669Filter() {
    (0, _classCallCheck3.default)(this, Pola669Filter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 0], [56, 18], [196, 209], [255, 255]],
        green: [[0, 38], [71, 84], [255, 255]],
        blue: [[0, 0], [131, 133], [204, 211], [255, 255]]
      }
    }));

    _this._stack.push(new FilterPrimitives.Saturation({
      saturation: 0.8
    }));

    _this._stack.push(new FilterPrimitives.Contrast({
      contrast: 1.5
    }));
    return _this;
  }

  return Pola669Filter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


Pola669Filter.identifier = 'pola669';

Pola669Filter.displayName = 'Pola 669';

exports.default = Pola669Filter;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType,
    RendererType = _globals.Constants.RendererType; /*
                                                     * This file is part of PhotoEditorSDK.
                                                     *
                                                     * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                     * All rights reserved.
                                                     *
                                                     * Redistribution and use in source and binary forms, without
                                                     * modification, are permitted provided that the following license agreement
                                                     * is approved and a legal/financial contract was signed by the user.
                                                     * The license agreement can be found under following link:
                                                     *
                                                     * https://www.photoeditorsdk.com/LICENSE.txt
                                                     */

var BlendFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(BlendFilter, _Engine$Filter);

  function BlendFilter() {
    (0, _classCallCheck3.default)(this, BlendFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(238);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {PhotoEditorSDK.Engine.CanvasRenderer} renderer
   * @param  {PhotoEditorSDK.Engine.RenderTarget} inputTarget
   * @param  {PhotoEditorSDK.Engine.RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  BlendFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var outputContext = outputTarget.getContext();

    var filteredCanvas = this._options.filteredCanvas;


    outputContext.save();
    outputContext.drawImage(canvas, 0, 0);
    outputContext.globalAlpha = this._options.intensity;
    outputContext.drawImage(filteredCanvas, 0, 0);
    outputContext.restore();
  };

  return BlendFilter;
}(_globals.Engine.Filter);

BlendFilter.prototype.availableOptions = {
  filteredImage: { type: OptionType.NUMBER, default: 1, uniformType: UniformType.INT },
  filteredCanvas: { type: OptionType.OBJECT, default: null },
  intensity: { type: OptionType.NUMBER, default: 1, uniformType: UniformType.FLOAT }
};

/**
 * A helper class that can collect {@link Primitive} instances and render
 * the stack
 * @class
 * @memberof PhotoEditorSDK.Filter
 */

var PrimitivesStack = function () {
  function PrimitivesStack() {
    var intensity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    (0, _classCallCheck3.default)(this, PrimitivesStack);

    this._intensity = intensity;

    this._stack = [];
    this._dirtiness = {};
    this._renderTextures = {};
    this._container = new _globals.Engine.Container();
    this._sprite = new _globals.Engine.Sprite();
    this._container.addChild(this._sprite);

    this._blendFilter = new BlendFilter();
  }

  /**
   * Adds the given primitive to the stack
   * @param {PhotoEditorSDK.Filter.Primitive} primitive
   */


  PrimitivesStack.prototype.push = function push(primitive) {
    this._stack.push(primitive);
  };

  /**
   * Clears the stack
   */


  PrimitivesStack.prototype.clear = function clear() {
    this._stack = [];
  };

  /**
   * Renders this stack
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @param  {PhotoEditorSDK.Engine.RenderTexture} outputTexture
   * @return {Promise}
   * @description This takes the output sprite's current texture and renders
   *              it to this stack's internal render texture. It then uses the
   *              internal texture as a uniform for a blend shader and renders
   *              the sprite with the original texture and the blend shader to
   *              the outputTexture
   */


  PrimitivesStack.prototype.render = function render(sdk, inputTexture, outputTexture) {
    if (this._stack.length === 0) {
      return _promise2.default.resolve();
    }
    var renderer = sdk.getRenderer();

    this._sprite.setTexture(inputTexture);

    // Make sure we have a RenderTexture we can render the filtered image to
    var filteredRenderTexture = this._renderTextures[renderer.id];
    if (!filteredRenderTexture) {
      var frame = sdk.getSprite().getTexture().getFrame();
      filteredRenderTexture = new _globals.Engine.RenderTexture(sdk.getRenderer(), frame.width, frame.height);
      this._renderTextures[renderer.id] = filteredRenderTexture;
    }

    // Resize filtered render texture to output texture dimensions
    var textureDimensions = outputTexture.getDimensions();
    filteredRenderTexture.resizeTo(textureDimensions);

    var shouldRender = this.isDirtyForRenderer(renderer);
    if (shouldRender) {
      // Update primitives
      this._stack.forEach(function (p) {
        p.update(sdk);
      });

      // Set filters
      var filters = this._stack.map(function (p) {
        return p.getFilter();
      });
      this._sprite.setFilters(filters);

      // Render to RenderTexture
      filteredRenderTexture.render(this._container);
      this.setDirtyForRenderer(false, renderer);
    }

    // Use filteredRenderTexture as uniform for blend shader, blend the two
    // to achieve intensity
    this._blendFilter.setIntensity(this._intensity);
    if (renderer.isOfType(RendererType.CANVAS)) {
      this._blendFilter.setFilteredCanvas(filteredRenderTexture.getRenderTarget().getCanvas());
    } else if (renderer.isOfType(RendererType.WEBGL)) {
      var baseTexture = filteredRenderTexture.getBaseTexture();
      baseTexture.setGLUnit(this._blendFilter.getFilteredImage());
      renderer.updateTexture(baseTexture, false);
    }
    this._sprite.setFilters([this._blendFilter]);

    outputTexture.clear(_globals.Color.TRANSPARENT);
    outputTexture.render(this._container);

    if (shouldRender) {
      this.disposeRenderTextures();
    }

    return _promise2.default.resolve(outputTexture);
  };

  PrimitivesStack.prototype.setIntensity = function setIntensity(intensity) {
    this._intensity = intensity;
  };

  /**
   * Checks if this operation is dirty for the given renderer
   * @param  {PhotoEditorSDK.Engine.BaseRenderer}  renderer
   * @return {Boolean}
   */


  PrimitivesStack.prototype.isDirtyForRenderer = function isDirtyForRenderer(renderer) {
    if (!(renderer.id in this._dirtiness)) {
      this._dirtiness[renderer.id] = true;
    }
    return this._dirtiness[renderer.id];
  };

  /**
   * Sets the dirtiness for the given renderer
   * @param {Boolean} dirty
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   */


  PrimitivesStack.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
    this._dirtiness[renderer.id] = dirty;
  };

  /**
   * Sets the dirtiness for all renderers
   * @param {Boolean} dirty
   */


  PrimitivesStack.prototype.setDirty = function setDirty(dirty) {
    for (var rendererId in this._dirtiness) {
      this._dirtiness[rendererId] = dirty;
    }
  };

  /**
   * Disposes the render textures, frees some memory
   */


  PrimitivesStack.prototype.disposeRenderTextures = function disposeRenderTextures() {
    for (var rendererId in this._renderTextures) {
      this._renderTextures[rendererId].dispose();
      delete this._renderTextures[rendererId];
    }
  };

  /**
   * Cleans up this instance
   */


  PrimitivesStack.prototype.dispose = function dispose() {
    this.disposeRenderTextures();
    this._stack.forEach(function (primitive) {
      return primitive.dispose();
    });
    this._stack = [];
    this._blendFilter.dispose();

    this._sprite.dispose();
  };

  return PrimitivesStack;
}();

exports.default = PrimitivesStack;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

var _constants = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BrightnessFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(BrightnessFilter, _Engine$Filter);

  function BrightnessFilter() {
    (0, _classCallCheck3.default)(this, BrightnessFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(242);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  BrightnessFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    var brightness = this._options.brightness;


    if (brightness === 0) {
      return;
    }
    brightness = brightness * 255;

    for (var i = 0; i < canvas.width * canvas.height; i++) {
      var index = i * 4;
      imageData.data[index] += brightness;
      imageData.data[index + 1] += brightness;
      imageData.data[index + 2] += brightness;
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return BrightnessFilter;
}(_globals.Engine.Filter);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

BrightnessFilter.prototype.availableOptions = {
  brightness: { type: _constants.OptionType.NUMBER, default: 0, uniformType: _constants.UniformType.FLOAT }
};

/**
 * Brightness primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var Brightness = function (_Primitive) {
  (0, _inherits3.default)(Brightness, _Primitive);

  function Brightness() {
    (0, _classCallCheck3.default)(this, Brightness);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new BrightnessFilter();
    return _this2;
  }

  /**
   * Updates the filter's uniforms
   */


  Brightness.prototype.update = function update() {
    this._filter.setBrightness(this._options.brightness);
  };

  return Brightness;
}(_primitive2.default);

/**
 * Specifies the available options for this primitive
 * @type {Object}
 * @ignore
 */


Brightness.prototype.availableOptions = BrightnessFilter.prototype.availableOptions;

exports.default = Brightness;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

var _colorMatrix = __webpack_require__(35);

var _colorMatrix2 = _interopRequireDefault(_colorMatrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType;

var ColorMatrixFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(ColorMatrixFilter, _Engine$Filter);

  function ColorMatrixFilter() {
    (0, _classCallCheck3.default)(this, ColorMatrixFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(243);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  ColorMatrixFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    var colormatrix = this._options.colormatrix;

    var color = new _color2.default(0, 0, 0, 0);

    for (var i = 0; i < canvas.width * canvas.height; i++) {
      var index = i * 4;
      color.r = imageData.data[index];
      color.g = imageData.data[index + 1];
      color.b = imageData.data[index + 2];
      color.a = imageData.data[index + 3];
      color = colormatrix.apply(color);
      imageData.data[index] = color.r;
      imageData.data[index + 1] = color.g;
      imageData.data[index + 2] = color.b;
      imageData.data[index + 3] = color.a;
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return ColorMatrixFilter;
}(_globals.Engine.Filter);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */


ColorMatrixFilter.prototype.availableOptions = {
  colormatrix: { type: OptionType.COLOR_MATRIX, default: new _colorMatrix2.default(), uniformType: UniformType.MAT4 }
};

/**
 * ColorMatrix primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var ColorMatrixPrimitive = function (_Primitive) {
  (0, _inherits3.default)(ColorMatrixPrimitive, _Primitive);

  function ColorMatrixPrimitive() {
    (0, _classCallCheck3.default)(this, ColorMatrixPrimitive);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new ColorMatrixFilter();
    return _this2;
  }

  /**
   * Updates the filter's uniforms
   */


  ColorMatrixPrimitive.prototype.update = function update() {
    this._filter.setColormatrix(this._options.colormatrix);
  };

  return ColorMatrixPrimitive;
}(_primitive2.default);

/**
 * Specifies the available options for this primitive
 * @type {Object}
 * @ignore
 */


ColorMatrixPrimitive.prototype.availableOptions = ColorMatrixFilter.prototype.availableOptions;

exports.default = ColorMatrixPrimitive;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType;

var ContrastFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(ContrastFilter, _Engine$Filter);

  function ContrastFilter() {
    (0, _classCallCheck3.default)(this, ContrastFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(244);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  ContrastFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    var contrast = this._options.contrast;

    if (contrast === 1) {
      return;
    }

    for (var i = 0; i < canvas.width * canvas.height; i++) {
      var index = i * 4;
      imageData.data[index] = (imageData.data[index] - 127) * contrast + 127;
      imageData.data[index + 1] = (imageData.data[index + 1] - 127) * contrast + 127;
      imageData.data[index + 2] = (imageData.data[index + 2] - 127) * contrast + 127;
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return ContrastFilter;
}(_globals.Engine.Filter);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */


ContrastFilter.prototype.availableOptions = {
  contrast: { type: OptionType.NUMBER, default: 1, uniformType: UniformType.FLOAT }
};

/**
 * Contrast primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var Contrast = function (_Primitive) {
  (0, _inherits3.default)(Contrast, _Primitive);

  function Contrast() {
    (0, _classCallCheck3.default)(this, Contrast);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new ContrastFilter();
    return _this2;
  }

  /**
   * Updates the filter's uniforms
   */


  Contrast.prototype.update = function update() {
    this._filter.setContrast(this._options.contrast);
  };

  return Contrast;
}(_primitive2.default);

/**
 * Specifies the available options for this primitive
 * @type {Object}
 * @ignore
 */


Contrast.prototype.availableOptions = ContrastFilter.prototype.availableOptions;

exports.default = Contrast;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

var _constants = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DesaturationFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(DesaturationFilter, _Engine$Filter);

  function DesaturationFilter() {
    (0, _classCallCheck3.default)(this, DesaturationFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(245);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  DesaturationFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    var desaturation = this._options.desaturation;


    for (var i = 0; i < canvas.width * canvas.height; i++) {
      var index = i * 4;
      var luminance = imageData.data[index] * 0.3 + imageData.data[index + 1] * 0.59 + imageData.data[index + 2] * 0.11;
      imageData.data[index] = luminance * (1 - desaturation) + imageData.data[index] * desaturation;
      imageData.data[index + 1] = luminance * (1 - desaturation) + imageData.data[index + 1] * desaturation;
      imageData.data[index + 2] = luminance * (1 - desaturation) + imageData.data[index + 2] * desaturation;
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return DesaturationFilter;
}(_engine2.default.Filter);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

DesaturationFilter.prototype.availableOptions = {
  desaturation: { type: _constants.OptionType.NUMBER, default: 1, uniformType: _constants.UniformType.FLOAT }
};

/**
 * Desaturation primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var Desaturation = function (_Primitive) {
  (0, _inherits3.default)(Desaturation, _Primitive);

  function Desaturation() {
    (0, _classCallCheck3.default)(this, Desaturation);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new DesaturationFilter();
    return _this2;
  }

  /**
   * Updates the filter's uniforms
   */


  Desaturation.prototype.update = function update() {
    this._filter.setDesaturation(this._options.desaturation);
  };

  return Desaturation;
}(_primitive2.default);

/**
 * Specifies the available options for this primitive
 * @type {Object}
 * @ignore
 */


Desaturation.prototype.availableOptions = DesaturationFilter.prototype.availableOptions;

exports.default = Desaturation;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType; /*
                                                  * This file is part of PhotoEditorSDK.
                                                  *
                                                  * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                  * All rights reserved.
                                                  *
                                                  * Redistribution and use in source and binary forms, without
                                                  * modification, are permitted provided that the following license agreement
                                                  * is approved and a legal/financial contract was signed by the user.
                                                  * The license agreement can be found under following link:
                                                  *
                                                  * https://www.photoeditorsdk.com/LICENSE.txt
                                                  */

var GammaFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(GammaFilter, _Engine$Filter);

  function GammaFilter() {
    (0, _classCallCheck3.default)(this, GammaFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(246);
    return _this;
  }

  /**
  * Applies this filter to the given inputTarget and renders it to
  * the given outputTarget using the CanvasRenderer
  * @param  {CanvasRenderer} renderer
  * @param  {RenderTarget} inputTarget
  * @param  {RenderTarget} outputTarget
  * @param  {Boolean} clear = false
  * @private
  */


  GammaFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    var gamma = this._options.gamma;
    // pre calculate lookup tables for each channel

    var gammaArrayRed = new Float32Array(256);
    for (var i = 0; i < 256; i++) {
      gammaArrayRed[i] = 255.0 * Math.pow(i / 255.0, gamma.r);
    }

    var gammaArrayGreen = new Float32Array(256);
    for (var _i = 0; _i < 256; _i++) {
      gammaArrayGreen[_i] = 255.0 * Math.pow(_i / 255.0, gamma.g);
    }

    var gammaArrayBlue = new Float32Array(256);
    for (var _i2 = 0; _i2 < 256; _i2++) {
      gammaArrayBlue[_i2] = 255.0 * Math.pow(_i2 / 255.0, gamma.b);
    }

    for (var _i3 = 0; _i3 < canvas.width * canvas.height; _i3++) {
      var index = _i3 * 4;
      imageData.data[index] = gammaArrayRed[imageData.data[index]];
      imageData.data[index + 1] = gammaArrayGreen[imageData.data[index + 1]];
      imageData.data[index + 2] = gammaArrayBlue[imageData.data[index + 2]];
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return GammaFilter;
}(_globals.Engine.Filter);

/**
* Specifies the available options for this filter
* @type {Object}
* @ignore
*/


GammaFilter.prototype.availableOptions = {
  gamma: { type: OptionType.COLOR, default: _color2.default.WHITE, uniformType: UniformType.FLOAT3 }
};

/**
* Gamma primitive
* @class
* @extends PhotoEditorSDK.Filters.Primitive
* @memberof PhotoEditorSDK.FilterPrimitives
*/

var Gamma = function (_Primitive) {
  (0, _inherits3.default)(Gamma, _Primitive);

  function Gamma() {
    (0, _classCallCheck3.default)(this, Gamma);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new GammaFilter();
    return _this2;
  }

  /**
  * Updates the filter's uniforms
  */


  Gamma.prototype.update = function update() {
    this._filter.setGamma(this._options.gamma);
  };

  return Gamma;
}(_primitive2.default);

/**
* Specifies the available options for this primitive
* @type {Object}
* @ignore
*/


Gamma.prototype.availableOptions = GammaFilter.prototype.availableOptions;

exports.default = Gamma;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType; /*
                                                   * This file is part of PhotoEditorSDK.
                                                   *
                                                   * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                   * All rights reserved.
                                                   *
                                                   * Redistribution and use in source and binary forms, without
                                                   * modification, are permitted provided that the following license agreement
                                                   * is approved and a legal/financial contract was signed by the user.
                                                   * The license agreement can be found under following link:
                                                   *
                                                   * https://www.photoeditorsdk.com/LICENSE.txt
                                                   */

var GlowFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(GlowFilter, _Engine$Filter);

  function GlowFilter() {
    (0, _classCallCheck3.default)(this, GlowFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(247);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  GlowFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    var color = this._options.color;


    var d;
    for (var x = 0; x < canvas.width; x++) {
      for (var y = 0; y < canvas.height; y++) {
        var index = (canvas.width * y + x) * 4;

        var x01 = x / canvas.width;
        var y01 = y / canvas.height;

        var nx = (x01 - 0.5) / 0.75;
        var ny = (y01 - 0.5) / 0.75;

        var scalarX = nx * nx;
        var scalarY = ny * ny;
        d = 1 - (scalarX + scalarY);
        d = Math.min(Math.max(d, 0.1), 1.0);

        imageData.data[index] = imageData.data[index] * (d * color.r);
        imageData.data[index + 1] = imageData.data[index + 1] * (d * color.g);
        imageData.data[index + 2] = imageData.data[index + 2] * (d * color.b);
        imageData.data[index + 3] = 255;
      }
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return GlowFilter;
}(_globals.Engine.Filter);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */


GlowFilter.prototype.availableOptions = {
  color: { type: OptionType.COLOR, default: _color2.default.WHITE, uniformType: UniformType.FLOAT3 }
};

/**
 * Glow primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var Glow = function (_Primitive) {
  (0, _inherits3.default)(Glow, _Primitive);

  function Glow() {
    (0, _classCallCheck3.default)(this, Glow);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new GlowFilter();
    return _this2;
  }

  /**
   * Updates the filter's uniforms
   */


  Glow.prototype.update = function update() {
    this._filter.setColor(this._options.color);
  };

  return Glow;
}(_primitive2.default);

/**
 * Specifies the available options for this primitive
 * @type {Object}
 * @ignore
 */


Glow.prototype.availableOptions = GlowFilter.prototype.availableOptions;

exports.default = Glow;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var GobblinFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(GobblinFilter, _Engine$Filter);

  function GobblinFilter() {
    (0, _classCallCheck3.default)(this, GobblinFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(248);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  GobblinFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    for (var x = 0; x < canvas.width; x++) {
      for (var y = 0; y < canvas.height; y++) {
        var index = (canvas.width * y + x) * 4;

        imageData.data[index + 2] = imageData.data[index + 1] * 0.33;
        imageData.data[index] = imageData.data[index] * 0.6;
        imageData.data[index + 2] += imageData.data[index] * 0.33;
        imageData.data[index + 1] = imageData.data[index + 1] * 0.7;
        imageData.data[index + 3] = 255;
      }
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return GobblinFilter;
}(_engine2.default.Filter);

/**
 * Gobblin primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */


var Gobblin = function (_Primitive) {
  (0, _inherits3.default)(Gobblin, _Primitive);

  function Gobblin() {
    (0, _classCallCheck3.default)(this, Gobblin);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new GobblinFilter();
    return _this2;
  }

  return Gobblin;
}(_primitive2.default);

exports.default = Gobblin;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var GrayscaleFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(GrayscaleFilter, _Engine$Filter);

  function GrayscaleFilter() {
    (0, _classCallCheck3.default)(this, GrayscaleFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(249);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  GrayscaleFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    for (var x = 0; x < canvas.width; x++) {
      for (var y = 0; y < canvas.height; y++) {
        var index = (canvas.width * y + x) * 4;

        var luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;

        imageData.data[index] = luminance;
        imageData.data[index + 1] = luminance;
        imageData.data[index + 2] = luminance;
      }
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return GrayscaleFilter;
}(_engine2.default.Filter);

/**
 * Grayscale primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */


var Grayscale = function (_Primitive) {
  (0, _inherits3.default)(Grayscale, _Primitive);

  function Grayscale() {
    (0, _classCallCheck3.default)(this, Grayscale);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new GrayscaleFilter();
    return _this2;
  }

  return Grayscale;
}(_primitive2.default);

exports.default = Grayscale;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

var _constants = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TEXTURE_GL_UNIT = 3;

var LookupTableImageFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(LookupTableImageFilter, _Engine$Filter);

  function LookupTableImageFilter() {
    (0, _classCallCheck3.default)(this, LookupTableImageFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._precomputeQuads();
    _this._fragmentSource = __webpack_require__(250);
    return _this;
  }

  /**
   * This function pre-calculates an array that holds quads for each
   * of the 256 possible values of the blue channel
   * @private
   */


  LookupTableImageFilter.prototype._precomputeQuads = function _precomputeQuads() {
    this._quads = [];
    for (var i = 0; i < 256; i++) {
      var blueColor = i / 255 * 63;
      var quad = new _globals.Vector2();

      quad.y = (blueColor | 0) * 0.125 | 0;
      quad.x = (blueColor | 0) - quad.y * 8;
      this._quads.push(quad);
    }
  };

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  LookupTableImageFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var lutImage = this._options.lookupTableImage;
    var lutCanvas = this._createImageCanvas(lutImage);
    var lutContext = lutCanvas.getContext('2d');

    var inputImageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
    var filterImageData = lutContext.getImageData(0, 0, lutImage.width, lutImage.height);

    var texCoord = new _globals.Vector2();
    for (var index = 0; index < canvas.width * canvas.height * 4; index += 4) {
      var r = inputImageData.data[index];
      var g = inputImageData.data[index + 1];
      var b = inputImageData.data[index + 2];
      var a = inputImageData.data[index + 3] / 255;
      var quad = this._quads[b];

      // 64 since we have 8x8 tiles on a 512x512 texture.
      var tileSideLength = 64;

      // calculate pixel position of the coordinate origin.
      texCoord.x = quad.x * tileSideLength;
      texCoord.y = quad.y * tileSideLength;

      // now lookup the correct color within the tile.
      // the position of the pixel is indicated by the vector,
      // induced by the combination of the red and green vector.
      texCoord.x += Math.floor(r / 4); // r / 256 * 64 = r / 4
      texCoord.y += Math.floor(g / 4); // g / 256 * 64 = r / 4

      var texCoordIndex = (lutImage.width * texCoord.y + texCoord.x) * 4 | 0;
      var newR = filterImageData.data[texCoordIndex];
      newR = r * (1 - a) + newR * a;
      var newG = filterImageData.data[texCoordIndex + 1];
      newG = g * (1 - a) + newG * a;
      var newB = filterImageData.data[texCoordIndex + 2];
      newB = b * (1 - a) + newB * a;
      inputImageData.data[index] = newR;
      inputImageData.data[index + 1] = newG;
      inputImageData.data[index + 2] = newB;
    }
    outputContext.putImageData(inputImageData, 0, 0);
  };

  /**
   * Creates a canvas with the given image
   * @param  {Image} image
   * @return {HTMLCanvasElement}
   * @private
   */


  LookupTableImageFilter.prototype._createImageCanvas = function _createImageCanvas(image) {
    var canvas = _globals.Utils.createCanvas();
    canvas.width = image.width;
    canvas.height = image.height;

    var context = canvas.getContext('2d');
    context.drawImage(image, 0, 0);

    return canvas;
  };

  return LookupTableImageFilter;
}(_engine2.default.Filter);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */


LookupTableImageFilter.prototype.availableOptions = {
  lookupTable: { type: _constants.OptionType.NUMBER, default: TEXTURE_GL_UNIT, uniformType: _constants.UniformType.INT },
  lookupTableImage: { type: _constants.OptionType.IMAGE, uniformType: null }
};

/**
 * Stores a 256 byte long lookup table in a 2d texture which will be
 * used to look up the corresponding value for each channel.
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var LookupTableImage = function (_Primitive) {
  (0, _inherits3.default)(LookupTableImage, _Primitive);

  function LookupTableImage() {
    (0, _classCallCheck3.default)(this, LookupTableImage);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new LookupTableImageFilter();
    _this2._textures = {};
    return _this2;
  }

  /**
   * Gets called before this primitive's filter is being applied
   * @param {PhotoEditorSDK} sdk
   */


  LookupTableImage.prototype.update = function update(sdk) {
    var renderer = sdk.getRenderer();
    /* istanbul ignore if */
    if (renderer.isOfType(_constants.RendererType.WEBGL)) {
      this._updateWebGLTexture(sdk);
    } else if (renderer.isOfType(_constants.RendererType.CANVAS)) {
      this._filter.setLookupTableImage(this._options.image);
    }
  };

  /**
   * Updates the lookup table texture (WebGL only)
   * @param {PhotoEditorSDK} sdk
   * @private
   */
  /* istanbul ignore next */


  LookupTableImage.prototype._updateWebGLTexture = function _updateWebGLTexture(sdk) {
    var renderer = sdk.getRenderer();
    var id = renderer.id;

    if (!this._textures[id]) {
      this._textures[id] = new _engine2.default.BaseTexture();
    }

    var texture = this._textures[id];
    texture.setSource(this._options.image);
    texture.setGLUnit(TEXTURE_GL_UNIT);

    renderer.updateTexture(texture);
  };

  /**
   * Cleans up this primitive
   */


  LookupTableImage.prototype.dispose = function dispose() {
    _Primitive.prototype.dispose.call(this);
    for (var id in this._textures) {
      delete this._textures[id];
    }
  };

  return LookupTableImage;
}(_primitive2.default);

LookupTableImage.prototype.availableOptions = {
  image: { type: _constants.OptionType.IMAGE }
};

exports.default = LookupTableImage;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType;

var SaturationFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(SaturationFilter, _Engine$Filter);

  function SaturationFilter() {
    (0, _classCallCheck3.default)(this, SaturationFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(252);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  SaturationFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
    var saturation = this._options.saturation;


    for (var x = 0; x < canvas.width; x++) {
      for (var y = 0; y < canvas.height; y++) {
        var index = (canvas.width * y + x) * 4;

        var luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
        imageData.data[index] = luminance * (1 - saturation) + imageData.data[index] * saturation;
        imageData.data[index + 1] = luminance * (1 - saturation) + imageData.data[index + 1] * saturation;
        imageData.data[index + 2] = luminance * (1 - saturation) + imageData.data[index + 2] * saturation;
      }
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return SaturationFilter;
}(_globals.Engine.Filter);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */


SaturationFilter.prototype.availableOptions = {
  saturation: { type: OptionType.NUMBER, default: 0, uniformType: UniformType.FLOAT }
};

/**
 * Saturation primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var Saturation = function (_Primitive) {
  (0, _inherits3.default)(Saturation, _Primitive);

  function Saturation() {
    (0, _classCallCheck3.default)(this, Saturation);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new SaturationFilter();
    return _this2;
  }

  /**
   * Updates the filter's uniforms
   */


  Saturation.prototype.update = function update() {
    this._filter.setSaturation(this._options.saturation);
  };

  return Saturation;
}(_primitive2.default);

/**
 * Specifies the available options for this primitive
 * @type {Object}
 * @ignore
 */


Saturation.prototype.availableOptions = SaturationFilter.prototype.availableOptions;

exports.default = Saturation;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType; /*
                                                   * This file is part of PhotoEditorSDK.
                                                   *
                                                   * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                   * All rights reserved.
                                                   *
                                                   * Redistribution and use in source and binary forms, without
                                                   * modification, are permitted provided that the following license agreement
                                                   * is approved and a legal/financial contract was signed by the user.
                                                   * The license agreement can be found under following link:
                                                   *
                                                   * https://www.photoeditorsdk.com/LICENSE.txt
                                                   */

var SoftColorOverlayFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(SoftColorOverlayFilter, _Engine$Filter);

  function SoftColorOverlayFilter() {
    (0, _classCallCheck3.default)(this, SoftColorOverlayFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(253);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  SoftColorOverlayFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    for (var x = 0; x < canvas.width; x++) {
      for (var y = 0; y < canvas.height; y++) {
        var index = (canvas.width * y + x) * 4;

        imageData.data[index] = Math.max(this._options.color.r * 255, imageData.data[index]);
        imageData.data[index + 1] = Math.max(this._options.color.g * 255, imageData.data[index + 1]);
        imageData.data[index + 2] = Math.max(this._options.color.b * 255, imageData.data[index + 2]);
      }
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return SoftColorOverlayFilter;
}(_globals.Engine.Filter);

/**
 * Specifies the available options for this filter
 * @type {Object}
 * @ignore
 */


SoftColorOverlayFilter.prototype.availableOptions = {
  color: { type: OptionType.COLOR, default: _color2.default.WHITE, uniformType: UniformType.FLOAT3 }
};

/**
 * SoftColorOverlay primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var SoftColorOverlay = function (_Primitive) {
  (0, _inherits3.default)(SoftColorOverlay, _Primitive);

  function SoftColorOverlay() {
    (0, _classCallCheck3.default)(this, SoftColorOverlay);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new SoftColorOverlayFilter();
    return _this2;
  }

  /**
   * Updates the filter's uniforms
   */


  SoftColorOverlay.prototype.update = function update() {
    this._filter.setColor(this._options.color);
  };

  return SoftColorOverlay;
}(_primitive2.default);

/**
 * Specifies the available options for this primitive
 * @type {Object}
 * @ignore
 */


SoftColorOverlay.prototype.availableOptions = SoftColorOverlayFilter.prototype.availableOptions;

exports.default = SoftColorOverlay;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _lookupTable = __webpack_require__(83);

var _lookupTable2 = _interopRequireDefault(_lookupTable);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType;

/**
 * Tone curve primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitives.LookupTable
 * @memberof PhotoEditorSDK.FilterPrimitives
 */

var ToneCurve = function (_LookupTable) {
  (0, _inherits3.default)(ToneCurve, _LookupTable);

  function ToneCurve() {
    (0, _classCallCheck3.default)(this, ToneCurve);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _LookupTable.call.apply(_LookupTable, [this].concat(args)));

    if (!_this._options.rgbControlPoints) {
      _this._options.rgbControlPoints = {
        red: _this._options.controlPoints,
        green: _this._options.controlPoints,
        blue: _this._options.controlPoints
      };
    }

    _this._updateLookupTable();
    return _this;
  }

  /**
   * Calculates the lookup table
   * @private
   */


  ToneCurve.prototype._updateLookupTable = function _updateLookupTable() {
    var r = this._calculateSplineCurve(this._options.rgbControlPoints.red);
    var g = this._calculateSplineCurve(this._options.rgbControlPoints.green);
    var b = this._calculateSplineCurve(this._options.rgbControlPoints.blue);

    this._options.data = this._buildLookupTable(r, g, b);
  };

  /**
   * Builds the lookup table
   * @param  {Array} r
   * @param  {Array} g
   * @param  {Array} b
   * @return {Array}
   * @private
   */


  ToneCurve.prototype._buildLookupTable = function _buildLookupTable(r, g, b) {
    var data = [];

    for (var i = 0; i < 256; i++) {
      data.push(Math.min(Math.max(i + r[i], 0), 255));
      data.push(Math.min(Math.max(i + g[i], 0), 255));
      data.push(Math.min(Math.max(i + b[i], 0), 255));
      data.push(255);
    }

    return data;
  };

  /**
   * Calculates the spline curve data for the given points
   * @param  {Array.<Array.<Number>>} points
   * @return {Array.<Number>}
   */


  ToneCurve.prototype._calculateSplineCurve = function _calculateSplineCurve(points) {
    points = points.sort(function (a, b) {
      return a[0] > b[0];
    });

    var splinePoints = this._getSplineCurve(points);
    var firstSplinePoint = splinePoints[0];
    var i;

    if (firstSplinePoint[0] > 0) {
      for (i = 0; i < firstSplinePoint[0]; i++) {
        splinePoints.unshift([0, 0]);
      }
    }

    var preparedPoints = [];
    for (i = 0; i < splinePoints.length; i++) {
      var newPoint = splinePoints[i];
      var origPoint = [newPoint[0], newPoint[0]];

      var distance = Math.sqrt(Math.pow(origPoint[0] - newPoint[0], 2) + Math.pow(origPoint[1] - newPoint[1], 2));

      if (origPoint[1] > newPoint[1]) {
        distance = -distance;
      }

      preparedPoints.push(distance);
    }

    return preparedPoints;
  };

  ToneCurve.prototype._getSplineCurve = function _getSplineCurve(points) {
    var sdA = this._secondDerivative(points);

    var n = sdA.length;
    var sd = [];
    var i;

    for (i = 0; i < n; i++) {
      sd[i] = sdA[i];
    }

    var output = [];

    for (i = 0; i < n - 1; i++) {
      var cur = points[i];
      var next = points[i + 1];

      for (var x = cur[0]; x < next[0]; x++) {
        var t = (x - cur[0]) / (next[0] - cur[0]);

        var a = 1 - t;
        var b = t;
        var h = next[0] - cur[0];

        var y = a * cur[1] + b * next[1] + h * h / 6 * ((a * a * a - a) * sd[i] + (b * b * b - b) * sd[i + 1]);

        if (y > 255) {
          y = 255;
        } else if (y < 0) {
          y = 0;
        }

        output.push([x, y]);
      }
    }

    if (output.length === 255) {
      output.push(points[points.length - 1]);
    }

    return output;
  };

  ToneCurve.prototype._secondDerivative = function _secondDerivative(points) {
    var n = points.length;
    if (n <= 0 || n === 1) {
      return null;
    }

    var matrix = [];
    var result = [];
    var i, k;

    matrix[0] = [0, 1, 0];

    for (i = 1; i < n - 1; i++) {
      var P1 = points[i - 1];
      var P2 = points[i];
      var P3 = points[i + 1];

      matrix[i] = matrix[i] || [];
      matrix[i][0] = (P2[0] - P1[0]) / 6;
      matrix[i][1] = (P3[0] - P1[0]) / 3;
      matrix[i][2] = (P3[0] - P2[0]) / 6;
      result[i] = (P3[1] - P2[1]) / (P3[0] - P2[0]) - (P2[1] - P1[1]) / (P2[0] - P1[0]);
    }

    result[0] = 0;
    result[n - 1] = 0;

    matrix[n - 1] = [0, 1, 0];

    // Pass 1
    for (i = 1; i < n; i++) {
      k = matrix[1][0] / matrix[i - 1][1];
      matrix[i][1] -= k * matrix[i - 1][2];
      matrix[i][0] = 0;
      result[i] -= k * result[i - 1];
    }

    // Pass 2
    for (i = n - 2; i > 0; i--) {
      k = matrix[i][2] / matrix[i + 1][1];
      matrix[i][1] -= k * matrix[i + 1][0];
      matrix[i][2] = 0;
      result[i] -= k * result[i + 1];
    }

    var y2 = [];
    for (i = 0; i < n; i++) {
      y2[i] = result[i] / matrix[i][1];
    }

    return y2;
  };

  return ToneCurve;
}(_lookupTable2.default);

/**
 * Specifies the available options for this primitive
 * @type {Object}
 * @ignore
 */


ToneCurve.prototype.availableOptions = {
  rgbControlPoints: { type: OptionType.OBJECT },
  controlPoints: { type: OptionType.ARRAY, default: [] }
};

exports.default = ToneCurve;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _primitive = __webpack_require__(8);

var _primitive2 = _interopRequireDefault(_primitive);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var X400Filter = function (_Engine$Filter) {
  (0, _inherits3.default)(X400Filter, _Engine$Filter);

  function X400Filter() {
    (0, _classCallCheck3.default)(this, X400Filter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(254);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  X400Filter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var canvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);

    for (var x = 0; x < canvas.width; x++) {
      for (var y = 0; y < canvas.height; y++) {
        var index = (canvas.width * y + x) * 4;

        var gray = imageData.data[index] / 255 * 0.3 + imageData.data[index + 1] / 255 * 0.3 + imageData.data[index + 2] / 255 * 0.3;
        gray -= 0.2;
        gray = Math.max(0.0, Math.min(1.0, gray));
        gray += 0.15;
        gray *= 1.4;

        gray *= 255;
        imageData.data[index] = gray;
        imageData.data[index + 1] = gray;
        imageData.data[index + 2] = gray;
      }
    }

    outputContext.putImageData(imageData, 0, 0);
  };

  return X400Filter;
}(_engine2.default.Filter);

/**
 * X400 primitive
 * @class
 * @extends PhotoEditorSDK.Filters.Primitive
 * @memberof PhotoEditorSDK.FilterPrimitives
 */


var X400 = function (_Primitive) {
  (0, _inherits3.default)(X400, _Primitive);

  function X400() {
    (0, _classCallCheck3.default)(this, X400);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));

    _this2._filter = new X400Filter();
    return _this2;
  }

  return X400;
}(_primitive2.default);

exports.default = X400;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Quozi Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var QuoziFilter = function (_Filter) {
  (0, _inherits3.default)(QuoziFilter, _Filter);

  function QuoziFilter() {
    (0, _classCallCheck3.default)(this, QuoziFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // Desaturation
    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.Desaturation({
      desaturation: 0.65
    }));

    // Tone curve
    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 50], [40, 78], [118, 170], [181, 211], [255, 255]],
        green: [[0, 27], [28, 45], [109, 157], [157, 195], [179, 208], [206, 212], [255, 240]],
        blue: [[0, 50], [12, 55], [46, 103], [103, 162], [194, 182], [241, 201], [255, 219]]
      }
    }));
    return _this;
  }

  return QuoziFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


QuoziFilter.identifier = 'quozi';

QuoziFilter.displayName = 'Quozi';

exports.default = QuoziFilter;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Semired Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SemiredFilter = function (_Filter) {
  (0, _inherits3.default)(SemiredFilter, _Filter);

  function SemiredFilter() {
    (0, _classCallCheck3.default)(this, SemiredFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 129], [75, 153], [181, 227], [255, 255]],
        green: [[0, 8], [111, 85], [212, 158], [255, 226]],
        blue: [[0, 5], [75, 22], [193, 90], [255, 229]]
      }
    }));

    _this._stack.push(new FilterPrimitives.Glow());
    return _this;
  }

  return SemiredFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


SemiredFilter.identifier = 'semired';

SemiredFilter.displayName = 'Semired';

exports.default = SemiredFilter;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sunny Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var SunnyFilter = function (_Filter) {
  (0, _inherits3.default)(SunnyFilter, _Filter);

  function SunnyFilter() {
    (0, _classCallCheck3.default)(this, SunnyFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 0], [62, 82], [141, 154], [255, 255]],
        green: [[0, 39], [56, 96], [192, 176], [255, 255]],
        blue: [[0, 0], [174, 99], [255, 235]]
      }
    }));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      controlPoints: [[0, 0], [55, 20], [158, 191], [255, 255]]
    }));
    return _this;
  }

  return SunnyFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


SunnyFilter.identifier = 'sunny';

SunnyFilter.displayName = 'Sunny';

exports.default = SunnyFilter;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Texas Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TexasFilter = function (_Filter) {
  (0, _inherits3.default)(TexasFilter, _Filter);

  function TexasFilter() {
    (0, _classCallCheck3.default)(this, TexasFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.ToneCurve({
      rgbControlPoints: {
        red: [[0, 72], [89, 99], [176, 212], [255, 237]],
        green: [[0, 49], [255, 192]],
        blue: [[0, 72], [255, 151]]
      }
    }));
    return _this;
  }

  return TexasFilter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


TexasFilter.identifier = 'texas';

TexasFilter.displayName = 'Texas';

exports.default = TexasFilter;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * X400 Filter
 * @class
 * @extends PhotoEditorSDK.Filter
 * @memberof PhotoEditorSDK.Filters
 */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var X400Filter = function (_Filter) {
  (0, _inherits3.default)(X400Filter, _Filter);

  function X400Filter() {
    (0, _classCallCheck3.default)(this, X400Filter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));

    _this._stack.push(new FilterPrimitives.X400());
    return _this;
  }

  return X400Filter;
}(_filter2.default);

/**
 * This filter's identifier
 * @type {String}
 * @default
 */


X400Filter.identifier = 'x400';

X400Filter.displayName = 'X400';

exports.default = X400Filter;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _stackBlur = __webpack_require__(37);

var _stackBlur2 = _interopRequireDefault(_stackBlur);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType; /*
                                                   * This file is part of PhotoEditorSDK.
                                                   *
                                                   * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                   * All rights reserved.
                                                   *
                                                   * Redistribution and use in source and binary forms, without
                                                   * modification, are permitted provided that the following license agreement
                                                   * is approved and a legal/financial contract was signed by the user.
                                                   * The license agreement can be found under following link:
                                                   *
                                                   * https://www.photoeditorsdk.com/LICENSE.txt
                                                   */

var LinearFocusFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(LinearFocusFilter, _Engine$Filter);

  function LinearFocusFilter() {
    (0, _classCallCheck3.default)(this, LinearFocusFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call.apply(_Engine$Filter, [this].concat(args)));

    _this._fragmentSource = __webpack_require__(235);

    _this._lastBlurRadius = null;
    _this._lastGradientRadius = null;
    _this._lastStart = new _globals.Vector2();
    _this._lastEnd = new _globals.Vector2();

    _this._blurredRenderTarget = new _globals.Engine.CanvasRenderTarget(100, 100, 1);

    _this._maskRenderTarget = new _globals.Engine.CanvasRenderTarget(100, 100, 1);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  LinearFocusFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var inputDimensions = inputTarget.getDimensions();
    var dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);

    this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());

    this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._maskRenderTarget.resizeTo(inputTarget.getDimensions());

    if (!this._outputRenderTexture) {
      this._outputRenderTexture = new _globals.Engine.RenderTexture(renderer, inputTarget.getWidth(), inputTarget.getHeight(), inputTarget.getPixelRatio());
    }

    if (!this._lastStart.equals(this._options.start) || !this._lastEnd.equals(this._options.end) || this._lastGradientRadius !== this._options.size || dimensionsChanged) {
      this._renderMask();

      this._lastStart = this._options.start.clone();
      this._lastEnd = this._options.end.clone();
      this._lastGradientRadius = this._options.size;
    }

    if (this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged) {
      this._blurImage(inputTarget);
      this._lastBlurRadius = this._options.blurRadius;
    }

    this._applyMask(inputTarget, outputTarget);
  };

  /**
   * Creates a blurred copy of the image
   * @param  {CanvasRenderTarget} inputTarget
   * @return {Canvas}
   * @private
   */


  LinearFocusFilter.prototype._blurImage = function _blurImage(inputTarget) {
    var inputCanvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();

    var inputDimensions = new _globals.Vector2(inputCanvas.width, inputCanvas.height);
    var blurryImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    _stackBlur2.default.stackBlurCanvasRGBA(blurryImageData, 0, 0, inputCanvas.width, inputCanvas.height, this._options.blurRadius * inputDimensions.min());

    var blurryContext = this._blurredRenderTarget.getContext();
    blurryContext.putImageData(blurryImageData, 0, 0);
  };

  /**
   * Renders the mask canvas
   * @private
   */


  LinearFocusFilter.prototype._renderMask = function _renderMask() {
    var canvas = this._maskRenderTarget.getCanvas();
    var context = this._maskRenderTarget.getContext();
    var pixelRatio = this._maskRenderTarget.getPixelRatio();

    var canvasDimensions = new _globals.Vector2(canvas.width, canvas.height);

    var size = this._options.size * canvasDimensions.min() * pixelRatio;
    var gradientSize = this._options.gradientSize * canvasDimensions.min() * pixelRatio;
    var start = this._options.start.clone().multiply(canvasDimensions);
    var end = this._options.end.clone().multiply(canvasDimensions);
    var dist = end.clone().subtract(start);
    var middle = start.clone().add(dist.clone().divide(2));

    var totalDist = dist.len();
    var factor = dist.clone().divide(totalDist);

    var gradientStart = middle.clone().add((size + gradientSize) * factor.y, -(size + gradientSize) * factor.x);
    var gradientEnd = middle.clone().add(-(size + gradientSize) * factor.y, (size + gradientSize) * factor.x);

    // Build gradient
    var gradient = context.createLinearGradient(gradientStart.x, gradientStart.y, gradientEnd.x, gradientEnd.y);
    var fullGradientSize = gradientEnd.clone().subtract(gradientStart).len();
    gradient.addColorStop(0, '#000000');
    gradient.addColorStop(gradientSize / 2 / fullGradientSize, '#FFFFFF');
    gradient.addColorStop(1.0 - gradientSize / 2 / fullGradientSize, '#FFFFFF');
    gradient.addColorStop(1, '#000000');

    // Draw gradient
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas.width, canvas.height);
  };

  /**
   * Applies the blur and mask to the input canvas
   * @param {CanvasRenderTarget} inputTarget
   * @param {CanvasRenderTarget} outputTarget
   * @private
   */


  LinearFocusFilter.prototype._applyMask = function _applyMask(inputTarget, outputTarget) {
    var outputContext = outputTarget.getContext();
    var inputCanvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var blurredContext = this._blurredRenderTarget.getContext();
    var maskContext = this._maskRenderTarget.getContext();

    var inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    var pixels = inputImageData.data;
    var blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    var maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;

    var alpha = void 0;
    for (var i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
      alpha = maskPixels[i] / 255;

      pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
      pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
      pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
    }

    outputContext.putImageData(inputImageData, 0, 0);
  };

  return LinearFocusFilter;
}(_globals.Engine.Filter);

LinearFocusFilter.prototype.availableOptions = {
  blurRadius: { type: OptionType.NUMBER, default: 30, uniformType: UniformType.FLOAT },
  size: { type: OptionType.NUMBER, default: 50, uniformType: UniformType.FLOAT },
  gradientSize: { type: OptionType.NUMBER, default: 50, uniformType: UniformType.FLOAT },
  start: { type: OptionType.VECTOR2, default: new _globals.Vector2(0, 0.5), uniformType: UniformType.FLOAT2 },
  end: { type: OptionType.VECTOR2, default: new _globals.Vector2(1, 0.5), uniformType: UniformType.FLOAT2 },
  delta: { type: OptionType.VECTOR2, default: new _globals.Vector2(1, 1), uniformType: UniformType.FLOAT2 },
  texSize: { type: OptionType.VECTOR2, default: new _globals.Vector2(100, 100), uniformType: UniformType.FLOAT2 }
};

exports.default = LinearFocusFilter;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _stackBlur = __webpack_require__(37);

var _stackBlur2 = _interopRequireDefault(_stackBlur);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UniformType = _globals.Constants.UniformType,
    OptionType = _globals.Constants.OptionType; /*
                                                 * This file is part of PhotoEditorSDK.
                                                 *
                                                 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                 * All rights reserved.
                                                 *
                                                 * Redistribution and use in source and binary forms, without
                                                 * modification, are permitted provided that the following license agreement
                                                 * is approved and a legal/financial contract was signed by the user.
                                                 * The license agreement can be found under following link:
                                                 *
                                                 * https://www.photoeditorsdk.com/LICENSE.txt
                                                 */

var RadialFocusFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(RadialFocusFilter, _Engine$Filter);

  function RadialFocusFilter() {
    (0, _classCallCheck3.default)(this, RadialFocusFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call.apply(_Engine$Filter, [this].concat(args)));

    _this._fragmentSource = __webpack_require__(236);

    _this._lastBlurRadius = null;
    _this._lastGradientRadius = null;
    _this._lastPosition = new _globals.Vector2();

    _this._blurredRenderTarget = new _globals.Engine.CanvasRenderTarget(100, 100, 1);

    _this._maskRenderTarget = new _globals.Engine.CanvasRenderTarget(100, 100, 1);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  RadialFocusFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var inputDimensions = inputTarget.getDimensions();
    var dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);

    this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());

    this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._maskRenderTarget.resizeTo(inputTarget.getDimensions());

    if (!this._outputRenderTexture) {
      this._outputRenderTexture = new _globals.Engine.RenderTexture(renderer, inputTarget.getWidth(), inputTarget.getHeight(), inputTarget.getPixelRatio());
    }

    if (!this._lastPosition.equals(this._options.position) || this._lastGradientRadius !== this._options.gradientRadius || dimensionsChanged) {
      this._renderMask();

      this._lastPosition = this._options.position.clone();
      this._lastGradientRadius = this._options.gradientRadius;
    }

    if (this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged) {
      this._blurImage(inputTarget);
      this._lastBlurRadius = this._options.blurRadius;
    }

    this._applyMask(inputTarget, outputTarget);
  };

  /**
   * Creates a blurred copy of the image
   * @param  {CanvasRenderTarget} inputTarget
   * @return {Canvas}
   * @private
   */


  RadialFocusFilter.prototype._blurImage = function _blurImage(inputTarget) {
    var inputCanvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();

    var inputDimensions = new _globals.Vector2(inputCanvas.width, inputCanvas.height);
    var blurryImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    _stackBlur2.default.stackBlurCanvasRGBA(blurryImageData, 0, 0, inputCanvas.width, inputCanvas.height, this._options.blurRadius * inputDimensions.min());

    var blurryContext = this._blurredRenderTarget.getContext();
    blurryContext.putImageData(blurryImageData, 0, 0);
  };

  /**
   * Renders the mask canvas
   * @private
   */


  RadialFocusFilter.prototype._renderMask = function _renderMask() {
    var canvas = this._maskRenderTarget.getCanvas();
    var context = this._maskRenderTarget.getContext();

    var canvasDimensions = new _globals.Vector2(canvas.width, canvas.height);
    var pixelRatio = this._maskRenderTarget.getPixelRatio();
    var position = this._options.position.clone().multiply(canvasDimensions);

    var _options = this._options,
        radius = _options.radius,
        gradientRadius = _options.gradientRadius;

    radius *= canvas.height;
    gradientRadius *= canvas.height;

    // Build gradient
    var gradient = context.createRadialGradient(position.x, position.y, 0, position.x, position.y, (radius + gradientRadius) * pixelRatio);
    gradient.addColorStop(0, '#FFFFFF');
    gradient.addColorStop(radius / (radius + gradientRadius), '#FFFFFF');
    gradient.addColorStop(1, '#000000');

    // Draw gradient
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvasDimensions.x, canvasDimensions.y);
  };

  /**
   * Applies the blur and mask to the input canvas
   * @param {CanvasRenderTarget} inputTarget
   * @param {CanvasRenderTarget} outputTarget
   * @private
   */


  RadialFocusFilter.prototype._applyMask = function _applyMask(inputTarget, outputTarget) {
    var outputContext = outputTarget.getContext();
    var inputCanvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();
    var blurredContext = this._blurredRenderTarget.getContext();
    var maskContext = this._maskRenderTarget.getContext();

    var inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    var pixels = inputImageData.data;
    var blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    var maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;

    var alpha = void 0;
    for (var i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
      alpha = maskPixels[i] / 255;

      pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
      pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
      pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
    }

    outputContext.putImageData(inputImageData, 0, 0);
  };

  return RadialFocusFilter;
}(_globals.Engine.Filter);

RadialFocusFilter.prototype.availableOptions = {
  blurRadius: { type: OptionType.NUMBER, default: 30, uniformType: UniformType.FLOAT },
  radius: { type: OptionType.NUMBER, default: 50, uniformType: UniformType.FLOAT },
  gradientRadius: { type: OptionType.NUMBER, default: 25, uniformType: UniformType.FLOAT },
  position: { type: OptionType.VECTOR2, default: new _globals.Vector2(0.5, 0.5), uniformType: UniformType.FLOAT2 },
  delta: { type: OptionType.VECTOR2, default: new _globals.Vector2(1, 1), uniformType: UniformType.FLOAT2 },
  texSize: { type: OptionType.VECTOR2, default: new _globals.Vector2(100, 100), uniformType: UniformType.FLOAT2 }
};

exports.default = RadialFocusFilter;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(24);

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global HTMLImageElement */
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType,
    RendererType = _globals.Constants.RendererType;


var Image = void 0;
if (true) {
  Image = window.Image;
}

/**
 * An operation that can draw a frame around the image
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */

var FrameOperation = function (_Operation) {
  (0, _inherits3.default)(FrameOperation, _Operation);

  /**
   * Creates a new FrameOperation
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} [options]
   */
  function FrameOperation() {
    (0, _classCallCheck3.default)(this, FrameOperation);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));

    _this._colorOverlayFilter = new _globals.Engine.Filters.ColorOverlayFilter({
      color: _this.getTintColor()
    });

    _this._frameContainer = new _globals.Engine.Container();

    _this._resetSprites();
    if (_this._options.frame) {
      _this._createSpritesForFrame(_this._options.frame);
    }
    return _this;
  }

  /**
   * Resets the spriteGroups and sprites attributes
   * @private
   */


  FrameOperation.prototype._resetSprites = function _resetSprites() {
    this._spriteGroups = {
      top: {},
      left: {},
      right: {},
      bottom: {}
    };
    this._sprites = [];
    this._repeatSprites = {
      top: [],
      left: [],
      right: [],
      bottom: []
    };
  };

  /**
   * Creates the sprites and image groups for the given frame object
   * @param  {Object} frame
   * @private
   */


  FrameOperation.prototype._createSpritesForFrame = function _createSpritesForFrame(frame) {
    var _this2 = this;

    if (!frame) return this._disposeSprites();

    var imageGroups = frame.imageGroups,
        layoutMode = frame.layoutMode;

    this._layoutMode = layoutMode || 'horizontal-inside';

    this._disposeSprites();

    ['top', 'left', 'right', 'bottom'].forEach(function (group) {
      if (typeof imageGroups[group] === 'undefined') return;

      ['start', 'mid', 'end'].forEach(function (part) {
        if (typeof imageGroups[group][part] === 'undefined') return;

        // In case object is passed, pick attributes
        var image = imageGroups[group][part];
        if ('image' in image) {
          image = image.image;
        }

        // Create texture and sprites
        var texture = _globals.Engine.Texture.fromImage(image);
        var sprite = new _globals.Engine.Sprite(texture);
        _this2._spriteGroups[group][part] = sprite;
        _this2._sprites.push(sprite);
        _this2._frameContainer.addChild(sprite);
      });
    });
  };

  /**
   * Renders the frame operation
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @private
   */


  FrameOperation.prototype._render = function _render(inputTexture) {
    var dimensions = this._renderTexture.getDimensions();

    // Create and position sprites
    if (this._options.frame) {
      this._colorOverlayFilter.setColor(this.getTintColor());
      this._updateSprites(inputTexture);
    }

    // Prepare render texture for frame
    if (!this._frameRenderTexture) {
      this._frameRenderTexture = new _globals.Engine.RenderTexture(this._sdk.getRenderer(), dimensions.x, dimensions.y);
      this._frameSprite = new _globals.Engine.Sprite(this._frameRenderTexture);
      this._container.addChild(this._frameSprite);
    } else {
      this._frameRenderTexture.resizeTo(dimensions);
    }

    // Handle tinting
    var isWebGL = this._sdk.getRenderer().isOfType(RendererType.WEBGL);
    if (isWebGL) {
      if (this._options.frame && this._options.frame.tintable) {
        this._frameSprite.setFilters([this._colorOverlayFilter]);
      } else {
        this._frameSprite.setFilters([]);
      }
    }

    // Render frame
    this._frameRenderTexture.clear();
    this._frameRenderTexture.render(this._frameContainer);

    // Render everything
    this._renderTexture.render(this._container);
    return _globals.Promise.resolve(this._renderTexture);
  };

  /**
   * Updates the sprite positions and scalings
   * @param {PhotoEditorSDK.Engine.Texture} inputTexture
   * @private
   */


  FrameOperation.prototype._updateSprites = function _updateSprites(inputTexture) {
    var dimensions = inputTexture.getDimensions();
    this._frameWidth = Math.ceil(inputTexture.getDimensions().min() * this._options.scale);

    this._updateHorizontalSpriteGroup(inputTexture, 'top', 0);
    this._updateHorizontalSpriteGroup(inputTexture, 'bottom', dimensions.y - this._frameWidth);
    this._updateVerticalSpriteGroup(inputTexture, 'left', 0);
    this._updateVerticalSpriteGroup(inputTexture, 'right', dimensions.x - this._frameWidth);
  };

  /**
   * Updates the sprite positions and scale for the given horizontal sprite group
   * @param {PhotoEditorSDK.Engine.Texture} inputTexture
   * @param {String} group
   * @param {Number} offset = 0
   * @private
   */


  FrameOperation.prototype._updateHorizontalSpriteGroup = function _updateHorizontalSpriteGroup(inputTexture, group) {
    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var dimensions = inputTexture.getDimensions();
    var horizontalInside = this._layoutMode === 'horizontal-inside';

    var startSprite = this._spriteGroups[group].start;
    var midSprite = this._spriteGroups[group].mid;
    var endSprite = this._spriteGroups[group].end;

    var startWidth = 0;
    var endWidth = 0;

    var textureDimensions = void 0,
        textureRatio = void 0;
    if (startSprite) {
      textureDimensions = startSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;

      startWidth = Math.floor(this._frameWidth / textureRatio);

      var startPosition = new _globals.Vector2(0, offset);
      startPosition.x = horizontalInside ? this._frameWidth : 0;

      startSprite.setPosition(startPosition);
      startSprite.setHeight(this._frameWidth);
      startSprite.setWidth(startWidth);
    }

    if (endSprite) {
      textureDimensions = endSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;

      endWidth = Math.floor(this._frameWidth * textureRatio);

      var endPosition = new _globals.Vector2(dimensions.x - endWidth, offset);
      endPosition.x -= horizontalInside ? this._frameWidth : 0;

      endSprite.setPosition(endPosition);
      endSprite.setHeight(this._frameWidth);
      endSprite.setWidth(endWidth);
    }

    if (midSprite) {
      textureDimensions = midSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;

      var midPosition = new _globals.Vector2(startWidth, offset);
      var midWidth = dimensions.x - startWidth - endWidth;

      if (horizontalInside) {
        midPosition.x += this._frameWidth;
        midWidth -= this._frameWidth * 2;
      }

      midSprite.setPosition(midPosition);
      midSprite.setWidth(midWidth);
      midSprite.setHeight(this._frameWidth);

      // Handle repeat
      if (this._options.frame.imageGroups[group].mid.mode === 'repeat') {
        // Make sure we have exactly the right amount of sprites we need
        var defaultSpriteWidth = this._frameWidth / textureRatio;
        var requiredRepeatSprites = Math.ceil(midWidth / defaultSpriteWidth);
        var consumedWidth = 0;

        if (requiredRepeatSprites !== -1) {
          var spriteWidth = Math.round(midWidth / requiredRepeatSprites);
          midSprite.setWidth(spriteWidth);
          consumedWidth += spriteWidth;

          this._ensureRepeatSpritesExist(requiredRepeatSprites - 1, group, midSprite);

          // Reposition all repeat sprites
          for (var i = 0; i < requiredRepeatSprites - 1; i++) {
            // Divide the remaining height by the remaining amount of sprites to be placed
            spriteWidth = Math.round((midWidth - consumedWidth) / (requiredRepeatSprites - i - 1));

            var sprite = this._repeatSprites[group][i];
            var spritePosition = midPosition.clone().add(consumedWidth, 0).floor();
            sprite.setPosition(spritePosition);
            sprite.setWidth(spriteWidth);
            sprite.setHeight(this._frameWidth);

            consumedWidth += spriteWidth;
          }
        }
      }
    }
  };

  FrameOperation.prototype._ensureRepeatSpritesExist = function _ensureRepeatSpritesExist(requiredSpritesCount, group, sourceSprite) {
    var _this3 = this;

    // Make sure we don't get an EventEmitter warning
    sourceSprite.getTexture().setMaxListeners(requiredSpritesCount + 1);

    var existingSpritesCount = this._repeatSprites[group].length;
    if (requiredSpritesCount > existingSpritesCount) {
      // We need more sprites
      var missingRepeatSprites = requiredSpritesCount - existingSpritesCount;
      for (var i = 0; i < missingRepeatSprites; i++) {
        var sprite = new _globals.Engine.Sprite(sourceSprite.getTexture());
        this._repeatSprites[group].push(sprite);
        this._frameContainer.addChild(sprite);
        this._sprites.push(sprite);
      }
    } else if (requiredSpritesCount < existingSpritesCount) {
      // We need less sprites
      var spareRepeatSprites = this._repeatSprites[group].splice(requiredSpritesCount);
      spareRepeatSprites.forEach(function (sprite) {
        var index = _this3._sprites.indexOf(sprite);
        if (index === -1) return;

        _this3._sprites.splice(index, 1);
        _this3._frameContainer.removeChild(sprite);
        sprite.dispose();
      });
    }
  };

  /**
   * Updates the sprite positions and scale for given vertical column
   * @param {PhotoEditorSDK.Engine.Texture} inputTexture
   * @param {String} group
   * @param {Number} offset = 0
   * @private
   */


  FrameOperation.prototype._updateVerticalSpriteGroup = function _updateVerticalSpriteGroup(inputTexture, group) {
    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var dimensions = inputTexture.getDimensions();
    var verticalInside = this._layoutMode === 'vertical-inside';

    var startSprite = this._spriteGroups[group].start;
    var midSprite = this._spriteGroups[group].mid;
    var endSprite = this._spriteGroups[group].end;

    var startHeight = 0;
    var endHeight = 0;

    var textureDimensions = void 0,
        textureRatio = void 0;
    if (startSprite) {
      textureDimensions = startSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;

      startHeight = Math.floor(this._frameWidth * textureRatio);

      var startPosition = new _globals.Vector2(offset, 0);
      startPosition.y = verticalInside ? this._frameWidth : 0;

      startSprite.setPosition(startPosition);
      startSprite.setWidth(this._frameWidth);
      startSprite.setHeight(startHeight);
    }

    if (endSprite) {
      textureDimensions = endSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;

      endHeight = Math.floor(this._frameWidth * textureRatio);

      var endPosition = new _globals.Vector2(offset, dimensions.y - endHeight);
      endPosition.y -= verticalInside ? this._frameWidth : 0;

      endSprite.setPosition(endPosition);
      endSprite.setWidth(this._frameWidth);
      endSprite.setHeight(endHeight);
    }

    if (midSprite) {
      textureDimensions = midSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;

      var midPosition = new _globals.Vector2(offset, startHeight);
      var midHeight = dimensions.y - startHeight - endHeight;

      if (verticalInside) {
        midPosition.y += this._frameWidth;
        midHeight -= this._frameWidth * 2;
      }

      midSprite.setPosition(midPosition);
      midSprite.setHeight(midHeight);
      midSprite.setWidth(this._frameWidth);

      // Handle repeat
      if (this._options.frame.imageGroups[group].mid.mode === 'repeat') {
        // Make sure we have exactly the right amount of sprites we need
        var defaultSpriteHeight = this._frameWidth * textureRatio;
        var requiredRepeatSprites = Math.ceil(midHeight / defaultSpriteHeight);
        var consumedHeight = 0;

        if (requiredRepeatSprites !== -1) {
          var spriteHeight = Math.round(midHeight / requiredRepeatSprites);
          midSprite.setHeight(spriteHeight);
          consumedHeight += spriteHeight;

          this._ensureRepeatSpritesExist(requiredRepeatSprites - 1, group, midSprite);

          // Reposition all repeat sprites
          for (var i = 0; i < requiredRepeatSprites - 1; i++) {
            // Divide the remaining height by the remaining amount of sprites to be placed
            spriteHeight = Math.round((midHeight - consumedHeight) / (requiredRepeatSprites - i - 1));

            var sprite = this._repeatSprites[group][i];
            var spritePosition = midPosition.clone().add(0, consumedHeight).floor();
            sprite.setPosition(spritePosition);
            sprite.setHeight(spriteHeight);
            sprite.setWidth(this._frameWidth);

            consumedHeight += spriteHeight;
          }
        }
      }
    }
  };

  /**
   * Disposes all sprites
   * @private
   */


  FrameOperation.prototype._disposeSprites = function _disposeSprites() {
    var _this4 = this;

    this._sprites.forEach(function (sprite) {
      _this4._frameContainer.removeChild(sprite);
      var baseTexture = sprite.getTexture().getBaseTexture();
      baseTexture.dispose();

      sprite.dispose();
    });
    this._resetSprites();
  };

  /**
   * Disposes this operation
   */


  FrameOperation.prototype.dispose = function dispose() {
    _Operation.prototype.dispose.call(this);
    this._disposeSprites();
  };

  /**
   * Validates the given frame object
   * @param  {Object} frame
   */


  FrameOperation.validateFrame = function validateFrame(frame) {
    if (!frame) return;
    var imageGroups = frame.imageGroups,
        layoutMode = frame.layoutMode;


    if (typeof frame.name !== 'string') {
      throw new Error('Frame needs a property `name` of type String.');
    }

    if (typeof frame.label !== 'string') {
      throw new Error('Frame needs a property `label` of type String.');
    }

    if ((0, _typeof3.default)(frame.imageGroups) !== 'object') {
      throw new Error('Frame needs a property `imageGroups` of type Object.');
    }

    var validateImageGroup = function validateImageGroup(group) {
      var _imageGroups$group = imageGroups[group],
          start = _imageGroups$group.start,
          end = _imageGroups$group.end,
          mid = _imageGroups$group.mid;


      if (typeof imageGroups[group] === 'undefined') return;
      if ((0, _typeof3.default)(imageGroups[group]) !== 'object') {
        throw new Error('Frame: `imageGroups.' + group + '` needs to be of type Object.');
      }

      if (typeof start !== 'undefined' && !(start instanceof Image || typeof HTMLImageElement !== 'undefined' && start instanceof HTMLImageElement)) {
        throw new Error('Frame: `imageGroups.' + group + '.start` needs to be of type Image.');
      }

      if (typeof mid !== 'undefined' && !(start instanceof Image || typeof HTMLImageElement !== 'undefined' && start instanceof HTMLImageElement) && (typeof mid === 'undefined' ? 'undefined' : (0, _typeof3.default)(mid)) !== 'object') {
        throw new Error('Frame: `imageGroups.' + group + '.mid` needs to be of type Image or Object.');
      }

      if (typeof end !== 'undefined' && !(end instanceof Image || typeof HTMLImageElement !== 'undefined' && end instanceof HTMLImageElement)) {
        throw new Error('Frame: `imageGroups.' + group + '.end` needs to be of type Image.');
      }
    };

    if (typeof layoutMode !== 'undefined' && ['vertical-inside', 'horizontal-inside'].indexOf(layoutMode) === -1) {
      throw new Error('Frame: `layoutMode` must be one of vertical-inside, horizontal-inside');
    }

    if (typeof tintable !== 'undefined' && typeof tintable !== 'boolean') {
      throw new Error('Frame: `tintable` needs to be of type Boolean.');
    }

    validateImageGroup('top');
    validateImageGroup('left');
    validateImageGroup('right');
    validateImageGroup('bottom');
  };

  return FrameOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */


FrameOperation.identifier = 'frame';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
FrameOperation.prototype.availableOptions = {
  frame: {
    type: OptionType.OBJECT,
    validation: FrameOperation.validateFrame,
    setter: function setter(frame, initial) {
      if (!initial) {
        this._createSpritesForFrame(frame);
      }
      return frame;
    }
  },
  tintColor: { type: OptionType.COLOR, default: new _globals.Color(1, 1, 1, 0) },
  scale: { type: OptionType.NUMBER, default: 0.1 }
};

exports.default = FrameOperation;

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _linearFocusFilter = __webpack_require__(169);

var _linearFocusFilter2 = _interopRequireDefault(_linearFocusFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType;

/**
 * An operation that can draw a linear focus
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */

var LinearFocusOperation = function (_Operation) {
  (0, _inherits3.default)(LinearFocusOperation, _Operation);

  /**
   * Creates a new LinearFocusOperation
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} [options]
   */
  function LinearFocusOperation() {
    (0, _classCallCheck3.default)(this, LinearFocusOperation);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));

    _this._lastBlurRadius = _this._options.blurRadius;
    _this._lastSize = _this._options.size;
    _this._lastGradientSize = _this._options.gradientSize;

    _this._horizontalFilter = new _linearFocusFilter2.default();
    _this._verticalFilter = new _linearFocusFilter2.default();
    _this._sprite.setFilters([_this._horizontalFilter, _this._verticalFilter]);

    _this._horizontalFilter.setDelta(new _globals.Vector2(1, 1));
    _this._verticalFilter.setDelta(new _globals.Vector2(-1, 1));

    _this._filter = new _linearFocusFilter2.default();
    return _this;
  }

  /**
   * Applies the given rotation change
   * @param  {PhotoEditorSDK.Operations.RotationOperation} operation
   * @param  {Number} degrees
   */


  LinearFocusOperation.prototype.rotate = function rotate(degrees) {
    var start = this._options.start;
    var end = this._options.end;

    if (degrees === 90) {
      start.flip();
      start.x = 1 - start.x;
      end.flip();
      end.x = 1 - end.x;
    } else if (degrees === -90) {
      start.flip();
      start.y = 1 - start.y;
      end.flip();
      end.y = 1 - end.y;
    }

    this.set({ start: start, end: end });
  };

  /**
   * Applies a flip with the given direction
   * @param  {String} direction
   */


  LinearFocusOperation.prototype.flip = function flip(direction) {
    var start = this._options.start;
    var end = this._options.end;

    switch (direction) {
      case 'horizontal':
        start.x = 1 - start.x;
        end.x = 1 - end.x;
        break;
      case 'vertical':
        start.y = 1 - start.y;
        end.y = 1 - end.y;
        break;
    }

    this.set({ start: start, end: end });
  };

  /**
   * Crops this image using WebGL
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @override
   * @private
   */
  /* istanbul ignore next */


  LinearFocusOperation.prototype._renderWebGL = function _renderWebGL(inputTexture) {
    var inputDimensions = inputTexture.getDimensions();
    var shortestSide = inputDimensions.min();

    var start = this._options.start.clone();
    var end = this._options.end.clone();

    var _options = this._options,
        blurRadius = _options.blurRadius,
        size = _options.size,
        gradientSize = _options.gradientSize;

    var commonOptions = {
      blurRadius: blurRadius * shortestSide,
      size: size * shortestSide,
      gradientSize: gradientSize * shortestSide,

      start: start.clone().multiply(inputDimensions),
      end: end.clone().multiply(inputDimensions),
      texSize: inputDimensions
    };

    this._horizontalFilter.set(commonOptions);
    this._verticalFilter.set(commonOptions);

    this._renderTexture.render(this._container);

    return _promise2.default.resolve();
  };

  /**
   * Renders the radial blur using Canvas2D
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @override
   * @private
   */


  LinearFocusOperation.prototype._renderCanvas = function _renderCanvas(inputTexture) {
    var inputDimensions = inputTexture.getDimensions();

    var _options2 = this._options,
        blurRadius = _options2.blurRadius,
        size = _options2.size,
        gradientSize = _options2.gradientSize,
        start = _options2.start,
        end = _options2.end;

    this._filter.set({
      blurRadius: blurRadius,
      gradientSize: gradientSize,
      size: size,
      start: start.clone(),
      end: end.clone(),
      texSize: inputDimensions
    });

    this._sprite.setFilters([this._filter]);

    this._renderTexture.render(this._container);

    return _promise2.default.resolve();
  };

  /**
   * Disposes this operation
   */


  LinearFocusOperation.prototype.dispose = function dispose() {
    _Operation.prototype.dispose.call(this);
    this._filter.dispose();
    this._verticalFilter.dispose();
    this._horizontalFilter.dispose();
  };

  return LinearFocusOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */


LinearFocusOperation.identifier = 'linear-focus';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
LinearFocusOperation.prototype.availableOptions = {
  start: { type: OptionType.VECTOR2, default: new _globals.Vector2(0.0, 0.5) },
  end: { type: OptionType.VECTOR2, default: new _globals.Vector2(1.0, 0.5) },
  blurRadius: { type: OptionType.NUMBER, default: 0.025 },
  size: { type: OptionType.NUMBER, default: 0.1 },
  gradientSize: { type: OptionType.NUMBER, default: 0.1 }
};

exports.default = LinearFocusOperation;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _vector = __webpack_require__(23);

var _vector2 = _interopRequireDefault(_vector);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType;

/**
 * An operation that can rotate and flip an image
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */

var OrientationOperation = function (_Operation) {
  (0, _inherits3.default)(OrientationOperation, _Operation);

  function OrientationOperation() {
    (0, _classCallCheck3.default)(this, OrientationOperation);
    return (0, _possibleConstructorReturn3.default)(this, _Operation.apply(this, arguments));
  }

  /**
   * Rotates and/or flips the image
   * @param  {PhotoEditorSDK} sdk
   * @returns {Promise}
   * @override
   * @private
   */
  OrientationOperation.prototype._render = function _render(sdk) {
    var actualDegrees = this._options.rotation % 360;
    var radians = actualDegrees * (Math.PI / 180);

    this._sprite.setScale(this._options.flipHorizontally ? -1 : 1, this._options.flipVertically ? -1 : 1);
    this._sprite.setRotation(radians);
    this._sprite.setAnchor(0.5, 0.5);
    this._sprite.updateTransform();

    var bounds = this._sprite.getBounds();
    this._renderTexture.resizeTo(new _vector2.default(bounds.width, bounds.height));

    // Make sure we're rendering to top left corner
    this._sprite.setPosition(this._renderTexture.getDimensions().divide(2));

    // Draw
    this._renderTexture.render(this._container);

    return _promise2.default.resolve();
  };

  /**
   * Returns the dimensions the given dimensions will have after this operation
   * has been applied
   * @param {PhotoEditorSDK.Math.Vector2} dimensions
   * @return {PhotoEditorSDK.Math.Vector2}
   * @override
   */


  OrientationOperation.prototype.getNewDimensions = function getNewDimensions(dimensions) {
    dimensions = dimensions.clone();
    if (this._options.rotation % 180) {
      dimensions.flip();
    }
    return dimensions;
  };

  /**
   * Flips the image while incorporating the current rotation
   * @param {String} direction
   */


  OrientationOperation.prototype.flip = function flip(direction) {
    var rotation = this._options.rotation;

    if (rotation === 90 || rotation === 270) {
      if (direction === 'vertical') {
        direction = 'horizontal';
      } else {
        direction = 'vertical';
      }
    }

    switch (direction) {
      case 'vertical':
        this.setFlipVertically(!this.getFlipVertically());
        break;
      case 'horizontal':
        this.setFlipHorizontally(!this.getFlipHorizontally());
        break;
    }
  };

  return OrientationOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */


OrientationOperation.identifier = 'orientation';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
OrientationOperation.prototype.availableOptions = {
  rotation: {
    type: OptionType.NUMBER,
    default: 0,
    validation: function validation(value) {
      if (value % 90 !== 0) {
        throw new Error('OrientationOperation: `rotation` has to be a multiple of 90.');
      }
    },
    setter: function setter(value) {
      return (value + 360) % 360;
    }
  },
  flipVertically: { type: OptionType.BOOLEAN, default: false },
  flipHorizontally: { type: OptionType.BOOLEAN, default: false }
};

exports.default = OrientationOperation;

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _radialFocusFilter = __webpack_require__(170);

var _radialFocusFilter2 = _interopRequireDefault(_radialFocusFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType;

/**
 * An operation that can draw a radial focus
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */

var RadialFocusOperation = function (_Operation) {
  (0, _inherits3.default)(RadialFocusOperation, _Operation);

  /**
   * Creates a new RadialFocusOperation
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} [options]
   */
  function RadialFocusOperation() {
    (0, _classCallCheck3.default)(this, RadialFocusOperation);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));

    _this._lastBlurRadius = _this._options.blurRadius;
    _this._lastGradientRadius = _this._options.gradientRadius;

    _this._horizontalFilter = new _radialFocusFilter2.default();
    _this._verticalFilter = new _radialFocusFilter2.default();
    _this._sprite.setFilters([_this._horizontalFilter, _this._verticalFilter]);

    _this._horizontalFilter.setDelta(new _globals.Vector2(1, 1));
    _this._verticalFilter.setDelta(new _globals.Vector2(-1, 1));

    _this._filter = new _radialFocusFilter2.default();
    return _this;
  }

  /**
   * Applies the given rotation change
   * @param  {Number} degrees
   */


  RadialFocusOperation.prototype.rotate = function rotate(degrees) {
    var position = this._options.position;

    if (degrees === 90) {
      position.flip();
      position.x = 1 - position.x;
    } else if (degrees === -90) {
      position.flip();
      position.y = 1 - position.y;
    }

    this.set({ position: position });
  };

  /**
   * Applies a flip with the given direction
   * @param  {String} direction
   */


  RadialFocusOperation.prototype.flip = function flip(direction) {
    var position = this._options.position;

    switch (direction) {
      case 'horizontal':
        position.x = 1 - position.x;
        break;
      case 'vertical':
        position.y = 1 - position.y;
        break;
    }

    this.set({ position: position });
  };

  /**
   * Renders the radial blur using WebGL
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @private
   * @override
   */
  /* istanbul ignore next */


  RadialFocusOperation.prototype._renderWebGL = function _renderWebGL(inputTexture) {
    var inputDimensions = inputTexture.getDimensions();
    var shortestSide = inputDimensions.min();

    var _options = this._options,
        position = _options.position,
        blurRadius = _options.blurRadius,
        radius = _options.radius,
        gradientRadius = _options.gradientRadius;


    var commonOptions = {
      blurRadius: blurRadius * shortestSide,
      radius: radius * shortestSide,
      gradientRadius: gradientRadius * shortestSide,
      position: position.clone().multiply(inputDimensions),
      texSize: inputDimensions
    };

    this._horizontalFilter.set(commonOptions);
    this._verticalFilter.set(commonOptions);

    this._renderTexture.render(this._container);

    return _promise2.default.resolve();
  };

  /**
   * Renders the radial blur using Canvas2D
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @private
   * @override
   */


  RadialFocusOperation.prototype._renderCanvas = function _renderCanvas(inputTexture) {
    var _options2 = this._options,
        blurRadius = _options2.blurRadius,
        radius = _options2.radius,
        gradientRadius = _options2.gradientRadius,
        position = _options2.position;

    var inputDimensions = inputTexture.getDimensions();

    this._filter.set({
      blurRadius: blurRadius,
      radius: radius,
      gradientRadius: gradientRadius,
      position: position,
      texSize: inputDimensions
    });

    this._sprite.setFilters([this._filter]);

    this._renderTexture.render(this._container);

    return _promise2.default.resolve();
  };

  /**
   * Disposes this operation
   */


  RadialFocusOperation.prototype.dispose = function dispose() {
    _Operation.prototype.dispose.call(this);
    this._filter.dispose();
    this._verticalFilter.dispose();
    this._horizontalFilter.dispose();
  };

  return RadialFocusOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */


RadialFocusOperation.identifier = 'radial-focus';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
RadialFocusOperation.prototype.availableOptions = {
  position: { type: OptionType.VECTOR2, default: new _globals.Vector2(0.5, 0.5) },
  radius: { type: OptionType.NUMBER, default: 0.25 },
  gradientRadius: { type: OptionType.NUMBER, default: 0.125 },
  blurRadius: { type: OptionType.NUMBER, default: 0.025 }
};

exports.default = RadialFocusOperation;

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

var _brush = __webpack_require__(84);

var _brush2 = _interopRequireDefault(_brush);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _blurFilter = __webpack_require__(176);

var _blurFilter2 = _interopRequireDefault(_blurFilter);

var _maskFilter = __webpack_require__(177);

var _maskFilter2 = _interopRequireDefault(_maskFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType,
    RendererType = _globals.Constants.RendererType;

/**
 * An operation that can draw a selective blur using brushes
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */

var SelectiveBlurOperation = function (_Operation) {
  (0, _inherits3.default)(SelectiveBlurOperation, _Operation);

  /**
   * Creates a new SelectiveBlurOperation
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} [options]
   */
  function SelectiveBlurOperation() {
    (0, _classCallCheck3.default)(this, SelectiveBlurOperation);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));

    var renderer = _this._sdk.getRenderer();

    _this._lastBlurRadius = null;
    _this._blurredRenderTexture = new _globals.Engine.RenderTexture(renderer, 100, 100, 1);
    _this._maskRenderTexture = new _globals.Engine.RenderTexture(renderer, 100, 100, 1);

    _this._brush = new _brush2.default(_this);
    _this._brushContainer = new _globals.Engine.Container();
    var brushSprite = _this._brush.getDisplayObject();
    _this._brushContainer.addChild(brushSprite);

    _this._outputSprite = new _globals.Engine.Sprite();
    _this._outputContainer = new _globals.Engine.Container();
    _this._outputContainer.addChild(_this._outputSprite);

    _this._maskFilter = new _maskFilter2.default();
    if (renderer.isOfType(RendererType.WEBGL)) {
      _this._horizontalFilter = new _blurFilter2.default();
      _this._verticalFilter = new _blurFilter2.default();
      _this._sprite.setFilters([_this._horizontalFilter, _this._verticalFilter]);

      _this._horizontalFilter.setDelta(new _globals.Vector2(1, 1));
      _this._verticalFilter.setDelta(new _globals.Vector2(-1, 1));

      var baseTexture = _this._maskRenderTexture.getBaseTexture();
      baseTexture.setGLUnit(_this._maskFilter.getMaskImage());
      renderer.updateTexture(baseTexture, false);

      baseTexture = _this._blurredRenderTexture.getBaseTexture();
      baseTexture.setGLUnit(_this._maskFilter.getFilterImage());
      renderer.updateTexture(baseTexture, false);
    } else if (renderer.isOfType(RendererType.CANVAS)) {
      _this._blurFilter = new _blurFilter2.default();

      _this._sprite.setFilters([_this._blurFilter]);

      _this._maskFilter.setMaskCanvas(_this._maskRenderTexture.getRenderTarget().getCanvas());
      _this._maskFilter.setFilterCanvas(_this._blurredRenderTexture.getRenderTarget().getCanvas());
    }

    _this._outputSprite.setFilters([_this._maskFilter]);
    return _this;
  }

  /**
   * Applies a flip to this operation
   * @param  {String} direction
   */


  SelectiveBlurOperation.prototype.flip = function flip(direction) {
    this._brush.applyFlip(direction);
    this.setDirty(true, true);
    this._lastBlurRadius = null;
  };

  /**
   * Applies a rotation to this operation
   * @param  {Number} degrees
   */


  SelectiveBlurOperation.prototype.rotate = function rotate(degrees) {
    this._brush.applyRotation(degrees);
    this.setDirty(true, true);
    this._lastBlurRadius = null;
  };

  /**
   * Applies a crop to this operation
   * @param  {PhotoEditorSDK.Operation} cropOperation
   * @param  {Object} options
   */


  SelectiveBlurOperation.prototype.crop = function crop(cropOperation, options) {
    this._brush.applyCrop(cropOperation, options);
    this.setDirty(true, true);
    this._lastBlurRadius = null;
  };

  /**
   * Renders this operation
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @override
   * @private
   */


  SelectiveBlurOperation.prototype._render = function _render(inputTexture) {
    this._renderBlur(inputTexture);
    this._renderMask(inputTexture);

    this._outputSprite.setTexture(inputTexture);
    this._renderTexture.render(this._outputContainer);

    return _promise2.default.resolve();
  };

  /**
   * Renders the mask
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @private
   */


  SelectiveBlurOperation.prototype._renderMask = function _renderMask(inputTexture) {
    var inputDimensions = inputTexture.getDimensions();

    var maskDimensions = this._maskRenderTexture.getDimensions();
    if (!maskDimensions.equals(inputDimensions)) {
      this._maskRenderTexture.resizeTo(inputDimensions);
    }

    this._brush.update(this._sdk, inputDimensions);
    this._maskRenderTexture.clear(_globals.Color.BLACK);
    this._maskRenderTexture.render(this._brushContainer);

    var renderer = this._sdk.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      renderer.updateTexture(this._maskRenderTexture.getBaseTexture(), false);
    }
  };

  /**
   * Blurs the input image
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @private
   */


  SelectiveBlurOperation.prototype._renderBlur = function _renderBlur(inputTexture) {
    var inputDimensions = inputTexture.getDimensions();

    var blurredDimensions = this._blurredRenderTexture.getDimensions();
    if (!blurredDimensions.equals(inputDimensions)) {
      this._blurredRenderTexture.resizeTo(inputDimensions);
    }

    var blurRadius = this._options.blurRadius;

    if (this._lastBlurRadius !== blurRadius || !blurredDimensions.equals(inputDimensions)) {
      var renderer = this._sdk.getRenderer();

      var blurOptions = void 0;
      if (renderer.isOfType(RendererType.WEBGL)) {
        var shortestSide = inputDimensions.min();
        blurOptions = {
          blurRadius: blurRadius * shortestSide,
          texSize: inputDimensions
        };

        this._horizontalFilter.set(blurOptions);
        this._verticalFilter.set(blurOptions);
      } else if (renderer.isOfType(RendererType.CANVAS)) {
        blurOptions = { blurRadius: blurRadius };
        this._blurFilter.set(blurOptions);
      }

      this._blurredRenderTexture.render(this._container);
      this._lastBlurRadius = blurRadius;
    }
  };

  /**
   * Returns this operation's brush
   * @return {PhotoEditorSDK.Operations.SpriteOperation.Brush}
   */


  SelectiveBlurOperation.prototype.getBrush = function getBrush() {
    return this._brush;
  };

  /**
   * Creates and adds a new path
   * @param {Number} thickness
   * @param {Number} hardness = 1
   * @return {PhotoEditorSDK.Operations.BrushOperation.Path}
   */


  SelectiveBlurOperation.prototype.createPath = function createPath(thickness) {
    var hardness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    var path = this._brush.createPath(thickness, hardness, _globals.Color.WHITE);
    this._options.paths.push(path);
    this.setDirty(true);
    return path;
  };

  /**
   * Sets the dirtiness for the given renderer
   * @param {Boolean} dirty
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param {Boolean} dimensionsChanged = false
   */


  SelectiveBlurOperation.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer, dimensionsChanged) {
    _Operation.prototype.setDirtyForRenderer.call(this, dirty, renderer, dimensionsChanged);
    this._brush.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
  };

  /**
   * Disposes this operation
   */


  SelectiveBlurOperation.prototype.dispose = function dispose() {
    _Operation.prototype.dispose.call(this);

    var renderer = this._sdk.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      this._verticalFilter.dispose();
      this._horizontalFilter.dispose();
    } else {
      this._blurFilter.dispose();
    }

    this._brush.dispose();
    this._maskFilter.dispose();
    this._blurredRenderTexture.dispose();
    this._maskRenderTexture.dispose();
  };

  return SelectiveBlurOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */


SelectiveBlurOperation.identifier = 'selective-blur';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
SelectiveBlurOperation.prototype.availableOptions = {
  blurRadius: { type: OptionType.NUMBER, default: 0.05 },
  paths: {
    type: OptionType.ARRAY,
    default: [],
    setter: function setter(paths) {
      if (this._brush) {
        this._brush.setPaths(paths);
      }
      return paths;
    }
  }
};

exports.default = SelectiveBlurOperation;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _stackBlur = __webpack_require__(37);

var _stackBlur2 = _interopRequireDefault(_stackBlur);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType; /*
                                                   * This file is part of PhotoEditorSDK.
                                                   *
                                                   * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                   * All rights reserved.
                                                   *
                                                   * Redistribution and use in source and binary forms, without
                                                   * modification, are permitted provided that the following license agreement
                                                   * is approved and a legal/financial contract was signed by the user.
                                                   * The license agreement can be found under following link:
                                                   *
                                                   * https://www.photoeditorsdk.com/LICENSE.txt
                                                   */

var BlurFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(BlurFilter, _Engine$Filter);

  function BlurFilter() {
    (0, _classCallCheck3.default)(this, BlurFilter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call.apply(_Engine$Filter, [this].concat(args)));

    _this._fragmentSource = __webpack_require__(239);

    _this._lastBlurRadius = null;
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {CanvasRenderer} renderer
   * @param  {RenderTarget} inputTarget
   * @param  {RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  BlurFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var inputDimensions = inputTarget.getDimensions();
    var dimensionsChanged = !outputTarget.getDimensions().equals(inputDimensions);

    outputTarget.setPixelRatio(inputTarget.getPixelRatio());
    outputTarget.resizeTo(inputTarget.getDimensions());

    if (this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged) {
      this._blurImage(inputTarget, outputTarget);
      this._lastBlurRadius = this._options.blurRadius;
    }
  };

  /**
   * Creates a blurred copy of the image
   * @param  {CanvasRenderTarget} inputTarget
   * @param  {CanvasRenderTarget} outputTarget
   * @return {Canvas}
   * @private
   */


  BlurFilter.prototype._blurImage = function _blurImage(inputTarget, outputTarget) {
    var inputCanvas = inputTarget.getCanvas();
    var inputContext = inputTarget.getContext();

    var inputDimensions = new _globals.Vector2(inputCanvas.width, inputCanvas.height);
    var blurryImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    _stackBlur2.default.stackBlurCanvasRGBA(blurryImageData, 0, 0, inputCanvas.width, inputCanvas.height, this._options.blurRadius * inputDimensions.min());

    var outputContext = outputTarget.getContext();
    outputContext.putImageData(blurryImageData, 0, 0);
  };

  return BlurFilter;
}(_globals.Engine.Filter);

BlurFilter.prototype.availableOptions = {
  blurRadius: { type: OptionType.NUMBER, default: 30, uniformType: UniformType.FLOAT },
  delta: { type: OptionType.VECTOR2, default: new _globals.Vector2(1, 1), uniformType: UniformType.FLOAT2 },
  texSize: { type: OptionType.VECTOR2, default: new _globals.Vector2(100, 100), uniformType: UniformType.FLOAT2 }
};

exports.default = BlurFilter;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    UniformType = _globals.Constants.UniformType; /*
                                                   * This file is part of PhotoEditorSDK.
                                                   *
                                                   * Copyright (C) 2016 9elements GbmH <contact@9elements.com>
                                                   * All rights reserved.
                                                   *
                                                   * Redistribution and use in source and binary forms, without
                                                   * modification, are permitted provided that the following license agreement
                                                   * is approved and a legal/financial contract was signed by the user.
                                                   * The license agreement can be found under following link:
                                                   *
                                                   * https://www.photoeditorsdk.com/LICENSE.txt
                                                   */

var MaskFilter = function (_Engine$Filter) {
  (0, _inherits3.default)(MaskFilter, _Engine$Filter);

  function MaskFilter() {
    (0, _classCallCheck3.default)(this, MaskFilter);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));

    _this._fragmentSource = __webpack_require__(241);
    return _this;
  }

  /**
   * Applies this filter to the given inputTarget and renders it to
   * the given outputTarget using the CanvasRenderer
   * @param  {PhotoEditorSDK.Engine.CanvasRenderer} renderer
   * @param  {PhotoEditorSDK.Engine.RenderTarget} inputTarget
   * @param  {PhotoEditorSDK.Engine.RenderTarget} outputTarget
   * @param  {Boolean} clear = false
   * @private
   */


  MaskFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var inputCanvas = inputTarget.getCanvas();

    var inputContext = inputTarget.getContext();
    var outputContext = outputTarget.getContext();

    var _options = this._options,
        maskCanvas = _options.maskCanvas,
        filterCanvas = _options.filterCanvas;

    var maskContext = maskCanvas.getContext('2d');
    var filterContext = filterCanvas.getContext('2d');

    var maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    var existingImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    var existingPixels = existingImageData.data;
    var newPixels = filterContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;

    var alpha = void 0;
    for (var i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
      alpha = maskPixels[i] / 255;

      existingPixels[i] = alpha * newPixels[i] + (1 - alpha) * existingPixels[i];
      existingPixels[i + 1] = alpha * newPixels[i + 1] + (1 - alpha) * existingPixels[i + 1];
      existingPixels[i + 2] = alpha * newPixels[i + 2] + (1 - alpha) * existingPixels[i + 2];
    }

    outputContext.putImageData(existingImageData, 0, 0);
  };

  return MaskFilter;
}(_globals.Engine.Filter);

MaskFilter.prototype.availableOptions = {
  maskImage: { type: OptionType.NUMBER, default: 1, uniformType: UniformType.INT },
  maskCanvas: { type: OptionType.OBJECT, default: null },
  filterImage: { type: OptionType.NUMBER, default: 2, uniformType: UniformType.INT },
  filterCanvas: { type: OptionType.OBJECT, default: null }
};

exports.default = MaskFilter;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

var _sprite = __webpack_require__(36);

var _sprite2 = _interopRequireDefault(_sprite);

var _sticker = __webpack_require__(181);

var _sticker2 = _interopRequireDefault(_sticker);

var _text = __webpack_require__(182);

var _text2 = _interopRequireDefault(_text);

var _brush = __webpack_require__(84);

var _brush2 = _interopRequireDefault(_brush);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType;

/**
 * An operation that can draw sprites (text and stickers) on the canvas
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */

var SpriteOperation = function (_Operation) {
  (0, _inherits3.default)(SpriteOperation, _Operation);

  /**
   * Creates a new SpriteOperation
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} [options]
   */
  function SpriteOperation() {
    (0, _classCallCheck3.default)(this, SpriteOperation);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));

    _this._onSpriteUpdate = _this._onSpriteUpdate.bind(_this);

    var sprites = _this._options.sprites.slice();
    sprites.forEach(function (sprite) {
      _this.removeSprite(sprite);
      _this.addSprite(sprite);
    });
    return _this;
  }

  /**
   * Returns the sprites that are instances of the given class
   * @param  {Class} Klass
   * @return {PhotoEditorSDK.Sprite[]}
   */


  SpriteOperation.prototype.getSpritesOfType = function getSpritesOfType(Klass) {
    return this._options.sprites.filter(function (sprite) {
      return sprite instanceof Klass;
    });
  };

  /**
   * Applies a rotation with the given degrees
   * @param  {Number} degrees
   * @private
   */


  SpriteOperation.prototype.rotate = function rotate(degrees) {
    this._options.sprites.forEach(function (sprite) {
      sprite.applyRotation(degrees);
    });
  };

  /**
   * Applies a flip with the given direction
   * @param  {String} direction
   * @private
   */


  SpriteOperation.prototype.flip = function flip(direction) {
    this._options.sprites.forEach(function (sprite) {
      sprite.applyFlip(direction);
    });
  };

  /**
   * Gets called when a sprite is flagged as dirty / its options changed
   * @param  {PhotoEditorSDK.Sprite} sprite
   * @param  {Object} options
   * @private
   */


  SpriteOperation.prototype._onSpriteUpdate = function _onSpriteUpdate(sprite, options) {
    this.setDirty(true);
  };

  /**
   * Applies the given rotation change
   * @param  {PhotoEditorSDK.Operations.RotationOperation} operation
   * @param  {Object} options
   * @private
   */


  SpriteOperation.prototype._applyRotation = function _applyRotation(operation, options) {
    this._options.sprites.forEach(function (sprite) {
      return sprite.applyRotation(operation, options);
    });
  };

  /**
   * Applies the given crop change
   * @param  {PhotoEditorSDK.Operations.CropOperation} operation
   * @param  {Object} options
   * @private
   */


  SpriteOperation.prototype.crop = function crop(operation, options) {
    this._options.sprites.forEach(function (sprite) {
      return sprite.applyCrop(operation, options);
    });
  };

  /**
   * Returns a serialized version of the given option
   * @param {String} optionName
   * @return {*} optionName
   * @private
   * @override
   */


  SpriteOperation.prototype._serializeOption = function _serializeOption(optionName) {
    // Since `sprites` is an array of configurables, we need
    // to serialize them as well
    if (optionName === 'sprites') {
      return this._options.sprites.map(function (sprite) {
        return sprite.serializeOptions();
      });
    }
    return _Operation.prototype._serializeOption.call(this, optionName);
  };

  /**
   * Creates a new sticker object and returns it
   * @param  {Object} options
   * @return {PhotoEditorSDK.Operations.SpriteOperation.Sticker}
   */


  SpriteOperation.prototype.createSticker = function createSticker(options) {
    return new _sticker2.default(this, options);
  };

  /**
   * Creates a new sticker object and returns it
   * @param  {Object} options
   * @return {PhotoEditorSDK.Operations.SpriteOperation.Text}
   */


  SpriteOperation.prototype.createText = function createText(options) {
    return new _text2.default(this, options);
  };

  /**
   * Creates a brush object and returns it
   * @param  {Object} options
   * @return {PhotoEditorSDK.Operations.SpriteOperation.Brush}
   */


  SpriteOperation.prototype.createBrush = function createBrush(options) {
    return new _brush2.default(this, options);
  };

  /**
   * Gets called when a sprite has been added
   * @param {PhotoEditorSDK.Sprite} sprite
   */


  SpriteOperation.prototype.addSprite = function addSprite(sprite) {
    this._options.sprites.push(sprite);
    this._container.addChild(sprite.getDisplayObject());

    // This operation needs to be rerendered
    this.setDirty(true);

    sprite.on('update', this._onSpriteUpdate);
  };

  /**
   * Removes the given sprite from the list of sprites
   * @param  {PhotoEditorSDK.Sprite} sprite
   * @return {Boolean}
   */


  SpriteOperation.prototype.removeSprite = function removeSprite(sprite) {
    var sprites = this._options.sprites;
    var index = sprites.indexOf(sprite);
    if (index !== -1) {
      sprite.off('update', this._onSpriteUpdate);
      this._container.removeChild(sprite.getDisplayObject());
      sprites.splice(index, 1);

      // This operation needs to be rerendered
      this.setDirty(true);

      return true;
    }
    return false;
  };

  /**
   * Renders this operation
   * @param {PhotoEditorSDK.Engine.Texture} inputTexture
   * @returns {Promise}
   * @override
   * @private
   */


  SpriteOperation.prototype._render = function _render(inputTexture) {
    var _this2 = this;

    var container = this._container;
    var sprites = this._options.sprites;

    var inputDimensions = inputTexture.getDimensions().clone().floor();
    return _globals.Promise.all(sprites.map(function (s) {
      return s.validateSettings();
    })).then(function () {
      sprites.forEach(function (sprite) {
        sprite.update(_this2._sdk, inputDimensions);
      });

      _this2._renderTexture.clear();
      _this2._renderTexture.render(container);
    });
  };

  /**
   * Takes the given Sprite to front
   * @param  {PhotoEditorSDK.Operations.SpriteOperation.Sprite} sprite
   */


  SpriteOperation.prototype.takeSpriteToFront = function takeSpriteToFront(sprite) {
    var sprites = this._options.sprites;

    var spriteIndex = sprites.indexOf(sprite);
    if (spriteIndex === -1) return;

    _globals.Utils.moveArrayItem(sprites, spriteIndex, sprites.length - 1);

    var displayObject = sprite.getDisplayObject();
    this._container.removeChild(displayObject);
    this._container.addChild(displayObject);

    this.setDirty(true);
  };

  /**
   * Returns the sprites at the given position on the canvas
   * @param  {PhotoEditorSDK.Math.Vector2} position
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {PhotoEditorSDK.Sprite[]}
   */


  SpriteOperation.prototype.getSpritesAtPosition = function getSpritesAtPosition(position, inputDimensions) {
    var _this3 = this;

    var intersectingSprites = [];

    this._options.sprites.forEach(function (s) {
      return s.update(_this3._sdk, inputDimensions);
    });

    // Translate canvas position to relative position on sprite by
    // applying the inverse of our outputSprite's world transform matrix
    var outputSprite = this._sdk.getSprite();
    var actualPosition = outputSprite.getWorldTransform().applyInverseToVector(position);

    // Apply anchor

    var _outputSprite$getText = outputSprite.getTexture().getFrame(),
        width = _outputSprite$getText.width,
        height = _outputSprite$getText.height;

    var anchorOffset = outputSprite.getAnchor().clone().multiply(-width, -height);
    actualPosition.subtract(anchorOffset);

    // Note: `actualPosition` is now the pixel position on the output sprite, NOT
    // on the sticker / text / brush

    // Find intersecting sprite
    var sprites = this._options.sprites.slice(0).reverse();
    for (var i = 0, c = sprites.length; i < c; i++) {
      var sprite = sprites[i];
      if (sprite.getDisplayObject().isAtPosition(actualPosition)) {
        intersectingSprites.push(sprite);
      }
    }

    return intersectingSprites;
  };

  /**
   * Sets the dirtiness for the given renderer
   * @param {Boolean} dirty
   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
   * @param {Boolean} dimensionsChanged = false
   */


  SpriteOperation.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer, dimensionsChanged) {
    _Operation.prototype.setDirtyForRenderer.call(this, dirty, renderer, dimensionsChanged);
    this._options.sprites.forEach(function (sprite) {
      sprite.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
    });
  };

  /**
   * Disposes this operation
   */


  SpriteOperation.prototype.dispose = function dispose() {
    _Operation.prototype.dispose.call(this);
    this._options.sprites.forEach(function (sprite) {
      sprite.dispose();
    });
  };

  return SpriteOperation;
}(_operation2.default);

SpriteOperation.Sticker = _sticker2.default;
SpriteOperation.Text = _text2.default;
SpriteOperation.Brush = _brush2.default;

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */
SpriteOperation.identifier = 'sprite';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
SpriteOperation.prototype.availableOptions = {
  sprites: {
    type: OptionType.ARRAY,
    default: [],
    setter: function setter(sprites, initial) {
      var _this4 = this;

      sprites = sprites.map(function (sprite, i) {
        if (sprite instanceof _sprite2.default) {
          return sprite;
        }

        var type = sprite.type;

        delete sprite.type;

        // Create sprite from the given options
        switch (type) {
          case 'text':
            return new _text2.default(_this4, sprite);
          case 'sticker':
            return new _sticker2.default(_this4, sprite);
          case 'brush':
            return new _brush2.default(_this4, sprite);
          default:
            _globals.Log.error(_this4.constructor.name, 'Invalid sprite type: ' + sprite.type);
        }
      });

      // Remove all sprites
      if (!initial) {
        if (this._options.sprites) {
          var spritesToRemove = this._options.sprites.slice();
          spritesToRemove.forEach(function (sprite) {
            sprite.dispose();
            _this4.removeSprite(sprite);
          });
        }

        // Add all sprites
        sprites.forEach(function (sprite) {
          _this4.addSprite(sprite);
        });
      }

      return sprites;
    }
  }
};

exports.default = SpriteOperation;

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A ControlPoint is a part of a {@link PhotoEditorSDK.Operations.BrushOperation.Path}, so a Path
 * consists of multiple ControlPoints. Should only be created using {@link PhotoEditorSDK.Operations.BrushOperation.Path#addControlPoint}
 * @class
 * @memberof PhotoEditorSDK.Operations.BrushOperation
 */
var ControlPoint = function () {
  /**
   * Creates a ControlPoint
   * @param  {PhotoEditorSDK.Operations.BrushOperation.Path} path
   * @param  {PhotoEditorSDK.Math.Vector2} position
   */
  function ControlPoint(path, position) {
    (0, _classCallCheck3.default)(this, ControlPoint);

    this._path = path;
    this._drawnCanvases = [];
    this._position = position;
  }

  /**
   * Renders this ControlPoint to the given canvas
   * @param  {HTMLCanvasElement} brush
   * @param  {HTMLCanvasElement} canvas
   * @param  {PhotoEditorSDK.Operations.BrushOperation.ControlPoint} lastControlPoint
   */


  ControlPoint.prototype.renderToCanvas = function renderToCanvas(brush, canvas, lastControlPoint) {
    if (this._drawnCanvases.indexOf(canvas) !== -1) {
      // This control point has already been drawn on this canvas. Ignore.
      return;
    }

    var canvasDimensions = new _globals.Vector2(canvas.width, canvas.height);

    var context = canvas.getContext('2d');
    var position = this._position.clone().multiply(canvasDimensions); // x2
    var lastPosition = lastControlPoint.getPosition().clone().multiply(canvasDimensions); // x1
    var distance = position.clone().subtract(lastPosition).len();
    var step = brush.width / 10;

    var i = 0;
    while (i <= distance) {
      var t = Math.max(0, Math.min(1, i / distance));
      var x = lastPosition.x + (position.x - lastPosition.x) * t;
      var y = lastPosition.y + (position.y - lastPosition.y) * t;

      context.drawImage(brush, x - brush.width / 2, y - brush.height / 2);
      i += step;
    }

    this._drawnCanvases.push(canvas);
  };

  /**
   * Sets the position
   * @param {PhotoEditorSDK.Math.Vector2} position
   */


  ControlPoint.prototype.setPosition = function setPosition(position) {
    this._position = position;
  };

  /**
   * Returns the position
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  ControlPoint.prototype.getPosition = function getPosition() {
    return this._position.clone();
  };

  /**
   * Sets this ControlPoint to dirty
   */


  ControlPoint.prototype.setDirty = function setDirty() {
    this._drawnCanvases = [];
  };

  return ControlPoint;
}(); /*
      * This file is part of PhotoEditorSDK.
      *
      * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
      * All rights reserved.
      *
      * Redistribution and use in source and binary forms, without
      * modification, are permitted provided that the following license agreement
      * is approved and a legal/financial contract was signed by the user.
      * The license agreement can be found under following link:
      *
      * https://www.photoeditorsdk.com/LICENSE.txt
      */

exports.default = ControlPoint;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _controlPoint = __webpack_require__(179);

var _controlPoint2 = _interopRequireDefault(_controlPoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType; /*
                                                 * This file is part of PhotoEditorSDK.
                                                 *
                                                 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                 * All rights reserved.
                                                 *
                                                 * Redistribution and use in source and binary forms, without
                                                 * modification, are permitted provided that the following license agreement
                                                 * is approved and a legal/financial contract was signed by the user.
                                                 * The license agreement can be found under following link:
                                                 *
                                                 * https://www.photoeditorsdk.com/LICENSE.txt
                                                 */

/**
 * A path that can be drawn on a {@link PhotoEditorSDK.Operations.BrushOperation}. Should only be
 * created using {@link PhotoEditorSDK.Operations.BrushOperation#createPath}
 * @class
 * @extends PhotoEditorSDK.EventEmitter
 * @memberof PhotoEditorSDK.Operations.BrushOperation
 */
var Path = function (_Configurable) {
  (0, _inherits3.default)(Path, _Configurable);

  /**
   * Creates a Path
   * @param  {PhotoEditorSDK.Operations.BrushOperation} operation
   * @param  {Object} options
   * @param  {HTMLCanvasElement} canvas
   */
  function Path(operation, options, canvas) {
    (0, _classCallCheck3.default)(this, Path);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Configurable.call(this, options));

    _this._operation = operation;

    _this._canvas = canvas || _globals.Utils.createCanvas();
    _this._context = _this._canvas.getContext('2d');
    return _this;
  }

  /**
   * Draws this path onto its canvas
   * @param {PhotoEditorSDK.Math.Vector2} inputDimensions
   */


  Path.prototype.render = function render(inputDimensions) {
    var _options = this._options,
        controlPoints = _options.controlPoints,
        thickness = _options.thickness;

    if (controlPoints.length < 2) {
      return;
    }

    _globals.Utils.ensureCanvasDimensions(this._canvas, inputDimensions);

    if (!this._brush || this._lastBrushThickness !== thickness || !inputDimensions.equals(this._brushInputDimensions)) {
      this._brush = this._createBrush(inputDimensions);
      this._brushInputDimensions = inputDimensions.clone();
      this._lastBrushThickness = thickness;
    }

    var lastControlPoint = controlPoints[0];
    var controlPoint = lastControlPoint;
    for (var i = 1; i < controlPoints.length; i++) {
      controlPoint = controlPoints[i];
      controlPoint.renderToCanvas(this._brush, this._canvas, lastControlPoint);
      lastControlPoint = controlPoint;
    }
  };

  /**
   * Creates a brush from the given thickness, hardness and color
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {HTMLCanvasElement}
   * @private
   */


  Path.prototype._createBrush = function _createBrush(inputDimensions) {
    var _options2 = this._options,
        thickness = _options2.thickness,
        hardness = _options2.hardness,
        color = _options2.color;

    var canvas = _globals.Utils.createCanvas();
    canvas.width = canvas.height = Math.ceil(thickness * inputDimensions.min());

    var context = canvas.getContext('2d');

    // Brush always has 100% opacity
    color = color.clone();
    color.a = 1;

    if (canvas.width === 1) {
      context.fillStyle = color.toRGBA();
      context.fillRect(0, 0, 1, 1);
    } else {
      var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, Math.min(canvas.width / 2 - 1, canvas.width / 2 * hardness), canvas.width / 2, canvas.height / 2, canvas.width / 2);

      gradient.addColorStop(0, color.toRGBA());
      var transparentColor = color.clone();
      transparentColor.a = 0;
      gradient.addColorStop(1, transparentColor.toRGBA());

      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas.width, canvas.height);
    }

    return canvas;
  };

  /**
   * Adds a control point at the given position to this path
   * @param {PhotoEditorSDK.Math.Vector2} position
   */


  Path.prototype.addControlPoint = function addControlPoint(position) {
    var controlPoint = new _controlPoint2.default(this, position);
    this._options.controlPoints.push(controlPoint);
    this.emit('update', this);
  };

  /**
   * Returns this path's canvas
   * @return {Canvas}
   */


  Path.prototype.getCanvas = function getCanvas() {
    return this._canvas;
  };

  /**
   * Sets the given canvas
   * @param {HTMLCanvasElement} canvas
   */


  Path.prototype.setCanvas = function setCanvas(canvas) {
    this._canvas = canvas;
    this._context = canvas.getContext('2d');
  };

  /**
   * Sets this path to dirty
   */


  Path.prototype.setDirty = function setDirty() {
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);

    this._options.controlPoints.forEach(function (point) {
      point.setDirty();
    });
  };

  /**
   * Calls `iterator` for each control point
   * @param  {Function} iterator
   */


  Path.prototype.forEachControlPoint = function forEachControlPoint(iterator) {
    this._options.controlPoints.forEach(iterator);
  };

  /**
   * Renders this path to the given canvas with the right opacity
   * @param  {Canvas} canvas
   */


  Path.prototype.renderToCanvas = function renderToCanvas(canvas) {
    var context = canvas.getContext('2d');
    context.save();
    context.globalAlpha = this._options.color.a;
    context.drawImage(this._canvas, 0, 0);
    context.restore();
  };

  /**
   * Returns the canvas dimension for this path
   * @return {PhotoEditorSDK.Math.Vector2}
   */


  Path.prototype.getCanvasDimensions = function getCanvasDimensions() {
    return this._canvasDimensions;
  };

  return Path;
}(_globals.Configurable);

Path.prototype.availableOptions = {
  id: { type: OptionType.STRING, default: function _default() {
      return _globals.Utils.getUUID();
    } },
  color: { type: OptionType.COLOR, default: _globals.Color.RED },
  hardness: { type: OptionType.NUMBER, default: 1 },
  thickness: { type: OptionType.NUMBER, default: 0.05 },
  controlPoints: { type: OptionType.ARRAY, default: [] },
  closed: { type: OptionType.BOOLEAN, default: false }
};

exports.default = Path;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _sprite = __webpack_require__(36);

var _sprite2 = _interopRequireDefault(_sprite);

var _adjustmentsFilter = __webpack_require__(81);

var _adjustmentsFilter2 = _interopRequireDefault(_adjustmentsFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    RendererType = _globals.Constants.RendererType; /*
                                                     * This file is part of PhotoEditorSDK.
                                                     *
                                                     * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                     * All rights reserved.
                                                     *
                                                     * Redistribution and use in source and binary forms, without
                                                     * modification, are permitted provided that the following license agreement
                                                     * is approved and a legal/financial contract was signed by the user.
                                                     * The license agreement can be found under following link:
                                                     *
                                                     * https://www.photoeditorsdk.com/LICENSE.txt
                                                     */

/**
 * A sticker that can be drawn by SpriteOperation. Should only be created via {@link PhotoEditorSDK.Operations.SpriteOperation#createSticker}
 * @class
 * @memberof PhotoEditorSDK.Operations.SpriteOperation
 */
var Sticker = function (_Sprite) {
  (0, _inherits3.default)(Sticker, _Sprite);

  /**
   * Creates a new Sticker
   * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
   * @param  {Object} [options]
   */
  function Sticker() {
    (0, _classCallCheck3.default)(this, Sticker);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Sprite.call.apply(_Sprite, [this].concat(args)));

    if (_this._options.image) {
      _this._onImageUpdate();
    }

    _this._adjustmentsFilter = new _adjustmentsFilter2.default();

    _this._onOptionsChange = _this._onOptionsChange.bind(_this);
    _this._options.adjustments.on('updated', _this._onOptionsChange);
    return _this;
  }

  /**
   * Returns a serialized version of this configurable
   * @param {String[]} keys
   * @param {Boolean} toObject = false
   * @return {Object}
   */


  Sticker.prototype.serializeOptions = function serializeOptions(keys) {
    var toObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var options = _Sprite.prototype.serializeOptions.call(this, keys, toObject);
    if (!keys) options.type = 'sticker';
    return options;
  };

  /**
   * Checks if this sprite should be rendered to a render texture
   * @param  {PhotoEditorSDK} sdk
   * @return {Boolean}
   * @private
   */


  Sticker.prototype._rendersToRenderTexture = function _rendersToRenderTexture(sdk) {
    var smoothDownscaling = this._options.smoothDownscaling && sdk.getRenderer().isOfType(RendererType.WEBGL);
    return smoothDownscaling || this._hasAdjustments();
  };

  /**
   * Returns the texture for the sprite that should be rendered
   * @return {PhotoEditorSDK.Engine.Texture}
   * @private
   * @abstract
   */


  Sticker.prototype._getTexture = function _getTexture() {
    return this._inputTexture;
  };

  /**
   * Updates this sprite
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Promise}
   */


  Sticker.prototype.update = function update(sdk, inputDimensions) {
    var _options = this._options,
        dimensions = _options.dimensions,
        image = _options.image;

    if (dimensions.equals(_globals.Vector2.NULL)) {
      dimensions.set(image.width, image.height);
    }

    if (this._rendersToRenderTexture(sdk)) {
      this._prepareRenderTexture(sdk);
    }

    // Stickers with adjustments are rendered to a render texture that
    // can be re-used
    if (this._hasAdjustments()) {
      // Apply adjustments
      this._renderTextureSprite.setFilters([this._adjustmentsFilter]);

      var adjustments = this._options.adjustments;
      this._adjustmentsFilter.set({
        brightness: adjustments.getBrightness(),
        saturation: adjustments.getSaturation(),
        contrast: adjustments.getContrast()
      });
    }

    this._updateSprite(inputDimensions);

    if (this._rendersToRenderTexture(sdk)) {
      this._renderToRenderTexture(sdk);
    }
    this._applyFlip();

    return _globals.Promise.resolve();
  };

  /**
   * If flip is enabled, this flips the sprite
   * @private
   */


  Sticker.prototype._applyFlip = function _applyFlip() {
    var scale = this._sprite.getScale();
    if (this._options.flipVertically) {
      scale.y *= -1;
    }
    if (this._options.flipHorizontally) {
      scale.x *= -1;
    }
    this._sprite.setScale(scale);
  };

  /**
   * Applies a flip in the given direction
   * @param  {String} direction
   */


  Sticker.prototype.applyFlip = function applyFlip(direction) {
    _Sprite.prototype.applyFlip.call(this, direction);

    var options = {
      rotation: this._options.rotation
    };

    var degrees = options.rotation / Math.PI * 180;
    var newDegrees = degrees * -1;
    options.rotation = newDegrees * Math.PI / 180;

    switch (direction) {
      case 'horizontal':
        options.flipHorizontally = !this._options.flipHorizontally;
        this.set(options);
        break;
      case 'vertical':
        options.flipVertically = !this._options.flipVertically;
        this.set(options);
        break;
    }
  };

  /**
   * Checks if this sticker has any adjustments and a filter is needed
   * @return {Boolean}
   * @private
   */


  Sticker.prototype._hasAdjustments = function _hasAdjustments() {
    var adjustments = this._options.adjustments;
    return adjustments.getBrightness() !== 0 || adjustments.getSaturation() !== 1 || adjustments.getContrast() !== 1;
  };

  /**
   * Gets called when this sticker's image is updated
   * @private
   */


  Sticker.prototype._onImageUpdate = function _onImageUpdate() {
    this._inputTexture = _globals.Engine.Texture.fromImage(this._options.image);
    this._identitySprite.setTexture(this._inputTexture);
    this._sprite.setTexture(this._inputTexture);
    this.setDirty(true);
  };

  /**
   * Sets the value for the given option, validates it
   * @param {String} optionName
   * @param {*} value
   * @param {Boolean} update = true
   * @override
   */


  Sticker.prototype.setOption = function setOption(optionName, value) {
    var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    _Sprite.prototype.setOption.call(this, optionName, value, update);

    if (optionName === 'image' && this._identitySprite) {
      this._onImageUpdate();
    }
  };

  /**
   * Gets called when options have been changed. Sets this operation to dirty.
   * @private
   */


  Sticker.prototype._onOptionsChange = function _onOptionsChange() {
    var dirtiness = this._dirtiness;
    for (var id in dirtiness) {
      dirtiness[id] = true;
    }
  };

  /**
   * Disposes this sprite
   */


  Sticker.prototype.dispose = function dispose() {
    _Sprite.prototype.dispose.call(this);
    this._inputTexture.getBaseTexture().dispose();
    this._inputTexture = null;
    this._options.adjustments.off('updated', this._onOptionsChange);
  };

  return Sticker;
}(_sprite2.default);

Sticker.prototype.availableOptions = {
  id: { type: OptionType.STRING, default: function _default() {
      return _globals.Utils.getUUID();
    } },
  name: { type: OptionType.STRING, default: '' },
  image: { type: OptionType.OBJECT, required: true },
  position: { type: OptionType.VECTOR2, default: _globals.Vector2.NULL },
  dimensions: { type: OptionType.VECTOR2, default: _globals.Vector2.NULL },
  anchor: { type: OptionType.VECTOR2, default: new _globals.Vector2(0.0, 0.0) },
  pivot: { type: OptionType.VECTOR2, default: new _globals.Vector2(0.5, 0.5) },
  rotation: { type: OptionType.NUMBER, default: 0 },
  flipHorizontally: { type: OptionType.BOOLEAN, default: false },
  flipVertically: { type: OptionType.BOOLEAN, default: false },
  smoothDownscaling: { type: OptionType.BOOLEAN, default: false },
  adjustments: {
    type: OptionType.CONFIGURABLE,
    structure: {
      brightness: { type: OptionType.NUMBER, default: 0 },
      saturation: { type: OptionType.NUMBER, default: 1 },
      contrast: { type: OptionType.NUMBER, default: 1 }
    }
  }
};

exports.default = Sticker;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _sprite = __webpack_require__(36);

var _sprite2 = _interopRequireDefault(_sprite);

var _textRenderer = __webpack_require__(183);

var _textRenderer2 = _interopRequireDefault(_textRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OptionType = _globals.Constants.OptionType,
    RendererType = _globals.Constants.RendererType; /*
                                                     * This file is part of PhotoEditorSDK.
                                                     *
                                                     * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
                                                     * All rights reserved.
                                                     *
                                                     * Redistribution and use in source and binary forms, without
                                                     * modification, are permitted provided that the following license agreement
                                                     * is approved and a legal/financial contract was signed by the user.
                                                     * The license agreement can be found under following link:
                                                     *
                                                     * https://www.photoeditorsdk.com/LICENSE.txt
                                                     */

/**
 * A text that can be drawn by SpriteOperation. Should only be created via {@link PhotoEditorSDK.Operations.SpriteOperation#createText}
 * @class
 * @memberof PhotoEditorSDK.Operations.SpriteOperation
 */
var Text = function (_Sprite) {
  (0, _inherits3.default)(Text, _Sprite);

  /**
   * Creates a new Text
   * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
   * @param  {Object} [options]
   */
  function Text() {
    (0, _classCallCheck3.default)(this, Text);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Sprite.call.apply(_Sprite, [this].concat(args)));

    _this._textRenderer = new _textRenderer2.default(_this, _this._operation);
    _this._sprite.setTexture(_this._textRenderer.getTexture());
    return _this;
  }

  /**
   * Returns a serialized version of this configurable
   * @param {String[]} keys
   * @param {Boolean} toObject = false
   * @return {Object}
   */


  Text.prototype.serializeOptions = function serializeOptions(keys) {
    var toObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var options = _Sprite.prototype.serializeOptions.call(this, keys, toObject);
    if (!keys) options.type = 'text';
    return options;
  };

  /**
   * Returns a style object for this text
   * @param {PhotoEditorSDK} SDK
   * @param {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Object}
   */
  /* istanbul ignore next */


  Text.prototype.getDOMStyle = function getDOMStyle(sdk, inputDimensions) {
    var actualFontSize = this.getFontSize() * inputDimensions.y;

    return {
      fontWeight: this._options.fontWeight,
      fontSize: Math.round(actualFontSize) + 'px',
      fontStyle: this._options.fontStyle,
      fontFamily: this._options.fontFamily,
      lineHeight: Math.round(actualFontSize * this.getLineHeight()) + 'px',
      color: this._options.color.toRGBA(),
      backgroundColor: this._options.backgroundColor.toRGBA(),
      textAlign: this._options.alignment
    };
  };

  /**
   * Returns the bounding box for this text
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {PhotoEditorSDK.Math.Vector2}
   */
  /* istanbul ignore next */


  Text.prototype.getBoundingBox = function getBoundingBox(sdk, inputDimensions) {
    return this._textRenderer.getBoundingBox(sdk, inputDimensions);
  };

  /**
   * Applies a flip in the given direction
   * @param  {String} direction
   */


  Text.prototype.applyFlip = function applyFlip(direction) {
    _Sprite.prototype.applyFlip.call(this, direction);

    var rotation = this._options.rotation;
    switch (direction) {
      case 'horizontal':
        rotation += (Math.PI - rotation) * 2;
        this.setRotation(rotation);
        break;
      case 'vertical':
        rotation += (Math.PI / 2 - rotation) * 2;
        this.setRotation(rotation);
        break;
    }
  };

  /**
   * Applies a crop with the given options
   * @param  {PhotoEditorSDK.Operations.CropOperation} cropOperation
   * @param  {Object} options
   */


  Text.prototype.applyCrop = function applyCrop(cropOperation, options) {
    _Sprite.prototype.applyCrop.call(this, cropOperation, options);
    var oldSize = cropOperation.getEnd().clone().subtract(cropOperation.getStart());
    var newSize = options.end.clone().subtract(options.start);

    var factor = newSize.clone().divide(oldSize);
    var scale = options.scale / cropOperation.getScale();
    this.setFontSize(this.getFontSize() / factor.y * scale);
    this.setMaxWidth(this.getMaxWidth() / factor.x * scale);
  };

  /**
   * Applies a rotation with the given degrees
   * @param  {Number} degrees
   */


  Text.prototype.applyRotation = function applyRotation(degrees) {
    _Sprite.prototype.applyRotation.call(this, degrees);

    var inputDimensions = this._operation.getInputDimensions();
    this.setMaxWidth(this.getMaxWidth() / inputDimensions.x * inputDimensions.y);
    this.setFontSize(this.getFontSize() / inputDimensions.y * inputDimensions.x);
  };

  /**
   * Updates this sprite
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Promise}
   */


  Text.prototype.update = function update(sdk, inputDimensions) {
    // Re-render text
    this._textRenderer.update(sdk, inputDimensions);
    var textTexture = this._textRenderer.getTexture();
    var baseTexture = textTexture.getBaseTexture();
    baseTexture.update();

    // Upload texture
    var renderer = sdk.getRenderer();

    /* istanbul ignore next */
    if (renderer.isOfType(RendererType.WEBGL)) {
      renderer.updateTexture(textTexture.getBaseTexture());
    }

    _Sprite.prototype.update.call(this, sdk, inputDimensions);

    return Promise.resolve();
  };

  /**
   * Returns the texture for the sprite that should be rendered
   * @return {PhotoEditorSDK.Engine.Texture}
   * @private
   * @abstract
   */


  Text.prototype._getTexture = function _getTexture() {
    return this._textRenderer.getTexture();
  };

  /**
   * Cleans up this Sprite
   */


  Text.prototype.dispose = function dispose() {
    _Sprite.prototype.dispose.call(this);
    this._textRenderer.dispose();
  };

  return Text;
}(_sprite2.default);

Text.prototype.availableOptions = {
  id: { type: OptionType.STRING, default: function _default() {
      return _globals.Utils.getUUID();
    } },
  fontSize: { type: OptionType.NUMBER, default: 0.1 },
  lineHeight: { type: OptionType.NUMBER, default: 1.1 },
  fontFamily: { type: OptionType.STRING, default: 'Times New Roman' },
  fontWeight: { type: OptionType.ALL, default: 'normal' },
  fontStyle: { type: OptionType.STRING, default: 'normal' },
  outlineWidth: { type: OptionType.NUMBER, default: 0 },
  outlineColor: { type: OptionType.COLOR, default: _globals.Color.BLACK },
  alignment: { type: OptionType.STRING, default: 'left', available: ['left', 'center', 'right'] },
  verticalAlignment: { type: OptionType.STRING, default: 'top', available: ['top', 'center', 'bottom'] },
  color: { type: OptionType.COLOR, default: new _globals.Color(1, 0, 0, 1) },
  backgroundColor: { type: OptionType.COLOR, default: _globals.Color.TRANSPARENT },
  position: { type: OptionType.VECTOR2, default: new _globals.Vector2(0.5, 0.5) },
  anchor: { type: OptionType.VECTOR2, default: new _globals.Vector2(0, 0) },
  pivot: { type: OptionType.VECTOR2, default: new _globals.Vector2(0.5, 0) },
  rotation: { type: OptionType.NUMBER, default: 0 },
  text: { type: OptionType.STRING, required: true },
  maxWidth: { type: OptionType.NUMBER, default: 0.5 },
  maxHeight: { type: OptionType.NUMBER, default: 0 }
};

exports.default = Text;

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _globals = __webpack_require__(3);

var _textSplitter = __webpack_require__(184);

var _textSplitter2 = _interopRequireDefault(_textSplitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TextRenderer = function () {
  function TextRenderer(text, operation) {
    (0, _classCallCheck3.default)(this, TextRenderer);

    this._text = text;
    this._operation = operation;
    this._textOptions = {};

    this._createCanvas();
    this._createMeasurementCanvas();
    this._createTexture();
  }

  /**
   * Creates the canvas and initializes the text splitter
   * @private
   */


  TextRenderer.prototype._createCanvas = function _createCanvas() {
    this._canvas = _globals.Utils.createCanvas();
    this._context = this._canvas.getContext('2d');
    this._textSplitter = new _textSplitter2.default(this._context);
  };

  /**
   * Creates the canvas that we need for measuring the maximum text height
   * @private
   */


  TextRenderer.prototype._createMeasurementCanvas = function _createMeasurementCanvas() {
    this._measurementCanvas = _globals.Utils.createCanvas();
    this._measurementContext = this._measurementCanvas.getContext('2d');
  };

  /**
   * Creates the texture
   * @private
   */


  TextRenderer.prototype._createTexture = function _createTexture() {
    this._texture = _globals.Engine.Texture.fromCanvas(this._canvas);
  };

  /**
   * Applies the text options on the given context
   * @param  {Object} textOptions
   * @param  {CanvasRenderingContext2D} context
   * @private
   */


  TextRenderer.prototype._applyTextOptions = function _applyTextOptions(textOptions, context) {
    context.font = this._text.getFontWeight() + ' ' + textOptions.fontSize + 'px ' + this._text.getFontFamily();

    context.textBaseline = 'top';
    context.textAlign = this._text.getAlignment();
    context.fillStyle = this._text.getColor().toRGBA();

    context.strokeStyle = this._text.getOutlineColor().toRGBA();
    var outlineWidth = this._text.getOutlineWidth();
    if (outlineWidth > 0) {
      context.lineWidth = outlineWidth;
    }
  };

  /**
   * Iterate over all lines and split them into multiple lines, depending
   * on the width they need
   * @param {Number} maxWidth
   * @return {Array.<string>}
   * @private
   */


  TextRenderer.prototype._buildOutputLines = function _buildOutputLines(maxWidth) {
    this._textSplitter.setText(this._text.getText());
    this._textSplitter.setMaxWidth(maxWidth);
    return this._textSplitter.getLines();
  };

  /**
   * Draws the given line onto context at the given Y position
   * @param  {String} text
   * @param  {Number} y
   * @private
   */


  TextRenderer.prototype._renderTextLine = function _renderTextLine(text, y) {
    var textAlignment = this._text.getAlignment();
    var drawPosition = new _globals.Vector2(0, y); // Left alignment

    switch (textAlignment) {
      case 'center':
        drawPosition.x = this._canvas.width / 2;
        break;
      case 'right':
        drawPosition.x = this._canvas.width;
        break;
    }

    this._context.fillText(text, drawPosition.x, drawPosition.y);
    var outlineWidth = this._text.getOutlineWidth();
    if (outlineWidth > 0) {
      this._context.miterLimit = 2;
      this._context.strokeText(text, drawPosition.x, drawPosition.y);
    }
  };

  /**
   * Renders this sprite
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @returns {Promise}
   */


  TextRenderer.prototype.update = function update(sdk, inputDimensions) {
    var textOptions = this.calculateFontStyles(sdk, inputDimensions);

    var _calculateText2 = this._calculateText(sdk, textOptions, inputDimensions),
        boundingBox = _calculateText2.boundingBox,
        lines = _calculateText2.lines;

    return this._renderText(sdk, boundingBox, lines, textOptions, inputDimensions);
  };

  /**
   * Renders the text
   * @param  {PhotoEditorSDK} sdk
   * @param  {Vector2} boundingBox
   * @param  {Array.<String>} lines
   * @param  {Object} textOptions
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Promise}
   * @private
   */


  TextRenderer.prototype._renderText = function _renderText(sdk, boundingBox, lines, textOptions, inputDimensions) {
    var _this = this;

    return new _globals.Promise(function (resolve, reject) {
      // Resize the canvas
      _this._canvas.width = boundingBox.x;
      _this._canvas.height = boundingBox.y;

      if (_this._text.getMaxHeight()) {
        _this._canvas.height = Math.min(_this._text.getMaxHeight() * inputDimensions.y, _this._canvas.height);
      }

      // Update the context
      _this._context = _this._canvas.getContext('2d');

      // Render background color
      _this._context.fillStyle = _this._text.getBackgroundColor().toRGBA();
      _this._context.fillRect(0, 0, boundingBox.x, boundingBox.y);

      // Apply text options
      _this._applyTextOptions(textOptions, _this._context);

      // Draw lines
      for (var lineNum = 0; lineNum < lines.length; lineNum++) {
        var line = lines[lineNum];
        _this._renderTextLine(line, textOptions.lineHeight * lineNum);
      }

      resolve();
    });
  };

  /**
   * Calculates the actual font size and line height
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   */


  TextRenderer.prototype.calculateFontStyles = function calculateFontStyles(sdk, inputDimensions) {
    var fontFamily = this._text.getFontFamily();
    var fontSize = Math.round(this._text.getFontSize() * inputDimensions.y);
    var lineHeight = Math.round(this._text.getLineHeight() * fontSize);

    var textOptions = { fontFamily: fontFamily, fontSize: fontSize, lineHeight: lineHeight };
    if (this._textOptions.fontFamily !== fontFamily || this._textOptions.fontSize !== fontSize || this._textOptions.lineHeight !== lineHeight) {
      this._maxTextHeight = null;
      this._textOptions = textOptions;
    }

    return textOptions;
  };

  /**
   * Calculates the bounding box and new lines according to max width
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} textOptions
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Object}
   * @private
   */


  TextRenderer.prototype._calculateText = function _calculateText(sdk, textOptions, inputDimensions) {
    // Calculate max width
    var maxWidth = this._text.getMaxWidth() * inputDimensions.x;

    // Apply text options
    this._applyTextOptions(textOptions, this._context);

    // Calculate bounding box
    var boundingBox = new _globals.Vector2();
    var lines = this._text.getText().split('\n');
    if (typeof maxWidth !== 'undefined') {
      // Calculate the bounding box
      boundingBox.x = maxWidth;
      lines = this._buildOutputLines(maxWidth);
    } else {
      for (var lineNum = 0; lineNum < lines.length; lineNum++) {
        var line = lines[lineNum];
        boundingBox.x = Math.max(boundingBox.x, this._context.measureText(line).width);
      }
    }

    // Calculate boundingbox height
    var lineHeight = textOptions.lineHeight;

    var maxTextHeight = this._getMaxTextHeight(sdk, textOptions, inputDimensions) * 1.1; // + 10%

    boundingBox.y += lines.length * lineHeight + (maxTextHeight - lineHeight);

    return { boundingBox: boundingBox, lines: lines };
  };

  /**
   * Returns the maximum text height per line
   * @param  {PhotoEditorSDK} sdk
   * @param {Object} textOptions
   * @param {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Number}
   * @private
   */


  TextRenderer.prototype._getMaxTextHeight = function _getMaxTextHeight(sdk, textOptions, inputDimensions) {
    if (this._maxTextHeight) return this._maxTextHeight;

    this._maxTextHeight = this._getMaxTextHeightUsingDOM(sdk, textOptions, inputDimensions);

    return this._maxTextHeight;
  };

  /**
   * Calculates the maximum text height per line using a DOM element
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} textOptions
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Number}
   * @private
   */


  TextRenderer.prototype._getMaxTextHeightUsingDOM = function _getMaxTextHeightUsingDOM(sdk, textOptions, inputDimensions) {
    var measureElement = document.createElement('span');
    var style = this._text.getDOMStyle(sdk, inputDimensions);
    var blockedProps = ['lineHeight'];
    for (var prop in style) {
      if (blockedProps.indexOf(prop) !== -1) {
        continue;
      }
      measureElement.style[prop] = style[prop];
    }

    measureElement.style.position = 'absolute';
    measureElement.style.left = '-9999px';
    measureElement.style.top = '-9999px';
    measureElement.style.whiteSpace = 'nowrap';

    document.body.appendChild(measureElement);
    measureElement.innerHTML = '!"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';
    var height = measureElement.offsetHeight;
    document.body.removeChild(measureElement);

    return height;
  };

  /**
   * Calculates the maximum text height per line using canvas estimation
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} textOptions
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Number}
   * @private
   */


  TextRenderer.prototype._getMaxTextHeightUsingCanvas = function _getMaxTextHeightUsingCanvas(sdk, textOptions, inputDimensions) {
    var canvas = this._measurementCanvas;
    var context = this._measurementContext;

    var fontSize = textOptions.fontSize;

    canvas.width = fontSize * 10;
    canvas.height = fontSize * 2;

    this._applyTextOptions(textOptions, this._measurementContext);

    context.textBaseline = 'middle';
    context.textAlign = 'center';
    context.fillStyle = 'black';

    context.clearRect(0, 0, canvas.width, canvas.height);
    var chars = '!"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';
    var charsCount = chars.length;
    var pointer = 0;
    while (pointer < charsCount) {
      var printableString = chars.substr(pointer, 5);
      pointer += 5;
      context.fillText(printableString, canvas.width / 2, canvas.height / 2);
    }

    var _context$getImageData = context.getImageData(0, 0, canvas.width, canvas.height),
        data = _context$getImageData.data;

    var y = void 0;
    // Find start Y
    var startY = null;
    for (y = 0; y < canvas.height; y++) {
      var pixelFound = false;
      for (var x = 0; x < canvas.width; x++) {
        var index = (y * canvas.width + x) * 4;
        var color = data[index] + data[index + 1] + data[index + 2] + data[index + 3];
        if (color > 0) {
          pixelFound = true;
          break;
        }
      }

      if (!pixelFound) {
        startY++;
        continue;
      }
      break;
    }

    // Find end Y
    var endY = canvas.height;
    for (y = canvas.height - 1; y >= 0; y--) {
      var _pixelFound = false;
      for (var _x = 0; _x < canvas.width; _x++) {
        var _index = (y * canvas.width + _x) * 4;
        var _color = data[_index] + data[_index + 1] + data[_index + 2] + data[_index + 3];
        if (_color > 0) {
          _pixelFound = true;
          break;
        }
      }

      if (!_pixelFound) {
        endY--;
        continue;
      }
      break;
    }

    this._maxTextHeight = endY - startY;
    return this._maxTextHeight;
  };

  /**
   * Returns this renderer's texture
   * @return {Engine.Texture}
   */


  TextRenderer.prototype.getTexture = function getTexture() {
    return this._texture;
  };

  /**
   * Returns the bounding box for this text
   * @param  {PhotoEditorSDK} sdk
   * @param  {PhotoEditorSDK.Math.Vector2} inputDimensions
   * @return {Vector2}
   */


  TextRenderer.prototype.getBoundingBox = function getBoundingBox(sdk, inputDimensions) {
    var textOptions = this.calculateFontStyles(sdk, inputDimensions);

    var _calculateText3 = this._calculateText(sdk, textOptions, inputDimensions),
        boundingBox = _calculateText3.boundingBox;

    return boundingBox;
  };

  /**
   * Disposes this text renderer
   */


  TextRenderer.prototype.dispose = function dispose() {
    this._texture.getBaseTexture().dispose();
    this._texture = null;
  };

  return TextRenderer;
}();

exports.default = TextRenderer;

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var TextSplitter = function () {
  function TextSplitter(context) {
    (0, _classCallCheck3.default)(this, TextSplitter);

    this._context = context;
    this._lastFontStyle = {};
  }

  /**
   * Returns the lines that fit the maxWidth
   * @return {Array.<String>}
   */


  TextSplitter.prototype.getLines = function getLines() {
    var lines = [];
    var newLineWords = [];

    // Iterate over lines
    var linesCount = this._lines.length;
    for (var l = 0; l < linesCount; l++) {
      var line = this._lines[l];

      // Iterate over words
      var words = this._buildWords(line);
      var wordsCount = words.length;
      for (var w = 0; w < wordsCount; w++) {
        var word = words[w];

        // Check if line is too wide for the maxwidth
        var currentLine = newLineWords.concat(word).join('').replace(/\s+$/i, '');
        var width = this._getWidth(currentLine);
        if (width > this._maxWidth) {
          // If there have been words before this one, start
          // a new line
          if (newLineWords.length > 0) {
            // Line too long -> line ended
            lines.push(newLineWords.join(''));

            // Start a new line with the word
            newLineWords = [word];
          }

          // If the next word is too long (without trailing spaces), split it up
          var _word = word.replace(/\s+$/i, '');
          if (this._getWidth(_word) > this._maxWidth) {
            var splitWord = this._splitWord(word);
            lines = lines.concat(splitWord.lines);
            if (splitWord.rest) {
              newLineWords = [splitWord.rest];
            }
          }
        } else {
          newLineWords.push(word);
        }
      }

      lines.push(newLineWords.join(''));
      newLineWords = [];
    }

    return lines;
  };

  /**
   * Builds an array of words from the given line
   * @param  {String} line
   * @return {Array.<String>}
   * @private
   */


  TextSplitter.prototype._buildWords = function _buildWords(line) {
    var words = [];
    var word = '';

    var len = line.length;
    for (var i = 0; i < len; i++) {
      var char = line[i];
      word += char;
      if (char === ' ' || char === '-' || i === len - 1) {
        words.push(word);
        word = '';
      }
    }

    return words;
  };

  /**
   * Splits up the given word to fit the max width
   * @param  {String} word
   * @return {Object}
   * @private
   */


  TextSplitter.prototype._splitWord = function _splitWord(word) {
    var response = {
      lines: [],
      rest: null
    };

    var wordLength = word.length;
    var chars = [];
    for (var c = 0; c < wordLength; c++) {
      var char = word[c];
      if (this._getWidth(chars.concat(char).join('')) > this._maxWidth) {
        if (chars.length > 0) {
          response.lines.push(chars.join(''));
        }
        chars = [char];
      } else {
        chars.push(char);
      }

      if (c === wordLength - 1 && chars.length > 0) {
        response.rest = chars.join('');
      }
    }

    return response;
  };

  /**
   * Checks if the font style changed from the last call
   * @return {Boolean}
   * @private
   */


  TextSplitter.prototype._fontStyleChanged = function _fontStyleChanged() {
    if (this._context.font !== this._lastFontStyle) {
      this._lastFontStyle = this._context.font;
      return true;
    }
    return false;
  };

  /**
   * Returns the measured width for the given string
   * @param  {String} string
   * @return {Number}
   * @private
   */


  TextSplitter.prototype._getWidth = function _getWidth(string) {
    return this._context.measureText(string).width;
  };

  /**
   * Sets the text
   * @param {String} text
   */


  TextSplitter.prototype.setText = function setText(text) {
    this._text = text;
    this._lines = text.split('\n');
  };

  /**
   * Sets the max width
   * @param {Number} maxWidth
   */


  TextSplitter.prototype.setMaxWidth = function setMaxWidth(maxWidth) {
    this._maxWidth = maxWidth;
  };

  return TextSplitter;
}();

exports.default = TextSplitter;

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(0);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(2);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(1);

var _inherits3 = _interopRequireDefault(_inherits2);

var _globals = __webpack_require__(3);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 */

var OptionType = _globals.Constants.OptionType;

/**
 * An operation that can draw a watermark on top of the image
 * @class
 * @extends PhotoEditorSDK.Operation
 * @memberof PhotoEditorSDK.Operations
 */

var WatermarkOperation = function (_Operation) {
  (0, _inherits3.default)(WatermarkOperation, _Operation);

  /**
   * Creates a new WatermarkOperation
   * @param  {PhotoEditorSDK} sdk
   * @param  {Object} [options]
   */
  function WatermarkOperation() {
    (0, _classCallCheck3.default)(this, WatermarkOperation);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));

    _this._watermarkSprite = new _globals.Engine.Sprite();
    _this._watermarkSprite.setAnchor(0.5, 0.5);
    _this._container.addChild(_this._watermarkSprite);
    return _this;
  }

  /**
   * Renders the watermark
   * @param  {PhotoEditorSDK.Engine.Texture} inputTexture
   * @private
   * @override
   */


  WatermarkOperation.prototype._render = function _render(inputTexture) {
    if (!this._watermarkTexture) {
      this._watermarkTexture = _globals.Engine.Texture.fromImage(this._options.image);
      this._watermarkSprite.setTexture(this._watermarkTexture);
    }

    var textureDimensions = inputTexture.getDimensions();

    var _options$image = this._options.image,
        width = _options$image.width,
        height = _options$image.height;

    var dimensions = _globals.Utils.resizeVectorToFit(new _globals.Vector2(width, height), textureDimensions);
    this._watermarkSprite.setPosition(textureDimensions.clone().divide(2));
    this._watermarkSprite.setWidth(dimensions.x);
    this._watermarkSprite.setHeight(dimensions.y);

    this._renderTexture.render(this._container);

    return _globals.Promise.resolve();
  };

  /**
   * Disposes this operation
   */


  WatermarkOperation.prototype.dispose = function dispose() {
    _Operation.prototype.dispose.call(this);
    this._watermarkSprite.dispose();
  };

  return WatermarkOperation;
}(_operation2.default);

/**
 * A unique string that identifies this operation. Can be used to select
 * operations.
 * @type {String}
 * @default
 */


WatermarkOperation.identifier = 'watermark';

/**
 * Specifies the available options for this operation
 * @type {Object}
 * @ignore
 */
WatermarkOperation.prototype.availableOptions = {
  image: { type: OptionType.OBJECT, required: true }
};

exports.default = WatermarkOperation;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 * requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel
 * MIT license
 * @license
 */
var root = typeof window === 'undefined' ? global : window;
var rAF = root.requestAnimationFrame;
var cAF = root.cancelAnimationFrame;

var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
for (var x = 0; x < vendors.length && !rAF; ++x) {
  exports.requestAnimationFrame = rAF = root[vendors[x] + 'RequestAnimationFrame'];
  exports.cancelAnimationFrame = cAF = root[vendors[x] + 'CancelAnimationFrame'] || root[vendors[x] + 'CancelRequestAnimationFrame'];
}

/* istanbul ignore next */
if (!rAF) {
  exports.requestAnimationFrame = rAF = function rAF(callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}

/* istanbul ignore next */
if (!cAF) {
  exports.cancelAnimationFrame = cAF = function cAF(id) {
    clearTimeout(id);
  };
}

exports.requestAnimationFrame = rAF;
exports.cancelAnimationFrame = cAF;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(98)))

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(194), __esModule: true };

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(195), __esModule: true };

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(196), __esModule: true };

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(198), __esModule: true };

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(199), __esModule: true };

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(200), __esModule: true };

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";

exports.__esModule = true;

var _isIterable2 = __webpack_require__(188);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(187);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(64);
__webpack_require__(63);
module.exports = __webpack_require__(221);

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(64);
__webpack_require__(63);
module.exports = __webpack_require__(222);

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(224);
var $Object = __webpack_require__(13).Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(225);
var $Object = __webpack_require__(13).Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(226);
module.exports = __webpack_require__(13).Object.setPrototypeOf;

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(228);
__webpack_require__(227);
__webpack_require__(229);
__webpack_require__(230);
module.exports = __webpack_require__(13).Symbol;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(63);
__webpack_require__(64);
module.exports = __webpack_require__(62).f('iterator');

/***/ },
/* 201 */
/***/ function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ },
/* 202 */
/***/ function(module, exports) {

module.exports = function(){ /* empty */ };

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(20)
  , toLength  = __webpack_require__(218)
  , toIndex   = __webpack_require__(217);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(40)
  , gOPS    = __webpack_require__(94)
  , pIE     = __webpack_require__(55);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(15).document && document.documentElement;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(50);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(50);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var create         = __webpack_require__(54)
  , descriptor     = __webpack_require__(41)
  , setToStringTag = __webpack_require__(56)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(26)(IteratorPrototype, __webpack_require__(14)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ },
/* 209 */
/***/ function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(40)
  , toIObject = __webpack_require__(20);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

var META     = __webpack_require__(42)('meta')
  , isObject = __webpack_require__(31)
  , has      = __webpack_require__(18)
  , setDesc  = __webpack_require__(19).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(39)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(19)
  , anObject = __webpack_require__(25)
  , getKeys  = __webpack_require__(40);

module.exports = __webpack_require__(17) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(20)
  , gOPN      = __webpack_require__(93).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(18)
  , toObject    = __webpack_require__(219)
  , IE_PROTO    = __webpack_require__(57)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(31)
  , anObject = __webpack_require__(25);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(88)(Function.call, __webpack_require__(92).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(59)
  , defined   = __webpack_require__(51);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(59)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(59)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(51);
module.exports = function(it){
  return Object(defined(it));
};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(87)
  , ITERATOR  = __webpack_require__(14)('iterator')
  , Iterators = __webpack_require__(32);
module.exports = __webpack_require__(13).getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(25)
  , get      = __webpack_require__(220);
module.exports = __webpack_require__(13).getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(87)
  , ITERATOR  = __webpack_require__(14)('iterator')
  , Iterators = __webpack_require__(32);
module.exports = __webpack_require__(13).isIterable = function(it){
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
var addToUnscopables = __webpack_require__(202)
  , step             = __webpack_require__(209)
  , Iterators        = __webpack_require__(32)
  , toIObject        = __webpack_require__(20);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(91)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

var $export = __webpack_require__(30)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(54)});

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

var $export = __webpack_require__(30);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(17), 'Object', {defineProperty: __webpack_require__(19).f});

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(30);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(215).set});

/***/ },
/* 227 */
/***/ function(module, exports) {



/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
// ECMAScript 6 symbols shim
var global         = __webpack_require__(15)
  , has            = __webpack_require__(18)
  , DESCRIPTORS    = __webpack_require__(17)
  , $export        = __webpack_require__(30)
  , redefine       = __webpack_require__(96)
  , META           = __webpack_require__(211).KEY
  , $fails         = __webpack_require__(39)
  , shared         = __webpack_require__(58)
  , setToStringTag = __webpack_require__(56)
  , uid            = __webpack_require__(42)
  , wks            = __webpack_require__(14)
  , wksExt         = __webpack_require__(62)
  , wksDefine      = __webpack_require__(61)
  , keyOf          = __webpack_require__(210)
  , enumKeys       = __webpack_require__(204)
  , isArray        = __webpack_require__(207)
  , anObject       = __webpack_require__(25)
  , toIObject      = __webpack_require__(20)
  , toPrimitive    = __webpack_require__(60)
  , createDesc     = __webpack_require__(41)
  , _create        = __webpack_require__(54)
  , gOPNExt        = __webpack_require__(213)
  , $GOPD          = __webpack_require__(92)
  , $DP            = __webpack_require__(19)
  , $keys          = __webpack_require__(40)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(93).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(55).f  = $propertyIsEnumerable;
  __webpack_require__(94).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(53)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(26)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(61)('asyncIterator');

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(61)('observable');

/***/ },
/* 231 */
/***/ function(module, exports) {

module.exports = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nuniform vec4 u_color;\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(mix(color.rgb, u_color.rgb, u_color.a), color.a) * color.a;\n}\n"

/***/ },
/* 232 */
/***/ function(module, exports) {

module.exports = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(color.a > 0. ? color.rgb / color.a : vec3(0), color.a);\n}\n"

/***/ },
/* 233 */
/***/ function(module, exports) {

module.exports = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = texture2D(u_image, v_texCoord) * v_color;\n}\n"

/***/ },
/* 234 */
/***/ function(module, exports) {

module.exports = "attribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\nuniform mat3 u_projMatrix;\n\nvoid main() {\n  gl_Position = vec4((u_projMatrix * vec3(a_position, 1)).xy, 0, 1);\n  v_texCoord = a_texCoord;\n  v_color = vec4(a_color.rgb * a_color.a, a_color.a);\n}\n"

/***/ },
/* 235 */
/***/ function(module, exports) {

module.exports = "/*\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n * @license\n */\n\nuniform sampler2D u_image;\nuniform float u_blurRadius;\nuniform float u_gradientSize;\nuniform float u_size;\nuniform vec2 u_start;\nuniform vec2 u_end;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n\n    vec2 normal = normalize(vec2(u_start.y - u_end.y, u_end.x - u_start.x));\n    float radius = smoothstep(0.0, 1.0,\n      (abs(\n        dot(v_texCoord * u_texSize - u_start, normal)\n      ) - u_size) / u_gradientSize\n    ) * u_blurRadius;\n\n    for (float t = -30.0; t <= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n"

/***/ },
/* 236 */
/***/ function(module, exports) {

module.exports = "/*\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n * @license\n */\n\nuniform sampler2D u_image;\nuniform float u_radius;\nuniform float u_blurRadius;\nuniform float u_gradientRadius;\nuniform vec2 u_position;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n    float radius = smoothstep(\n      0.0, 1.0,\n      (abs(\n        distance(v_texCoord * u_texSize, u_position)\n      ) - u_radius) / (u_gradientRadius * 2.0)\n    ) * u_blurRadius;\n    for (float t = -30.0; t <= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n"

/***/ },
/* 237 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_brightness;\nuniform float u_saturation;\nuniform float u_contrast;\nuniform float u_gamma;\nuniform float u_exposure;\nuniform float u_shadows;\nuniform float u_highlights;\n\nconst vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n\n  vec4 color = texColor;\n\n  // Apply gamma\n  color.rgb = pow(color.rgb, vec3(1.0 / u_gamma));\n\n  // Apply shadows and highlights\n  float luminance = dot(color.rgb, luminanceWeighting);\n  float shadow = clamp((pow(luminance, 1.0/(u_shadows+1.0)) + (-0.76)*pow(luminance, 2.0/(u_shadows+1.0))) - luminance, 0.0, 1.0);\n  float highlight = clamp((1.0 - (pow(1.0-luminance, 1.0/(2.0-u_highlights)) + (-0.8)*pow(1.0-luminance, 2.0/(2.0-u_highlights)))) - luminance, -1.0, 0.0);\n  color.rgb = (luminance + shadow + highlight) * (color.rgb / luminance );\n\n  // Apply exposure\n  color.rgb = color.rgb * pow(2.0, u_exposure);\n\n  // Apply brightness\n  color.rgb = (color.rgb + u_brightness);\n\n  // Apply saturation\n  vec3 greyScaleColor = vec3(luminance);\n  color.rgb = mix(greyScaleColor, color.rgb, u_saturation);\n\n  // Apply contrast\n  color.rgb = (color.rgb - 0.5) * u_contrast + 0.5;\n\n  // Apply alpha\n  color = vec4(color.rgb * texColor.a, texColor.a);\n\n  gl_FragColor = color;\n}\n"

/***/ },
/* 238 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_filteredImage;\nuniform float u_intensity;\n\nvoid main() {\n  vec4 color0 = texture2D(u_image, v_texCoord);\n  vec4 color1 = texture2D(u_filteredImage, v_texCoord);\n  gl_FragColor = mix(color0, color1, u_intensity);\n}\n"

/***/ },
/* 239 */
/***/ function(module, exports) {

module.exports = "/*\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n * @license\n */\n\nuniform sampler2D u_image;\nuniform float u_blurRadius;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n\n    float radius = u_blurRadius;\n\n    for (float t = -30.0; t <= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n"

/***/ },
/* 240 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_clarity;\nuniform vec2 u_texSize;\n\nfloat random(vec3 scale, float seed) {\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main() {\n  vec4 original = texture2D(u_image, v_texCoord);\n\n  vec4 color = texture2D(u_image, v_texCoord);\n  color +=  texture2D(u_image, v_texCoord + vec2(-1.0, 0.0) * u_texSize);\n  color +=  texture2D(u_image, v_texCoord + vec2(1.0, 0.0) * u_texSize);\n\n  color +=  texture2D(u_image, v_texCoord + vec2(0.0, 1.0) * u_texSize);\n  color +=  texture2D(u_image, v_texCoord + vec2(-1.0, 1.0) * u_texSize);\n  color +=  texture2D(u_image, v_texCoord + vec2(1.0, 1.0) * u_texSize);\n\n  color +=  texture2D(u_image, v_texCoord + vec2(0.0, -1.0) * u_texSize);\n  color +=  texture2D(u_image, v_texCoord + vec2(-1.0, -1.0) * u_texSize);\n  color +=  texture2D(u_image, v_texCoord + vec2(1.0, -1.0) * u_texSize);\n\n  // apply unsharp mask\n  vec4 blurred = color / 9.0;\n  color = mix(blurred, original, 1.0 + u_clarity);\n\n  // desaturation, to emphesize the effect\n  vec3 grayXfer = vec3(0.3, 0.59, 0.11);\n  vec3 gray = vec3(dot(grayXfer, color.xyz));\n  float desaturation = clamp(u_clarity * 0.13, 0.0, 1.0);\n  gl_FragColor = vec4(mix(color.xyz, gray, desaturation) * color.a, color.a);\n}\n"

/***/ },
/* 241 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_filterImage;\nuniform sampler2D u_maskImage;\n\nvoid main() {\n  vec4 color0 = texture2D(u_image, v_texCoord);\n  vec4 color1 = texture2D(u_filterImage, v_texCoord);\n  vec4 mask = texture2D(u_maskImage, v_texCoord);\n  gl_FragColor = mix(color0, color1, mask);\n}\n"

/***/ },
/* 242 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_brightness;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4((texColor.rgb + vec3(u_brightness) * texColor.a), texColor.a);;\n}\n"

/***/ },
/* 243 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform mat4 u_colormatrix;\nuniform vec4 u_colormatrix_vec;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = texColor * u_colormatrix + u_colormatrix_vec;\n}\n"

/***/ },
/* 244 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_contrast;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(((texColor.rgb - vec3(0.5)) * u_contrast + vec3(0.5) * texColor.a), texColor.a);\n}\n"

/***/ },
/* 245 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_desaturation;\n\nconst vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec3 grayXfer = vec3(0.3, 0.59, 0.11);\n  vec3 gray = vec3(dot(grayXfer, texColor.xyz));\n  gl_FragColor = vec4(mix(texColor.xyz, gray, u_desaturation) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 246 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform vec3 u_gamma;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec3 rgb = vec3(texColor.r, texColor.g, texColor.b);\n  rgb = pow(rgb, u_gamma);\n  gl_FragColor = vec4(rgb * texColor.a, texColor.a);;\n}\n"

/***/ },
/* 247 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nuniform vec3 u_color;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n\n  vec2 textureCoord = v_texCoord - vec2(0.5, 0.5);\n  textureCoord /= 0.75;\n\n  float d = 1.0 - dot(textureCoord, textureCoord);\n  d = clamp(d, 0.2, 1.0);\n  vec3 newColor = texColor.rgb * d * u_color.rgb;\n  gl_FragColor = vec4(vec3(newColor) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 248 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  texColor.b = texColor.g * 0.33;\n  texColor.r = texColor.r * 0.6;\n  texColor.b += texColor.r * 0.33;\n  texColor.g = texColor.g * 0.7;\n  gl_FragColor = texColor;\n}\n"

/***/ },
/* 249 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nvec3 W = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float luminance = dot(texColor.rgb, W);\n  gl_FragColor = vec4(vec3(luminance) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 250 */
/***/ function(module, exports) {

module.exports = "/**\n * Based off of GPUImage's LookupFilter:\n * https://github.com/BradLarson/GPUImage/blob/master/framework/Source/GPUImageLookupFilter.m\n */\n\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_lookupTable;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float blueColor = texColor.b * 63.0;\n\n  vec2 quad1;\n  quad1.y = floor(floor(blueColor) / 8.0);\n  quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\n  vec2 quad2;\n  quad2.y = floor(ceil(blueColor) / 8.0);\n  quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\n  vec2 texCoord1;\n  texCoord1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.r);\n  texCoord1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.g);\n\n  vec2 texCoord2;\n  texCoord2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.r);\n  texCoord2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.g);\n\n  vec4 newColor1 = texture2D(u_lookupTable, texCoord1);\n  vec4 newColor2 = texture2D(u_lookupTable, texCoord2);\n\n  vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n  gl_FragColor = mix(texColor, vec4(newColor.rgb, texColor.w), texColor.a);\n}\n"

/***/ },
/* 251 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_lookupTable;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float r = texture2D(u_lookupTable, vec2(texColor.r, 0.0)).r;\n  float g = texture2D(u_lookupTable, vec2(texColor.g, 0.0)).g;\n  float b = texture2D(u_lookupTable, vec2(texColor.b, 0.0)).b;\n\n  gl_FragColor = vec4(vec3(r, g, b) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 252 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_saturation;\n\nconst vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float luminance = dot(texColor.rgb, luminanceWeighting);\n\n  vec3 greyScaleColor = vec3(luminance);\n\n  gl_FragColor = vec4(mix(greyScaleColor, texColor.rgb, u_saturation) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 253 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform vec3 u_color;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec4 overlayVec4 = vec4(u_color, texColor.a);\n  gl_FragColor = max(overlayVec4 * texColor.a, texColor);\n}\n"

/***/ },
/* 254 */
/***/ function(module, exports) {

module.exports = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float gray = texColor.r * 0.3 + texColor.g * 0.3 + texColor.b * 0.3;\n  gray -= 0.2;\n  gray = clamp(gray, 0.0, 1.0);\n  gray += 0.15;\n  gray *= 1.4;\n  gl_FragColor = vec4(vec3(gray) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 255 */
/***/ function(module, exports) {

// stats.js - http://github.com/mrdoob/stats.js
var Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel("FPS","#0ff","#002")),f=h(new Stats.Panel("MS","#0f0","#020"));
if(self.performance&&self.performance.memory)var t=h(new Stats.Panel("MB","#f08","#201"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};
Stats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=f;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,
v){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+" "+h+" ("+e(c)+"-"+e(g)+")",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};"object"===typeof module&&(module.exports=Stats);


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var _sdk = __webpack_require__(100);

var _sdk2 = _interopRequireDefault(_sdk);

var _math = __webpack_require__(67);

var Math = _interopRequireWildcard(_math);

var _operations = __webpack_require__(69);

var Operations = _interopRequireWildcard(_operations);

var _filters = __webpack_require__(99);

var Filters = _interopRequireWildcard(_filters);

var _primitives = __webpack_require__(5);

var FilterPrimitives = _interopRequireWildcard(_primitives);

var _engine = __webpack_require__(12);

var _engine2 = _interopRequireDefault(_engine);

var _color = __webpack_require__(11);

var _color2 = _interopRequireDefault(_color);

var _filter = __webpack_require__(4);

var _filter2 = _interopRequireDefault(_filter);

var _operation = __webpack_require__(10);

var _operation2 = _interopRequireDefault(_operation);

var _eventEmitter = __webpack_require__(28);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _utils = __webpack_require__(21);

var _utils2 = _interopRequireDefault(_utils);

var _operationsStack = __webpack_require__(68);

var _operationsStack2 = _interopRequireDefault(_operationsStack);

var _exif = __webpack_require__(43);

var _exif2 = _interopRequireDefault(_exif);

var _promise = __webpack_require__(7);

var _promise2 = _interopRequireDefault(_promise);

var _configurable = __webpack_require__(16);

var _configurable2 = _interopRequireDefault(_configurable);

var _log = __webpack_require__(22);

var _log2 = _interopRequireDefault(_log);

var _constants = __webpack_require__(9);

var _base = __webpack_require__(27);

var _base2 = _interopRequireDefault(_base);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The current version of the SDK
 * @name PhotoEditorSDK.version
 * @internal Keep in sync with package.json
 */
_sdk2.default.version = __webpack_require__(70).version;

// Namespaces
/*
 * This file is part of PhotoEditorSDK.
 *
 * Copyright (C) 2016-2017 9elements GmbH <contact@9elements.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, without
 * modification, are permitted provided that the following license agreement
 * is approved and a legal/financial contract was signed by the user.
 * The license agreement can be found under following link:
 *
 * https://www.photoeditorsdk.com/LICENSE.txt
 * @license
 */

_sdk2.default.Math = Math;

_sdk2.default.Operations = Operations;

_sdk2.default.Filters = Filters;

_sdk2.default.FilterPrimitives = FilterPrimitives;

_sdk2.default.Engine = _engine2.default;

// Classes

_sdk2.default.Color = _color2.default;

_sdk2.default.Filter = _filter2.default;

_sdk2.default.Operation = _operation2.default;

_sdk2.default.EventEmitter = _eventEmitter2.default;

_sdk2.default.Utils = _utils2.default;

_sdk2.default.OperationsStack = _operationsStack2.default;

_sdk2.default.EXIF = _exif2.default;

_sdk2.default.Promise = _promise2.default;

_sdk2.default.Configurable = _configurable2.default;

_sdk2.default.Log = _log2.default;

// Constants

_sdk2.default.RenderType = _constants.RenderType;
_sdk2.default.ImageFormat = _constants.ImageFormat;
_sdk2.default.OptionType = _constants.OptionType;

// Libs

_sdk2.default.Base64 = _base2.default;

module.exports = _sdk2.default;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA4OWFlNzc5MDBiZWM0YWQ2NDVmZiIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovLy8uL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vLi92ZW5kb3IvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL2xpYi9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL2xpYi9jb25maWd1cmFibGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vc2hhcmVkL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvbWF0aC92ZWN0b3IyLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2V2ZW50LWVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3RleHR1cmVzL2Jhc2UtdGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvdXRpbHMvY2FudmFzLXJlbmRlci10YXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3V0aWxzL3dlYmdsLXJlbmRlci10YXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL21hdGgvY29sb3ItbWF0cml4LmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvc3ByaXRlcy9zcHJpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vdmVuZG9yL3N0YWNrLWJsdXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZXhpZi5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZGlzcGxheS9kaXNwbGF5LW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZmlsdGVycy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL21hbmFnZXJzL2NhbnZhcy1maWx0ZXItbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvbWFuYWdlcnMvd2ViZ2wtZmlsdGVyLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3NoYWRlcnMvc2hhZGVyLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9zaGFkZXJzL3RleHR1cmUtc2hhZGVyLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbGliL21hdGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbGliL29wZXJhdGlvbnMtc3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L3BhY2thZ2UuanNvbiIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZGlzcGxheS9jb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3JlbmRlcmVycy9iYXNlLXJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9yZW5kZXJlcnMvd2ViZ2wvb2JqZWN0LXJlbmRlcmVycy9vYmplY3QtcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3RleHR1cmVzL3RleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3V0aWxzL2NvbnRleHQtcGVyZm9ybWFuY2UtaG9vay5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvdXRpbHMvcGl4ZWwtYXJyYXktaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2dsLXV0aWxzLmpzIiwid2VicGFjazovLy8uL2xpYi9tYXRoL21hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvbWF0aC9yZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3BlcmZvcm1hbmNlLXRlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9hZGp1c3RtZW50cy9hZGp1c3RtZW50cy1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2lkZW50aXR5LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9sb29rdXAtdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9zcHJpdGVzL2JydXNoLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3Nkay5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZmlsdGVycy9jb2xvci1vdmVybGF5LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZmlsdGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZmlsdGVycy91bnByZW11bHRpcGx5LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvcmVuZGVyZXJzL2NhbnZhcy9jYW52YXMtcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3JlbmRlcmVycy93ZWJnbC9vYmplY3QtcmVuZGVyZXJzL3Nwcml0ZS1yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvcmVuZGVyZXJzL3dlYmdsL3dlYmdsLXJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9zaGFkZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9zcHJpdGVzL3Nwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvdGV4dHVyZXMvcmVuZGVyLXRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3V0aWxzL3F1YWQuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3V0aWxzL3RleHR1cmUtdXZzLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS91dGlscy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvdXRpbHMvd2ViZ2wvd2ViZ2wtbWVtb3J5LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2FycmF5LXN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvaW1hZ2UtZXhwb3J0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2xpY2Vuc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvbm9kZS1nbC1leHBvcnRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcG90LXJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2xpYi92ZXJzaW9uLWNoZWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9hZGp1c3RtZW50cy1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9hZGp1c3RtZW50cy9jbGFyaXR5LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2Nyb3Atb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZXhpZi1vcmllbnRhdGlvbi1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXItb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9hMTUtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9icmVlemUtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9idy1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2J3aGFyZC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2NlbHNpdXMtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9jaGVzdC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpeGllLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvZm9vZC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZyaWRnZS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2Zyb250LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvZ2xhbS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2dvYmJsaW4tZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9rMS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2syLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvazYtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9rZHluYW1pYy1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2xlbmluLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvbG9tby1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2x1dC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL21lbGxvdy1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL21ldGFsLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvbW9ybmluZy1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL29yY2hpZC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3BvbGEtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wb2xhNjY5LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy1zdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9icmlnaHRuZXNzLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2NvbG9yLW1hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9jb250cmFzdC5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9kZXNhdHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZ2FtbWEuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZ2xvdy5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9nb2JibGluLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2dyYXlzY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9sb29rdXAtdGFibGUtaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvc2F0dXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9zb2Z0LWNvbG9yLW92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvdG9uZS1jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy94NDAwLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9xdW96aS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3NlbWlyZWQtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9zdW5ueS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3RleGFzLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMveDQwMC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9mb2N1cy9saW5lYXItZm9jdXMtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZm9jdXMvcmFkaWFsLWZvY3VzLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZyYW1lLW9wZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2xpbmVhci1mb2N1cy1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9vcmllbnRhdGlvbi1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9yYWRpYWwtZm9jdXMtb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvc2VsZWN0aXZlLWJsdXItb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvc2hhcmVkL2JsdXItZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvc2hhcmVkL21hc2stZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvc3ByaXRlLW9wZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3Nwcml0ZXMvYnJ1c2gvY29udHJvbC1wb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3Nwcml0ZXMvYnJ1c2gvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3Nwcml0ZXMvc3RpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3Nwcml0ZXMvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3Nwcml0ZXMvdGV4dC90ZXh0LXJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvc3ByaXRlcy90ZXh0L3RleHQtc3BsaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy93YXRlcm1hcmstb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uLi9zaGFyZWQvYW5pbWF0aW9uLWZyYW1lLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8vaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9maWx0ZXJzL3NvdXJjZS9jb2xvci1vdmVybGF5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL2ZpbHRlcnMvc291cmNlL3VucHJlbXVsdGlwbHkuZnJhZyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvc2hhZGVycy9zb3VyY2UvdGV4dHVyZS5mcmFnIiwid2VicGFjazovLy8uL2VuZ2luZS9zaGFkZXJzL3NvdXJjZS90ZXh0dXJlLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc2hhZGVycy9mb2N1cy9saW5lYXItZm9jdXMuZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL2ZvY3VzL3JhZGlhbC1mb2N1cy5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvZ2VuZXJpYy9hZGp1c3RtZW50cy5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvZ2VuZXJpYy9ibGVuZC5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvZ2VuZXJpYy9ibHVyLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc2hhZGVycy9nZW5lcmljL2NsYXJpdHkuZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL2dlbmVyaWMvbWFzay5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9icmlnaHRuZXNzLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc2hhZGVycy9wcmltaXRpdmVzL2NvbG9yLW1hdHJpeC5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9jb250cmFzdC5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9kZXNhdHVyYXRpb24uZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL3ByaW1pdGl2ZXMvZ2FtbWEuZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL3ByaW1pdGl2ZXMvZ2xvdy5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9nb2JibGluLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc2hhZGVycy9wcmltaXRpdmVzL2dyYXlzY2FsZS5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9sb29rdXAtdGFibGUtaW1hZ2UuZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL3ByaW1pdGl2ZXMvbG9va3VwLXRhYmxlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc2hhZGVycy9wcmltaXRpdmVzL3NhdHVyYXRpb24uZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL3ByaW1pdGl2ZXMvc29mdC1jb2xvci1vdmVybGF5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc2hhZGVycy9wcmltaXRpdmVzL3g0MDAuZnJhZyIsIndlYnBhY2s6Ly8vL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vc3RhdHMuanMvYnVpbGQvc3RhdHMubWluLmpzIiwid2VicGFjazovLy8uL2luZGV4LmpzIl0sIm5hbWVzIjpbInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiQ29uc3RhbnRzIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJuYW1lIiwidW5kZWZpbmVkIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJmdW5jTmFtZVJlZ2V4IiwicmVzdWx0cyIsImV4ZWMiLCJ0b1N0cmluZyIsImxlbmd0aCIsInRyaW0iLCJzZXQiLCJ2YWx1ZSIsIkVuZ2luZSIsIkV2ZW50RW1pdHRlciIsIlV0aWxzIiwiQ29uZmlndXJhYmxlIiwiQ29sb3IiLCJMb2ciLCJQcm9taXNlIiwiR0xVdGlscyIsIkJhc2U2NCIsIkxpY2Vuc2luZyIsIk9wdGlvblR5cGUiLCJGaWx0ZXIiLCJvcHRpb25zIiwiaW50ZW5zaXR5IiwidHlwZSIsIk5VTUJFUiIsImRlZmF1bHQiLCJzZXR0ZXIiLCJfc3RhY2siLCJzZXRJbnRlbnNpdHkiLCJkaXJ0eSIsIkJPT0xFQU4iLCJfb3B0aW9ucyIsInJlbmRlciIsInNkayIsImlucHV0VGV4dHVyZSIsIm91dHB1dFRleHR1cmUiLCJ0aGVuIiwicmVzcG9uc2UiLCJzZXREaXJ0eSIsInNldERpcnR5Rm9yUmVuZGVyZXIiLCJyZW5kZXJlciIsImRpc3Bvc2VSZW5kZXJUZXh0dXJlcyIsImRpc3Bvc2UiLCJpZGVudGlmaWVyIiwiaXNJZGVudGl0eSIsImRpc3BsYXlOYW1lIiwiUHJpbWl0aXZlc1N0YWNrIiwiZXhwb3J0cyIsIkJBVENIX1NJWkUiLCJWRVJURVhfU0laRSIsIlZFUlRFWF9CWVRFX1NJWkUiLCJNYXRyaXgiLCJWZWN0b3IyIiwiUmVjdGFuZ2xlIiwiVU1EIiwiY29udGV4dCIsImRlZmluaXRpb24iLCJtb2R1bGUiLCJkZWZpbmUiLCIkQU1EJCIsImdsb2JhbCIsIkRFRiIsImJ1aWx0SW5Qcm9wIiwiY3ljbGUiLCJzY2hlZHVsaW5nX3F1ZXVlIiwiVG9TdHJpbmciLCJ0aW1lciIsInNldEltbWVkaWF0ZSIsImZuIiwic2V0VGltZW91dCIsIm9iaiIsInZhbCIsImNvbmZpZyIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZXJyIiwiUXVldWUiLCJmaXJzdCIsImxhc3QiLCJpdGVtIiwiSXRlbSIsInNlbGYiLCJuZXh0IiwiYWRkIiwiZHJhaW4iLCJmIiwiY2FsbCIsInNjaGVkdWxlIiwiaXNUaGVuYWJsZSIsIm8iLCJfdGhlbiIsIm9fdHlwZSIsIm5vdGlmeSIsImkiLCJjaGFpbiIsIm5vdGlmeUlzb2xhdGVkIiwic3RhdGUiLCJzdWNjZXNzIiwiZmFpbHVyZSIsImNiIiwicmV0IiwicmVqZWN0IiwibXNnIiwicHJvbWlzZSIsIlR5cGVFcnJvciIsInJlc29sdmUiLCJ0cmlnZ2VyZWQiLCJkZWYiLCJkZWZfd3JhcHBlciIsIk1ha2VEZWZXcmFwcGVyIiwiJHJlc29sdmUkIiwiYXBwbHkiLCJhcmd1bWVudHMiLCIkcmVqZWN0JCIsIml0ZXJhdGVQcm9taXNlcyIsIkNvbnN0cnVjdG9yIiwiYXJyIiwicmVzb2x2ZXIiLCJyZWplY3RlciIsImlkeCIsIklJRkUiLCIkcmVzb2x2ZXIkIiwiTWFrZURlZiIsImV4ZWN1dG9yIiwiX19OUE9fXyIsImNvbnN0cnVjdG9yIiwiZXh0cmFjdENoYWluIiwicHVzaCIsIiRjYXRjaCQiLCJwdWJsaWNSZXNvbHZlIiwicHVibGljUmVqZWN0IiwiUHJvbWlzZVByb3RvdHlwZSIsIlByb21pc2UkcmVzb2x2ZSIsIlByb21pc2UkcmVqZWN0IiwiUHJvbWlzZSRhbGwiLCJsZW4iLCJtc2dzIiwiQXJyYXkiLCJjb3VudCIsIlByb21pc2UkcmFjZSIsIlByaW1pdGl2ZSIsInVwZGF0ZSIsImdldEZpbHRlciIsIl9maWx0ZXIiLCJSZW5kZXJUeXBlIiwiSU1BR0UiLCJEQVRBVVJMIiwiQlVGRkVSIiwiQkxPQiIsIk1TQkxPQiIsIkltYWdlRm9ybWF0IiwiUE5HIiwiSlBFRyIsIkV2ZW50cyIsIk9QRVJBVElPTl9VUERBVEVEIiwiVkVDVE9SMiIsIkNPTE9SX01BVFJJWCIsIkNPTE9SIiwiQVJSQVkiLCJPQkpFQ1QiLCJTVFJJTkciLCJDT05GSUdVUkFCTEUiLCJBTEwiLCJVbmlmb3JtVHlwZSIsIlNBTVBMRVIyRCIsIklOVCIsIklOVDEiLCJGTE9BVCIsIkZMT0FUMSIsIkZMT0FUMiIsIkZMT0FUX1ZFQ1RPUjIiLCJGTE9BVDMiLCJGTE9BVDQiLCJNQVQzIiwiTUFUM0ZWIiwiTUFUNCIsIlJlbmRlcmVyVHlwZSIsIldFQkdMIiwiQ0FOVkFTIiwiT3BlcmF0aW9uIiwiZW5hYmxlZCIsIl9zZGsiLCJfY2FjaGVFbmFibGVkIiwiX2RpcnRpbmVzcyIsIl9zcHJpdGUiLCJTcHJpdGUiLCJfY29udGFpbmVyIiwiQ29udGFpbmVyIiwiYWRkQ2hpbGQiLCJfb25PcHRpb25zQ2hhbmdlIiwiZ2V0RW5hYmxlZCIsImluZm8iLCJfcmVuZGVyVGV4dHVyZSIsImZyYW1lIiwiZ2V0U3ByaXRlIiwiZ2V0VGV4dHVyZSIsImdldEZyYW1lIiwiUmVuZGVyVGV4dHVyZSIsImdldFJlbmRlcmVyIiwid2lkdGgiLCJoZWlnaHQiLCJwZXJmIiwiY2FuTG9nIiwiaXNEaXJ0eUZvclJlbmRlcmVyIiwic2V0VGV4dHVyZSIsIm5ld0RpbWVuc2lvbnMiLCJnZXROZXdEaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsImZsb29yIiwicmVzaXplVG8iLCJjbGVhciIsIl9yZW5kZXIiLCJzdG9wIiwicmVuZGVyRm4iLCJpc09mVHlwZSIsIl9yZW5kZXJXZWJHTCIsImJpbmQiLCJfcmVuZGVyQ2FudmFzIiwiRXJyb3IiLCJkaW1lbnNpb25zIiwiY2xvbmUiLCJyZXNldCIsIl9kaXJ0eSIsIl9nbHNsUHJvZ3JhbXMiLCJpZCIsImRpbWVuc2lvbnNDaGFuZ2VkIiwicmVuZGVyZXJJZCIsImdldFNESyIsImdldElucHV0RGltZW5zaW9ucyIsIm9wRm91bmQiLCJnZXRPcGVyYXRpb25zU3RhY2siLCJmb3JFYWNoIiwib3AiLCJyIiwiZyIsImIiLCJhIiwidG9SR0JBIiwiY29sb3JzIiwiTWF0aCIsInJvdW5kIiwiam9pbiIsInRvSGV4IiwiY29tcG9uZW50cyIsIl9jb21wb25lbnRUb0hleCIsInRvR0xDb2xvciIsInRvQXJyYXkiLCJ0b1JHQkdMQ29sb3IiLCJ0b0hTViIsIm1heCIsIm1pbiIsImgiLCJzIiwidiIsImQiLCJmcm9tSFNWIiwicCIsInEiLCJ0IiwiZnJvbUFycmF5IiwiZXF1YWxzIiwiY29sb3IiLCJjb21wb25lbnQiLCJoZXgiLCJGaWx0ZXJzIiwiV2ViR0xSZW5kZXJlciIsIkNhbnZhc1JlbmRlcmVyIiwiV2ViR0xGaWx0ZXJNYW5hZ2VyIiwiQ2FudmFzRmlsdGVyTWFuYWdlciIsIkRpc3BsYXlPYmplY3QiLCJCYXNlVGV4dHVyZSIsIlRleHR1cmUiLCJXZWJHTFJlbmRlclRhcmdldCIsIkNhbnZhc1JlbmRlclRhcmdldCIsIlNoYWRlcnMiLCJTaGFkZXIiLCJQaXhlbEFycmF5SW1hZ2UiLCJhdXRvRGV0ZWN0UmVuZGVyZXIiLCJpc1N1cHBvcnRlZCIsIkltYWdlIiwid2luZG93IiwiYWRkaXRpb25hbEF2YWlsYWJsZU9wdGlvbnMiLCJhdmFpbGFibGVPcHRpb25zIiwiZXh0ZW5kIiwiX29uQ29uZmlndXJhYmxlVXBkYXRlIiwiX2luaXRPcHRpb25zIiwiX2J1aWxkQ29uZmlnRXJyb3IiLCJtZXNzYWdlIiwiZXJyb3JNZXNzYWdlIiwidmFsaWRhdGVTZXR0aW5ncyIsIm9wdGlvbk5hbWUiLCJvcHRpb25Db25maWciLCJyZXF1aXJlZCIsInVzZXJPcHRpb25zIiwib3B0aW9uIiwiY2FwaXRhbGl6ZWQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiaW5kZXhPZiIsImluaXRpYWwiLCJzZXRPcHRpb24iLCJnZXRPcHRpb24iLCJzdHJ1Y3R1cmUiLCJvbiIsImRlZmF1bHRWYWx1ZSIsImVtaXRVcGRhdGUiLCJlbWl0IiwiZ2V0T3B0aW9uRGVmYXVsdCIsImdldE9wdGlvbnMiLCJnZXREZWZhdWx0T3B0aW9ucyIsIm9wdGlvbnNFcXVhbCIsIl9vcHRpb25FcXVhbHMiLCJvcHRpb25UeXBlIiwiY3VycmVudFZhbHVlIiwiX2FycmF5T3B0aW9uRXF1YWxzIiwic3JjIiwidGhpc0FyciIsImVxdWFsIiwidGhpc1ZhbHVlIiwic2VyaWFsaXplT3B0aW9ucyIsImtleXMiLCJ0b09iamVjdCIsImtleSIsIl9zZXJpYWxpemVPcHRpb24iLCJ2YWxpZGF0aW9uIiwiYXZhaWxhYmxlIiwiZnJvbU9iamVjdCIsImltYWdlIiwiSFRNTEltYWdlRWxlbWVudCIsImFyZ3MiLCJpc0FycmF5Iiwib2JqZWN0IiwiaXNNb2JpbGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ2ZW5kb3IiLCJvcGVyYSIsInRlc3QiLCJzdWJzdHIiLCJ2YWx1ZXMiLCJpc0RPTUVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIm5vZGVUeXBlIiwibm9kZU5hbWUiLCJpc1RvdWNoRXZlbnQiLCJlIiwicmVzaXplVmVjdG9yVG9GaXQiLCJ2ZWN0b3IiLCJzY2FsZSIsIngiLCJ5IiwibmV3U2l6ZSIsIm11bHRpcGx5IiwiaXNFeHRlbmRhYmxlIiwiZGVmYXVsdHMiLCJuZXdPYmplY3QiLCJzb3VyY2VzIiwic291cmNlIiwiZGVlcERlZmF1bHRzIiwiY3JlYXRlQmxvYlVSSUZyb21EYXRhVVJJIiwiZGF0YSIsIkJsb2IiLCJVUkwiLCJBcnJheUJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJyYXdEYXRhIiwiZGVjb2RlIiwic3BsaXQiLCJtaW1lU3RyaW5nIiwiYXJyYXlCdWZmZXIiLCJpbnRBcnJheSIsImJsb2IiLCJjcmVhdGVPYmplY3RVUkwiLCJmYWxsYmFjayIsImNhbGxiYWNrIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZ2V0VVVJRCIsInJlcGxhY2UiLCJjIiwicmFuZG9tIiwiZmxhdHRlbiIsImFycmF5IiwicmVkdWNlIiwiZmxhdCIsInRvRmxhdHRlbiIsImNvbmNhdCIsImNyZWF0ZUNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlzUG93ZXJPZlR3byIsIm5leHRMb3dlc3RQT1QiLCJuZXh0SGlnaGVzdFBPVCIsIm1vdmVBcnJheUl0ZW0iLCJvbGRJbmRleCIsIm5ld0luZGV4IiwiayIsInNwbGljZSIsImVuc3VyZUNhbnZhc0RpbWVuc2lvbnMiLCJjYW52YXMiLCJieXRlQXJyYXlUb1N0cmluZyIsImJ5dGVBcnJheSIsIm1hcCIsImJ5dGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJtYXhMb2dMZXZlbCIsIkxFVkVMUyIsImJhY2tncm91bmQiLCJMRVZFTF9UWVBFUyIsImwiLCJzZXRMZXZlbCIsIl9sZXZlbCIsImN1cnJlbnRMZXZlbEluZGV4IiwibWF4TGV2ZWxJbmRleCIsImhhc0NvbG9yZnVsT3V0cHV0IiwicHJvY2VzcyIsImJyb3dzZXIiLCJtYXRjaCIsInByaW50RXJyb3IiLCJsaW5lcyIsInN0YWNrIiwibGluZSIsImVycm9yIiwibGV2ZWwiLCJ0YWciLCJvdXRwdXQiLCJjb25zb2xlIiwibG9nIiwiY29weSIsIm90aGVyIiwiY2xhbXAiLCJtaW5pbXVtIiwibWF4aW11bSIsIm1pbmltdW1TZXQiLCJtYXhpbXVtU2V0IiwiZGl2aWRlIiwiZGl2aXNvciIsInN1YnRyYWN0Iiwic3VidHJhaGVuZCIsImZhY3RvciIsImFkZGVuZCIsInZlYyIsImZsaXAiLCJ0ZW1wWCIsImNlaWwiLCJhYnMiLCJzcXJ0Iiwicm91bmREZWNpbWFsIiwiZGVjaW1hbHMiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsIktFWV9TVFIiLCJlbmNvZGUiLCJpbnB1dCIsImNocjEiLCJjaHIyIiwiY2hyMyIsImVuYzEiLCJlbmMyIiwiZW5jMyIsImVuYzQiLCJpc05hTiIsImJ1ZiIsImJhc2U2NHRlc3QiLCJERUZBVUxUX01BWF9MSVNURU5FUlMiLCJfbWF4TGlzdGVuZXJzIiwiX2V2ZW50cyIsIl9waXBlRGVzdGluYXRpb25zIiwicGlwZUV2ZW50cyIsImRlc3RpbmF0aW9uIiwidW5waXBlRXZlbnRzIiwibGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJ3YXJuIiwidHJhY2UiLCJvbmNlIiwiZXZlbnRzSW5zdGFuY2UiLCJvbmNlQ2FsbGJhY2siLCJvZmYiLCJpbmRleE9mTGlzdGVuZXIiLCJkZXN0Iiwic2V0TWF4TGlzdGVuZXJzIiwibmV3TWF4TGlzdGVuZXJzIiwicGFyc2VJbnQiLCJfb25Tb3VyY2VMb2FkZWQiLCJfcmVuZGVyZXJzIiwiX2dsVGV4dHVyZXMiLCJfc291cmNlIiwiX2dsVW5pdCIsIl9taXBNYXBwaW5nIiwiX21hZ0ZpbHRlciIsIkRlZmF1bHRNYWdGaWx0ZXIiLCJfbWluRmlsdGVyIiwiRGVmYXVsdE1pbkZpbHRlciIsIl9yZXBlYXRYIiwiQ2xhbXBUb0VkZ2UiLCJfcmVwZWF0WSIsIl9waXhlbFJhdGlvIiwiX2xvYWRlZCIsIl9mcmFtZSIsIl9sb2FkU291cmNlIiwic291cmNlTG9hZGVkIiwiY29tcGxldGUiLCJzb3VyY2VJc0NhbnZhcyIsInRhZ05hbWUiLCJhZGRFdmVudExpc3RlbmVyIiwiX3VwZGF0ZUdMRmlsdGVycyIsInNvdXJjZURpbWVuc2lvbnMiLCJUcmlsaW5lYXJGaWx0ZXIiLCJnZXRHTEZpbHRlciIsImdsIiwibWluT3JNYWciLCJmaWx0ZXJFbnVtIiwiTGluZWFyRmlsdGVyIiwiTElORUFSIiwiTmVhcmVzdEZpbHRlciIsIk5FQVJFU1QiLCJCaWxpbmVhckZpbHRlciIsIkxJTkVBUl9NSVBNQVBfTkVBUkVTVCIsIkxJTkVBUl9NSVBNQVBfTElORUFSIiwiaXNMb2FkZWQiLCJzZXRMb2FkZWQiLCJsb2FkZWQiLCJnZXRTb3VyY2UiLCJzZXRTb3VyY2UiLCJnZXRHTFRleHR1cmVGb3JSZW5kZXJlciIsInNldEdMVGV4dHVyZUZvclJlbmRlcmVyIiwidGV4dHVyZSIsInNldEZyYW1lIiwiZ2V0UGl4ZWxSYXRpbyIsInNldFBpeGVsUmF0aW8iLCJwaXhlbFJhdGlvIiwiZ2V0R0xVbml0Iiwic2V0R0xVbml0IiwiZ2xVbml0Iiwic2V0TWluRmlsdGVyIiwibWluRmlsdGVyIiwiZ2V0TWluRmlsdGVyIiwic2V0TWFnRmlsdGVyIiwibWFnRmlsdGVyIiwiZ2V0TWFnRmlsdGVyIiwic2V0UmVwZWF0WCIsInJlcGVhdCIsImdldFJlcGVhdFgiLCJzZXRSZXBlYXRZIiwiZ2V0UmVwZWF0WSIsImdldEdMUmVwZWF0IiwiZGlyZWN0aW9uIiwiQ0xBTVBfVE9fRURHRSIsIlJlcGVhdCIsIlJFUEVBVCIsIk1pcnJvcmVkUmVwZWF0IiwiTUlSUk9SRURfUkVQRUFUIiwiaXNEaXJ0eSIsImRpc3Bvc2VHTFRleHR1cmVzIiwiZGlzcG9zZUdMVGV4dHVyZXNGb3JSZW5kZXJlciIsImdldENvbnRleHQiLCJkZWxldGVUZXh0dXJlIiwiaXNNaXBNYXBwaW5nRW5hYmxlZCIsInNldE1pcE1hcHBpbmdFbmFibGVkIiwiX3dpZHRoIiwiX2hlaWdodCIsIl9iYXNlVGV4dHVyZSIsIl9jYW52YXMiLCJfY3JlYXRlQ2FudmFzIiwiX2NvbnRleHQiLCJfZmlsdGVyU3RhY2siLCJyZW5kZXJUYXJnZXQiLCJmaWx0ZXIiLCJjdHgiLCJzZXRUcmFuc2Zvcm0iLCJjbGVhclJlY3QiLCJnZXRDYW52YXMiLCJnZXRGaWx0ZXJTdGFjayIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwiZ2V0QmFzZVRleHR1cmUiLCJpc1Jvb3QiLCJfcmVuZGVyZXIiLCJfZ2wiLCJfcHJvamVjdGlvbk1hdHJpeCIsIl9mcmFtZWJ1ZmZlciIsIl9pc1Jvb3QiLCJfaW5pdEZyYW1lQnVmZmVyIiwiX3Jlc2l6ZVRleHR1cmUiLCJfZ2V0TWluRmlsdGVyIiwiX2dldE1hZ0ZpbHRlciIsIl9jYWxjdWxhdGVQcm9qZWN0aW9uTWF0cml4IiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwiX3RleHR1cmUiLCJyZWFsV2lkdGgiLCJyZWFsSGVpZ2h0IiwidGV4SW1hZ2UyRCIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwiYWN0aXZhdGUiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsInZpZXdwb3J0IiwiZGlzYWJsZSIsIlNURU5DSUxfVEVTVCIsIlRSQU5TUEFSRU5UIiwiY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyIsImNsZWFyQ29sb3IiLCJDT0xPUl9CVUZGRVJfQklUIiwicHJvamVjdGlvbk1hdHJpeCIsInR4IiwidHkiLCJjcmVhdGVGcmFtZWJ1ZmZlciIsImNyZWF0ZVRleHR1cmUiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwiZ2V0UHJvamVjdGlvbk1hdHJpeCIsImRlbGV0ZUZyYW1lYnVmZmVyIiwiQ29sb3JNYXRyaXgiLCJqIiwibSIsIm4iLCJtYXRyaXgiLCJBIiwiQiIsImNyZWF0ZUJyaWdodG5lc3NNYXRyaXgiLCJicmlnaHRuZXNzIiwiY3JlYXRlQ29udHJhc3RNYXRyaXgiLCJjb250cmFzdCIsImNyZWF0ZVNhdHVyYXRpb25NYXRyaXgiLCJzYXR1cmF0aW9uIiwiaW52U2F0IiwiY3JlYXRlTGluZWFyTWF0cml4Iiwic2xvcGUiLCJpbnRlcmNlcHQiLCJvcGVyYXRpb24iLCJfb3BlcmF0aW9uIiwiX3JlbmRlclRleHR1cmVzIiwiX2lkZW50aXR5U3ByaXRlIiwiYXBwbHlSb3RhdGlvbiIsImRlZ3JlZXMiLCJpbnB1dERpbWVuc2lvbnMiLCJzcHJpdGVEZWdyZWVzIiwiZ2V0Um90YXRpb24iLCJQSSIsInNldFJvdGF0aW9uIiwiYWN0dWFsRGVncmVlcyIsInJhZGlhbnMiLCJjb3MiLCJzaW4iLCJyZWxhdGl2ZVBvc2l0aW9uIiwicG9zaXRpb24iLCJuZXdSZWxhdGl2ZVBvc2l0aW9uIiwic2V0UG9zaXRpb24iLCJhcHBseUZsaXAiLCJnZXRQb3NpdGlvbiIsImFwcGx5Q3JvcCIsImNyb3BPcGVyYXRpb24iLCJyb3RhdGlvbkRlbHRhIiwicm90YXRpb24iLCJvbGRBYnNvbHV0ZVNpemUiLCJnZXRFbmQiLCJnZXRTdGFydCIsIm5ld0Fic29sdXRlU2l6ZSIsImVuZCIsInN0YXJ0IiwiYWJzb2x1dGVTdGFydERpZmYiLCJzY2FsZVJhdGlvIiwiZ2V0U2NhbGUiLCJhYnNvbHV0ZVN0YXJ0IiwiYWJzb2x1dGVQb3NpdGlvbk9uSW1hZ2UiLCJkZWx0YVRvQ2VudGVyIiwibmV3RGVsdGFUb0NlbnRlciIsInRleHR1cmVTY2FsZSIsImdldFRleHR1cmVTY2FsZSIsImludmVyc2VDcm9wRGVncmVlcyIsImdldERpc3BsYXlPYmplY3QiLCJfZ2V0VGV4dHVyZSIsIl9wcmVwYXJlUmVuZGVyVGV4dHVyZSIsIl9yZW5kZXJUZXh0dXJlQ29udGFpbmVyIiwiX3JlbmRlclRleHR1cmVTcHJpdGUiLCJfZ2V0UmVuZGVyVGV4dHVyZSIsIl9yZW5kZXJzVG9SZW5kZXJUZXh0dXJlIiwic21vb3RoRG93bnNjYWxpbmciLCJfdXBkYXRlU3ByaXRlIiwiX3JlbmRlclRvUmVuZGVyVGV4dHVyZSIsInNldEFuY2hvciIsImFuY2hvciIsInNldFdpZHRoIiwic2V0SGVpZ2h0IiwidXBkYXRlVHJhbnNmb3JtIiwic3ByaXRlRGltZW5zaW9ucyIsInNldFBpdm90IiwicGl2b3QiLCJ0ZXh0dXJlRGltZW5zaW9ucyIsInJlbmRlclRleHR1cmUiLCJmaW5hbERpbWVuc2lvbnMiLCJyZWxhdGl2ZURpZmZlcmVuY2UiLCJ1dnMiLCJnZXRVVnMiLCJtdWxfdGFibGUiLCJzaGdfdGFibGUiLCJzdGFja0JsdXJDYW52YXNSR0JBIiwiaW1hZ2VEYXRhIiwidG9wX3giLCJ0b3BfeSIsInJhZGl1cyIsInBpeGVscyIsInlwIiwieWkiLCJ5dyIsInJfc3VtIiwiZ19zdW0iLCJiX3N1bSIsImFfc3VtIiwicl9vdXRfc3VtIiwiZ19vdXRfc3VtIiwiYl9vdXRfc3VtIiwiYV9vdXRfc3VtIiwicl9pbl9zdW0iLCJnX2luX3N1bSIsImJfaW5fc3VtIiwiYV9pbl9zdW0iLCJwciIsInBnIiwicGIiLCJwYSIsInJicyIsImRpdiIsIndpZHRoTWludXMxIiwiaGVpZ2h0TWludXMxIiwicmFkaXVzUGx1czEiLCJzdW1GYWN0b3IiLCJzdGFja1N0YXJ0IiwiQmx1clN0YWNrIiwic3RhY2tFbmQiLCJzdGFja0luIiwic3RhY2tPdXQiLCJtdWxfc3VtIiwic2hnX3N1bSIsIkVYSUZfVEFHUyIsIkRBVEFfSlBFR19QUkVGSVgiLCJKUEVHX1JFR0VYIiwiUmVnRXhwIiwiRVhJRiIsIl9idWYiLCJfc3RyZWFtIiwic2V0SGVhZCIsIl9zZWdtZW50cyIsIl9zbGljZUludG9TZWdtZW50cyIsIl9leGlmQnVmZmVyIiwiX2dldEV4aWZCdWZmZXIiLCJfZXhpZlN0cmVhbSIsIl9wYXJzZUV4aWYiLCJyZXN0b3JlRXhpZlRhZ3MiLCJiYXNlNjRTdHJpbmciLCJyYXciLCJzZWdtZW50cyIsInNlZ21lbnRTdGFydCIsImRhdGFCZWZvcmUiLCJkYXRhQWZ0ZXIiLCJuZXdEYXRhIiwic2V0T3JpZW50YXRpb24iLCJvcmllbnRhdGlvbiIsIl90YWdEYXRhIiwiT3JpZW50YXRpb24iLCJlbnRyeU9mZnNldCIsIndyaXRlSW50MTYiLCJpc0pQRUciLCJmcm9tQmFzZTY0U3RyaW5nIiwicmVhZEludDE2IiwiaGVhZGVyIiwicmVhZFN0cmluZyIsInRpZmZPZmZzZXQiLCJnZXRIZWFkIiwiYmlnRW5kaWFuIiwiZW5kaWFuIiwiZmlyc3RJRkRPZmZzZXQiLCJyZWFkSW50MzIiLCJpZmRPZmZzZXQiLCJ0YWdzIiwiX3JlYWRUYWdzIiwiX3RhZ3MiLCJ0YWdEYXRhIiwic3RyZWFtIiwidGlmZlN0YXJ0IiwiaWZkU3RhcnQiLCJlbnRyaWVzQ291bnQiLCJudW1WYWx1ZXMiLCJ2YWx1ZU9mZnNldCIsInJlYWRJbnQ4IiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJvZmZzZXQiLCJtYXJrZXIiLCJwZWVrSW50MTYiLCJnZXRUYWdzIiwiZ2V0VGFnRGF0YSIsIl9wb3NpdGlvbiIsIl9zY2FsZSIsIl9waXZvdCIsIl9yb3RhdGlvbiIsIl9sYXN0Um90YXRpb24iLCJfYWxwaGEiLCJfdmlzaWJsZSIsIl93b3JsZFRyYW5zZm9ybSIsIl9wYXJlbnQiLCJfc2hhZGVycyIsIl9ib3VuZHNOZWVkVXBkYXRlIiwiX2JvdW5kcyIsIl9sb2NhbEJvdW5kc05lZWRVcGRhdGUiLCJfbG9jYWxCb3VuZHMiLCJfdGludCIsIl9maWx0ZXJSZWN0YW5nbGUiLCJyZW5kZXJXZWJHTCIsInJlbmRlckNhbnZhcyIsInBhcmVudFRyYW5zZm9ybSIsImdldFdvcmxkVHJhbnNmb3JtIiwiSURFTlRJVFkiLCJ3b3JsZFRyYW5zZm9ybSIsInJvdGF0aW9uQ2hhbmdlZCIsIl9zaW5Sb3RhdGlvbiIsIl9jb3NSb3RhdGlvbiIsImFkZFNoYWRlciIsInNoYWRlciIsInJlbW92ZVNoYWRlciIsImluZGV4IiwicmVtb3ZlU2hhZGVyQXQiLCJnZXRCb3VuZHMiLCJzZXRTY2FsZSIsImdldFBpdm90IiwiZ2V0QWxwaGEiLCJzZXRBbHBoYSIsImFscGhhIiwiZ2V0V29ybGRBbHBoYSIsImdldFBhcmVudCIsInNldFBhcmVudCIsInBhcmVudCIsImdldEZpbHRlclJlY3RhbmdsZSIsInNldEZpbHRlclJlY3RhbmdsZSIsInJlY3RhbmdsZSIsImdldFRpbnQiLCJzZXRUaW50IiwidGludCIsImlzVmlzaWJsZSIsInNldFZpc2libGUiLCJ2aXNpYmxlIiwiX2F2YWlsYWJsZVVuaWZvcm1zIiwiZGVmYXVsdFVuaWZvcm1zIiwiX2F0dHJpYnV0ZXMiLCJkZWZhdWx0QXR0cmlidXRlcyIsIl92ZXJ0ZXhTb3VyY2UiLCJkZWZhdWx0VmVydGV4U291cmNlIiwiX2ZyYWdtZW50U291cmNlIiwiZGVmYXVsdEZyYWdtZW50U291cmNlIiwiX2luaXRVbmlmb3JtcyIsIl91bmlmb3JtcyIsInVuaWZvcm0iLCJ1bmlmb3JtVHlwZSIsInVuaWZvcm1WYWx1ZSIsInVuaWZvcm1OYW1lIiwidmVjdG9yVmFsdWUiLCJzZXRVbmlmb3JtIiwic3luYyIsInNldFVuaWZvcm1zIiwidW5pZm9ybXMiLCJzeW5jVW5pZm9ybSIsInN5bmNVbmlmb3JtcyIsImdldFNoYWRlckZvclJlbmRlcmVyIiwiaW5wdXRUYXJnZXQiLCJvdXRwdXRUYXJnZXQiLCJfYXBwbHlXZWJHTCIsIl9hcHBseUNhbnZhcyIsInNldFJlbmRlclRhcmdldCIsInNldFNoYWRlciIsImdldEN1cnJlbnRSZW5kZXJUYXJnZXQiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJkcmF3RWxlbWVudHMiLCJUUklBTkdMRVMiLCJVTlNJR05FRF9TSE9SVCIsIm91dHB1dENvbnRleHQiLCJkcmF3SW1hZ2UiLCJmaWx0ZXJzIiwiX2N1cnJlbnRGcmFtZSIsIl90ZXh0dXJlcyIsIl90ZXh0dXJlRnJhbWUiLCJwdXNoRmlsdGVycyIsImRpc3BsYXlPYmplY3QiLCJib3VuZHMiLCJfZ2V0T3JDcmVhdGVSZW5kZXJUYXJnZXQiLCJwb3BGaWx0ZXJzIiwicG9wIiwibGFzdEZpbHRlciIsImlucHV0UmVuZGVyVGFyZ2V0Iiwib3V0cHV0UmVuZGVyVGFyZ2V0IiwiX2FwcGx5RmlsdGVycyIsImZsaXBSZW5kZXJUYXJnZXQiLCJmbG9wUmVuZGVyVGFyZ2V0IiwiaXNMYXN0RmlsdGVyIiwidGVtcCIsInNldEZpbHRlclN0YWNrIiwiZmlsdGVyU3RhY2siLCJfcmVuZGVyVGFyZ2V0cyIsIl9vbkNvbnRleHRDaGFuZ2UiLCJmaWx0ZXJSZWN0YW5nbGUiLCJfcXVhZCIsInZlcnRleEJ1ZmZlciIsImdldFZlcnRleEJ1ZmZlciIsImluZGV4QnVmZmVyIiwiZ2V0SW5kZXhCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJhdHRyaWJ1dGVMb2NhdGlvbnMiLCJnZXRBdHRyaWJ1dGVMb2NhdGlvbnMiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiYV9wb3NpdGlvbiIsImFfdGV4Q29vcmQiLCJhX2NvbG9yIiwidXBkYXRlVGV4dHVyZSIsInRhcmdldCIsInZlcnRleFNvdXJjZSIsImZyYWdtZW50U291cmNlIiwiYXR0cmlidXRlcyIsIl91bmlmb3JtTG9jYXRpb25zIiwiX2F0dHJpYnV0ZUxvY2F0aW9ucyIsIl9pbml0IiwiX2NvbXBpbGUiLCJ1c2VQcm9ncmFtIiwiX3Byb2dyYW0iLCJfY2FjaGVVbmlmb3JtTG9jYXRpb25zIiwiX2NhY2hlQXR0cmlidXRlTG9jYXRpb25zIiwic2V0dXBCdWZmZXJzIiwibG9jYXRpb24iLCJ1bmlmb3JtMWkiLCJ1bmlmb3JtMWYiLCJ1bmlmb3JtMmYiLCJ1bmlmb3JtM2YiLCJ1bmlmb3JtNGYiLCJ1bmlmb3JtMmZ2IiwidW5pZm9ybU1hdHJpeDNmdiIsInVuaWZvcm1NYXRyaXg0ZnYiLCJnZXRBdHRyaWJMb2NhdGlvbiIsImdldFVuaWZvcm1Mb2NhdGlvbiIsIl9hZGRQcmVjaXNpb25Ub1NvdXJjZSIsIm1heEZsb2F0UHJlY2lzaW9uIiwiZ2V0TWF4RmxvYXRQcmVjaXNpb24iLCJwcmVjaXNpb24iLCJ2ZXJ0ZXhTaGFkZXIiLCJfY29tcGlsZVNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJfdmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJfZnJhZ21lbnRTaGFkZXIiLCJwcm9ncmFtIiwiY3JlYXRlUHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwibGlua2VkIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJpc0NvbnRleHRMb3N0IiwiZGVsZXRlUHJvZ3JhbSIsInNoYWRlclR5cGUiLCJzaGFkZXJTb3VyY2UiLCJjcmVhdGVTaGFkZXIiLCJjb21waWxlU2hhZGVyIiwiY29tcGlsZWQiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImdldFNoYWRlckluZm9Mb2ciLCJkZWxldGVTaGFkZXIiLCJnZXRVbmlmb3JtcyIsImdldEF0dHJpYnV0ZXMiLCJnZXRQcm9ncmFtIiwiVGV4dHVyZVNoYWRlciIsInJlcXVpcmUiLCJ1X2ltYWdlIiwidV9wcm9qTWF0cml4IiwiT3BlcmF0aW9uc1N0YWNrIiwib3BlcmF0aW9ucyIsIl9vbk9wZXJhdGlvblVwZGF0ZSIsInJlbW92ZSIsImVuYWJsZUNhY2hlIiwiZGlzYWJsZUNhY2hlIiwiaXRlcmF0b3IiLCJjdXJyZW50VGV4dHVyZSIsInJldmVyc2UiLCJmaXJzdFVuZGlydHlPcGVyYXRpb24iLCJmaXJzdFVuZGlydHlJbmRleCIsInN0YXJ0SW5kZXgiLCJvcGVyYXRpb25PdXRwdXQiLCJhbGwiLCJzZXRBbGxUb0RpcnR5IiwidXBkYXRlRGlydGluZXNzRm9yUmVuZGVyZXIiLCJkaXJ0eUZvdW5kIiwidW5zaGlmdCIsInJlbW92ZUF0IiwiZ2V0U3RhY2siLCJfY2hpbGRyZW4iLCJfZmlsdGVycyIsImFkZEZpbHRlciIsInJlbW92ZUZpbHRlciIsInNldEZpbHRlcnMiLCJjaGlsZCIsIm9yaWdpbmFsUGFyZW50IiwicmVtb3ZlQ2hpbGQiLCJwcmVwZW5kQ2hpbGQiLCJoYXNDaGlsZCIsImNsZWFyQ2hpbGRyZW4iLCJmaWx0ZXJNYW5hZ2VyIiwiZ2V0RmlsdGVyTWFuYWdlciIsImdldEN1cnJlbnRPYmplY3RSZW5kZXJlciIsImZsdXNoIiwiZ2V0TG9jYWxCb3VuZHMiLCJnZXRDaGlsZHJlbiIsImdldEZpbHRlcnMiLCJCYXNlUmVuZGVyZXIiLCJ0cmFuc3BhcmVudCIsIkJMQUNLIiwiZGVidWciLCJfZGltZW5zaW9ucyIsIl9tYXhUZXh0dXJlU2l6ZSIsIl9jbGVhckNvbG9yIiwic2V0Q2FudmFzIiwicHJldmlvdXNDYW52YXMiLCJfY3JlYXRlQ29udGV4dCIsIl9vbkJlZm9yZUNvbnRleHQiLCJfc2V0dXBDb250ZXh0IiwicmVzaXplQ2FudmFzIiwic3R5bGUiLCJnZXRNYXhEaW1lbnNpb25zIiwiX2RlZmF1bHRSZW5kZXJUYXJnZXQiLCJnZXRNYXhUZXh0dXJlU2l6ZSIsIl9maWx0ZXJNYW5hZ2VyIiwic2V0RmlsdGVyTWFuYWdlciIsIl90eXBlIiwiT2JqZWN0UmVuZGVyZXIiLCJiYXNlVGV4dHVyZSIsIl91dnMiLCJfZnJhbWVMb2NrZWQiLCJfb25CYXNlVGV4dHVyZUxvYWRlZCIsIl9vbkJhc2VUZXh0dXJlVXBkYXRlZCIsInNldEJhc2VUZXh0dXJlIiwiZnJvbUltYWdlIiwiZnJvbUNhbnZhcyIsIl91cGRhdGVVVnMiLCJub3ciLCJwZXJmb3JtYW5jZSIsIkNvbnRleHRQZXJmb3JtYW5jZUhvb2siLCJfdHJhY2tpbmciLCJyZXN1bHQiLCJ0aW1lIiwiZnVuY3Rpb25OYW1lIiwiZHVyYXRpb24iLCJfdHJhY2tlZENhbGxzIiwiX21ha2VQcm9wZXJ0eVdyYXBwZXIiLCJwcm9wZXJ0eSIsImluc2VjdXJlUHJvcGVydGllcyIsIl9fZGVmaW5lR2V0dGVyX18iLCJfX2RlZmluZVNldHRlcl9fIiwic3RhcnRGcmFtZSIsImVuZEZyYW1lIiwiZ3JvdXBlZENhbGxzIiwidG90YWxEdXJhdGlvbiIsImNhbGxzIiwiY2FsbHNBcnJheSIsImF2ZXJhZ2VEdXJhdGlvbiIsInNvcnQiLCJmcm9tTm9kZUNhbnZhc0ltYWdlIiwiQ2FudmFzIiwiZ2V0SW1hZ2VEYXRhIiwiZmJvU3RhdHVzIiwicG9zc2libGVTdGF0dXNlcyIsIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVCIsIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UIiwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TIiwiRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQiLCJGUkFNRUJVRkZFUl9DT01QTEVURSIsImFwcGx5VG9WZWN0b3IiLCJhcHBseUludmVyc2VUb1ZlY3RvciIsImRldGVybWluYW50IiwicmVjdGFuZ2xlVG9Db29yZGluYXRlcyIsIncwIiwidzEiLCJoMCIsImgxIiwicG9zaXRpb25zIiwiRmxvYXQzMkFycmF5IiwicmVjdCIsIlBlcmZvcm1hbmNlVGVzdCIsIl90YWciLCJfbmFtZSIsIl9zdGFydCIsIm1zIiwiZnBzIiwiQWRqdXN0bWVudHNGaWx0ZXIiLCJpbnB1dENvbnRleHQiLCJnYW1tYSIsImV4cG9zdXJlIiwic2hhZG93cyIsImhpZ2hsaWdodHMiLCJhcHBseUJyaWdodG5lc3MiLCJhcHBseVNhdHVyYXRpb24iLCJhcHBseUNvbnRyYXN0IiwiYXBwbHlFeHBvc3VyZSIsImFwcGx5R2FtbWEiLCJhcHBseVNoYWRvd3NBbmRIaWdobGlnaHRzIiwiZXhwb3N1cmVGYWN0b3IiLCJwb3ciLCJsdW1pbmFuY2UiLCJzaGFkb3ciLCJoaWdobGlnaHQiLCJwdXRJbWFnZURhdGEiLCJJZGVudGl0eUZpbHRlciIsIlRFWFRVUkVfR0xfVU5JVCIsIkxvb2t1cFRhYmxlRmlsdGVyIiwidGFibGUiLCJsb29rdXBUYWJsZURhdGEiLCJsb29rdXBUYWJsZSIsIkxvb2t1cFRhYmxlIiwiX3VwZGF0ZVdlYkdMVGV4dHVyZSIsInNldExvb2t1cFRhYmxlRGF0YSIsInBpeGVsQXJyYXlJbWFnZSIsIkJydXNoIiwiX3BlcnNpc3RlZFBhdGhzIiwiX291dHB1dENhbnZhc0RpcnR5IiwiX291dHB1dENhbnZhcyIsIl9vdXRwdXRDb250ZXh0IiwiX3BlcnNpc3RDYW52YXMiLCJfcGVyc2lzdENvbnRleHQiLCJfbmV4dENhbnZhcyIsIl9vblBhdGhVcGRhdGUiLCJwYXRocyIsInBhdGgiLCJmb3JFYWNoQ29udHJvbFBvaW50IiwiY29udHJvbFBvaW50IiwiX3Jlc2V0IiwibmV3UmVsYXRpdmVUaGlja25lc3MiLCJnZXRUaGlja25lc3MiLCJzZXRUaGlja25lc3MiLCJjbGVhckNhbnZhcyIsImNsZWFyUGVyc2lzdENhbnZhcyIsImNyZWF0ZVBhdGgiLCJ0aGlja25lc3MiLCJoYXJkbmVzcyIsIl9vblBhdGhQZXJzaXN0IiwicmVuZGVyVG9DYW52YXMiLCJnZXRDbG9zZWQiLCJnbG9iYWxzIiwiT3BlcmF0aW9ucyIsImJkIiwic3RyIiwiUGhvdG9FZGl0b3JTREsiLCJwcmVmZXJyZWRSZW5kZXJlciIsIl9vbkNvbnRleHRSZXN0b3JlZCIsInZlcnNpb24iLCJfcHJlZmVycmVkUmVuZGVyZXIiLCJleHRlbnNpb25zIiwicmVuZGVyTW9kZSIsInZlcnNpb25DaGVjayIsImRpc3BsYXlXZWxjb21lTWVzc2FnZSIsInRleHR1cmVRdWFsaXR5Iiwiem9vbSIsInNwcml0ZVNjYWxlIiwic21vb3RoVXBzY2FsaW5nIiwibG9nTGV2ZWwiLCJkZXZpY2VQaXhlbFJhdGlvIiwiY29udHJvbHMiLCJsYW5ndWFnZXMiLCJfdiIsIl9kZWZhdWx0UmVuZGVyTW9kZSIsIl9yZW5kZXJNb2RlIiwiX3RleHR1cmVRdWFsaXR5IiwiX29mZnNldCIsIl96b29tIiwiX3Nwcml0ZVNjYWxlIiwiX29wZXJhdGlvbnMiLCJfb3BlcmF0aW9uc1N0YWNrIiwic2V0T3BlcmF0aW9uc1N0YWNrIiwiX2lucHV0QmFzZVRleHR1cmUiLCJfaW5wdXRUZXh0dXJlIiwiX2N1cnJlbnRJbnB1dFRleHR1cmUiLCJfY3VycmVudFRleHR1cmUiLCJfcmVzaXplZFRleHR1cmUiLCJfcmVzaXplZENvbnRhaW5lciIsIl9yZXNpemVkU3ByaXRlIiwic2V0U21vb3RoRG93bnNjYWxpbmciLCJfY2hlY2tGb3JVcGRhdGVzIiwiX3JlZ2lzdGVyT3BlcmF0aW9ucyIsIl9pbml0UmVuZGVyZXIiLCJzZXRJbWFnZSIsIkwiLCJfbGljIiwiY2F0Y2giLCJfY3YiLCJfdCIsInNldEFsbE9wZXJhdGlvbnNUb0RpcnR5IiwiZXhwb3J0IiwicmVuZGVyVHlwZSIsImltYWdlRm9ybWF0IiwicXVhbGl0eSIsImltYWdlRXhwb3J0ZXIiLCJfaW1hZ2UiLCJwZXJmVGVzdCIsIl9wcmVwYXJlVGV4dHVyZSIsImNlbnRlciIsIm5lZWRzUmVyZW5kZXIiLCJvcGVyYXRpb25OYW1lIiwiY3JlYXRlT3BlcmF0aW9uIiwiYWRkVG9TdGFjayIsImFkZE9wZXJhdGlvbiIsInJlbW92ZU9wZXJhdGlvbiIsImdldEZpbmFsRGltZW5zaW9ucyIsImluY29ycG9yYXRlU3ByaXRlU2NhbGUiLCJvcGVyYXRpb25zU3RhY2siLCJnZXRPdXRwdXREaW1lbnNpb25zIiwiZ2V0T3V0cHV0VGV4dHVyZURpbWVuc2lvbnMiLCJfdmVyc2lvbkNoZWNrZXIiLCJyZW5kZXJlck9wdGlvbnMiLCJwYXJzZUV4aWYiLCJleGlmIiwiX2hhbmRsZUV4aWZPcmllbnRhdGlvbiIsImV4aWZUYWdzIiwiX2V4aWYiLCJyb3RhdGlvbk5lZWRzQ2hhbmdlIiwiZmxpcE5lZWRzQ2hhbmdlIiwiX2V4aWZPcGVyYXRpb24iLCJzZXRUYWdzIiwiaGFzSW1hZ2UiLCJnZXRJbWFnZSIsImdldENvbnRhaW5lciIsImdldE9wZXJhdGlvbnMiLCJnZXRPZmZzZXQiLCJzZXRPZmZzZXQiLCJnZXRSZW5kZXJNb2RlIiwic2V0UmVuZGVyTW9kZSIsImdldFpvb20iLCJzZXRab29tIiwiZ2V0VGV4dHVyZVF1YWxpdHkiLCJzZXRUZXh0dXJlUXVhbGl0eSIsImdldFNwcml0ZVNjYWxlIiwic2V0U3ByaXRlU2NhbGUiLCJnZXRFeGlmIiwiZ2V0SW5wdXRUZXh0dXJlIiwiQ29sb3JPdmVybGF5RmlsdGVyIiwiV0hJVEUiLCJVbnByZW11bHRpcGx5RmlsdGVyIiwiY29udGV4dElkIiwicHJvcCIsImltYWdlU21vb3RoaW5nRW5hYmxlZCIsIl9yZW5kZXJUYXJnZXQiLCJfZmFrZU9iamVjdCIsImdsb2JhbEFscGhhIiwic2F2ZSIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwicmVzdG9yZSIsInJlbmRlckRpc3BsYXlPYmplY3QiLCJvcmlnaW5hbFJlbmRlclRhcmdldCIsIlNwcml0ZVJlbmRlcmVyIiwiX21heEJhdGNoU2l6ZSIsIl92ZXJ0aWNlcyIsIl9wb3NpdGlvbnMiLCJfY29sb3JzIiwiVWludDMyQXJyYXkiLCJfaW5kaWNlcyIsIlVpbnQxNkFycmF5IiwiX3Nwcml0ZXMiLCJfY3VycmVudEJhdGNoU2l6ZSIsIl9jdXJyZW50QmFzZVRleHR1cmUiLCJzcHJpdGUiLCJ0ZXh0dXJlRnJhbWUiLCJfYWRkVmVydGV4Q29vcmRpbmF0ZXMiLCJfYWRkVGV4dHVyZVVWcyIsIl9hZGRDb2xvcnMiLCJ1dkNvb3JkcyIsImdldFVWc0F0IiwiZ2V0QW5jaG9yIiwicmVjdFBvc2l0aW9ucyIsInN0cmlkZSIsIl9zaGFkZXIiLCJzaGFkZXJzIiwiX3ZlcnRleEJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsIl9pbmRleEJ1ZmZlciIsImJ1ZmZlckRhdGEiLCJTVEFUSUNfRFJBVyIsIkRZTkFNSUNfRFJBVyIsImJ1ZmZlclN1YkRhdGEiLCJzdWJBcnJheSIsInN1YmFycmF5IiwiY3VycmVudEJhdGNoU2l6ZSIsImN1cnJlbnRCYXNlVGV4dHVyZSIsIm5leHRCYXNlVGV4dHVyZSIsImN1cnJlbnRTaGFkZXIiLCJuZXh0U2hhZGVyIiwic2hhZGVyQ2hhbmdlZCIsInRleHR1cmVDaGFuZ2VkIiwiYmF0Y2hTdGFydEluZGV4IiwiZ2V0U2hhZGVyIiwiX3JlbmRlckJhdGNoIiwiYmF0Y2hTaXplIiwiZ2xUZXh0dXJlIiwiZ2V0T3JDcmVhdGVHTFRleHR1cmUiLCJ2ZXJ0aWNlc0NvdW50IiwidmVydGV4T2Zmc2V0IiwiZGVsZXRlQnVmZmVyIiwiX29uQ29udGV4dExvc3QiLCJfaW5pdFNoYWRlcnMiLCJyZW5kZXJlcnMiLCJfaW5pdFJlbmRlcmVycyIsInByZXZlbnREZWZhdWx0IiwiX29uQ29udGV4dENyZWF0aW9uRXJyb3IiLCJzdGF0dXNNZXNzYWdlIiwiX2N1cnJlbnRPYmplY3RSZW5kZXJlciIsIl9jdXJyZW50U2hhZGVyIiwiX3NldEF0dHJpYnV0ZXNGb3JTaGFkZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZUxvY2F0aW9uIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJjb250ZXh0T3B0aW9ucyIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsIldlYkdMRGVidWdVdGlscyIsImxvZ0dMIiwiZ2xGdW5jdGlvbkFyZ3NUb1N0cmluZyIsIm1ha2VEZWJ1Z0NvbnRleHQiLCJnZXRQYXJhbWV0ZXIiLCJNQVhfVEVYVFVSRV9TSVpFIiwiREVQVEhfVEVTVCIsIkNVTExfRkFDRSIsImVuYWJsZSIsIkJMRU5EIiwiYmxlbmRGdW5jIiwiT05FIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsIl9nZXRNYXhQcmVjaXNpb24iLCJoaWdoRmxvYXQiLCJnZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQiLCJISUdIX0ZMT0FUIiwiX21heEZsb2F0UHJlY2lzaW9uIiwiaGlnaEludCIsIkhJR0hfSU5UIiwiX21heEludFByZWNpc2lvbiIsInJhbmdlTWF4IiwiX2N1cnJlbnRSZW5kZXJUYXJnZXQiLCJzZXRPYmplY3RSZW5kZXJlciIsIm9iamVjdFJlbmRlcmVyIiwidXBsb2FkIiwiaGFzU291cmNlIiwicGl4ZWxTdG9yZWkiLCJVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wiLCJOb2RlQ2FudmFzSW1hZ2UiLCJnZW5lcmF0ZU1pcG1hcCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX1dSQVBfUyIsIlRFWFRVUkVfV1JBUF9UIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwibWF4VGV4dHVyZVNpemUiLCJsb3NlQ29udGV4dEV4dGVuc2lvbiIsImdldEV4dGVuc2lvbiIsImxvc2VDb250ZXh0IiwiZ2V0TWF4SW50UHJlY2lzaW9uIiwiX29uVGV4dHVyZVVwZGF0ZSIsIl9hbmNob3IiLCJfc21vb3RoRG93bnNjYWxpbmciLCJfcG90UmVuZGVyZXIiLCJ0cmFuc2Zvcm0iLCJkeCIsImR5IiwidGV4dHVyZVBpeGVsUmF0aW8iLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwiaXNBdFBvc2l0aW9uIiwibG9jYWxQb3NpdGlvbiIsInVwcGVyTGVmdCIsImxvd2VyUmlnaHQiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiaXNTbW9vdGhEb3duc2NhbGluZyIsIl9zZXR1cEZpbHRlck1hbmFnZXIiLCJfc2V0dXBCdWZmZXIiLCJfc2V0dXBXZWJHTFJlbmRlclRhcmdldCIsIl9zZXR1cENhbnZhc1JlbmRlclRhcmdldCIsInRlbXBGaWx0ZXJNYW5hZ2VyIiwiZ2V0UmVuZGVyVGFyZ2V0IiwiUXVhZCIsIl9pbml0QnVmZmVycyIsIl91cGxvYWRCdWZmZXJzIiwicmVjdDEiLCJyZWN0MiIsIlRleHR1cmVVVnMiLCJiYXNlRnJhbWUiLCJ1diIsIldlYkdMTWVtb3J5TWFuYWdlciIsIl9ob29rSW50b0NvbnRleHQiLCJfZnJhbWVidWZmZXJzIiwiX3Byb2dyYW1zIiwiX2J1ZmZlcnMiLCJfYm91bmRUZXh0dXJlIiwiX2lkIiwiX3NldHVwU3RhdHMiLCJfdXBkYXRlTWVtb3J5U3RhdHMiLCJfc3RhdHMiLCJzaG93UGFuZWwiLCJfbWVtUGFuZWwiLCJhZGRQYW5lbCIsIlBhbmVsIiwiX3RleFBhbmVsIiwiX2J1ZlBhbmVsIiwiX2Zib1BhbmVsIiwiX3ByZ1BhbmVsIiwiX3NoZFBhbmVsIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZG9tIiwidG9wIiwiX3VwZGF0ZVBhbmVsIiwicGFuZWwiLCJiZWdpbiIsImdldFRleHR1cmVzQ291bnQiLCJnZXRCdWZmZXJzQ291bnQiLCJnZXRGQk9Db3VudCIsImdldFByb2dyYW1Db3VudCIsImdldFNoYWRlckNvdW50IiwibWVtb3J5IiwiX2dldE1lbW9yeVVzYWdlIiwiYnl0ZXMiLCJfdHJhY2tHTENhbGwiLCJvdmVycmlkZUZ1bmN0aW9ucyIsIl9jcmVhdGVQcm9ncmFtIiwiX3dtbUlkIiwiX2RlbGV0ZVByb2dyYW0iLCJfY3JlYXRlU2hhZGVyIiwiX2RlbGV0ZVNoYWRlciIsIl9jcmVhdGVGcmFtZWJ1ZmZlciIsImZyYW1lYnVmZmVyIiwiX2RlbGV0ZUZyYW1lYnVmZmVyIiwiX2NyZWF0ZUJ1ZmZlciIsImJ1ZmZlciIsIl9iaW5kQnVmZmVyIiwiX2JvdW5kQnVmZmVyIiwiX2J1ZmZlckRhdGEiLCJzaXplT3JEYXRhIiwidXNhZ2UiLCJzaXplIiwiYnl0ZUxlbmd0aCIsIl9kZWxldGVCdWZmZXIiLCJfY3JlYXRlVGV4dHVyZSIsIl9kZWxldGVUZXh0dXJlIiwiX2JpbmRUZXh0dXJlIiwiX3RleEltYWdlMkQiLCJpbnRlcm5hbGZvcm1hdCIsImJvcmRlciIsImJ5dGVDb3VudCIsIl9jYWxjdWxhdGVCeXRlQ291bnRGb3JUZXh0dXJlIiwiZm9ybWF0IiwiYnl0ZXNQZXJQaXhlbCIsIkFMUEhBIiwiUkdCIiwiQXJyYXlTdHJlYW0iLCJfaGVhZCIsInBlZWtJbnQ4IiwibGl0dGxlRW5kaWFuIiwicGVla0ludDI0IiwicGVla0ludDMyIiwibnVtIiwicmVhZEludDI0IiwiY2hhcmFjdGVyIiwiaGVhZCIsIkltYWdlRXhwb3J0ZXIiLCJfcHJlcGFyZVNESyIsIl9jcmVhdGVDYW52YXNGcm9tVGV4dHVyZSIsInRvRGF0YVVSTCIsInJlbmRlckNvbnRleHRUb0NhbnZhcyIsIm91dHB1dEltYWdlIiwidG9CdWZmZXIiLCJtc1RvQmxvYiIsInRvQmxvYiIsIl9yZXN0b3JlU0RLIiwiX3Nka1NldHRpbmdzIiwiZmJvIiwicmVhZFBpeGVscyIsImhhc1RyYW5zcGFyZW5jeSIsIl9jaGVja1BpeGVsc0ZvclRyYW5zcGFyZW5jeSIsImNvbnRhaW5lciIsImNyZWF0ZUltYWdlRGF0YSIsIm1heEluZGV4IiwiSE9TVCIsImRldmVsb3BtZW50IiwicHJvZHVjdGlvbiIsIkFVVEhfUEFUSCIsIkNCX1NVRkZJWCIsIlRSQUNLX1BBVEgiLCJBVVRIT1JJWkVEIiwiRVJST1IiLCJhcGlLZXkiLCJfWVhCcFMyVjUiLCJfbG9hZEpTT04iLCJ1cmwiLCJfbG9hZEpTT05Ccm93c2VyIiwiX2xvYWRKU09OTm9kZSIsInNjcmlwdCIsInBhcmVudE5vZGUiLCJhc3luYyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiTm9kZUdMRXhwb3J0ZXIiLCJJbWFnZURhdGEiLCJQT1RSZW5kZXJlciIsImlucHV0U3ByaXRlIiwibmV4dFBPVCIsIl9nZXROZXh0SGlnaGVzdFBPVCIsImluaXRpYWxEaW1lbnNpb25zIiwiVkVSU0lPTl9DSEVDS19GTiIsIlZFUlNJT05fQ0hFQ0tfVVJMIiwiVmVyc2lvbkNoZWNrZXIiLCJfdmVyc2lvbiIsIl9jaGVjayIsIm91dGRhdGVkIiwiQWRqdXN0bWVudHNPcGVyYXRpb24iLCJfY2xhcml0eUZpbHRlciIsImNsYXJpdHkiLCJ0ZXhTaXplIiwiQ2xhcml0eUZpbHRlciIsIl9sYXN0Q2xhcml0eSIsIl9ibHVycmVkUmVuZGVyVGFyZ2V0IiwiX291dHB1dFJlbmRlclRleHR1cmUiLCJfYmx1ckltYWdlIiwiX2FwcGx5Q2xhcml0eSIsImlucHV0Q2FudmFzIiwiYmx1cnJ5SW1hZ2VEYXRhIiwiYmx1cnJ5Q29udGV4dCIsImJsdXJyZWRDb250ZXh0IiwiaW5wdXRJbWFnZURhdGEiLCJibHVycmVkUGl4ZWxzIiwiaW52ZXJzZVNhdHVyYXRpb24iLCJpbnZlcnNlRmFjdG9yIiwibHVtaW5hbmNlU2F0dXJhdGlvbiIsIkNyb3BPcGVyYXRpb24iLCJmaW5hbFNjYWxlIiwic2NhbGVkSW5wdXREaW1lbnNpb25zIiwidG1wU3RhcnQiLCJyb3RhdGUiLCJkZWdyZWVzRGlmZmVyZW5jZSIsInRlbXBTdGFydCIsIkV4aWZPcmllbnRhdGlvbk9wZXJhdGlvbiIsIl9nZXRSb3RhdGlvbiIsIl9nZXRGbGlwVmVydGljYWxseSIsIl9nZXRGbGlwSG9yaXpvbnRhbGx5IiwiX2dldEZpbmFsT3B0aW9ucyIsImZsaXBWZXJ0aWNhbGx5IiwiZmxpcEhvcml6b250YWxseSIsIkZpbHRlck9wZXJhdGlvbiIsIl9zZWxlY3RlZEZpbHRlciIsImdldERpcnR5IiwiRmlsdGVyUHJpbWl0aXZlcyIsIkExNUZpbHRlciIsIkNvbnRyYXN0IiwiQnJpZ2h0bmVzcyIsIlRvbmVDdXJ2ZSIsInJnYkNvbnRyb2xQb2ludHMiLCJyZWQiLCJncmVlbiIsImJsdWUiLCJCcmVlemVGaWx0ZXIiLCJEZXNhdHVyYXRpb24iLCJkZXNhdHVyYXRpb24iLCJCV0ZpbHRlciIsIkdyYXlzY2FsZSIsIkJXSGFyZEZpbHRlciIsIkNlbHNpdXNGaWx0ZXIiLCJDaGVzdEZpbHRlciIsIkZpeGllRmlsdGVyIiwiRm9vZEZpbHRlciIsIlNhdHVyYXRpb24iLCJGcmlkZ2VGaWx0ZXIiLCJGcm9udEZpbHRlciIsIkdsYW1GaWx0ZXIiLCJHb2JibGluRmlsdGVyIiwiR29iYmxpbiIsIksxRmlsdGVyIiwiY29udHJvbFBvaW50cyIsIksyRmlsdGVyIiwiU29mdENvbG9yT3ZlcmxheSIsIks2RmlsdGVyIiwiS0R5bmFtaWNGaWx0ZXIiLCJMZW5pbkZpbHRlciIsIkxvbW9GaWx0ZXIiLCJMVVRGaWx0ZXIiLCJfbHV0UHJpbWl0aXZlIiwiTG9va3VwVGFibGVJbWFnZSIsIk1lbGxvd0ZpbHRlciIsIk1ldGFsRmlsdGVyIiwibWF0cml4MSIsIkNvbG9yTWF0cml4UHJpbWl0aXZlIiwiY29sb3JtYXRyaXgiLCJnYW1tYUNvbG9yIiwiR2FtbWEiLCJNb3JuaW5nRmlsdGVyIiwiR2xvdyIsIk9yY2hpZEZpbHRlciIsIlBvbGFGaWx0ZXIiLCJQb2xhNjY5RmlsdGVyIiwiQmxlbmRGaWx0ZXIiLCJmaWx0ZXJlZENhbnZhcyIsImZpbHRlcmVkSW1hZ2UiLCJfaW50ZW5zaXR5IiwiX2JsZW5kRmlsdGVyIiwicHJpbWl0aXZlIiwiZmlsdGVyZWRSZW5kZXJUZXh0dXJlIiwic2hvdWxkUmVuZGVyIiwic2V0RmlsdGVyZWRDYW52YXMiLCJnZXRGaWx0ZXJlZEltYWdlIiwiQnJpZ2h0bmVzc0ZpbHRlciIsInNldEJyaWdodG5lc3MiLCJDb2xvck1hdHJpeEZpbHRlciIsInNldENvbG9ybWF0cml4IiwiQ29udHJhc3RGaWx0ZXIiLCJzZXRDb250cmFzdCIsIkRlc2F0dXJhdGlvbkZpbHRlciIsInNldERlc2F0dXJhdGlvbiIsIkdhbW1hRmlsdGVyIiwiZ2FtbWFBcnJheVJlZCIsImdhbW1hQXJyYXlHcmVlbiIsImdhbW1hQXJyYXlCbHVlIiwic2V0R2FtbWEiLCJHbG93RmlsdGVyIiwieDAxIiwieTAxIiwibngiLCJueSIsInNjYWxhclgiLCJzY2FsYXJZIiwic2V0Q29sb3IiLCJHcmF5c2NhbGVGaWx0ZXIiLCJMb29rdXBUYWJsZUltYWdlRmlsdGVyIiwiX3ByZWNvbXB1dGVRdWFkcyIsIl9xdWFkcyIsImJsdWVDb2xvciIsInF1YWQiLCJsdXRJbWFnZSIsImxvb2t1cFRhYmxlSW1hZ2UiLCJsdXRDYW52YXMiLCJfY3JlYXRlSW1hZ2VDYW52YXMiLCJsdXRDb250ZXh0IiwiZmlsdGVySW1hZ2VEYXRhIiwidGV4Q29vcmQiLCJ0aWxlU2lkZUxlbmd0aCIsInRleENvb3JkSW5kZXgiLCJuZXdSIiwibmV3RyIsIm5ld0IiLCJzZXRMb29rdXBUYWJsZUltYWdlIiwiU2F0dXJhdGlvbkZpbHRlciIsInNldFNhdHVyYXRpb24iLCJTb2Z0Q29sb3JPdmVybGF5RmlsdGVyIiwiX3VwZGF0ZUxvb2t1cFRhYmxlIiwiX2NhbGN1bGF0ZVNwbGluZUN1cnZlIiwiX2J1aWxkTG9va3VwVGFibGUiLCJwb2ludHMiLCJzcGxpbmVQb2ludHMiLCJfZ2V0U3BsaW5lQ3VydmUiLCJmaXJzdFNwbGluZVBvaW50IiwicHJlcGFyZWRQb2ludHMiLCJuZXdQb2ludCIsIm9yaWdQb2ludCIsImRpc3RhbmNlIiwic2RBIiwiX3NlY29uZERlcml2YXRpdmUiLCJzZCIsImN1ciIsIlAxIiwiUDIiLCJQMyIsInkyIiwiWDQwMEZpbHRlciIsImdyYXkiLCJYNDAwIiwiUXVvemlGaWx0ZXIiLCJTZW1pcmVkRmlsdGVyIiwiU3VubnlGaWx0ZXIiLCJUZXhhc0ZpbHRlciIsIkxpbmVhckZvY3VzRmlsdGVyIiwiX2xhc3RCbHVyUmFkaXVzIiwiX2xhc3RHcmFkaWVudFJhZGl1cyIsIl9sYXN0U3RhcnQiLCJfbGFzdEVuZCIsIl9tYXNrUmVuZGVyVGFyZ2V0IiwiX3JlbmRlck1hc2siLCJibHVyUmFkaXVzIiwiX2FwcGx5TWFzayIsImNhbnZhc0RpbWVuc2lvbnMiLCJncmFkaWVudFNpemUiLCJkaXN0IiwibWlkZGxlIiwidG90YWxEaXN0IiwiZ3JhZGllbnRTdGFydCIsImdyYWRpZW50RW5kIiwiZ3JhZGllbnQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImZ1bGxHcmFkaWVudFNpemUiLCJhZGRDb2xvclN0b3AiLCJtYXNrQ29udGV4dCIsIm1hc2tQaXhlbHMiLCJkZWx0YSIsIlJhZGlhbEZvY3VzRmlsdGVyIiwiX2xhc3RQb3NpdGlvbiIsImdyYWRpZW50UmFkaXVzIiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJGcmFtZU9wZXJhdGlvbiIsIl9jb2xvck92ZXJsYXlGaWx0ZXIiLCJnZXRUaW50Q29sb3IiLCJfZnJhbWVDb250YWluZXIiLCJfcmVzZXRTcHJpdGVzIiwiX2NyZWF0ZVNwcml0ZXNGb3JGcmFtZSIsIl9zcHJpdGVHcm91cHMiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJfcmVwZWF0U3ByaXRlcyIsIl9kaXNwb3NlU3ByaXRlcyIsImltYWdlR3JvdXBzIiwibGF5b3V0TW9kZSIsIl9sYXlvdXRNb2RlIiwiZ3JvdXAiLCJwYXJ0IiwiX3VwZGF0ZVNwcml0ZXMiLCJfZnJhbWVSZW5kZXJUZXh0dXJlIiwiX2ZyYW1lU3ByaXRlIiwiaXNXZWJHTCIsInRpbnRhYmxlIiwiX2ZyYW1lV2lkdGgiLCJfdXBkYXRlSG9yaXpvbnRhbFNwcml0ZUdyb3VwIiwiX3VwZGF0ZVZlcnRpY2FsU3ByaXRlR3JvdXAiLCJob3Jpem9udGFsSW5zaWRlIiwic3RhcnRTcHJpdGUiLCJtaWRTcHJpdGUiLCJtaWQiLCJlbmRTcHJpdGUiLCJzdGFydFdpZHRoIiwiZW5kV2lkdGgiLCJ0ZXh0dXJlUmF0aW8iLCJzdGFydFBvc2l0aW9uIiwiZW5kUG9zaXRpb24iLCJtaWRQb3NpdGlvbiIsIm1pZFdpZHRoIiwibW9kZSIsImRlZmF1bHRTcHJpdGVXaWR0aCIsInJlcXVpcmVkUmVwZWF0U3ByaXRlcyIsImNvbnN1bWVkV2lkdGgiLCJzcHJpdGVXaWR0aCIsIl9lbnN1cmVSZXBlYXRTcHJpdGVzRXhpc3QiLCJzcHJpdGVQb3NpdGlvbiIsInJlcXVpcmVkU3ByaXRlc0NvdW50Iiwic291cmNlU3ByaXRlIiwiZXhpc3RpbmdTcHJpdGVzQ291bnQiLCJtaXNzaW5nUmVwZWF0U3ByaXRlcyIsInNwYXJlUmVwZWF0U3ByaXRlcyIsInZlcnRpY2FsSW5zaWRlIiwic3RhcnRIZWlnaHQiLCJlbmRIZWlnaHQiLCJtaWRIZWlnaHQiLCJkZWZhdWx0U3ByaXRlSGVpZ2h0IiwiY29uc3VtZWRIZWlnaHQiLCJzcHJpdGVIZWlnaHQiLCJ2YWxpZGF0ZUZyYW1lIiwibGFiZWwiLCJ2YWxpZGF0ZUltYWdlR3JvdXAiLCJ0aW50Q29sb3IiLCJMaW5lYXJGb2N1c09wZXJhdGlvbiIsIl9sYXN0U2l6ZSIsIl9sYXN0R3JhZGllbnRTaXplIiwiX2hvcml6b250YWxGaWx0ZXIiLCJfdmVydGljYWxGaWx0ZXIiLCJzZXREZWx0YSIsInNob3J0ZXN0U2lkZSIsImNvbW1vbk9wdGlvbnMiLCJPcmllbnRhdGlvbk9wZXJhdGlvbiIsInNldEZsaXBWZXJ0aWNhbGx5IiwiZ2V0RmxpcFZlcnRpY2FsbHkiLCJzZXRGbGlwSG9yaXpvbnRhbGx5IiwiZ2V0RmxpcEhvcml6b250YWxseSIsIlJhZGlhbEZvY3VzT3BlcmF0aW9uIiwiU2VsZWN0aXZlQmx1ck9wZXJhdGlvbiIsIl9ibHVycmVkUmVuZGVyVGV4dHVyZSIsIl9tYXNrUmVuZGVyVGV4dHVyZSIsIl9icnVzaCIsIl9icnVzaENvbnRhaW5lciIsImJydXNoU3ByaXRlIiwiX291dHB1dFNwcml0ZSIsIl9vdXRwdXRDb250YWluZXIiLCJfbWFza0ZpbHRlciIsImdldE1hc2tJbWFnZSIsImdldEZpbHRlckltYWdlIiwiX2JsdXJGaWx0ZXIiLCJzZXRNYXNrQ2FudmFzIiwic2V0RmlsdGVyQ2FudmFzIiwiY3JvcCIsIl9yZW5kZXJCbHVyIiwibWFza0RpbWVuc2lvbnMiLCJibHVycmVkRGltZW5zaW9ucyIsImJsdXJPcHRpb25zIiwiZ2V0QnJ1c2giLCJzZXRQYXRocyIsIkJsdXJGaWx0ZXIiLCJNYXNrRmlsdGVyIiwibWFza0NhbnZhcyIsImZpbHRlckNhbnZhcyIsImZpbHRlckNvbnRleHQiLCJleGlzdGluZ0ltYWdlRGF0YSIsImV4aXN0aW5nUGl4ZWxzIiwibmV3UGl4ZWxzIiwibWFza0ltYWdlIiwiZmlsdGVySW1hZ2UiLCJTcHJpdGVPcGVyYXRpb24iLCJfb25TcHJpdGVVcGRhdGUiLCJzcHJpdGVzIiwicmVtb3ZlU3ByaXRlIiwiYWRkU3ByaXRlIiwiZ2V0U3ByaXRlc09mVHlwZSIsIktsYXNzIiwiX2FwcGx5Um90YXRpb24iLCJjcmVhdGVTdGlja2VyIiwiY3JlYXRlVGV4dCIsImNyZWF0ZUJydXNoIiwidGFrZVNwcml0ZVRvRnJvbnQiLCJzcHJpdGVJbmRleCIsImdldFNwcml0ZXNBdFBvc2l0aW9uIiwiaW50ZXJzZWN0aW5nU3ByaXRlcyIsIm91dHB1dFNwcml0ZSIsImFjdHVhbFBvc2l0aW9uIiwiYW5jaG9yT2Zmc2V0IiwiU3RpY2tlciIsIlRleHQiLCJzcHJpdGVzVG9SZW1vdmUiLCJDb250cm9sUG9pbnQiLCJfcGF0aCIsIl9kcmF3bkNhbnZhc2VzIiwiYnJ1c2giLCJsYXN0Q29udHJvbFBvaW50IiwibGFzdFBvc2l0aW9uIiwic3RlcCIsIlBhdGgiLCJfbGFzdEJydXNoVGhpY2tuZXNzIiwiX2JydXNoSW5wdXREaW1lbnNpb25zIiwiX2NyZWF0ZUJydXNoIiwidHJhbnNwYXJlbnRDb2xvciIsImFkZENvbnRyb2xQb2ludCIsInBvaW50IiwiZ2V0Q2FudmFzRGltZW5zaW9ucyIsIl9jYW52YXNEaW1lbnNpb25zIiwiUkVEIiwiY2xvc2VkIiwiX29uSW1hZ2VVcGRhdGUiLCJfYWRqdXN0bWVudHNGaWx0ZXIiLCJhZGp1c3RtZW50cyIsIl9oYXNBZGp1c3RtZW50cyIsIk5VTEwiLCJnZXRCcmlnaHRuZXNzIiwiZ2V0U2F0dXJhdGlvbiIsImdldENvbnRyYXN0IiwiX2FwcGx5RmxpcCIsIm5ld0RlZ3JlZXMiLCJkaXJ0aW5lc3MiLCJfdGV4dFJlbmRlcmVyIiwiZ2V0RE9NU3R5bGUiLCJhY3R1YWxGb250U2l6ZSIsImdldEZvbnRTaXplIiwiZm9udFdlaWdodCIsImZvbnRTaXplIiwiZm9udFN0eWxlIiwiZm9udEZhbWlseSIsImxpbmVIZWlnaHQiLCJnZXRMaW5lSGVpZ2h0IiwiYmFja2dyb3VuZENvbG9yIiwidGV4dEFsaWduIiwiYWxpZ25tZW50IiwiZ2V0Qm91bmRpbmdCb3giLCJvbGRTaXplIiwic2V0Rm9udFNpemUiLCJzZXRNYXhXaWR0aCIsImdldE1heFdpZHRoIiwidGV4dFRleHR1cmUiLCJvdXRsaW5lV2lkdGgiLCJvdXRsaW5lQ29sb3IiLCJ2ZXJ0aWNhbEFsaWdubWVudCIsInRleHQiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIlRleHRSZW5kZXJlciIsIl90ZXh0IiwiX3RleHRPcHRpb25zIiwiX2NyZWF0ZU1lYXN1cmVtZW50Q2FudmFzIiwiX3RleHRTcGxpdHRlciIsIl9tZWFzdXJlbWVudENhbnZhcyIsIl9tZWFzdXJlbWVudENvbnRleHQiLCJfYXBwbHlUZXh0T3B0aW9ucyIsInRleHRPcHRpb25zIiwiZm9udCIsImdldEZvbnRXZWlnaHQiLCJnZXRGb250RmFtaWx5IiwidGV4dEJhc2VsaW5lIiwiZ2V0QWxpZ25tZW50IiwiZ2V0Q29sb3IiLCJzdHJva2VTdHlsZSIsImdldE91dGxpbmVDb2xvciIsImdldE91dGxpbmVXaWR0aCIsImxpbmVXaWR0aCIsIl9idWlsZE91dHB1dExpbmVzIiwic2V0VGV4dCIsImdldFRleHQiLCJnZXRMaW5lcyIsIl9yZW5kZXJUZXh0TGluZSIsInRleHRBbGlnbm1lbnQiLCJkcmF3UG9zaXRpb24iLCJmaWxsVGV4dCIsIm1pdGVyTGltaXQiLCJzdHJva2VUZXh0IiwiY2FsY3VsYXRlRm9udFN0eWxlcyIsIl9jYWxjdWxhdGVUZXh0IiwiYm91bmRpbmdCb3giLCJfcmVuZGVyVGV4dCIsImdldE1heEhlaWdodCIsImdldEJhY2tncm91bmRDb2xvciIsImxpbmVOdW0iLCJfbWF4VGV4dEhlaWdodCIsIm1lYXN1cmVUZXh0IiwibWF4VGV4dEhlaWdodCIsIl9nZXRNYXhUZXh0SGVpZ2h0IiwiX2dldE1heFRleHRIZWlnaHRVc2luZ0RPTSIsIm1lYXN1cmVFbGVtZW50IiwiYmxvY2tlZFByb3BzIiwid2hpdGVTcGFjZSIsImlubmVySFRNTCIsIm9mZnNldEhlaWdodCIsIl9nZXRNYXhUZXh0SGVpZ2h0VXNpbmdDYW52YXMiLCJjaGFycyIsImNoYXJzQ291bnQiLCJwb2ludGVyIiwicHJpbnRhYmxlU3RyaW5nIiwic3RhcnRZIiwicGl4ZWxGb3VuZCIsImVuZFkiLCJUZXh0U3BsaXR0ZXIiLCJfbGFzdEZvbnRTdHlsZSIsIm5ld0xpbmVXb3JkcyIsImxpbmVzQ291bnQiLCJfbGluZXMiLCJ3b3JkcyIsIl9idWlsZFdvcmRzIiwid29yZHNDb3VudCIsInciLCJ3b3JkIiwiY3VycmVudExpbmUiLCJfZ2V0V2lkdGgiLCJfbWF4V2lkdGgiLCJfd29yZCIsInNwbGl0V29yZCIsIl9zcGxpdFdvcmQiLCJyZXN0IiwiY2hhciIsIndvcmRMZW5ndGgiLCJfZm9udFN0eWxlQ2hhbmdlZCIsInN0cmluZyIsIldhdGVybWFya09wZXJhdGlvbiIsIl93YXRlcm1hcmtTcHJpdGUiLCJfd2F0ZXJtYXJrVGV4dHVyZSIsInJvb3QiLCJyQUYiLCJjQUYiLCJsYXN0VGltZSIsInZlbmRvcnMiLCJlbGVtZW50IiwiY3VyclRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsInRpbWVUb0NhbGwiLCJjbGVhclRpbWVvdXQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Es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O0FBQy9CO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsQ0FBQyxFOzs7Ozs7QUNoQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3R0FBd0csT0FBTztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7O0FDWkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDcERBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFOzs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sVUFBVSxjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0EsRTs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELEU7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QWY7O0FBRUE7O0FBRUEsY0FBZUYsTUFBZjs7QUFFQXdDLE9BQU9WLE9BQVAsaUIiLCJmaWxlIjoiUGhvdG9FZGl0b3JTREsuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQaG90b0VkaXRvclNES1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJQaG90b0VkaXRvclNES1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9yeSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb3J5IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHR9KTtcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjU2KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA4OWFlNzc5MDBiZWM0YWQ2NDVmZiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pZiAoRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICduYW1lJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZ1bmNOYW1lUmVnZXggPSAvZnVuY3Rpb25cXHMoW14oXXsxLH0pXFwoL1xuICAgICAgdmFyIHJlc3VsdHMgPSAoZnVuY05hbWVSZWdleCkuZXhlYygodGhpcykudG9TdHJpbmcoKSlcbiAgICAgIHJldHVybiAocmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCA+IDEpID8gcmVzdWx0c1sxXS50cmltKCkgOiAnJ1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHt9XG4gIH0pXG4gIC8qIGVzbGludC1lbmFibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xufVxuXG5pbXBvcnQgRW5naW5lIGZyb20gJy4vZW5naW5lJ1xuXG5pbXBvcnQgKiBhcyBDb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnXG5cbmltcG9ydCBCYXNlNjQgZnJvbSAnLi9saWIvYmFzZTY0J1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2xpYi9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vbGliL3V0aWxzJ1xuaW1wb3J0IENvbmZpZ3VyYWJsZSBmcm9tICcuL2xpYi9jb25maWd1cmFibGUnXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi9saWIvY29sb3InXG5pbXBvcnQgTG9nIGZyb20gJy4uL3NoYXJlZC9sb2cnXG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuL3ZlbmRvci9wcm9taXNlJ1xuaW1wb3J0IEdMVXRpbHMgZnJvbSAnLi9saWIvZ2wtdXRpbHMnXG5pbXBvcnQgTGljZW5zaW5nIGZyb20gJy4vbGliL2xpY2Vuc2luZydcblxuZXhwb3J0IHsgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSB9IGZyb20gJy4uL3NoYXJlZC9hbmltYXRpb24tZnJhbWUnXG5cbmV4cG9ydCB7XG4gIEVuZ2luZSxcbiAgRXZlbnRFbWl0dGVyLFxuICBVdGlscyxcbiAgQ29uZmlndXJhYmxlLFxuICBDb2xvcixcbiAgQ29uc3RhbnRzLFxuICBMb2csXG4gIFByb21pc2UsXG4gIEdMVXRpbHMsXG4gIEJhc2U2NCxcbiAgTGljZW5zaW5nXG59XG5cbmV4cG9ydCAqIGZyb20gJy4vbGliL21hdGgvJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZ2xvYmFscy5qcyIsIi8qIGpzaGludCB1bnVzZWQ6IGZhbHNlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5jb25zdCB7IE9wdGlvblR5cGUgfSA9IENvbnN0YW50c1xuaW1wb3J0IFByaW1pdGl2ZXNTdGFjayBmcm9tICcuL3ByaW1pdGl2ZXMtc3RhY2snXG5pbXBvcnQgQ29uZmlndXJhYmxlIGZyb20gJy4uLy4uL2xpYi9jb25maWd1cmFibGUnXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZmlsdGVycy4gRXh0ZW5kYWJsZSB2aWEge0BsaW5rIFBob3RvRWRpdG9yU0RLLkZpbHRlciNleHRlbmR9XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICovXG5jbGFzcyBGaWx0ZXIgZXh0ZW5kcyBDb25maWd1cmFibGUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucywge1xuICAgICAgaW50ZW5zaXR5OiB7XG4gICAgICAgIHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLFxuICAgICAgICBkZWZhdWx0OiAxLjAsXG4gICAgICAgIHNldHRlcjogZnVuY3Rpb24gKGludGVuc2l0eSkge1xuICAgICAgICAgIHRoaXMuX3N0YWNrICYmXG4gICAgICAgICAgICB0aGlzLl9zdGFjay5zZXRJbnRlbnNpdHkoaW50ZW5zaXR5KVxuICAgICAgICAgIHJldHVybiBpbnRlbnNpdHlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpcnR5OiB7XG4gICAgICAgIHR5cGU6IE9wdGlvblR5cGUuQk9PTEVBTixcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9zdGFjayA9IG5ldyBQcmltaXRpdmVzU3RhY2sodGhpcy5fb3B0aW9ucy5pbnRlbnNpdHkpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlRleHR1cmV9IGlucHV0VGV4dHVyZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGV4dHVyZX0gb3V0cHV0VGV4dHVyZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChzZGssIGlucHV0VGV4dHVyZSwgb3V0cHV0VGV4dHVyZSkge1xuICAgIHJldHVybiB0aGlzLl9zdGFjay5yZW5kZXIoc2RrLCBpbnB1dFRleHR1cmUsIG91dHB1dFRleHR1cmUpXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgdGhpcy5zZXREaXJ0eShmYWxzZSlcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcnRpbmVzcyBmb3IgdGhlIGdpdmVuIHJlbmRlcmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgc2V0RGlydHlGb3JSZW5kZXJlciAoZGlydHksIHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fc3RhY2suc2V0RGlydHlGb3JSZW5kZXJlcihkaXJ0eSwgcmVuZGVyZXIpXG4gIH1cblxuICAvKipcbiAgICogRnJlZXMgdGhlIG1lbW9yeVxuICAgKi9cbiAgZGlzcG9zZVJlbmRlclRleHR1cmVzICgpIHtcbiAgICB0aGlzLl9zdGFjay5kaXNwb3NlUmVuZGVyVGV4dHVyZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB0aGlzIGluc3RhbmNlIHVwXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9zdGFjay5kaXNwb3NlKClcbiAgfVxufVxuXG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZpbHRlci5pZGVudGlmaWVyID0gbnVsbFxuXG4vKipcbiAqIElmIGBpc0lkZW50aXR5YCBpcyB0cnVlLCB0aGlzIGZpbHRlciBkb2VzIG5vdCBkbyBhbnl0aGluZyBhbmQgY2FuIGJlIHNlZW4gYXNcbiAqIHRoZSBkZWZhdWx0IGZpbHRlci5cbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5GaWx0ZXIuaXNJZGVudGl0eSA9IGZhbHNlXG5cbi8qKlxuICogVGhpcyBzdHJpbmcgaXMgdXNlZCBieSB0aGUgVUlcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZpbHRlci5kaXNwbGF5TmFtZSA9IG51bGxcblxuLy8gRXhwb3NlZCBjbGFzc2VzXG5GaWx0ZXIuUHJpbWl0aXZlc1N0YWNrID0gUHJpbWl0aXZlc1N0YWNrXG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBGaWx0ZXIgcHJpbWl0aXZlcyBhcmUgdGhlIGNvcmUgb2YgZmlsdGVycy4gT25lIGZpbHRlciBjb25zaXN0cyBvZiBtdWx0aXBsZSBmaWx0ZXIgcHJpbWl0aXZlcy5cbiAqIEZvciBhbiBleGFtcGxlLCBsb29rIGF0IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGZpbHRlciwgZS5nLiB7QGxpbmsgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5BMTVGaWx0ZXJ9XG4gKiBvciBzZWUgb3VyIGRvY3VtZW50YXRpb24gYXQge0BsaW5rIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9kb2NzfS5cbiAqIEBuYW1lc3BhY2UgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJyaWdodG5lc3MgfSBmcm9tICcuL2JyaWdodG5lc3MnXG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbnRyYXN0IH0gZnJvbSAnLi9jb250cmFzdCdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sb3JNYXRyaXhQcmltaXRpdmUgfSBmcm9tICcuL2NvbG9yLW1hdHJpeCdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGVzYXR1cmF0aW9uIH0gZnJvbSAnLi9kZXNhdHVyYXRpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIEdhbW1hIH0gZnJvbSAnLi9nYW1tYSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR2xvdyB9IGZyb20gJy4vZ2xvdydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR29iYmxpbiB9IGZyb20gJy4vZ29iYmxpbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JheXNjYWxlIH0gZnJvbSAnLi9ncmF5c2NhbGUnXG5leHBvcnQgeyBkZWZhdWx0IGFzIExvb2t1cFRhYmxlIH0gZnJvbSAnLi9sb29rdXAtdGFibGUnXG5leHBvcnQgeyBkZWZhdWx0IGFzIExvb2t1cFRhYmxlSW1hZ2UgfSBmcm9tICcuL2xvb2t1cC10YWJsZS1pbWFnZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2F0dXJhdGlvbiB9IGZyb20gJy4vc2F0dXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU29mdENvbG9yT3ZlcmxheSB9IGZyb20gJy4vc29mdC1jb2xvci1vdmVybGF5J1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUb25lQ3VydmUgfSBmcm9tICcuL3RvbmUtY3VydmUnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFg0MDAgfSBmcm9tICcuL3g0MDAnXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IExvZyBmcm9tICcuLi8uLi9zaGFyZWQvbG9nJ1xuaW1wb3J0IENvbG9yIGZyb20gJy4uL2xpYi9jb2xvcidcbmltcG9ydCBNYXRyaXggZnJvbSAnLi4vbGliL21hdGgvbWF0cml4J1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuLi9saWIvbWF0aC9yZWN0YW5nbGUnXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi9saWIvbWF0aC92ZWN0b3IyJ1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9saWIvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBVdGlscyBmcm9tICcuLi9saWIvdXRpbHMnXG5pbXBvcnQgR0xVdGlscyBmcm9tICcuLi9saWIvZ2wtdXRpbHMnXG5pbXBvcnQgKiBhcyBDb25zdGFudHMgZnJvbSAnLi4vY29uc3RhbnRzJ1xuXG5leHBvcnRzLkJBVENIX1NJWkUgPSAyMDAwXG5leHBvcnRzLlZFUlRFWF9TSVpFID0gNVxuZXhwb3J0cy5WRVJURVhfQllURV9TSVpFID0gZXhwb3J0cy5WRVJURVhfU0laRSAqIDRcblxuZXhwb3J0cy5Db2xvciA9IENvbG9yXG5leHBvcnRzLk1hdHJpeCA9IE1hdHJpeFxuZXhwb3J0cy5WZWN0b3IyID0gVmVjdG9yMlxuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGVcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyXG5leHBvcnRzLkxvZyA9IExvZ1xuZXhwb3J0cy5VdGlscyA9IFV0aWxzXG5leHBvcnRzLkNvbnN0YW50cyA9IENvbnN0YW50c1xuZXhwb3J0cy5HTFV0aWxzID0gR0xVdGlsc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL2dsb2JhbHMuanMiLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLypcbiAqIE5hdGl2ZSBQcm9taXNlIE9ubHlcbiAqIHYwLjguMC1hIChjKSBLeWxlIFNpbXBzb25cbiAqIE1JVCBMaWNlbnNlOiBodHRwOi8vZ2V0aWZ5Lm1pdC1saWNlbnNlLm9yZ1xuICogQGxpY2Vuc2VcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbihmdW5jdGlvbiBVTUQobmFtZSxjb250ZXh0LGRlZmluaXRpb24pe1xuICAvLyBzcGVjaWFsIGZvcm0gb2YgVU1EIGZvciBwb2x5ZmlsbGluZyBhY3Jvc3MgZXZpcm9ubWVudHNcbiAgY29udGV4dFtuYW1lXSA9IGNvbnRleHRbbmFtZV0gfHwgZGVmaW5pdGlvbigpO1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0W25hbWVdO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gJEFNRCQoKXsgcmV0dXJuIGNvbnRleHRbbmFtZV07IH0pO1xuICB9XG59KShcIlByb21pc2VcIix0eXBlb2YgZ2xvYmFsICE9IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0aGlzLGZ1bmN0aW9uIERFRigpe1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgYnVpbHRJblByb3AsIGN5Y2xlLCBzY2hlZHVsaW5nX3F1ZXVlLFxuICAgIFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICB0aW1lciA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9IFwidW5kZWZpbmVkXCIpID9cbiAgICAgIGZ1bmN0aW9uIHRpbWVyKGZuKSB7IHJldHVybiBzZXRJbW1lZGlhdGUoZm4pOyB9IDpcbiAgICAgIHNldFRpbWVvdXRcbiAgO1xuXG4gIC8vIGRhbW1pdCwgSUU4LlxuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInhcIix7fSk7XG4gICAgYnVpbHRJblByb3AgPSBmdW5jdGlvbiBidWlsdEluUHJvcChvYmosbmFtZSx2YWwsY29uZmlnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaixuYW1lLHtcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlnICE9PSBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBjYXRjaCAoZXJyKSB7XG4gICAgYnVpbHRJblByb3AgPSBmdW5jdGlvbiBidWlsdEluUHJvcChvYmosbmFtZSx2YWwpIHtcbiAgICAgIG9ialtuYW1lXSA9IHZhbDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE5vdGU6IHVzaW5nIGEgcXVldWUgaW5zdGVhZCBvZiBhcnJheSBmb3IgZWZmaWNpZW5jeVxuICBzY2hlZHVsaW5nX3F1ZXVlID0gKGZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgIHZhciBmaXJzdCwgbGFzdCwgaXRlbTtcblxuICAgIGZ1bmN0aW9uIEl0ZW0oZm4sc2VsZikge1xuICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZm4sc2VsZikge1xuICAgICAgICBpdGVtID0gbmV3IEl0ZW0oZm4sc2VsZik7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgbGFzdC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdCA9IGl0ZW07XG4gICAgICAgIGl0ZW0gPSB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgZHJhaW46IGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICAgICB2YXIgZiA9IGZpcnN0O1xuICAgICAgICBmaXJzdCA9IGxhc3QgPSBjeWNsZSA9IHZvaWQgMDtcblxuICAgICAgICB3aGlsZSAoZikge1xuICAgICAgICAgIGYuZm4uY2FsbChmLnNlbGYpO1xuICAgICAgICAgIGYgPSBmLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGZuLHNlbGYpIHtcbiAgICBzY2hlZHVsaW5nX3F1ZXVlLmFkZChmbixzZWxmKTtcbiAgICBpZiAoIWN5Y2xlKSB7XG4gICAgICBjeWNsZSA9IHRpbWVyKHNjaGVkdWxpbmdfcXVldWUuZHJhaW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb21pc2UgZHVjayB0eXBpbmdcbiAgZnVuY3Rpb24gaXNUaGVuYWJsZShvKSB7XG4gICAgdmFyIF90aGVuLCBvX3R5cGUgPSB0eXBlb2YgbztcblxuICAgIGlmIChvICE9IG51bGwgJiZcbiAgICAgIChcbiAgICAgICAgb190eXBlID09IFwib2JqZWN0XCIgfHwgb190eXBlID09IFwiZnVuY3Rpb25cIlxuICAgICAgKVxuICAgICkge1xuICAgICAgX3RoZW4gPSBvLnRoZW47XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgX3RoZW4gPT0gXCJmdW5jdGlvblwiID8gX3RoZW4gOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgbm90aWZ5SXNvbGF0ZWQoXG4gICAgICAgIHRoaXMsXG4gICAgICAgICh0aGlzLnN0YXRlID09PSAxKSA/IHRoaXMuY2hhaW5baV0uc3VjY2VzcyA6IHRoaXMuY2hhaW5baV0uZmFpbHVyZSxcbiAgICAgICAgdGhpcy5jaGFpbltpXVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jaGFpbi5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gTk9URTogVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGlzb2xhdGVcbiAgLy8gdGhlIGB0cnkuLmNhdGNoYCBzbyB0aGF0IG90aGVyIGNvZGUgY2FuIGJlXG4gIC8vIG9wdGltaXplZCBiZXR0ZXJcbiAgZnVuY3Rpb24gbm90aWZ5SXNvbGF0ZWQoc2VsZixjYixjaGFpbikge1xuICAgIHZhciByZXQsIF90aGVuO1xuICAgIHRyeSB7XG4gICAgICBpZiAoY2IgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluLnJlamVjdChzZWxmLm1zZyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNiID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0ID0gc2VsZi5tc2c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0ID0gY2IuY2FsbCh2b2lkIDAsc2VsZi5tc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldCA9PT0gY2hhaW4ucHJvbWlzZSkge1xuICAgICAgICAgIGNoYWluLnJlamVjdChUeXBlRXJyb3IoXCJQcm9taXNlLWNoYWluIGN5Y2xlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfdGhlbiA9IGlzVGhlbmFibGUocmV0KSkge1xuICAgICAgICAgIF90aGVuLmNhbGwocmV0LGNoYWluLnJlc29sdmUsY2hhaW4ucmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjaGFpbi5yZXNvbHZlKHJldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgY2hhaW4ucmVqZWN0KGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZShtc2cpIHtcbiAgICB2YXIgX3RoZW4sIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gYWxyZWFkeSB0cmlnZ2VyZWQ/XG4gICAgaWYgKHNlbGYudHJpZ2dlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi50cmlnZ2VyZWQgPSB0cnVlO1xuXG4gICAgLy8gdW53cmFwXG4gICAgaWYgKHNlbGYuZGVmKSB7XG4gICAgICBzZWxmID0gc2VsZi5kZWY7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChfdGhlbiA9IGlzVGhlbmFibGUobXNnKSkge1xuICAgICAgICBzY2hlZHVsZShmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBkZWZfd3JhcHBlciA9IG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX3RoZW4uY2FsbChtc2csXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICRyZXNvbHZlJCgpeyByZXNvbHZlLmFwcGx5KGRlZl93cmFwcGVyLGFyZ3VtZW50cyk7IH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICRyZWplY3QkKCl7IHJlamVjdC5hcHBseShkZWZfd3JhcHBlcixhcmd1bWVudHMpOyB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QuY2FsbChkZWZfd3JhcHBlcixlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLm1zZyA9IG1zZztcbiAgICAgICAgc2VsZi5zdGF0ZSA9IDE7XG4gICAgICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzY2hlZHVsZShub3RpZnksc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgcmVqZWN0LmNhbGwobmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpLGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVqZWN0KG1zZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuICAgIGlmIChzZWxmLnRyaWdnZXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgIC8vIHVud3JhcFxuICAgIGlmIChzZWxmLmRlZikge1xuICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHNlbGYubXNnID0gbXNnO1xuICAgIHNlbGYuc3RhdGUgPSAyO1xuICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgIHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLHJlc29sdmVyLHJlamVjdGVyKSB7XG4gICAgZm9yICh2YXIgaWR4PTA7IGlkeDxhcnIubGVuZ3RoOyBpZHgrKykge1xuICAgICAgKGZ1bmN0aW9uIElJRkUoaWR4KXtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShhcnJbaWR4XSlcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gJHJlc29sdmVyJChtc2cpe1xuICAgICAgICAgICAgcmVzb2x2ZXIoaWR4LG1zZyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWplY3RlclxuICAgICAgICApO1xuICAgICAgfSkoaWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBNYWtlRGVmV3JhcHBlcihzZWxmKSB7XG4gICAgdGhpcy5kZWYgPSBzZWxmO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBNYWtlRGVmKHNlbGYpIHtcbiAgICB0aGlzLnByb21pc2UgPSBzZWxmO1xuICAgIHRoaXMuc3RhdGUgPSAwO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5jaGFpbiA9IFtdO1xuICAgIHRoaXMubXNnID0gdm9pZCAwO1xuICB9XG5cbiAgZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX05QT19fICE9PSAwKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBwcm9taXNlXCIpO1xuICAgIH1cblxuICAgIC8vIGluc3RhbmNlIHNoYWRvd2luZyB0aGUgaW5oZXJpdGVkIFwiYnJhbmRcIlxuICAgIC8vIHRvIHNpZ25hbCBhbiBhbHJlYWR5IFwiaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG4gICAgdGhpcy5fX05QT19fID0gMTtcblxuICAgIHZhciBkZWYgPSBuZXcgTWFrZURlZih0aGlzKTtcblxuICAgIHRoaXNbXCJ0aGVuXCJdID0gZnVuY3Rpb24gdGhlbihzdWNjZXNzLGZhaWx1cmUpIHtcbiAgICAgIHZhciBvID0ge1xuICAgICAgICBzdWNjZXNzOiB0eXBlb2Ygc3VjY2VzcyA9PSBcImZ1bmN0aW9uXCIgPyBzdWNjZXNzIDogdHJ1ZSxcbiAgICAgICAgZmFpbHVyZTogdHlwZW9mIGZhaWx1cmUgPT0gXCJmdW5jdGlvblwiID8gZmFpbHVyZSA6IGZhbHNlXG4gICAgICB9O1xuICAgICAgLy8gTm90ZTogYHRoZW4oLi4pYCBpdHNlbGYgY2FuIGJlIGJvcnJvd2VkIHRvIGJlIHVzZWQgYWdhaW5zdFxuICAgICAgLy8gYSBkaWZmZXJlbnQgcHJvbWlzZSBjb25zdHJ1Y3RvciBmb3IgbWFraW5nIHRoZSBjaGFpbmVkIHByb21pc2UsXG4gICAgICAvLyBieSBzdWJzdGl0dXRpbmcgYSBkaWZmZXJlbnQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICBvLnByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihmdW5jdGlvbiBleHRyYWN0Q2hhaW4ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgby5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgby5yZWplY3QgPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICAgIGRlZi5jaGFpbi5wdXNoKG8pO1xuXG4gICAgICBpZiAoZGVmLnN0YXRlICE9PSAwKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vdGlmeSxkZWYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gby5wcm9taXNlO1xuICAgIH07XG4gICAgdGhpc1tcImNhdGNoXCJdID0gZnVuY3Rpb24gJGNhdGNoJChmYWlsdXJlKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxmYWlsdXJlKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yLmNhbGwoXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgZnVuY3Rpb24gcHVibGljUmVzb2x2ZShtc2cpe1xuICAgICAgICAgIHJlc29sdmUuY2FsbChkZWYsbXNnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gcHVibGljUmVqZWN0KG1zZykge1xuICAgICAgICAgIHJlamVjdC5jYWxsKGRlZixtc2cpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICByZWplY3QuY2FsbChkZWYsZXJyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUHJvbWlzZVByb3RvdHlwZSA9IGJ1aWx0SW5Qcm9wKHt9LFwiY29uc3RydWN0b3JcIixQcm9taXNlLFxuICAgIC8qY29uZmlndXJhYmxlPSovZmFsc2VcbiAgKTtcblxuICAvLyBOb3RlOiBBbmRyb2lkIDQgY2Fubm90IHVzZSBgT2JqZWN0LmRlZmluZVByb3BlcnR5KC4uKWAgaGVyZVxuICBQcm9taXNlLnByb3RvdHlwZSA9IFByb21pc2VQcm90b3R5cGU7XG5cbiAgLy8gYnVpbHQtaW4gXCJicmFuZFwiIHRvIHNpZ25hbCBhbiBcInVuaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG4gIGJ1aWx0SW5Qcm9wKFByb21pc2VQcm90b3R5cGUsXCJfX05QT19fXCIsMCxcbiAgICAvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG4gICk7XG5cbiAgYnVpbHRJblByb3AoUHJvbWlzZSxcInJlc29sdmVcIixmdW5jdGlvbiBQcm9taXNlJHJlc29sdmUobXNnKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgLy8gbm90ZTogYmVzdCBcImlzUHJvbWlzZVwiIGNoZWNrIHRoYXQncyBwcmFjdGljYWwgZm9yIG5vd1xuICAgIGlmIChtc2cgJiYgdHlwZW9mIG1zZyA9PSBcIm9iamVjdFwiICYmIG1zZy5fX05QT19fID09PSAxKSB7XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShtc2cpO1xuICAgIH0pO1xuICB9KTtcblxuICBidWlsdEluUHJvcChQcm9taXNlLFwicmVqZWN0XCIsZnVuY3Rpb24gUHJvbWlzZSRyZWplY3QobXNnKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChtc2cpO1xuICAgIH0pO1xuICB9KTtcblxuICBidWlsdEluUHJvcChQcm9taXNlLFwiYWxsXCIsZnVuY3Rpb24gUHJvbWlzZSRhbGwoYXJyKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgaWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTtcbiAgICB9XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoLCBtc2dzID0gQXJyYXkobGVuKSwgY291bnQgPSAwO1xuXG4gICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpIHtcbiAgICAgICAgbXNnc1tpZHhdID0gbXNnO1xuICAgICAgICBpZiAoKytjb3VudCA9PT0gbGVuKSB7XG4gICAgICAgICAgcmVzb2x2ZShtc2dzKTtcbiAgICAgICAgfVxuICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xuICB9KTtcblxuICBidWlsdEluUHJvcChQcm9taXNlLFwicmFjZVwiLGZ1bmN0aW9uIFByb21pc2UkcmFjZShhcnIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICBpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoXCJOb3QgYW4gYXJyYXlcIikpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKXtcbiAgICAgICAgcmVzb2x2ZShtc2cpO1xuICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gUHJvbWlzZTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdmVuZG9yL3Byb21pc2UuanMiLCIvKiBqc2hpbnQgdW51c2VkOiBmYWxzZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgQ29uZmlndXJhYmxlIGZyb20gJy4uLy4uLy4uL2xpYi9jb25maWd1cmFibGUnXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZmlsdGVyIHByaW1pdGl2ZXMuXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJQcmltaXRpdmVzXG4gKi9cbmNsYXNzIFByaW1pdGl2ZSBleHRlbmRzIENvbmZpZ3VyYWJsZSB7XG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBiZWZvcmUgdGhpcyBwcmltaXRpdmUncyBmaWx0ZXIgaXMgYmVpbmcgYXBwbGllZFxuICAgKi9cbiAgdXBkYXRlICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBwcmltaXRpdmUncyBmaWx0ZXJcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkZpbHRlcn1cbiAgICovXG4gIGdldEZpbHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlclxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGlzIGluc3RhbmNlXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICBpZiAodGhpcy5fZmlsdGVyKSB7XG4gICAgICB0aGlzLl9maWx0ZXIuZGlzcG9zZSgpXG4gICAgICB0aGlzLl9maWx0ZXIgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByaW1pdGl2ZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvcHJpbWl0aXZlLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4gLyoqXG4gICogVGhlIGF2YWlsYWJsZSByZW5kZXIgdHlwZXNcbiAgKiBAZW51bSB7U3RyaW5nfVxuICAqIEBhbGlhcyBSZW5kZXJUeXBlXG4gICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gICovXG5leHBvcnQgY29uc3QgUmVuZGVyVHlwZSA9IHtcbiAgSU1BR0U6ICdpbWFnZScsXG4gIERBVEFVUkw6ICdkYXRhLXVybCcsXG4gIEJVRkZFUjogJ2J1ZmZlcicsXG4gIEJMT0I6ICdibG9iJyxcbiAgTVNCTE9COiAnbXMtYmxvYidcbn1cblxuLyoqXG4gKiBUaGUgYXZhaWxhYmxlIGltYWdlIHR5cGVzXG4gKiBAZW51bSB7U3RyaW5nfVxuICogQGFsaWFzIEltYWdlRm9ybWF0XG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqL1xuZXhwb3J0IGNvbnN0IEltYWdlRm9ybWF0ID0ge1xuICBQTkc6ICdpbWFnZS9wbmcnLFxuICBKUEVHOiAnaW1hZ2UvanBlZydcbn1cblxuLyoqXG4gKiBFdmVudHMgdXNlZCBieSB0aGUgVUlcbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAYWxpYXMgRXZlbnRzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqL1xuZXhwb3J0IGNvbnN0IEV2ZW50cyA9IHtcbiAgT1BFUkFUSU9OX1VQREFURUQ6ICdvcGVyYXRpb246dXBkYXRlJ1xufVxuXG4vKipcbiAqIFRoZSBhdmFpbGFibGUgb3B0aW9uIHR5cGVzIGZvciBjbGFzc2VzIGluaGVyaXRpbmcge0BsaW5rIFBob3RvRWRpdG9yU0RLLkNvbmZpZ3VyYWJsZX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAYWxpYXMgT3B0aW9uVHlwZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gKi9cbmV4cG9ydCBjb25zdCBPcHRpb25UeXBlID0ge1xuICBOVU1CRVI6ICdudW1iZXInLFxuICBWRUNUT1IyOiAndmVjdG9yMicsXG4gIENPTE9SX01BVFJJWDogJ2NvbG9yLW1hdHJpeCcsXG4gIENPTE9SOiAnY29sb3InLFxuICBBUlJBWTogJ2FycmF5JyxcbiAgT0JKRUNUOiAnb2JqZWN0JyxcbiAgU1RSSU5HOiAnc3RyaW5nJyxcbiAgQk9PTEVBTjogJ2Jvb2xlYW4nLFxuICBDT05GSUdVUkFCTEU6ICdjb25maWd1cmFibGUnLFxuICBJTUFHRTogJ2ltYWdlJyxcbiAgQUxMOiAnKidcbn1cblxuLyoqXG4gKiBUaGUgYXZhaWxhYmxlIHVuaWZvcm0gdHlwZXMgZm9yIFdlYkdMIHNoYWRlcnNcbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAYWxpYXMgVW5pZm9ybVR5cGVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICovXG5leHBvcnQgY29uc3QgVW5pZm9ybVR5cGUgPSB7XG4gIFNBTVBMRVIyRDogJ3NhbXBsZXIyZCcsXG4gIElOVDogJ2knLFxuICBJTlQxOiAnMWknLFxuICBGTE9BVDogJ2YnLFxuICBGTE9BVDE6ICcxZicsXG4gIEZMT0FUMjogJzJmJyxcbiAgRkxPQVRfVkVDVE9SMjogJzJmdicsXG4gIEZMT0FUMzogJzNmJyxcbiAgRkxPQVQ0OiAnNGYnLFxuICBNQVQzOiAnbWF0MycsXG4gIE1BVDNGVjogJ21hdDNmdicsXG4gIE1BVDQ6ICdtYXQ0J1xufVxuXG4vKipcbiAqIFRoZSBhdmFpbGFibGUgcmVuZGVyZXIgdHlwZXNcbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAYWxpYXMgUmVuZGVyZXJUeXBlXG4gKiBAbWVtYmVyT2YgUGhvdG9FZGl0b3JTREtcbiAqL1xuZXhwb3J0IGNvbnN0IFJlbmRlcmVyVHlwZSA9IHtcbiAgV0VCR0w6ICd3ZWJnbCcsXG4gIENBTlZBUzogJ2NhbnZhcydcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbnN0YW50cy5qcyIsIi8qIGpzaGludCB1bnVzZWQ6ZmFsc2UgKi9cbi8qIGpzaGludCAtVzA4MyAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBPcHRpb25UeXBlLCBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi9jb25zdGFudHMnXG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuLi92ZW5kb3IvcHJvbWlzZSdcbmltcG9ydCBMb2cgZnJvbSAnLi4vLi4vc2hhcmVkL2xvZydcbmltcG9ydCBFbmdpbmUgZnJvbSAnLi4vZW5naW5lLydcbmltcG9ydCBDb25maWd1cmFibGUgZnJvbSAnLi4vbGliL2NvbmZpZ3VyYWJsZSdcbmltcG9ydCBQZXJmb3JtYW5jZVRlc3QgZnJvbSAnLi4vbGliL3BlcmZvcm1hbmNlLXRlc3QnXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgT3BlcmF0aW9uc1xuICogQGNsYXNzXG4gKiBAYWxpYXMgT3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5Db25maWd1cmFibGVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICovXG5jbGFzcyBPcGVyYXRpb24gZXh0ZW5kcyBDb25maWd1cmFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHNkaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucywge1xuICAgICAgZW5hYmxlZDogeyB0eXBlOiBPcHRpb25UeXBlLkJPT0xFQU4sIGRlZmF1bHQ6IHRydWUgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9zZGsgPSBzZGtcbiAgICB0aGlzLl9jYWNoZUVuYWJsZWQgPSBmYWxzZVxuICAgIHRoaXMuX2RpcnRpbmVzcyA9IHt9XG5cbiAgICB0aGlzLl9zcHJpdGUgPSBuZXcgRW5naW5lLlNwcml0ZSgpXG4gICAgdGhpcy5fY29udGFpbmVyID0gbmV3IEVuZ2luZS5Db250YWluZXIoKVxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRDaGlsZCh0aGlzLl9zcHJpdGUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBvcHRpb25zIGhhdmUgYmVlbiBjaGFuZ2VkLiBTZXRzIHRoaXMgb3BlcmF0aW9uIHRvIGRpcnR5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3B0aW9uc0NoYW5nZSAoKSB7XG4gICAgdGhpcy5zZXREaXJ0eSh0cnVlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRleHR1cmV9IGlucHV0VGV4dHVyZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHJlbmRlciAoaW5wdXRUZXh0dXJlKSB7XG4gICAgaWYgKCF0aGlzLmdldEVuYWJsZWQoKSkge1xuICAgICAgTG9nLmluZm8odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnRGlzYWJsZWQgLSBza2lwcGluZycpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGlucHV0VGV4dHVyZSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlbmRlclRleHR1cmUpIHtcbiAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5fc2RrLmdldFNwcml0ZSgpLmdldFRleHR1cmUoKS5nZXRGcmFtZSgpXG4gICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlID0gbmV3IEVuZ2luZS5SZW5kZXJUZXh0dXJlKHRoaXMuX3Nkay5nZXRSZW5kZXJlcigpLCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KVxuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fc2RrLmdldFJlbmRlcmVyKClcbiAgICBsZXQgcHJvbWlzZVxuICAgIGxldCBwZXJmXG4gICAgaWYgKExvZy5jYW5Mb2coJ2luZm8nKSkge1xuICAgICAgcGVyZiA9IG5ldyBQZXJmb3JtYW5jZVRlc3QodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnUmVuZGVyaW5nJylcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY2FjaGluZ1xuICAgIGlmICh0aGlzLmlzRGlydHlGb3JSZW5kZXJlcihyZW5kZXJlcikpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoaXMgT3BlcmF0aW9uJ3MgaW50ZXJuYWwgc3ByaXRlIGhhcyB0aGUgaW5wdXQgdGV4dHVyZSBhbmQgdGhhdFxuICAgICAgLy8gdGhlIFJlbmRlclRleHR1cmUgd2UncmUgcmVuZGVyaW5nIHRvIGhhcyB0aGUgc2FtZSBkaW1lbnNpb25zXG4gICAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZShpbnB1dFRleHR1cmUpXG5cbiAgICAgIGNvbnN0IG5ld0RpbWVuc2lvbnMgPSB0aGlzLmdldE5ld0RpbWVuc2lvbnMoaW5wdXRUZXh0dXJlLmdldERpbWVuc2lvbnMoKSlcbiAgICAgICAgLmZsb29yKClcbiAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUucmVzaXplVG8obmV3RGltZW5zaW9ucylcbiAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUuY2xlYXIoKVxuXG4gICAgICAvLyBMZXQgdGhlIG9wZXJhdGlvbiBkbyBpdHMgd29ya1xuICAgICAgcHJvbWlzZSA9IHRoaXMuX3JlbmRlcihpbnB1dFRleHR1cmUpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAvLyBPcGVyYXRpb24gaGFzIGJlZW4gcmVuZGVyZWQgLSBub3QgZGlydHkgYW55bW9yZVxuICAgICAgICAgIHRoaXMuc2V0RGlydHlGb3JSZW5kZXJlcihmYWxzZSwgcmVuZGVyZXIpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclRleHR1cmVcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nLmluZm8odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnUmVuZGVyaW5nIGZyb20gY2FjaGUnKVxuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aGlzLl9yZW5kZXJUZXh0dXJlKVxuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlXG4gICAgICAudGhlbigob3V0cHV0VGV4dHVyZSkgPT4ge1xuICAgICAgICBpZiAocGVyZikgcGVyZi5zdG9wKClcbiAgICAgICAgcmV0dXJuIG91dHB1dFRleHR1cmVcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyIChpbnB1dFRleHR1cmUpIHtcbiAgICBsZXQgcmVuZGVyRm5cbiAgICBpZiAodGhpcy5fc2RrLmdldFJlbmRlcmVyKCkuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJlbmRlckZuID0gdGhpcy5fcmVuZGVyV2ViR0wuYmluZCh0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJGbiA9IHRoaXMuX3JlbmRlckNhbnZhcy5iaW5kKHRoaXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlckZuKGlucHV0VGV4dHVyZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgb3BlcmF0aW9uIHVzaW5nIFdlYkdMXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfSBpbnB1dFRleHR1cmVcbiAgICogQHByb3RlY3RlZFxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIF9yZW5kZXJXZWJHTCAoaW5wdXRUZXh0dXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24jX3JlbmRlcldlYkdMIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzLicpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIG9wZXJhdGlvbiB1c2luZyBDYW52YXMyRFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBfcmVuZGVyQ2FudmFzIChpbnB1dFRleHR1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiNfcmVuZGVyQ2FudmFzIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzLicpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyB0aGF0IGFuIGltYWdlIHdpdGggdGhlIGdpdmVuIGBkaW1lbnNpb25zYFxuICAgKiB3b3VsZCBoYXZlIGFmdGVyIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGFwcGxpZWRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldE5ld0RpbWVuc2lvbnMgKGRpbWVuc2lvbnMpIHtcbiAgICByZXR1cm4gZGltZW5zaW9ucy5jbG9uZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICByZXNldCAoKSB7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlXG4gICAgdGhpcy5fZ2xzbFByb2dyYW1zID0ge31cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIERJUlRJTkVTU1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBvcGVyYXRpb24gaXMgZGlydHkgZm9yIHRoZSBnaXZlbiByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSAgcmVuZGVyZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRGlydHlGb3JSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgICBjb25zdCBkaXJ0eSA9IHRoaXMuX2RpcnRpbmVzc1tyZW5kZXJlci5pZF1cbiAgICByZXR1cm4gdHlwZW9mIGRpcnR5ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBkaXJ0eVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcnRpbmVzcyBmb3IgdGhlIGdpdmVuIHJlbmRlcmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpbWVuc2lvbnNDaGFuZ2VkID0gZmFsc2VcbiAgICovXG4gIHNldERpcnR5Rm9yUmVuZGVyZXIgKGRpcnR5LCByZW5kZXJlciwgZGltZW5zaW9uc0NoYW5nZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuX2RpcnRpbmVzc1tyZW5kZXJlci5pZF0gPSBkaXJ0eVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcnRpbmVzcyBmb3IgYWxsIHJlbmRlcmVyc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGltZW5zaW9uc0NoYW5nZWQgPSBmYWxzZVxuICAgKi9cbiAgc2V0RGlydHkgKGRpcnR5LCBkaW1lbnNpb25zQ2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgcmVuZGVyZXJJZCBpbiB0aGlzLl9kaXJ0aW5lc3MpIHtcbiAgICAgIHRoaXMuc2V0RGlydHlGb3JSZW5kZXJlcihkaXJ0eSwgeyBpZDogcmVuZGVyZXJJZCB9LCBkaW1lbnNpb25zQ2hhbmdlZClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2Yge0BsaW5rIFBob3RvRWRpdG9yU0RLfSB0aGF0IHRoaXMgb3BlcmF0aW9uIGJlbG9uZ3MgdG9cbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREt9XG4gICAqL1xuICBnZXRTREsgKCkge1xuICAgIHJldHVybiB0aGlzLl9zZGtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnB1dCBkaW1lbnNpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRJbnB1dERpbWVuc2lvbnMgKCkge1xuICAgIGxldCBkaW1lbnNpb25zID0gdGhpcy5fc2RrLmdldElucHV0RGltZW5zaW9ucygpXG4gICAgbGV0IG9wRm91bmRcbiAgICB0aGlzLl9zZGsuZ2V0T3BlcmF0aW9uc1N0YWNrKClcbiAgICAgIC5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICBpZiAob3BGb3VuZCkgcmV0dXJuXG4gICAgICAgIGlmIChvcCA9PT0gdGhpcykge1xuICAgICAgICAgIG9wRm91bmQgPSB0cnVlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZGltZW5zaW9ucyA9IG9wLmdldE5ld0RpbWVuc2lvbnMoZGltZW5zaW9ucylcbiAgICAgIH0pXG4gICAgcmV0dXJuIGRpbWVuc2lvbnMuZmxvb3IoKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoZSBSZW5kZXJUZXh0dXJlXG4gICAqL1xuICBkaXNwb3NlUmVuZGVyVGV4dHVyZXMgKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlLmRpc3Bvc2UoKVxuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJUZXh0dXJlID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSZW5kZXJUZXh0dXJlcygpXG4gICAgdGhpcy5fc3ByaXRlLmRpc3Bvc2UoKVxuICB9XG59XG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gKiBvcGVyYXRpb25zLlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuT3BlcmF0aW9uLmlkZW50aWZpZXIgPSBudWxsXG5cbmV4cG9ydCBkZWZhdWx0IE9wZXJhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9vcGVyYXRpb24uanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbG9yXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICovXG5jbGFzcyBDb2xvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29sb3JcbiAgICogQHBhcmFtICB7TnVtYmVyfSByXG4gICAqIEBwYXJhbSAge051bWJlcn0gZ1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbYSA9IDFdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAociwgZywgYiwgYSA9IDEuMCkge1xuICAgIHRoaXMuciA9IHJcbiAgICB0aGlzLmcgPSBnXG4gICAgdGhpcy5iID0gYlxuICAgIHRoaXMuYSA9IGFcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIHJnYmEoKSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvUkdCQSAoKSB7XG4gICAgdmFyIGNvbG9ycyA9IFtcbiAgICAgIE1hdGgucm91bmQodGhpcy5yICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQodGhpcy5nICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQodGhpcy5iICogMjU1KSxcbiAgICAgIHRoaXMuYVxuICAgIF1cbiAgICByZXR1cm4gJ3JnYmEoJyArIGNvbG9ycy5qb2luKCcsJykgKyAnKSdcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29sb3JcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9IZXggKCkge1xuICAgIHZhciBjb21wb25lbnRzID0gW1xuICAgICAgdGhpcy5fY29tcG9uZW50VG9IZXgoTWF0aC5yb3VuZCh0aGlzLnIgKiAyNTUpKSxcbiAgICAgIHRoaXMuX2NvbXBvbmVudFRvSGV4KE1hdGgucm91bmQodGhpcy5nICogMjU1KSksXG4gICAgICB0aGlzLl9jb21wb25lbnRUb0hleChNYXRoLnJvdW5kKHRoaXMuYiAqIDI1NSkpXG4gICAgXVxuICAgIHJldHVybiAnIycgKyBjb21wb25lbnRzLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIDQgdmFsdWVzICgwLi4uMSlcbiAgICogQHJldHVybiB7TnVtYmVyW119XG4gICAqL1xuICB0b0dMQ29sb3IgKCkge1xuICAgIHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCA0IHZhbHVlcyAoMC4uLjEpXG4gICAqIEByZXR1cm4ge051bWJlcltdfVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9HTENvbG9yKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggMyB2YWx1ZXMgKDAuLi4xKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJbXX1cbiAgICovXG4gIHRvUkdCR0xDb2xvciAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iXVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBSR0IgdmFsdWUgdG8gSFNWXG4gICAqIEByZXR1cm4ge051bWJlcltdfVxuICAgKi9cbiAgdG9IU1YgKCkge1xuICAgIGxldCBtYXggPSBNYXRoLm1heCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKVxuICAgIGxldCBtaW4gPSBNYXRoLm1pbih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKVxuICAgIGxldCBoXG4gICAgbGV0IHNcbiAgICBsZXQgdiA9IG1heFxuICAgIGxldCBkID0gbWF4IC0gbWluXG4gICAgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSAwIC8vIGFjaHJvbWF0aWNcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgY2FzZSB0aGlzLnI6XG4gICAgICAgICAgaCA9ICh0aGlzLmcgLSB0aGlzLmIpIC8gZFxuICAgICAgICAgIGlmICh0aGlzLmcgPCB0aGlzLmIpIHtcbiAgICAgICAgICAgIGggKz0gNlxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIHRoaXMuZzpcbiAgICAgICAgICBoID0gKHRoaXMuYiAtIHRoaXMucikgLyBkICsgMlxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgdGhpcy5iOlxuICAgICAgICAgIGggPSAodGhpcy5yIC0gdGhpcy5nKSAvIGQgKyA0XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGggLz0gNlxuICAgIH1cblxuICAgIHJldHVybiBbaCwgcywgdl1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIFJHQkEgY29sb3IgZnJvbSB0aGUgZ2l2ZW4gSFNWIGFuZCBhbHBoYSB2YWx1ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFthID0gMV1cbiAgICovXG4gIHN0YXRpYyBmcm9tSFNWIChoLCBzLCB2LCBhID0gMSkge1xuICAgIGxldCBbciwgZywgYl0gPSBbXVxuXG4gICAgbGV0IGkgPSBNYXRoLmZsb29yKGggKiA2KVxuICAgIGxldCBmID0gaCAqIDYgLSBpXG4gICAgbGV0IHAgPSB2ICogKDEgLSBzKVxuICAgIGxldCBxID0gdiAqICgxIC0gZiAqIHMpXG4gICAgbGV0IHQgPSB2ICogKDEgLSAoMSAtIGYpICogcylcblxuICAgIHN3aXRjaCAoaSAlIDYpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgciA9IHZcbiAgICAgICAgZyA9IHRcbiAgICAgICAgYiA9IHBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgciA9IHFcbiAgICAgICAgZyA9IHZcbiAgICAgICAgYiA9IHBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgciA9IHBcbiAgICAgICAgZyA9IHZcbiAgICAgICAgYiA9IHRcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgciA9IHBcbiAgICAgICAgZyA9IHFcbiAgICAgICAgYiA9IHZcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgciA9IHRcbiAgICAgICAgZyA9IHBcbiAgICAgICAgYiA9IHZcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgciA9IHZcbiAgICAgICAgZyA9IHBcbiAgICAgICAgYiA9IHFcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDb2xvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgbnVtYmVyc1xuICAgKiBAcGFyYW0gIHtOdW1iZXJbXX0gYXJyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkNvbG9yfVxuICAgKi9cbiAgc3RhdGljIGZyb21BcnJheSAoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihhcnJbMF0sIGFyclsxXSwgYXJyWzJdLCBhcnJbM10pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBjdXJyZW50IGNvbG9yXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkNvbG9yfVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGNvbG9yIGVxdWFscyB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkNvbG9yfSBjb2xvclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWxzIChjb2xvcikge1xuICAgIHJldHVybiB0aGlzLnIgPT09IGNvbG9yLnIgJiZcbiAgICAgIHRoaXMuZyA9PT0gY29sb3IuZyAmJlxuICAgICAgdGhpcy5iID09PSBjb2xvci5iICYmXG4gICAgICB0aGlzLmEgPT09IGNvbG9yLmFcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnaXZlbiBudW1iZXIgYXMgaGV4XG4gICAqIEBwYXJhbSAge051bWJlcn0gY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wb25lbnRUb0hleCAoY29tcG9uZW50KSB7XG4gICAgdmFyIGhleCA9IGNvbXBvbmVudC50b1N0cmluZygxNilcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIGBDb2xvcigke3RoaXMucn0sICR7dGhpcy5nfSwgJHt0aGlzLmJ9LCAke3RoaXMuYX0pYFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5Db2xvcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgVFJBTlNQQVJFTlQgKCkgeyByZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDApIH1cblxuICAvKipcbiAgICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLkNvbG9yfVxuICAgKi9cbiAgc3RhdGljIGdldCBXSElURSAoKSB7IHJldHVybiBuZXcgQ29sb3IoMSwgMSwgMSwgMSkgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuQ29sb3J9XG4gICAqL1xuICBzdGF0aWMgZ2V0IEJMQUNLICgpIHsgcmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAxKSB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbG9yXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvY29sb3IuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBDYW52YXNSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVycy9jYW52YXMvY2FudmFzLXJlbmRlcmVyJ1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlcnMvd2ViZ2wvd2ViZ2wtcmVuZGVyZXInXG5pbXBvcnQgQ2FudmFzRmlsdGVyTWFuYWdlciBmcm9tICcuL21hbmFnZXJzL2NhbnZhcy1maWx0ZXItbWFuYWdlcidcbmltcG9ydCBXZWJHTEZpbHRlck1hbmFnZXIgZnJvbSAnLi9tYW5hZ2Vycy93ZWJnbC1maWx0ZXItbWFuYWdlcidcbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gJy4vZGlzcGxheS9kaXNwbGF5LW9iamVjdCdcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9kaXNwbGF5L2NvbnRhaW5lcidcbmltcG9ydCBCYXNlVGV4dHVyZSBmcm9tICcuL3RleHR1cmVzL2Jhc2UtdGV4dHVyZSdcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZXMvdGV4dHVyZSdcbmltcG9ydCBSZW5kZXJUZXh0dXJlIGZyb20gJy4vdGV4dHVyZXMvcmVuZGVyLXRleHR1cmUnXG5pbXBvcnQgV2ViR0xSZW5kZXJUYXJnZXQgZnJvbSAnLi91dGlscy93ZWJnbC1yZW5kZXItdGFyZ2V0J1xuaW1wb3J0IENhbnZhc1JlbmRlclRhcmdldCBmcm9tICcuL3V0aWxzL2NhbnZhcy1yZW5kZXItdGFyZ2V0J1xuaW1wb3J0IFNwcml0ZSBmcm9tICcuL3Nwcml0ZXMvc3ByaXRlJ1xuaW1wb3J0IFNoYWRlcnMgZnJvbSAnLi9zaGFkZXJzLydcbmltcG9ydCBTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3NoYWRlcidcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXJzL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlcnMgZnJvbSAnLi9maWx0ZXJzJ1xuaW1wb3J0IFBpeGVsQXJyYXlJbWFnZSBmcm9tICcuL3V0aWxzL3BpeGVsLWFycmF5LWltYWdlJ1xuXG4vKipcbiAqIFRoZSBoZWFydCBvZiBQaG90b0VkaXRvclNESy4gSGFuZGxlcyBhbGwgdGhlIHJlbmRlcmluZyBpbiBhIHNjZW5lLWdyYXBoIGZhc2hpb25cbiAqIEBuYW1lc3BhY2UgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNvbnN0IEVuZ2luZSA9IHtcbiAgV2ViR0xSZW5kZXJlcixcbiAgQ2FudmFzUmVuZGVyZXIsXG4gIFdlYkdMRmlsdGVyTWFuYWdlcixcbiAgQ2FudmFzRmlsdGVyTWFuYWdlcixcbiAgRGlzcGxheU9iamVjdCxcbiAgQ29udGFpbmVyLFxuICBCYXNlVGV4dHVyZSxcbiAgVGV4dHVyZSxcbiAgUmVuZGVyVGV4dHVyZSxcbiAgV2ViR0xSZW5kZXJUYXJnZXQsXG4gIENhbnZhc1JlbmRlclRhcmdldCxcbiAgU3ByaXRlLFxuICBTaGFkZXJzLFxuICBTaGFkZXIsXG4gIEZpbHRlcixcbiAgRmlsdGVycyxcbiAgUGl4ZWxBcnJheUltYWdlLFxuXG4gIC8qKlxuICAgKiBJZiBXZWJHTCBpcyBzdXBwb3J0ZWQsIHRoaXMgcmV0dXJucyBhIFdlYkdMUmVuZGVyZXIgYW5kIGZhbGxzIGJhY2sgdG8gQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGhlaWdodFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zID0ge30gXVxuICAgKiBAcmV0dXJuIHsoUGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyZXJ8UGhvdG9FZGl0b3JTREsuRW5naW5lLkNhbnZhc1JlbmRlcmVyKX1cbiAgICovXG4gIGF1dG9EZXRlY3RSZW5kZXJlcjogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChXZWJHTFJlbmRlcmVyLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHJldHVybiBuZXcgV2ViR0xSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IENhbnZhc1JlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVuZ2luZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL2luZGV4LmpzIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFsIEhUTUxJbWFnZUVsZW1lbnQsIFdFQlBBQ0sgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vdmVuZG9yL3Byb21pc2UnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vZXZlbnQtZW1pdHRlcidcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4vbWF0aC92ZWN0b3IyJ1xuaW1wb3J0IENvbG9yIGZyb20gJy4vY29sb3InXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscydcbmltcG9ydCBDb2xvck1hdHJpeCBmcm9tICcuL21hdGgvY29sb3ItbWF0cml4J1xuaW1wb3J0IHsgT3B0aW9uVHlwZSB9IGZyb20gJy4uL2NvbnN0YW50cydcblxubGV0IEltYWdlXG5pZiAodHlwZW9mIFdFQlBBQ0sgIT09ICd1bmRlZmluZWQnKSB7XG4gIEltYWdlID0gd2luZG93LkltYWdlXG59XG5cbi8qKlxuICogQWRkcyBgc2V0e09wdGlvbk5hbWV9YCBhbmQgYGdldHtPcHRpb25OYW1lfWAgbWV0aG9kcyB0byBhbiBvYmplY3QuIE1ldGhvZCBuYW1lc1xuICogYXJlIHNwZWNpZmllZCB2aWEgdGhlIGBhdmFpbGFibGVPcHRpb25zYCBvYmplY3QuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gKi9cbmNsYXNzIENvbmZpZ3VyYWJsZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zID0ge30sIGFkZGl0aW9uYWxBdmFpbGFibGVPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5hdmFpbGFibGVPcHRpb25zID0gdGhpcy5hdmFpbGFibGVPcHRpb25zIHx8IHt9XG4gICAgdGhpcy5hdmFpbGFibGVPcHRpb25zID0gVXRpbHMuZXh0ZW5kKHRoaXMuYXZhaWxhYmxlT3B0aW9ucywgYWRkaXRpb25hbEF2YWlsYWJsZU9wdGlvbnMpXG5cbiAgICB0aGlzLl9vbkNvbmZpZ3VyYWJsZVVwZGF0ZSA9IHRoaXMuX29uQ29uZmlndXJhYmxlVXBkYXRlLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRPcHRpb25zKG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcmV0dXJuIHtFcnJvcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9idWlsZENvbmZpZ0Vycm9yIChtZXNzYWdlKSB7XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9ICcnXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfTogYFxuICAgIH1cbiAgICBlcnJvck1lc3NhZ2UgKz0gbWVzc2FnZVxuICAgIHJldHVybiBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gb3B0aW9ucyBoYXZlIGJlZW4gY2hhbmdlZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25PcHRpb25zQ2hhbmdlICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGFsbCByZXF1aXJlZCBvcHRpb25zIGFyZSBzcGVjaWZpZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHZhbGlkYXRlU2V0dGluZ3MgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBDaGVjayBmb3IgcmVxdWlyZWQgb3B0aW9uc1xuICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiB0aGlzLmF2YWlsYWJsZU9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdGlvbkNvbmZpZyA9IHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXVxuICAgICAgICBpZiAob3B0aW9uQ29uZmlnLnJlcXVpcmVkICYmIHR5cGVvZiB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICB0aGlzLl9idWlsZENvbmZpZ0Vycm9yKGBPcHRpb24gXFxgJHtvcHRpb25OYW1lfVxcYCBpcyByZXF1aXJlZC5gKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdvZXMgdGhyb3VnaCB0aGUgYXZhaWxhYmxlIG9wdGlvbnMsIHNldHMgX29wdGlvbnMgZGVmYXVsdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPcHRpb25zXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9pbml0T3B0aW9ucyAodXNlck9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB7fVxuXG4gICAgLy8gU2V0IGRlZmF1bHRzLCBjcmVhdGUgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgIHZhciBvcHRpb25OYW1lLCBvcHRpb24sIGNhcGl0YWxpemVkXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgZm9yIChvcHRpb25OYW1lIGluIHRoaXMuYXZhaWxhYmxlT3B0aW9ucykge1xuICAgICAgY2FwaXRhbGl6ZWQgPSBvcHRpb25OYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3B0aW9uTmFtZS5zbGljZSgxKVxuICAgICAgb3B0aW9uID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdXG5cbiAgICAgIGlmIChbXG4gICAgICAgIE9wdGlvblR5cGUuU1RSSU5HLCBPcHRpb25UeXBlLk5VTUJFUiwgT3B0aW9uVHlwZS5CT09MRUFOLCBPcHRpb25UeXBlLk9CSkVDVCxcbiAgICAgICAgT3B0aW9uVHlwZS5WRUNUT1IyLCBPcHRpb25UeXBlLkNPTE9SLCBPcHRpb25UeXBlLkNPTkZJR1VSQUJMRSwgT3B0aW9uVHlwZS5DT0xPUl9NQVRSSVgsXG4gICAgICAgIE9wdGlvblR5cGUuQVJSQVksIE9wdGlvblR5cGUuSU1BR0UsIE9wdGlvblR5cGUuQUxMXG4gICAgICBdLmluZGV4T2Yob3B0aW9uLnR5cGUpID09PSAtMSkge1xuICAgICAgICB0aHJvdyB0aGlzLl9idWlsZENvbmZpZ0Vycm9yKGBVbmtub3duIG9wdGlvbiB0eXBlOiBcXGAke29wdGlvbi50eXBlfVxcYGApXG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBzZXR0ZXIgYW5kIGdldHRlclxuICAgICAgbGV0IGZuID0gZnVuY3Rpb24gKG9wdGlvbk5hbWUsIG9wdGlvbikge1xuICAgICAgICBzZWxmWydzZXQnICsgY2FwaXRhbGl6ZWRdID0gZnVuY3Rpb24gKHZhbHVlLCB1cGRhdGUsIGluaXRpYWwpIHtcbiAgICAgICAgICBzZWxmLnNldE9wdGlvbihvcHRpb25OYW1lLCB2YWx1ZSwgdXBkYXRlLCBpbml0aWFsKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCBnZXR0ZXJcbiAgICAgICAgc2VsZlsnZ2V0JyArIGNhcGl0YWxpemVkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5nZXRPcHRpb24ob3B0aW9uTmFtZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm4ob3B0aW9uTmFtZSwgb3B0aW9uKVxuXG4gICAgICAvLyBIYW5kbGUgY29uZmlndXJhYmxlIGluaXRpYWxpemF0aW9uXG4gICAgICBpZiAob3B0aW9uLnR5cGUgPT09IE9wdGlvblR5cGUuQ09ORklHVVJBQkxFKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSBuZXcgQ29uZmlndXJhYmxlKHVuZGVmaW5lZCwgb3B0aW9uLnN0cnVjdHVyZSB8fCB7fSlcbiAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXS5vbigndXBkYXRlJywgdGhpcy5fb25Db25maWd1cmFibGVVcGRhdGUpXG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBkZWZhdWx0IGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24uZGVmYXVsdCAhPT0gJ3VuZGVmaW5lZCcgJiYgIShvcHRpb25OYW1lIGluIHVzZXJPcHRpb25zKSkge1xuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gb3B0aW9uLmRlZmF1bHRcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24uZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IG9wdGlvbi5kZWZhdWx0KClcbiAgICAgICAgfVxuICAgICAgICB0aGlzWydzZXQnICsgY2FwaXRhbGl6ZWRdKGRlZmF1bHRWYWx1ZSwgZmFsc2UsIHRydWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3ZlcndyaXRlIG9wdGlvbnMgd2l0aCB0aGUgb25lcyBnaXZlbiBieSB1c2VyXG4gICAgZm9yIChvcHRpb25OYW1lIGluIHVzZXJPcHRpb25zKSB7XG4gICAgICAvLyBDaGVjayBpZiBvcHRpb24gaXMgYXZhaWxhYmxlXG4gICAgICBpZiAodHlwZW9mIHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9wdGlvbjogJHtvcHRpb25OYW1lfWApXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdXNlck9wdGlvbnNbb3B0aW9uTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIENhbGwgc2V0dGVyXG4gICAgICAgIGNhcGl0YWxpemVkID0gb3B0aW9uTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wdGlvbk5hbWUuc2xpY2UoMSlcbiAgICAgICAgdGhpc1snc2V0JyArIGNhcGl0YWxpemVkXSh1c2VyT3B0aW9uc1tvcHRpb25OYW1lXSwgZmFsc2UsIHRydWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIHNldCAob3B0aW9ucywgZW1pdFVwZGF0ZSA9IHRydWUpIHtcbiAgICBpZiAoZW1pdFVwZGF0ZSkge1xuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLCBvcHRpb25zKVxuICAgIH1cblxuICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb24ob3B0aW9uTmFtZSwgb3B0aW9uc1tvcHRpb25OYW1lXSwgZmFsc2UpXG4gICAgfVxuICAgIHRoaXMuX29uT3B0aW9uc0NoYW5nZSgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBvcHRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldE9wdGlvbiAob3B0aW9uTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9wdGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldE9wdGlvbkRlZmF1bHQgKG9wdGlvbk5hbWUpIHtcbiAgICBjb25zdCBvcHRpb24gPSB0aGlzLmF2YWlsYWJsZU9wdGlvbnNbb3B0aW9uTmFtZV1cbiAgICBpZiAoIW9wdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9wdGlvbjogJHtvcHRpb25OYW1lfWApXG4gICAgfVxuICAgIHJldHVybiBvcHRpb24uZGVmYXVsdFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgaGFzaCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0RGVmYXVsdE9wdGlvbnMgKCkge1xuICAgIGxldCBvcHRpb25zID0ge31cbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHRoaXMuYXZhaWxhYmxlT3B0aW9ucykge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdLmRlZmF1bHRcbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAndW5kZWZpbmVkJykgY29udGludWVcblxuICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IGRlZmF1bHRWYWx1ZVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IG9wdGlvbnMgZXF1YWwgdGhlIGdpdmVuIG9uZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBvcHRpb25zRXF1YWwgKG9wdGlvbnMpIHtcbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRpb25OYW1lXVxuICAgICAgaWYgKCF0aGlzLl9vcHRpb25FcXVhbHMob3B0aW9uTmFtZSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gb3B0aW9uIGhhcyB0aGUgZ2l2ZW4gdmFsdWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBvcHRpb25OYW1lXG4gICAqIEBwYXJhbSAgeyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb3B0aW9uRXF1YWxzIChvcHRpb25OYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9wdGlvbjogJHtvcHRpb25OYW1lfWApXG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9uVHlwZSA9IHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXS50eXBlXG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXVxuXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdmFsdWUpIHJldHVybiB0cnVlXG5cbiAgICBzd2l0Y2ggKG9wdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgT3B0aW9uVHlwZS5TVFJJTkc6XG4gICAgICBjYXNlIE9wdGlvblR5cGUuTlVNQkVSOlxuICAgICAgY2FzZSBPcHRpb25UeXBlLkJPT0xFQU46XG4gICAgICBjYXNlIE9wdGlvblR5cGUuT0JKRUNUOlxuICAgICAgY2FzZSAnKic6XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHZhbHVlXG4gICAgICBjYXNlIE9wdGlvblR5cGUuVkVDVE9SMjpcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZS5lcXVhbHModmFsdWUpXG4gICAgICBjYXNlIE9wdGlvblR5cGUuQ09MT1I6XG4gICAgICBjYXNlIE9wdGlvblR5cGUuQ09MT1JfTUFUUklYOlxuICAgICAgICByZXR1cm4gdmFsdWUuZXF1YWxzKGN1cnJlbnRWYWx1ZSlcbiAgICAgIGNhc2UgT3B0aW9uVHlwZS5DT05GSUdVUkFCTEU6XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUub3B0aW9uc0VxdWFsKHZhbHVlKVxuICAgICAgY2FzZSBPcHRpb25UeXBlLkFSUkFZOlxuICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXlPcHRpb25FcXVhbHMob3B0aW9uTmFtZSwgdmFsdWUpXG4gICAgICBjYXNlIE9wdGlvblR5cGUuSU1BR0U6XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUuc3JjID09PSB2YWx1ZS5zcmNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBvcHRpb24gb2YgdHlwZSBgYXJyYXlgIG1hdGNoZXMgdGhlIGdpdmVuIHZhbHVlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXJyYXlPcHRpb25FcXVhbHMgKG9wdGlvbk5hbWUsIGFycikge1xuICAgIGxldCB0aGlzQXJyID0gdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXVxuICAgIGxldCBlcXVhbCA9IHRydWVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRoaXNWYWx1ZSA9IHRoaXNBcnJbaV1cbiAgICAgIGNvbnN0IHZhbHVlID0gYXJyW2ldXG4gICAgICBpZiAodGhpc1ZhbHVlIGluc3RhbmNlb2YgQ29uZmlndXJhYmxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8ICF0aGlzVmFsdWUub3B0aW9uc0VxdWFsKHZhbHVlKSkge1xuICAgICAgICAgIGVxdWFsID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB0aGlzVmFsdWUpIHtcbiAgICAgICAgZXF1YWwgPSBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXF1YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoaXMgY29uZmlndXJhYmxlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdG9PYmplY3QgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzZXJpYWxpemVPcHRpb25zIChrZXlzID0gT2JqZWN0LmtleXModGhpcy5fb3B0aW9ucyksIHRvT2JqZWN0ID0gZmFsc2UpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHt9XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIG9wdGlvbnNba2V5XSA9IHRoaXMuX3NlcmlhbGl6ZU9wdGlvbihrZXksIHRvT2JqZWN0KVxuICAgIH0pXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBvcHRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHBhcmFtIHtCb29sZWFufSB0b09iamVjdCA9IGZhbHNlXG4gICAqIEByZXR1cm4geyp9IG9wdGlvbk5hbWVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3NlcmlhbGl6ZU9wdGlvbiAob3B0aW9uTmFtZSwgdG9PYmplY3QgPSBmYWxzZSkge1xuICAgIGNvbnN0IG9wdGlvblR5cGUgPSB0aGlzLmF2YWlsYWJsZU9wdGlvbnNbb3B0aW9uTmFtZV0udHlwZVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXVxuICAgIGlmICghdmFsdWUpIHJldHVybiB2YWx1ZVxuXG4gICAgc3dpdGNoIChvcHRpb25UeXBlKSB7XG4gICAgICBjYXNlIE9wdGlvblR5cGUuU1RSSU5HOlxuICAgICAgY2FzZSBPcHRpb25UeXBlLk5VTUJFUjpcbiAgICAgIGNhc2UgT3B0aW9uVHlwZS5CT09MRUFOOlxuICAgICAgY2FzZSBPcHRpb25UeXBlLk9CSkVDVDpcbiAgICAgIGNhc2UgT3B0aW9uVHlwZS5BTEw6XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgY2FzZSBPcHRpb25UeXBlLlZFQ1RPUjI6XG4gICAgICAgIHJldHVybiB0b09iamVjdCA/IHZhbHVlLnRvT2JqZWN0KCkgOiB2YWx1ZS5jbG9uZSgpXG4gICAgICBjYXNlIE9wdGlvblR5cGUuQ09MT1I6XG4gICAgICBjYXNlIE9wdGlvblR5cGUuQ09MT1JfTUFUUklYOlxuICAgICAgICByZXR1cm4gdG9PYmplY3QgPyB2YWx1ZS50b0FycmF5KCkgOiB2YWx1ZS5jbG9uZSgpXG4gICAgICBjYXNlIE9wdGlvblR5cGUuQ09ORklHVVJBQkxFOlxuICAgICAgICByZXR1cm4gdmFsdWUuc2VyaWFsaXplT3B0aW9ucyh1bmRlZmluZWQsIHRvT2JqZWN0KVxuICAgICAgY2FzZSBPcHRpb25UeXBlLkFSUkFZOlxuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMClcbiAgICAgIGNhc2UgT3B0aW9uVHlwZS5JTUFHRTpcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNyY1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9wdGlvbiwgdmFsaWRhdGVzIGl0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25OYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdXBkYXRlID0gdHJ1ZV0gLSBTaG91bGQgYW4gYHVwZGF0ZWAgZXZlbnQgYmUgZW1pdHRlZD9cbiAgICogQHBhcmFtIHtCb29sZWFufSBbaW5pdGlhbCA9IGZhbHNlXSAtIElzIHRoaXMgdGhlIGZpcnN0IHRpbWUgdGhpcyBvcHRpb24gaXMgc2V0P1xuICAgKi9cbiAgc2V0T3B0aW9uIChvcHRpb25OYW1lLCB2YWx1ZSwgdXBkYXRlID0gdHJ1ZSwgaW5pdGlhbCA9IGZhbHNlKSB7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLCB7IFtvcHRpb25OYW1lXTogdmFsdWUgfSlcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9uQ29uZmlnID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdXG4gICAgaWYgKCFvcHRpb25Db25maWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvcHRpb246ICR7b3B0aW9uTmFtZX1gKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uQ29uZmlnLnNldHRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlID0gb3B0aW9uQ29uZmlnLnNldHRlci5jYWxsKHRoaXMsIHZhbHVlLCBpbml0aWFsKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uQ29uZmlnLnZhbGlkYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25Db25maWcudmFsaWRhdGlvbih2YWx1ZSlcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25Db25maWcucmVxdWlyZWQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5fYnVpbGRDb25maWdFcnJvcihgT3B0aW9uIFxcYCR7b3B0aW9uTmFtZX1cXGAgaXMgcmVxdWlyZWQuYClcbiAgICAgIH1cbiAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKG9wdGlvbkNvbmZpZy50eXBlKSB7XG4gICAgICAgIC8vIFN0cmluZyBvcHRpb25zXG4gICAgICAgIGNhc2UgT3B0aW9uVHlwZS5TVFJJTkc6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gT3B0aW9uVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2J1aWxkQ29uZmlnRXJyb3IoYE9wdGlvbiBcXGAke29wdGlvbk5hbWV9XFxgIGhhcyB0byBiZSBhIHN0cmluZy5gKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN0cmluZyB2YWx1ZSByZXN0cmljdGlvbnNcbiAgICAgICAgICB2YXIgYXZhaWxhYmxlID0gb3B0aW9uQ29uZmlnLmF2YWlsYWJsZVxuICAgICAgICAgIGlmICh0eXBlb2YgYXZhaWxhYmxlICE9PSAndW5kZWZpbmVkJyAmJiBhdmFpbGFibGUuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9idWlsZENvbmZpZ0Vycm9yKGBJbnZhbGlkIHZhbHVlIGZvciBcXGAke29wdGlvbk5hbWV9XFxgICh2YWxpZCB2YWx1ZXMgYXJlOiAke29wdGlvbkNvbmZpZy5hdmFpbGFibGUuam9pbignLCAnKX0pYClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWVcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIC8vIE51bWJlciBvcHRpb25zXG4gICAgICAgIGNhc2UgT3B0aW9uVHlwZS5OVU1CRVI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gT3B0aW9uVHlwZS5OVU1CRVIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2J1aWxkQ29uZmlnRXJyb3IoYE9wdGlvbiBcXGAke29wdGlvbk5hbWV9XFxgIGhhcyB0byBiZSBhIG51bWJlci5gKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgLy8gQm9vbGVhbiBvcHRpb25zXG4gICAgICAgIGNhc2UgT3B0aW9uVHlwZS5CT09MRUFOOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IE9wdGlvblR5cGUuQk9PTEVBTikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fYnVpbGRDb25maWdFcnJvcihgT3B0aW9uIFxcYCR7b3B0aW9uTmFtZX1cXGAgaGFzIHRvIGJlIGEgYm9vbGVhbi5gKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZVxuXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICAvLyBWZWN0b3IyIG9wdGlvbnNcbiAgICAgICAgY2FzZSBPcHRpb25UeXBlLlZFQ1RPUjI6XG4gICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBWZWN0b3IyKSAmJiAhKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHZhbHVlICYmICd5JyBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2J1aWxkQ29uZmlnRXJyb3IoYE9wdGlvbiBcXGAke29wdGlvbk5hbWV9XFxgIGhhcyB0byBiZSBhbiBpbnN0YW5jZSBvZiBWZWN0b3IyIG9yIGFuIE9iamVjdCBob2xkaW5nIHggYW5kIHkgdmFsdWVzLmApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlLmNsb25lKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IFZlY3RvcjIuZnJvbU9iamVjdCh2YWx1ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIC8vIENvbG9yIG9wdGlvbnNcbiAgICAgICAgY2FzZSBPcHRpb25UeXBlLkNPTE9SOlxuICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQ29sb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9idWlsZENvbmZpZ0Vycm9yKGBPcHRpb24gXFxgJHtvcHRpb25OYW1lfVxcYCBoYXMgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgQ29sb3IuYClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWVcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIC8vIENvbG9yTWF0cml4IG9wdGlvbnNcbiAgICAgICAgY2FzZSBPcHRpb25UeXBlLkNPTE9SX01BVFJJWDpcbiAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yTWF0cml4KSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fYnVpbGRDb25maWdFcnJvcihgT3B0aW9uIFxcYCR7b3B0aW9uTmFtZX1cXGAgaGFzIHRvIGJlIGFuIGluc3RhbmNlIG9mIENvbG9yTWF0cml4LmApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlLmNsb25lKClcblxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgLy8gT2JqZWN0IG9wdGlvbnNcbiAgICAgICAgY2FzZSBPcHRpb25UeXBlLk9CSkVDVDpcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIE9wdGlvblR5cGUuSU1BR0U6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKClcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IHZhbHVlXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID0gaW1hZ2VcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW1hZ2UgfHwgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fYnVpbGRDb25maWdFcnJvcihgT3B0aW9uIFxcYCR7b3B0aW9uTmFtZX1cXGAgaGFzIHRvIGJlIGFuIEltYWdlIG9yIFN0cmluZy5gKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIC8vIENvbmZpZ3VyYWJsZSBvcHRpb25zXG4gICAgICAgIGNhc2UgT3B0aW9uVHlwZS5DT05GSUdVUkFCTEU6XG4gICAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXS5zZXQodmFsdWUpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICAvLyBBcnJheSBvcHRpb25zXG4gICAgICAgIGNhc2UgT3B0aW9uVHlwZS5BUlJBWTpcbiAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fYnVpbGRDb25maWdFcnJvcihgT3B0aW9uIFxcYCR7b3B0aW9uTmFtZX1cXGAgaGFzIHRvIGJlIGFuIEFycmF5LmApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZS5zbGljZSgwKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgLy8gVW5rbm93biBvcHRpb24gdHlwZVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IHRoaXMuX2J1aWxkQ29uZmlnRXJyb3IoYFVua25vd24gb3B0aW9uIHR5cGU6IFxcYCR7b3B0aW9uQ29uZmlnLnR5cGV9XFxgYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLl9vbk9wdGlvbnNDaGFuZ2UoKVxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLCB7IFtvcHRpb25OYW1lXTogdmFsdWUgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIGBjb25maWd1cmFibGVgIG9wdGlvbiBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwYXJhbSAgeyp9IC4uLmFyZ3NcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNvbmZpZ3VyYWJsZVVwZGF0ZSAoLi4uYXJncykge1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgLi4uYXJncylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25maWd1cmFibGVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9jb25maWd1cmFibGUuanMiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbCBIVE1MRWxlbWVudCwgV0VCUEFDSyAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgQmFzZTY0IGZyb20gJy4vYmFzZTY0J1xuXG4vKipcbiAqIFByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBpbnRlcm5hbCB1c2VcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBVdGlscyB7XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBBcnJheVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmplY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0FycmF5IChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBhZ2VudCByZXByZXNlbnRzIGEgbW9iaWxlIGRldmljZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzTW9iaWxlICgpIHtcbiAgICBjb25zdCBhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYVxuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgcmV0dXJuICgvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdChhKXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdChhLnN1YnN0cigwLCA0KSkpXG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdpdmVuIG9iamVjdCdzIHZhbHVlcyBhcyBhbiBhcnJheVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm5zIHtBcnJheTwqPn1cbiAgICovXG4gIHN0YXRpYyB2YWx1ZXMgKG9iamVjdCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXVxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIHZhbHVlcy5wdXNoKG9iamVjdFtrZXldKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBzdGF0aWMgaXNET01FbGVtZW50IChvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ29iamVjdCcgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcbiAgICAgIDogbyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSAnc3RyaW5nJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGggZ2l2ZW4gZXZlbnQgaXMgYSB0b3VjaCBldmVudFxuICAgKiBAcGFyYW0gIHtFdmVudH0gIGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1RvdWNoRXZlbnQgKGUpIHtcbiAgICByZXR1cm4gKGUudHlwZS5pbmRleE9mKCd0b3VjaCcpICE9PSAtMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gZml0IGluc2lkZSB0aGUgZ2l2ZW4gbWF4IHNpemUgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICogdGhlIGFzcGVjdCByYXRpb1xuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2ZWN0b3JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gbWF4XG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqL1xuICBzdGF0aWMgcmVzaXplVmVjdG9yVG9GaXQgKHZlY3RvciwgbWF4KSB7XG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1pbihtYXgueCAvIHZlY3Rvci54LCBtYXgueSAvIHZlY3Rvci55KVxuICAgIGNvbnN0IG5ld1NpemUgPSB2ZWN0b3IuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KHNjYWxlKVxuICAgIHJldHVybiBuZXdTaXplXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgdmFsdWUgaXMgZXh0ZW5kYWJsZSAvIGNhbiBoYXZlIGtleXNcbiAgICogQHBhcmFtICB7Kn0gIHZhbFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRXh0ZW5kYWJsZSAodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnICYmIHZhbCAhPT0gbnVsbCAmJlxuICAgICAgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpXG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIHVuZGVmaW5lZC4gT25jZSBhXG4gICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gLi4uc291cmNlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgKG9iamVjdCwgLi4uc291cmNlcykge1xuICAgIC8vIFNoYWxsb3cgY2xvbmVcbiAgICBsZXQgbmV3T2JqZWN0ID0ge31cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBuZXdPYmplY3Rba2V5XSA9IG9iamVjdFtrZXldXG4gICAgfVxuXG4gICAgLy8gQ2xvbmUgc291cmNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpXVxuICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09iamVjdFtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG5ld09iamVjdFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmplY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyBhbmQgdGhlaXIgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG9cbiAgICogdW5kZWZpbmVkLiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlIHNvZiB0aGUgc2FtZSBwcm9wZXJ0eVxuICAgKiBhcmUgaWdub3JlZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtICB7T2JqZWN0fSAuLi5zb3VyY2VzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBkZWVwRGVmYXVsdHMgKG9iamVjdCwgLi4uc291cmNlcykge1xuICAgIC8vIFNoYWxsb3cgY2xvbmVcbiAgICBsZXQgbmV3T2JqZWN0ID0ge31cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBuZXdPYmplY3Rba2V5XSA9IG9iamVjdFtrZXldXG4gICAgfVxuXG4gICAgLy8gQ2xvbmUgc291cmNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpXVxuICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoVXRpbHMuaXNFeHRlbmRhYmxlKG5ld09iamVjdFtrZXldKSAmJlxuICAgICAgICAgICAgVXRpbHMuaXNFeHRlbmRhYmxlKHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgIG5ld09iamVjdFtrZXldID0gVXRpbHMuZGVlcERlZmF1bHRzKG5ld09iamVjdFtrZXldLCBzb3VyY2Vba2V5XSlcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV3T2JqZWN0W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iamVjdFxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICogc291cmNlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gLi4uc291cmNlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZXh0ZW5kIChvYmplY3QsIC4uLnNvdXJjZXMpIHtcbiAgICAvLyBTaGFsbG93IGNsb25lXG4gICAgbGV0IG5ld09iamVjdCA9IHt9XG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSBvYmplY3Rba2V5XVxuICAgIH1cblxuICAgIC8vIEV4dGVuZCBzb3VyY2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2ldXG4gICAgICBmb3IgKGxldCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIG5ld09iamVjdFtrZXldID0gc291cmNlW2tleV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqZWN0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIGdpdmVuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgY2xvbmUgKG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7fSwgb2JqZWN0KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCbG9iIFVSSSBmcm9tIHRoZSBnaXZlbiBEYXRhIFVSSVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUJsb2JVUklGcm9tRGF0YVVSSSAoZGF0YSkge1xuICAgIGlmICghd2luZG93LkJsb2IgfHwgIXdpbmRvdy5VUkwgfHwgIUFycmF5QnVmZmVyIHx8ICFVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIGNvbnN0IHJhd0RhdGEgPSBCYXNlNjQuZGVjb2RlKGRhdGEuc3BsaXQoJywnKVsxXSlcbiAgICBjb25zdCBtaW1lU3RyaW5nID0gZGF0YS5zcGxpdCgnLCcpWzBdLnNwbGl0KCc6JylbMV0uc3BsaXQoJzsnKVswXVxuXG4gICAgLy8gd3JpdGUgdGhlIGJ5dGVzIG9mIHRoZSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXJcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihyYXdEYXRhLmxlbmd0aClcbiAgICBjb25zdCBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50QXJyYXlbaV0gPSByYXdEYXRhW2ldXG4gICAgfVxuXG4gICAgLy8gd3JpdGUgdGhlIEFycmF5QnVmZmVyIHRvIGEgYmxvYiwgYW5kIHlvdSdyZSBkb25lXG4gICAgY29uc3QgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbYXJyYXlCdWZmZXJdLCB7XG4gICAgICB0eXBlOiBtaW1lU3RyaW5nXG4gICAgfSlcbiAgICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgfVxuXG4gIC8qKlxuICAgKiBWZW5kb3IgcHJveHkgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIHJlcXVlc3RBbmltYXRpb25GcmFtZSAoY2IpIHtcbiAgICBjb25zdCBmYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbGxiYWNrKGNiKVxuICAgIH1cblxuICAgIHJldHVybiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgZmFsbGJhY2spKGNiKVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFVVSURcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldFVVSUQgKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDBcbiAgICAgIGxldCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KVxuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGF0dGVucyB0aGUgZ2l2ZW4gbXVsdGlkaW1lbnNpb25hbCBhcnJheVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBmbGF0dGVuIChhcnJheSkge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24gKGZsYXQsIHRvRmxhdHRlbikge1xuICAgICAgcmV0dXJuIGZsYXQuY29uY2F0KEFycmF5LmlzQXJyYXkodG9GbGF0dGVuKSA/IFV0aWxzLmZsYXR0ZW4odG9GbGF0dGVuKSA6IHRvRmxhdHRlbilcbiAgICB9LCBbXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FudmFzIERPTSBlbGVtZW50IChicm93c2VyKSBvciBhIG5vZGUtY2FudmFzIGNhbnZhcyAobm9kZSlcbiAgICogQHJldHVybiB7Q2FudmFzfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUNhbnZhcyAoKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIFBPVFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9ICBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNQb3dlck9mVHdvIChkaW1lbnNpb25zKSB7XG4gICAgcmV0dXJuIChkaW1lbnNpb25zLnggJiAoZGltZW5zaW9ucy54IC0gMSkpID09PSAwICYmXG4gICAgICAoZGltZW5zaW9ucy55ICYgKGRpbWVuc2lvbnMueSAtIDEpKSA9PT0gMFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgbG93ZXN0IHBvd2VyIG9mIHR3byBvZiB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAqIEBwYXJhbSAge051bWJlcn0geFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgbmV4dExvd2VzdFBPVCAoeCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMzI7IGkgPDw9IDEpIHtcbiAgICAgIHggPSB4IHwgeCA+PiBpXG4gICAgfVxuICAgIHJldHVybiB4IC0gKHggPj4gMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgdHdvIG9mIHRoZSBnaXZlbiBudW1iZXJcbiAgICogQHBhcmFtICB7TnVtYmVyfSB4XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHN0YXRpYyBuZXh0SGlnaGVzdFBPVCAoeCkge1xuICAgIHgtLVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMzI7IGkgPDw9IDEpIHtcbiAgICAgIHggPSB4IHwgeCA+PiBpXG4gICAgfVxuICAgIHJldHVybiB4ICsgMVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBhcnJheSBpdGVtIGF0IGBvbGRJbmRleGAgdG8gYG5ld0luZGV4YFxuICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAqIEBwYXJhbSAge051bWJlcn0gb2xkSW5kZXhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBuZXdJbmRleFxuICAgKi9cbiAgc3RhdGljIG1vdmVBcnJheUl0ZW0gKGFyciwgb2xkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgaWYgKG5ld0luZGV4ID49IGFyci5sZW5ndGgpIHtcbiAgICAgIGxldCBrID0gbmV3SW5kZXggLSBhcnIubGVuZ3RoXG4gICAgICB3aGlsZSAoKGstLSkgKyAxKSB7XG4gICAgICAgIGFyci5wdXNoKHVuZGVmaW5lZClcbiAgICAgIH1cbiAgICB9XG4gICAgYXJyLnNwbGljZShuZXdJbmRleCwgMCwgYXJyLnNwbGljZShvbGRJbmRleCwgMSlbMF0pXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgc3VyZSB0aGUgZ2l2ZW4gY2FudmFzIGhhcyB0aGUgZ2l2ZW4gZGltZW5zaW9ucy4gSWYgbm90LCBpdCBkb2VzIG5vdCBjaGFuZ2UgdGhlXG4gICAqIGNhbnZhcyBkaW1lbnNpb25zLlxuICAgKiBAcGFyYW0gIHtDYW52YXN9IGNhbnZhc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICovXG4gIHN0YXRpYyBlbnN1cmVDYW52YXNEaW1lbnNpb25zIChjYW52YXMsIGRpbWVuc2lvbnMpIHtcbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSBkaW1lbnNpb25zLnggfHxcbiAgICAgICAgY2FudmFzLmhlaWdodCAhPT0gZGltZW5zaW9ucy55KSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaW1lbnNpb25zLnhcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaW1lbnNpb25zLnlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGdpdmVuIGFycmF5IG9mIGJ5dGVzIHRvIGEgc3RyaW5nXG4gICAqIEBwYXJhbSAge051bWJlcltdfSBieXRlQXJyYXlcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGJ5dGVBcnJheVRvU3RyaW5nIChieXRlQXJyYXkpIHtcbiAgICByZXR1cm4gYnl0ZUFycmF5Lm1hcCgoYnl0ZSkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSkuam9pbignJylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVdGlsc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL3V0aWxzLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5sZXQgbWF4TG9nTGV2ZWwgPSAnd2FybidcblxuY29uc3QgTEVWRUxTID0gW1xuICB7IHR5cGU6ICd0cmFjZScsIGJhY2tncm91bmQ6ICcjRUVFRUVFJywgY29sb3I6ICcjQUFBQUFBJyB9LFxuICB7IHR5cGU6ICdpbmZvJywgYmFja2dyb3VuZDogJyNCREU1RjgnLCBjb2xvcjogJyMwMDUyOUInIH0sXG4gIHsgdHlwZTogJ3dhcm4nLCBiYWNrZ3JvdW5kOiAnI0ZFRUZCMycsIGNvbG9yOiAnIzlGNjAwMCcgfSxcbiAgeyB0eXBlOiAnZXJyb3InLCBiYWNrZ3JvdW5kOiAnI0ZGQkFCQScsIGNvbG9yOiAnI0Q4MDAwQycgfSxcbiAgeyB0eXBlOiAnbG9nJywgYmFja2dyb3VuZDogJyNFRUVFRUUnLCBjb2xvcjogJyMxZjRmNmInIH1cbl1cbmNvbnN0IExFVkVMX1RZUEVTID0gTEVWRUxTLm1hcCgobCkgPT4gbC50eXBlKVxuXG5sZXQgTG9nID0ge31cblxuTG9nLnNldExldmVsID0gKF9sZXZlbCkgPT4geyBtYXhMb2dMZXZlbCA9IF9sZXZlbCB9XG5Mb2cuY2FuTG9nID0gKHR5cGUpID0+IHtcbiAgaWYgKG1heExvZ0xldmVsID09PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgY29uc3QgY3VycmVudExldmVsSW5kZXggPSBMRVZFTF9UWVBFUy5pbmRleE9mKHR5cGUpXG4gIGNvbnN0IG1heExldmVsSW5kZXggPSBMRVZFTF9UWVBFUy5pbmRleE9mKG1heExvZ0xldmVsKVxuICBpZiAoY3VycmVudExldmVsSW5kZXggPCBtYXhMZXZlbEluZGV4KSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRydWVcbn1cbkxvZy5oYXNDb2xvcmZ1bE91dHB1dCA9ICgpID0+IHtcbiAgcmV0dXJuICghcHJvY2VzcyB8fCAocHJvY2VzcyAmJiBwcm9jZXNzLmJyb3dzZXIpKSAmJlxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0dlY2tvfFdlYktpdC9pKSAmJlxuICAgICAgIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvKVxuICAgIClcbn1cblxuTG9nLnByaW50RXJyb3IgPSAoZSkgPT4ge1xuICBjb25zdCBsaW5lcyA9IGUuc3RhY2suc3BsaXQoJ1xcbicpXG4gIGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICBMb2cuZXJyb3IoJ0Vycm9yJywgbGluZSlcbiAgfSlcbn1cblxuTEVWRUxTLmZvckVhY2goKGxldmVsKSA9PiB7XG4gIGNvbnN0IHsgdHlwZSwgYmFja2dyb3VuZCwgY29sb3IgfSA9IGxldmVsXG4gIExvZ1t0eXBlXSA9IGZ1bmN0aW9uICh0YWcsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIUxvZy5jYW5Mb2codHlwZSkpIHJldHVyblxuXG4gICAgY29uc3Qgb3V0cHV0ID0gYXJnc1xuICAgICAgLm1hcCgoYSkgPT4gKHR5cGVvZiBhID09PSAnc3RyaW5nJykgPyBhIDogYS50b1N0cmluZygpKVxuICAgICAgLmpvaW4oJyAnKVxuICAgIGlmICghTG9nLmhhc0NvbG9yZnVsT3V0cHV0KCkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyhgUGhvdG9FZGl0b3JTREsgfCAke3RhZ30gfCAke291dHB1dH1gKVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGAlYyAgJWMgUGhvdG9FZGl0b3JTREsgJWMgICVjICR7dGFnfSAlYyAgJHtvdXRwdXR9ICAlYyAgYCxcbiAgICAgICdiYWNrZ3JvdW5kOiAjNDNBREVCOyBsaW5lLWhlaWdodDogMjBweDsgcGFkZGluZzogNHB4IDAnLFxuICAgICAgJ2JhY2tncm91bmQ6ICMyQjJCMkI7IGNvbG9yOiB3aGl0ZTsgbGluZS1oZWlnaHQ6IDIwcHg7IHBhZGRpbmc6IDRweCAwJyxcbiAgICAgICdiYWNrZ3JvdW5kOiAjNDNBREVCOyBsaW5lLWhlaWdodDogMjBweDsgcGFkZGluZzogNHB4IDAnLFxuICAgICAgYGJhY2tncm91bmQ6ICR7YmFja2dyb3VuZH07IGNvbG9yOiAke2NvbG9yfTsgbGluZS1oZWlnaHQ6IDIwcHg7IHBhZGRpbmc6IDRweCAwOyBmb250LXdlaWdodDogYm9sZGAsXG4gICAgICAnYmFja2dyb3VuZDogIzJCMkIyQjsgY29sb3I6IHdoaXRlOyBsaW5lLWhlaWdodDogMjBweDsgcGFkZGluZzogNHB4IDAnLFxuICAgICAgJ2JhY2tncm91bmQ6ICM0M0FERUI7IGxpbmUtaGVpZ2h0OiAyMHB4OyBwYWRkaW5nOiA0cHggMCcpXG4gIH1cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IExvZ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3NoYXJlZC9sb2cuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIDItZGltZW5zaW9uYWwgdmVjdG9yIHdoaWxlIHByb3ZpZGluZyBtYXRoIGZ1bmN0aW9ucyB0b1xuICogbW9kaWZ5IC8gY2xvbmUgdGhlIHZlY3Rvci4gRnVsbHkgY2hhaW5hYmxlLlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuTWF0aFxuICovXG5jbGFzcyBWZWN0b3IyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBWZWN0b3IyXG4gICAqIEBwYXJhbSAge051bWJlcn0geFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh4LCB5KSB7XG4gICAgdGhpcy54ID0geFxuICAgIHRoaXMueSA9IHlcbiAgICBpZiAodHlwZW9mIHRoaXMueCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMueCA9IDBcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnkgPSAwXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIHZhbHVlc1xuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBzZXQgKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4XG4gICAgdGhpcy55ID0geVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgdmVjdG9yXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54LCB0aGlzLnkpXG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIHZlY3RvclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IG90aGVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGNvcHkgKG90aGVyKSB7XG4gICAgdGhpcy54ID0gb3RoZXIueFxuICAgIHRoaXMueSA9IG90aGVyLnlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENsYW1wcyB0aGlzIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBWZWN0b3IyIC8gTnVtYmVyXG4gICAqIEBwYXJhbSAgeyhOdW1iZXJ8UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyKX0gbWluaW11bVxuICAgKiBAcGFyYW0gIHsoTnVtYmVyfFBob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMil9IG1heGltdW1cbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgY2xhbXAgKG1pbmltdW0sIG1heGltdW0pIHtcbiAgICBsZXQgbWluaW11bVNldCA9IG1pbmltdW0gIT09IG51bGwgJiYgdHlwZW9mIG1pbmltdW0gIT09ICd1bmRlZmluZWQnXG4gICAgbGV0IG1heGltdW1TZXQgPSBtYXhpbXVtICE9PSBudWxsICYmIHR5cGVvZiBtYXhpbXVtICE9PSAndW5kZWZpbmVkJ1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG4gICAgaWYgKCEobWluaW11bSBpbnN0YW5jZW9mIFZlY3RvcjIpICYmIG1pbmltdW1TZXQpIHtcbiAgICAgIG1pbmltdW0gPSBuZXcgVmVjdG9yMihtaW5pbXVtLCBtaW5pbXVtKVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICBpZiAoIShtYXhpbXVtIGluc3RhbmNlb2YgVmVjdG9yMikgJiYgbWF4aW11bVNldCkge1xuICAgICAgbWF4aW11bSA9IG5ldyBWZWN0b3IyKG1heGltdW0sIG1heGltdW0pXG4gICAgfVxuXG4gICAgaWYgKG1pbmltdW1TZXQpIHtcbiAgICAgIHRoaXMueCA9IE1hdGgubWF4KG1pbmltdW0ueCwgdGhpcy54KVxuICAgICAgdGhpcy55ID0gTWF0aC5tYXgobWluaW11bS55LCB0aGlzLnkpXG4gICAgfVxuXG4gICAgaWYgKG1heGltdW1TZXQpIHtcbiAgICAgIHRoaXMueCA9IE1hdGgubWluKG1heGltdW0ueCwgdGhpcy54KVxuICAgICAgdGhpcy55ID0gTWF0aC5taW4obWF4aW11bS55LCB0aGlzLnkpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRGl2aWRlcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gVmVjdG9yMiAvIE51bWJlclxuICAgKiBAcGFyYW0gIHsoTnVtYmVyfFBob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMil9IGRpdmlzb3JcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbeV1cbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZGl2aWRlIChkaXZpc29yLCB5KSB7XG4gICAgaWYgKGRpdmlzb3IgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XG4gICAgICB0aGlzLnggLz0gZGl2aXNvci54XG4gICAgICB0aGlzLnkgLz0gZGl2aXNvci55XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueCAvPSBkaXZpc29yXG4gICAgICB0aGlzLnkgLz0gKHR5cGVvZiB5ID09PSAndW5kZWZpbmVkJyA/IGRpdmlzb3IgOiB5KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gVmVjdG9yMiAvIE51bWJlciBmcm9tIHRoaXMgdmVjdG9yXG4gICAqIEBwYXJhbSAgeyhOdW1iZXJ8UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyKX0gc3VidHJhaGVuZFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt5XVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBzdWJ0cmFjdCAoc3VidHJhaGVuZCwgeSkge1xuICAgIGlmIChzdWJ0cmFoZW5kIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy54IC09IHN1YnRyYWhlbmQueFxuICAgICAgdGhpcy55IC09IHN1YnRyYWhlbmQueVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggLT0gc3VidHJhaGVuZFxuICAgICAgdGhpcy55IC09ICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcgPyBzdWJ0cmFoZW5kIDogeSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoZSBnaXZlbiBWZWN0b3IyIC8gTnVtYmVyIHdpdGggdGhpcyB2ZWN0b3JcbiAgICogQHBhcmFtICB7KE51bWJlcnxQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjIpfSBzdWJ0cmFoZW5kXG4gICAqIEBwYXJhbSAge051bWJlcn0gW3ldXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIG11bHRpcGx5IChmYWN0b3IsIHkpIHtcbiAgICBpZiAoZmFjdG9yIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy54ICo9IGZhY3Rvci54XG4gICAgICB0aGlzLnkgKj0gZmFjdG9yLnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ICo9IGZhY3RvclxuICAgICAgdGhpcy55ICo9ICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3IgOiB5KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIFZlY3RvcjIgLyBOdW1iZXJzIHRvIHRoaXMgdmVjdG9yXG4gICAqIEBwYXJhbSB7KE51bWJlcnxQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjIpfSBhZGRlbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5XVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBhZGQgKGFkZGVuZCwgeSkge1xuICAgIGlmIChhZGRlbmQgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XG4gICAgICB0aGlzLnggKz0gYWRkZW5kLnhcbiAgICAgIHRoaXMueSArPSBhZGRlbmQueVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggKz0gYWRkZW5kXG4gICAgICB0aGlzLnkgKz0gKHR5cGVvZiB5ID09PSAndW5kZWZpbmVkJyA/IGFkZGVuZCA6IHkpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgdmFsdWUgYXJlIHRoZSBzYW1lIGFzIHRoZSBnaXZlbiBvbmVzXG4gICAqIEBwYXJhbSAgeyhOdW1iZXJ8UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyKX0gdmVjXG4gICAqIEBwYXJhbSAge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWxzICh2ZWMsIHkpIHtcbiAgICBpZiAodmVjIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgcmV0dXJuIHZlYy54ID09PSB0aGlzLnggJiYgdmVjLnkgPT09IHRoaXMueVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmVjID09PSB0aGlzLnggJiYgeSA9PT0gdGhpcy55XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsaXBzIHRoZSB4IGFuZCB5IHZhbHVlcyBvZiB0aGlzIHZlY3RvclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBmbGlwICgpIHtcbiAgICBsZXQgdGVtcFggPSB0aGlzLnhcbiAgICB0aGlzLnggPSB0aGlzLnlcbiAgICB0aGlzLnkgPSB0ZW1wWFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUm91bmRzIHRoZSB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3JcbiAgICogQHJldHVybnMge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIHJvdW5kICgpIHtcbiAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueClcbiAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdW5kcyB1cCB0aGUgdmFsdWVzIG9mIHRoaXMgdmVjdG9yXG4gICAqIEByZXR1cm5zIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBjZWlsICgpIHtcbiAgICB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KVxuICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3VuZHMgZG93biB0aGUgdmFsdWVzIG9mIHRoaXMgdmVjdG9yXG4gICAqIEByZXR1cm5zIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBmbG9vciAoKSB7XG4gICAgdGhpcy54ID0gdGhpcy54IHwgMFxuICAgIHRoaXMueSA9IHRoaXMueSB8IDBcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGJvdGggbnVtYmVycyBvZiB0aGlzIHZlY3RvciBwb3NpdGl2ZVxuICAgKiBAcmV0dXJucyB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgYWJzICgpIHtcbiAgICB0aGlzLnggPSBNYXRoLmFicyh0aGlzLngpXG4gICAgdGhpcy55ID0gTWF0aC5hYnModGhpcy55KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXVjbGlkZWFuIGxlbmd0aCBvZiB0aGlzIHZlY3RvclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBsZW4gKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNtYWxsZXN0IG51bWJlciBpbiB0aGlzIHZlY3RvclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBtaW4gKCkge1xuICAgIHJldHVybiBNYXRoLm1pbih0aGlzLngsIHRoaXMueSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXJnZXN0IG51bWJlciBpbiB0aGlzIHZlY3RvclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBtYXggKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLngsIHRoaXMueSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgUE9KTyBvZiB0aGlzIFZlY3RvcjJcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3QgKCkge1xuICAgIHJldHVybiB7IHg6IHRoaXMueCwgeTogdGhpcy55IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gYFZlY3RvcjIoeyB4OiAke3RoaXMueH0sIHk6ICR7dGhpcy55fSB9KWBcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3VuZHMgdGhpcyB2ZWN0b3IncyB2YWx1ZXMgdG8gdGhlIGdpdmVuIG51bWJlciBvZiBkZWNpbWFsc1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRlY2ltYWxzXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHJvdW5kRGVjaW1hbCAoZGVjaW1hbHMpIHtcbiAgICB0aGlzLnggPSBwYXJzZUZsb2F0KHRoaXMueC50b0ZpeGVkKGRlY2ltYWxzKSlcbiAgICB0aGlzLnkgPSBwYXJzZUZsb2F0KHRoaXMueS50b0ZpeGVkKGRlY2ltYWxzKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVmVjdG9yMiBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBPYmplY3RcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3QgKG9iamVjdCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMihvYmplY3QueCwgb2JqZWN0LnkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG51bGwgdmVjdG9yXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIHN0YXRpYyBnZXQgTlVMTCAoKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKDAsIDApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVjdG9yMlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL21hdGgvdmVjdG9yMi5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogRXh0cmFjdGVkIGZyb20gTWluaWZ5SnBlZyAoQ29weXJpZ2h0IChjKSAyMDE0IEhpcm9ha2kgTWF0b2JhLCBNSVQgTGljZW5zZSk6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vaE1hdG9iYS9NaW5pZnlKcGVnXG4gKiBAbGljZW5zZVxuICovXG5cbmNvbnN0IEtFWV9TVFIgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG5cbi8qKlxuICogUHJvdmlkZXMgQmFzZTY0IGVuY29kZSBhbmQgZGVjb2RlIG1ldGhvZHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBCYXNlNjQgPSB7XG4gIC8qKlxuICAgKiBFbmNvZGVzIHRoZSBnaXZlbiBpbnB1dCBpbnRvIGEgQmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlucHV0XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGVuY29kZSAoaW5wdXQpIHtcbiAgICBsZXQgb3V0cHV0ID0gJydcbiAgICBsZXQgY2hyMSwgY2hyMiwgY2hyM1xuICAgIGxldCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0XG4gICAgbGV0IGkgPSAwXG5cbiAgICBkbyB7XG4gICAgICBjaHIxID0gaW5wdXRbaSsrXVxuICAgICAgY2hyMiA9IGlucHV0W2krK11cbiAgICAgIGNocjMgPSBpbnB1dFtpKytdXG5cbiAgICAgIGVuYzEgPSBjaHIxID4+IDJcbiAgICAgIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpXG4gICAgICBlbmMzID0gKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNilcbiAgICAgIGVuYzQgPSBjaHIzICYgNjNcblxuICAgICAgaWYgKGlzTmFOKGNocjIpKSB7XG4gICAgICAgIGVuYzMgPSBlbmM0ID0gNjRcbiAgICAgIH0gZWxzZSBpZiAoaXNOYU4oY2hyMykpIHtcbiAgICAgICAgZW5jNCA9IDY0XG4gICAgICB9XG5cbiAgICAgIG91dHB1dCA9IG91dHB1dCArXG4gICAgICAgICBLRVlfU1RSLmNoYXJBdChlbmMxKSArXG4gICAgICAgICBLRVlfU1RSLmNoYXJBdChlbmMyKSArXG4gICAgICAgICBLRVlfU1RSLmNoYXJBdChlbmMzKSArXG4gICAgICAgICBLRVlfU1RSLmNoYXJBdChlbmM0KVxuICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gJydcbiAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSAnJ1xuICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpXG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlY29kZXMgdGhlIGdpdmVuIEJhc2U2NCBzdHJpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpbnB1dFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBkZWNvZGUgKGlucHV0KSB7XG4gICAgbGV0IGNocjEsIGNocjIsIGNocjNcbiAgICBsZXQgZW5jMSwgZW5jMiwgZW5jMywgZW5jNFxuICAgIGxldCBpID0gMFxuICAgIGxldCBidWYgPSBbXVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBBLVosIGEteiwgMC05LCArLCAvLCBvciA9XG4gICAgdmFyIGJhc2U2NHRlc3QgPSAvW15BLVphLXowLTkrLz1dL2dcbiAgICBpZiAoYmFzZTY0dGVzdC5leGVjKGlucHV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSB3ZXJlIGludmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0IHRleHQuXFxuJyArXG4gICAgICAgICAgICAnVmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMgYXJlIEEtWiwgYS16LCAwLTksIFxcJytcXCcsIFxcJy9cXCcsYW5kIFxcJz1cXCdcXG4nICtcbiAgICAgICAgICAgICdFeHBlY3QgZXJyb3JzIGluIGRlY29kaW5nLicpXG4gICAgfVxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTkrLz1dL2csICcnKVxuXG4gICAgZG8ge1xuICAgICAgZW5jMSA9IEtFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSlcbiAgICAgIGVuYzIgPSBLRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpXG4gICAgICBlbmMzID0gS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKVxuICAgICAgZW5jNCA9IEtFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSlcblxuICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNClcbiAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKVxuICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNFxuXG4gICAgICBidWYucHVzaChjaHIxKVxuXG4gICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgYnVmLnB1c2goY2hyMilcbiAgICAgIH1cbiAgICAgIGlmIChlbmM0ICE9PSA2NCkge1xuICAgICAgICBidWYucHVzaChjaHIzKVxuICAgICAgfVxuXG4gICAgICBjaHIxID0gY2hyMiA9IGNocjMgPSAnJ1xuICAgICAgZW5jMSA9IGVuYzIgPSBlbmMzID0gZW5jNCA9ICcnXG4gICAgfSB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aClcblxuICAgIHJldHVybiBidWZcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlNjRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9iYXNlNjQuanMiLCIvKipcbiAqIEV2ZW50RW1pdHRlciAoRVM2KSBmcm9tOlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmxvb2R5b3dsLzQxYjFkZTMzODhjNjI2Nzk2ZWNhXG4gKi9cblxuaW1wb3J0IExvZyBmcm9tICcuLi8uLi9zaGFyZWQvbG9nJ1xuY29uc3QgREVGQVVMVF9NQVhfTElTVEVORVJTID0gMTJcblxuLyoqXG4gKiBSZWNlaXZlcyBhbmQgZW1pdHMgZXZlbnRzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICogQGlnbm9yZVxuICovXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBFdmVudEVtaXR0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBERUZBVUxUX01BWF9MSVNURU5FUlNcbiAgICB0aGlzLl9ldmVudHMgPSB7fVxuICAgIHRoaXMuX3BpcGVEZXN0aW5hdGlvbnMgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIFBpcGVzIGFsbCBldmVudHMgdG8gdGhlIGdpdmVuIEV2ZW50RW1pdHRlclxuICAgKiBAcGFyYW0gIHtFdmVudEVtaXR0ZXJ9IGRlc3RpbmF0aW9uXG4gICAqL1xuICBwaXBlRXZlbnRzIChkZXN0aW5hdGlvbikge1xuICAgIHRoaXMuX3BpcGVEZXN0aW5hdGlvbnMucHVzaChkZXN0aW5hdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBwaXBpbmcgZXZlbnRzIHRvIHRoZSBnaXZlbiBFdmVudEVtaXR0ZXJcbiAgICogQHBhcmFtICB7RXZlbnRFbWl0dGVyfSBkZXN0aW5hdGlvblxuICAgKi9cbiAgdW5waXBlRXZlbnRzIChkZXN0aW5hdGlvbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9waXBlRGVzdGluYXRpb25zLmluZGV4T2YoZGVzdGluYXRpb24pXG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fcGlwZURlc3RpbmF0aW9ucy5zcGxpY2UoaSwgMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBsaXN0ZW5lciB0byB0aGUgZ2l2ZW4gdHlwZSBvZiBldmVudHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgKi9cbiAgb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpXG4gICAgfVxuXG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCAodGhpcy5fZXZlbnRzW3R5cGVdID0gW10pXG4gICAgaWYgKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKVxuXG4gICAgaWYgKHRoaXMuX21heExpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoID4gdGhpcy5fbWF4TGlzdGVuZXJzKSB7XG4gICAgICBMb2cud2FybignRXZlbnRFbWl0dGVyJyxcbiAgICAgICAgYFBvc3NpYmxlIG1lbW9yeSBsZWFrIGRldGVjdGVkLCBhZGRlZCAke2xpc3RlbmVycy5sZW5ndGh9IFxcYCR7dHlwZX1cXGAgbGlzdGVuZXJzIChjdXJyZW50IGxpbWl0IGlzICR7dGhpcy5fbWF4TGlzdGVuZXJzfSlgXG4gICAgICApXG4gICAgICBjb25zb2xlLnRyYWNlKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBsaXN0ZW5lciB0byB0aGUgZ2l2ZW4gdHlwZSBvZiBldmVudHMgYW5kIHJlbW92ZXMgaXRcbiAgICogb25jZSBpdCBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgKi9cbiAgb25jZSAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBsZXQgZXZlbnRzSW5zdGFuY2UgPSB0aGlzXG4gICAgZnVuY3Rpb24gb25jZUNhbGxiYWNrICgpIHtcbiAgICAgIGV2ZW50c0luc3RhbmNlLm9mZih0eXBlLCBvbmNlQ2FsbGJhY2spXG4gICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIG9uY2VDYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBsaXN0ZW5lciBmcm9tIHRoZSBnaXZlbiB0eXBlIG9mIGV2ZW50c1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtICB7Kn0gLi4uYXJnc1xuICAgKi9cbiAgb2ZmICh0eXBlLCAuLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGxldCBsaXN0ZW5lciA9IGFyZ3NbMF1cbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKClcbiAgICB9XG5cbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdXG4gICAgaWYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgbGV0IGluZGV4T2ZMaXN0ZW5lciA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKVxuICAgIGlmIChpbmRleE9mTGlzdGVuZXIgPT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXhPZkxpc3RlbmVyLCAxKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgYXJndW1lbnRzXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0gIHsqfSAuLi5hcmdzXG4gICAqL1xuICBlbWl0ICh0eXBlLCAuLi5hcmdzKSB7XG4gICAgdGhpcy5fcGlwZURlc3RpbmF0aW9ucy5mb3JFYWNoKChkZXN0KSA9PiB7XG4gICAgICBkZXN0LmVtaXQodHlwZSwgLi4uYXJncylcbiAgICB9KVxuXG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXVxuICAgIGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoZm4pID0+IGZuLmFwcGx5KG51bGwsIGFyZ3MpKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXhpbXVtIGFtb251dCBvZiBsaXN0ZW5lcnMgYmVmb3JlIGEgd2FybmluZyBpcyBwcmludGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuZXdNYXhMaXN0ZW5lcnNcbiAgICovXG4gIHNldE1heExpc3RlbmVycyAobmV3TWF4TGlzdGVuZXJzKSB7XG4gICAgaWYgKHBhcnNlSW50KG5ld01heExpc3RlbmVycywgMTApICE9PSBuZXdNYXhMaXN0ZW5lcnMpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXMuX21heExpc3RlbmVycyA9IG5ld01heExpc3RlbmVyc1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RW1pdHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL2V2ZW50LWVtaXR0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IExvZywgVmVjdG9yMiwgVXRpbHMsIFJlY3RhbmdsZSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vZ2xvYmFscydcblxuLyoqXG4gKiBBIEJhc2VUZXh0dXJlIGhvbGRzIGFuZCBoYW5kbGVzIHRoZSByYXcgc291cmNlIG9mIGEgdGV4dHVyZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuY2xhc3MgQmFzZVRleHR1cmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIEJhc2VUZXh0dXJlXG4gICAqIEBwYXJhbSAgeyp9IHNvdXJjZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuaWQgPSBCYXNlVGV4dHVyZS5pZCsrXG4gICAgdGhpcy5fb25Tb3VyY2VMb2FkZWQgPSB0aGlzLl9vblNvdXJjZUxvYWRlZC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9yZW5kZXJlcnMgPSBbXVxuICAgIHRoaXMuX2dsVGV4dHVyZXMgPSB7fVxuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZVxuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZVxuXG4gICAgdGhpcy5fZ2xVbml0ID0gMFxuICAgIHRoaXMuX21pcE1hcHBpbmcgPSBmYWxzZVxuICAgIHRoaXMuX21hZ0ZpbHRlciA9IEJhc2VUZXh0dXJlLkRlZmF1bHRNYWdGaWx0ZXJcbiAgICB0aGlzLl9taW5GaWx0ZXIgPSBCYXNlVGV4dHVyZS5EZWZhdWx0TWluRmlsdGVyXG4gICAgdGhpcy5fcmVwZWF0WCA9IEJhc2VUZXh0dXJlLkNsYW1wVG9FZGdlXG4gICAgdGhpcy5fcmVwZWF0WSA9IEJhc2VUZXh0dXJlLkNsYW1wVG9FZGdlXG5cbiAgICB0aGlzLl9waXhlbFJhdGlvID0gMVxuICAgIHRoaXMuX2xvYWRlZCA9IGZhbHNlXG4gICAgdGhpcy5fZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKVxuXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5fbG9hZFNvdXJjZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhpcyBCYXNlVGV4dHVyZSB0byB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICovXG4gIHJlc2l6ZVRvIChkaW1lbnNpb25zKSB7XG4gICAgaWYgKHRoaXMuX2ZyYW1lLndpZHRoID09PSBkaW1lbnNpb25zLnggJiZcbiAgICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9PT0gZGltZW5zaW9ucy55KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9mcmFtZS53aWR0aCA9IGRpbWVuc2lvbnMueFxuICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9IGRpbWVuc2lvbnMueVxuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBzb3VyY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkU291cmNlICgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLl9zb3VyY2VcblxuICAgIGNvbnN0IHNvdXJjZUxvYWRlZCA9IHNvdXJjZS5jb21wbGV0ZVxuICAgIGNvbnN0IHNvdXJjZUlzQ2FudmFzID0gc291cmNlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdDYW52YXMnIHx8XG4gICAgICAoc291cmNlLnRhZ05hbWUgJiYgc291cmNlLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUycpXG4gICAgaWYgKHNvdXJjZUxvYWRlZCB8fCBzb3VyY2VJc0NhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX29uU291cmNlTG9hZGVkKClcbiAgICB9XG5cbiAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX29uU291cmNlTG9hZGVkKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNvdXJjZSBvZiB0aGlzIEJhc2VUZXh0dXJlIGhhcyBiZWVuIGxvYWRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU291cmNlTG9hZGVkICgpIHtcbiAgICB0aGlzLl9sb2FkZWQgPSB0cnVlXG4gICAgdGhpcy5fdXBkYXRlR0xGaWx0ZXJzKClcbiAgICB0aGlzLmVtaXQoJ2xvYWRlZCcpXG4gICAgdGhpcy51cGRhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIG1pcC1tYXBwaW5nIGlzIGF2YWlsYWJsZSwgdXBkYXRlIEdMIGZpbHRlcnMgYWNjb3JkaW5nbHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF91cGRhdGVHTEZpbHRlcnMgKCkge1xuICAgIGNvbnN0IHNvdXJjZURpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihcbiAgICAgIHRoaXMuX3NvdXJjZS53aWR0aCwgdGhpcy5fc291cmNlLmhlaWdodFxuICAgIClcbiAgICBpZiAoVXRpbHMuaXNQb3dlck9mVHdvKHNvdXJjZURpbWVuc2lvbnMpKSB7XG4gICAgICBMb2cuaW5mbyh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsICdNaXAtbWFwcGluZyBlbmFibGVkJylcbiAgICAgIHRoaXMuX21pbkZpbHRlciA9IEJhc2VUZXh0dXJlLlRyaWxpbmVhckZpbHRlclxuICAgICAgdGhpcy5fbWlwTWFwcGluZyA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2FjaGVkIGRpbWVuc2lvbnMgb2YgdGhpcyBCYXNlVGV4dHVyZSdzIHNvdXJjZVxuICAgKi9cbiAgdXBkYXRlICgpIHtcbiAgICB0aGlzLl9mcmFtZSA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgdGhpcy5fc291cmNlLndpZHRoLCB0aGlzLl9zb3VyY2UuaGVpZ2h0KVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXIgZm9yIHRoZSBnaXZlbiBkaXJlY3Rpb24gZnJvbSB0aGUgZ2l2ZW4gV2ViR0wgY29udGV4dFxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbWluT3JNYWdcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0R0xGaWx0ZXIgKGdsLCBtaW5Pck1hZykge1xuICAgIHN3aXRjaCAobWluT3JNYWcpIHtcbiAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmdldEdMRmlsdGVyKGdsLCB0aGlzLl9taW5GaWx0ZXIpXG4gICAgICBjYXNlICdtYWcnOlxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRHTEZpbHRlcihnbCwgdGhpcy5fbWFnRmlsdGVyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXIgZm9yIHRoZSBnaXZlbiBlbnVtIHZhbHVlIGZyb20gdGhlIGdpdmVuIFdlYkdMIGNvbnRleHRcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZpbHRlckVudW1cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc3RhdGljIGdldEdMRmlsdGVyIChnbCwgZmlsdGVyRW51bSkge1xuICAgIHN3aXRjaCAoZmlsdGVyRW51bSkge1xuICAgICAgY2FzZSBCYXNlVGV4dHVyZS5MaW5lYXJGaWx0ZXI6XG4gICAgICAgIHJldHVybiBnbC5MSU5FQVJcbiAgICAgIGNhc2UgQmFzZVRleHR1cmUuTmVhcmVzdEZpbHRlcjpcbiAgICAgICAgcmV0dXJuIGdsLk5FQVJFU1RcbiAgICAgIGNhc2UgQmFzZVRleHR1cmUuQmlsaW5lYXJGaWx0ZXI6XG4gICAgICAgIHJldHVybiBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1RcbiAgICAgIGNhc2UgQmFzZVRleHR1cmUuVHJpbGluZWFyRmlsdGVyOlxuICAgICAgICByZXR1cm4gZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgQmFzZVRleHR1cmUgaGFzIGJlZW4gbG9hZGVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0xvYWRlZCAoKSB7IHJldHVybiB0aGlzLl9sb2FkZWQgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsb2FkZWQgc3RhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBsb2FkZWRcbiAgICovXG4gIHNldExvYWRlZCAobG9hZGVkKSB7IHRoaXMuX2xvYWRlZCA9IGxvYWRlZCB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNvdXJjZVxuICAgKiBAcmV0dXJuIHsqfSBzXG4gICAqL1xuICBnZXRTb3VyY2UgKCkgeyByZXR1cm4gdGhpcy5fc291cmNlIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc291cmNlXG4gICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAqL1xuICBzZXRTb3VyY2UgKHNvdXJjZSkgeyB0aGlzLl9zb3VyY2UgPSBzb3VyY2UgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBXZWJHTCB0ZXh0dXJlIGZvciB0aGUgZ2l2ZW4gcmVuZGVyZXIgSURcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtXZWJHTFRleHR1cmV9XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXRHTFRleHR1cmVGb3JSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2xUZXh0dXJlc1tyZW5kZXJlci5pZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBXZWJHTFRleHR1cmUgZm9yIHRoZSBnaXZlbiByZW5kZXJlciBJRFxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc2V0R0xUZXh0dXJlRm9yUmVuZGVyZXIgKHRleHR1cmUsIHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXJzW3JlbmRlcmVyLmlkXSA9IHJlbmRlcmVyXG4gICAgdGhpcy5fZ2xUZXh0dXJlc1tyZW5kZXJlci5pZF0gPSB0ZXh0dXJlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhbWVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9XG4gICAqL1xuICBnZXRGcmFtZSAoKSB7IHJldHVybiB0aGlzLl9mcmFtZSB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZyYW1lXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9IGZyYW1lXG4gICAqL1xuICBzZXRGcmFtZSAoZnJhbWUpIHsgdGhpcy5fZnJhbWUgPSBmcmFtZSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0RGltZW5zaW9ucyAoKSB7IHJldHVybiBuZXcgVmVjdG9yMih0aGlzLl9mcmFtZS53aWR0aCwgdGhpcy5fZnJhbWUuaGVpZ2h0KSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpeGVsIHJhdGlvXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFBpeGVsUmF0aW8gKCkgeyByZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbyB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBpeGVsIHJhdGlvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwaXhlbFJhdGlvXG4gICAqL1xuICBzZXRQaXhlbFJhdGlvIChwaXhlbFJhdGlvKSB7IHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgV2ViR0wgdGV4dHVyZSB1bml0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldEdMVW5pdCAoKSB7IHJldHVybiB0aGlzLl9nbFVuaXQgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBXZWJHTCB0ZXh0dXJlIHVuaXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGdsVW5pdFxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc2V0R0xVbml0IChnbFVuaXQpIHsgdGhpcy5fZ2xVbml0ID0gZ2xVbml0IH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWluIGZpbHRlciB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5GaWx0ZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHNldE1pbkZpbHRlciAobWluRmlsdGVyKSB7IHRoaXMuX21pbkZpbHRlciA9IG1pbkZpbHRlciB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyB0ZXh0dXJlJ3MgbWluIGZpbHRlclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXRNaW5GaWx0ZXIgKCkgeyByZXR1cm4gdGhpcy5fbWluRmlsdGVyIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWFnIGZpbHRlciB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYWdGaWx0ZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHNldE1hZ0ZpbHRlciAobWFnRmlsdGVyKSB7IHRoaXMuX21hZ0ZpbHRlciA9IG1hZ0ZpbHRlciB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyB0ZXh0dXJlJ3MgbWFnIGZpbHRlclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXRNYWdGaWx0ZXIgKCkgeyByZXR1cm4gdGhpcy5fbWFnRmlsdGVyIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgd2F5IHRoZSB0ZXh0dXJlIGlzIHJlcGVhdGVkIG9uIHRoZSBYIGF4aXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcGVhdFxuICAgKi9cbiAgc2V0UmVwZWF0WCAocmVwZWF0KSB7IHRoaXMuX3JlcGVhdFggPSByZXBlYXQgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3YXkgdGhlIHRleHR1cmUgaXMgcmVwZWF0ZWQgb24gdGhlIFggYXhpc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRSZXBlYXRYICgpIHsgcmV0dXJuIHRoaXMuX3JlcGVhdFggfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB3YXkgdGhlIHRleHR1cmUgaXMgcmVwZWF0ZWQgb24gdGhlIFkgYXhpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwZWF0XG4gICAqL1xuICBzZXRSZXBlYXRZIChyZXBlYXQpIHsgdGhpcy5fcmVwZWF0WSA9IHJlcGVhdCB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdheSB0aGUgdGV4dHVyZSBpcyByZXBlYXRlZCBvbiB0aGUgWSBheGlzXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFJlcGVhdFkgKCkgeyByZXR1cm4gdGhpcy5fcmVwZWF0WSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvcnJlY3QgRU5VTSB2YWx1ZSBmb3IgdGhlIGdpdmVuIHJlcGVhdCBkaXJlY3Rpb25cbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRHTFJlcGVhdCAoZ2wsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHZhbHVlID0gZGlyZWN0aW9uID09PSAneCcgPyB0aGlzLmdldFJlcGVhdFgoKSA6IHRoaXMuZ2V0UmVwZWF0WSgpXG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBCYXNlVGV4dHVyZS5DbGFtcFRvRWRnZTpcbiAgICAgICAgcmV0dXJuIGdsLkNMQU1QX1RPX0VER0VcbiAgICAgIGNhc2UgQmFzZVRleHR1cmUuUmVwZWF0OlxuICAgICAgICByZXR1cm4gZ2wuUkVQRUFUXG4gICAgICBjYXNlIEJhc2VUZXh0dXJlLk1pcnJvcmVkUmVwZWF0OlxuICAgICAgICByZXR1cm4gZ2wuTUlSUk9SRURfUkVQRUFUXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGJhc2UgdGV4dHVyZSBuZWVkcyB0byBiZSB1cGRhdGVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpc0RpcnR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkaXJ0aW5lc3Mgb2YgdGhpcyBiYXNlIHRleHR1cmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBkaXJ0eVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc2V0RGlydHkgKGRpcnR5KSB7XG4gICAgdGhpcy5fZGlydHkgPSBkaXJ0eVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoZSBXZWJHTCB0ZXh0dXJlcyBmb3IgYWxsIHJlbmRlcmVyc1xuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZGlzcG9zZUdMVGV4dHVyZXMgKCkge1xuICAgIGZvciAobGV0IHJlbmRlcmVySWQgaW4gdGhpcy5fcmVuZGVyZXJzKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VHTFRleHR1cmVzRm9yUmVuZGVyZXIodGhpcy5fcmVuZGVyZXJzW3JlbmRlcmVySWRdKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGUgV2ViR0wgdGV4dHVyZXMgZm9yIHRoZSBnaXZlbiByZW5kZXJlclxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZGlzcG9zZUdMVGV4dHVyZXNGb3JSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgICBpZiAoIXRoaXMuX2dsVGV4dHVyZXNbcmVuZGVyZXIuaWRdKSByZXR1cm5cblxuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLl9nbFRleHR1cmVzW3JlbmRlcmVyLmlkXSlcbiAgICBkZWxldGUgdGhpcy5fZ2xUZXh0dXJlc1tyZW5kZXJlci5pZF1cblxuICAgIGlmICghdGhpcy5fcmVuZGVyZXJzW3JlbmRlcmVyLmlkXSkge1xuICAgICAgZGVsZXRlIHRoaXMuX3JlbmRlcmVyc1tyZW5kZXJlci5pZF1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG1pcC1tYXBwaW5nIGlzIGVuYWJsZWQgZm9yIHRoaXMgdGV4dHVyZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNNaXBNYXBwaW5nRW5hYmxlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pcE1hcHBpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGF0ZSBmb3IgbWlwIG1hcHBpbmdcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAqL1xuICBzZXRNaXBNYXBwaW5nRW5hYmxlZCAoZW5hYmxlZCkge1xuICAgIHRoaXMuX21pcE1hcHBpbmcgPSBlbmFibGVkXG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgZGlzcG9zZSAocmVuZGVyZXIgPSBudWxsKSB7XG4gICAgdGhpcy5kaXNwb3NlR0xUZXh0dXJlcygpXG4gIH1cbn1cblxuQmFzZVRleHR1cmUuTmVhcmVzdEZpbHRlciA9IDBcbkJhc2VUZXh0dXJlLkxpbmVhckZpbHRlciA9IDFcbkJhc2VUZXh0dXJlLkJpbGluZWFyRmlsdGVyID0gMlxuQmFzZVRleHR1cmUuVHJpbGluZWFyRmlsdGVyID0gM1xuXG5CYXNlVGV4dHVyZS5EZWZhdWx0TWFnRmlsdGVyID0gQmFzZVRleHR1cmUuTmVhcmVzdEZpbHRlclxuQmFzZVRleHR1cmUuRGVmYXVsdE1pbkZpbHRlciA9IEJhc2VUZXh0dXJlLkxpbmVhckZpbHRlclxuXG5CYXNlVGV4dHVyZS5DbGFtcFRvRWRnZSA9IDBcbkJhc2VUZXh0dXJlLlJlcGVhdCA9IDFcbkJhc2VUZXh0dXJlLk1pcnJvcmVkUmVwZWF0ID0gMlxuXG5CYXNlVGV4dHVyZS5pZCA9IDBcblxuZXhwb3J0IGRlZmF1bHQgQmFzZVRleHR1cmVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS90ZXh0dXJlcy9iYXNlLXRleHR1cmUuanMiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVmVjdG9yMiwgVXRpbHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IEJhc2VUZXh0dXJlIGZyb20gJy4uL3RleHR1cmVzL2Jhc2UtdGV4dHVyZSdcblxuLyoqXG4gKiBBIGNhbnZhcyByZW5kZXIgdGFyZ2V0IHRoYXQgeW91IGNhbiByZW5kZXIgdG8uXG4gKiBDYW52YXMgZXF1aXZhbGVudCBvZiB7QGxpbmsgUGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyVGFyZ2V0fVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIENhbnZhc1JlbmRlclRhcmdldCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ2FudmFzUmVuZGVyVGFyZ2V0XG4gICAqIEBwYXJhbSAge051bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBoZWlnaHRcbiAgICogQHBhcmFtICB7TnVtYmVyfSBwaXhlbFJhdGlvXG4gICAqIEBwYXJhbSAge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAod2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbywgY2FudmFzLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aFxuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodFxuICAgIHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvXG5cbiAgICB0aGlzLl9iYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZSgpXG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzIHx8IHRoaXMuX2NyZWF0ZUNhbnZhcygpXG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICB0aGlzLl9iYXNlVGV4dHVyZS5zZXRTb3VyY2UodGhpcy5fY2FudmFzKVxuXG4gICAgdGhpcy5fY2FudmFzLndpZHRoID0gdGhpcy5fd2lkdGggKiB0aGlzLl9waXhlbFJhdGlvXG4gICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IHRoaXMuX2hlaWdodCAqIHRoaXMuX3BpeGVsUmF0aW9cbiAgICB0aGlzLl9maWx0ZXJTdGFjayA9IFtcbiAgICAgIHtcbiAgICAgICAgcmVuZGVyVGFyZ2V0OiB0aGlzLFxuICAgICAgICBmaWx0ZXI6IFtdXG4gICAgICB9XG4gICAgXVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYW52YXNcbiAgICogQHJldHVybiB7Q2FudmFzfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZUNhbnZhcyAoKSB7XG4gICAgcmV0dXJuIFV0aWxzLmNyZWF0ZUNhbnZhcygpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoaXMgQ2FudmFzUmVuZGVyVGFyZ2V0XG4gICAqL1xuICBjbGVhciAoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY29udGV4dFxuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX3dpZHRoICogdGhpcy5fcGl4ZWxSYXRpbywgdGhpcy5faGVpZ2h0ICogdGhpcy5fcGl4ZWxSYXRpbylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoaXMgY2FudmFzIGJ1ZmZlciB0byB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICovXG4gIHJlc2l6ZVRvIChkaW1lbnNpb25zKSB7XG4gICAgdGhpcy5fYmFzZVRleHR1cmUucmVzaXplVG8oZGltZW5zaW9ucylcblxuICAgIGlmICh0aGlzLl93aWR0aCAhPT0gZGltZW5zaW9ucy54KSB7XG4gICAgICB0aGlzLl93aWR0aCA9IGRpbWVuc2lvbnMueFxuICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gdGhpcy5fd2lkdGggKiB0aGlzLl9waXhlbFJhdGlvXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2hlaWdodCAhPT0gZGltZW5zaW9ucy55KSB7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBkaW1lbnNpb25zLnlcbiAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQgKiB0aGlzLl9waXhlbFJhdGlvXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNhbnZhc1xuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICovXG4gIGdldENhbnZhcyAoKSB7IHJldHVybiB0aGlzLl9jYW52YXMgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGdldENvbnRleHQgKCkgeyByZXR1cm4gdGhpcy5fY29udGV4dCB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbHRlciBzdGFja1xuICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICovXG4gIGdldEZpbHRlclN0YWNrICgpIHsgcmV0dXJuIHRoaXMuX2ZpbHRlclN0YWNrIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGhcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0V2lkdGggKCkgeyByZXR1cm4gdGhpcy5fd2lkdGggfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0SGVpZ2h0ICgpIHsgcmV0dXJuIHRoaXMuX2hlaWdodCB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpeGVsIHJhdGlvXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFBpeGVsUmF0aW8gKCkgeyByZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbyB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBpeGVsIHJhdGlvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwaXhlbFJhdGlvXG4gICAqL1xuICBzZXRQaXhlbFJhdGlvIChwaXhlbFJhdGlvKSB7IHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXREaW1lbnNpb25zICgpIHsgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSB0ZXh0dXJlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlVGV4dHVyZX1cbiAgICovXG4gIGdldEJhc2VUZXh0dXJlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZVRleHR1cmVcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhpcyBjYW52YXMgYnVmZmVyXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9jYW52YXMgPSBudWxsXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNSZW5kZXJUYXJnZXRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS91dGlscy9jYW52YXMtcmVuZGVyLXRhcmdldC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nLCBVdGlscywgQ29sb3IsIFZlY3RvcjIsIE1hdHJpeCwgUmVjdGFuZ2xlLCBHTFV0aWxzIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBCYXNlVGV4dHVyZSBmcm9tICcuLi90ZXh0dXJlcy9iYXNlLXRleHR1cmUnXG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgeW91IGNhbiByZW5kZXIgdG8uIFdlYkdMIGVxdWl2YWxlbnQgb2Yge0BsaW5rIFBob3RvRWRpdG9yU0RLLkVuZ2luZS5DYW52YXNSZW5kZXJUYXJnZXR9XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBXZWJHTFJlbmRlclRhcmdldFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSAgcmVuZGVyZXJcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgd2lkdGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgaGVpZ2h0XG4gICAqIEBwYXJhbSAge051bWJlcn0gIHBpeGVsUmF0aW9cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2lzUm9vdCA9IGZhbHNlXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJlbmRlcmVyLCB3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvLCBpc1Jvb3QgPSBmYWxzZSkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXJcbiAgICB0aGlzLl9nbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIHRoaXMuX3dpZHRoID0gd2lkdGhcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHRcbiAgICB0aGlzLl9mcmFtZSA9IG51bGxcbiAgICB0aGlzLl9waXhlbFJhdGlvID0gcGl4ZWxSYXRpb1xuICAgIHRoaXMuX3Byb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4KClcbiAgICB0aGlzLl9taXBNYXBwaW5nID0gZmFsc2VcblxuICAgIHRoaXMuX2Jhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKClcbiAgICBjb25zdCBmcmFtZSA9IHRoaXMuX2Jhc2VUZXh0dXJlLmdldEZyYW1lKClcbiAgICBmcmFtZS53aWR0aCA9IHdpZHRoXG4gICAgZnJhbWUuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgdGhpcy5fYmFzZVRleHR1cmUuc2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKVxuICAgIHRoaXMuX2Jhc2VUZXh0dXJlLnNldExvYWRlZCh0cnVlKVxuXG4gICAgLy8gYG51bGxgIG1lYW5zIHJlbmRlciB0byBjYW52YXMgZGlyZWN0bHlcbiAgICB0aGlzLl9mcmFtZWJ1ZmZlciA9IG51bGxcbiAgICB0aGlzLl9pc1Jvb3QgPSBpc1Jvb3RcbiAgICB0aGlzLl9maWx0ZXJTdGFjayA9IFtcbiAgICAgIHtcbiAgICAgICAgcmVuZGVyVGFyZ2V0OiB0aGlzLFxuICAgICAgICBmaWx0ZXI6IFtdXG4gICAgICB9XG4gICAgXVxuXG4gICAgaWYgKCFpc1Jvb3QpIHtcbiAgICAgIHRoaXMuX2luaXRGcmFtZUJ1ZmZlcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhpcyBXZWJHTFJlbmRlclRhcmdldCB0byB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICovXG4gIHJlc2l6ZVRvIChkaW1lbnNpb25zKSB7XG4gICAgdGhpcy5fd2lkdGggPSBkaW1lbnNpb25zLnggfCAwIC8vIHJvdW5kZWRcbiAgICB0aGlzLl9oZWlnaHQgPSBkaW1lbnNpb25zLnkgfCAwIC8vIHJvdW5kZWRcblxuICAgIHRoaXMuX2Jhc2VUZXh0dXJlLnJlc2l6ZVRvKGRpbWVuc2lvbnMpXG5cbiAgICBpZiAoIXRoaXMuX2lzUm9vdCkge1xuICAgICAgdGhpcy5fcmVzaXplVGV4dHVyZSgpXG4gICAgfVxuXG4gICAgdGhpcy5fYmFzZVRleHR1cmUuc2V0TWluRmlsdGVyKHRoaXMuX2dldE1pbkZpbHRlcigpKVxuICAgIHRoaXMuX2Jhc2VUZXh0dXJlLnNldE1hZ0ZpbHRlcih0aGlzLl9nZXRNYWdGaWx0ZXIoKSlcblxuICAgIHRoaXMuX2NhbGN1bGF0ZVByb2plY3Rpb25NYXRyaXgoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRvd25zYW1wbGluZyBmaWx0ZXJcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE1pbkZpbHRlciAoKSB7XG4gICAgbGV0IG1pbkZpbHRlciA9IEJhc2VUZXh0dXJlLkRlZmF1bHRNaW5GaWx0ZXJcbiAgICBpZiAodGhpcy5fbWlwTWFwcGluZykge1xuICAgICAgbWluRmlsdGVyID0gQmFzZVRleHR1cmUuVHJpbGluZWFyRmlsdGVyXG4gICAgfVxuICAgIHJldHVybiBtaW5GaWx0ZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1cHNhbXBsaW5nIGZpbHRlclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TWFnRmlsdGVyICgpIHtcbiAgICByZXR1cm4gQmFzZVRleHR1cmUuRGVmYXVsdE1hZ0ZpbHRlclxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIEZCTydzIHRleHR1cmUgdG8gdGhlIGN1cnJlbnQgZGltZW5zaW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2l6ZVRleHR1cmUgKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2xcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKVxuXG4gICAgY29uc3QgcmVhbFdpZHRoID0gdGhpcy5fd2lkdGggKiB0aGlzLl9waXhlbFJhdGlvXG4gICAgY29uc3QgcmVhbEhlaWdodCA9IHRoaXMuX2hlaWdodCAqIHRoaXMuX3BpeGVsUmF0aW9cbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsXG4gICAgICByZWFsV2lkdGgsIHJlYWxIZWlnaHQsXG4gICAgICAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKVxuXG4gICAgY29uc3QgZGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpXG4gICAgaWYgKFV0aWxzLmlzUG93ZXJPZlR3byhkaW1lbnNpb25zKSkge1xuICAgICAgTG9nLmluZm8oJ1dlYkdMUmVuZGVyVGFyZ2V0JywgJ01pcC1tYXBwaW5nIGVuYWJsZWQnKVxuICAgICAgdGhpcy5fbWlwTWFwcGluZyA9IHRydWVcbiAgICB9XG5cbiAgICB0aGlzLl9iYXNlVGV4dHVyZS5zZXRNaXBNYXBwaW5nRW5hYmxlZCh0aGlzLl9taXBNYXBwaW5nKVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIHRoZSBmcmFtZWJ1ZmZlciBhbmQgcmVzaXplcyB0aGUgdmlld3BvcnRcbiAgICovXG4gIGFjdGl2YXRlICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9mcmFtZWJ1ZmZlcilcblxuICAgIHRoaXMuX2NhbGN1bGF0ZVByb2plY3Rpb25NYXRyaXgoKVxuXG4gICAgZ2wudmlld3BvcnQoMCxcbiAgICAgIDAsXG4gICAgICB0aGlzLl93aWR0aCAqIHRoaXMuX3BpeGVsUmF0aW8sXG4gICAgICB0aGlzLl9oZWlnaHQgKiB0aGlzLl9waXhlbFJhdGlvKVxuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgZnJhbWVidWZmZXJcbiAgICovXG4gIGNsZWFyIChjb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbFxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVidWZmZXIpXG5cbiAgICBHTFV0aWxzLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoJ1dlYkdMUmVuZGVyVGFyZ2V0I2NsZWFyJywgZ2wpXG5cbiAgICBnbC5jbGVhckNvbG9yLmFwcGx5KGdsLCBjb2xvci50b0dMQ29sb3IoKSlcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHByb2plY3Rpb24gbWF0cml4IGZvciB0aGlzIHJlbmRlciB0YXJnZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWxjdWxhdGVQcm9qZWN0aW9uTWF0cml4ICgpIHtcbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5fcHJvamVjdGlvbk1hdHJpeFxuICAgIHByb2plY3Rpb25NYXRyaXgucmVzZXQoKVxuXG4gICAgY29uc3QgZnJhbWUgPSB0aGlzLl9mcmFtZSB8fCBuZXcgUmVjdGFuZ2xlKDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpXG5cbiAgICBjb25zdCB7IHgsIHkgfSA9IGZyYW1lXG4gICAgaWYgKCF0aGlzLl9pc1Jvb3QpIHtcbiAgICAgIHByb2plY3Rpb25NYXRyaXguYSA9IDEgLyB0aGlzLl93aWR0aCAqIDJcbiAgICAgIHByb2plY3Rpb25NYXRyaXguZCA9IDEgLyB0aGlzLl9oZWlnaHQgKiAyXG5cbiAgICAgIHByb2plY3Rpb25NYXRyaXgudHggPSAtMSAtIHggKiBwcm9qZWN0aW9uTWF0cml4LmFcbiAgICAgIHByb2plY3Rpb25NYXRyaXgudHkgPSAtMSAtIHkgKiBwcm9qZWN0aW9uTWF0cml4LmRcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvamVjdGlvbk1hdHJpeC5hID0gMSAvIHRoaXMuX3dpZHRoICogMlxuICAgICAgcHJvamVjdGlvbk1hdHJpeC5kID0gLTEgLyB0aGlzLl9oZWlnaHQgKiAyXG5cbiAgICAgIHByb2plY3Rpb25NYXRyaXgudHggPSAtMSAtIHggKiBwcm9qZWN0aW9uTWF0cml4LmFcbiAgICAgIHByb2plY3Rpb25NYXRyaXgudHkgPSAxIC0geSAqIHByb2plY3Rpb25NYXRyaXguZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgV2ViR0wgRkJPIGFuZCBUZXh0dXJlIGZvciB0aGlzIFdlYkdMUmVuZGVyVGFyZ2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdEZyYW1lQnVmZmVyICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsXG5cbiAgICAvLyBJbml0IHRoZSBGQk9cbiAgICB0aGlzLl9mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKClcblxuICAgIC8vIENyZWF0ZSB0aGUgdGV4dHVyZVxuICAgIHRoaXMuX3RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKVxuXG4gICAgLy8gQmluZCB0ZXh0dXJlIHRvIEZCT1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVidWZmZXIpXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlLCAwKVxuXG4gICAgdGhpcy5fYmFzZVRleHR1cmUuc2V0R0xUZXh0dXJlRm9yUmVuZGVyZXIodGhpcy5fdGV4dHVyZSwgdGhpcy5fcmVuZGVyZXIpXG4gICAgdGhpcy5yZXNpemVUbyhuZXcgVmVjdG9yMih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KSlcblxuICAgIEdMVXRpbHMuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cygnV2ViR0xSZW5kZXJUYXJnZXQjX2luaXRGcmFtZWJ1ZmZlcicsIGdsKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb2plY3Rpb24gbWF0cml4XG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguTWF0cml4fVxuICAgKi9cbiAgZ2V0UHJvamVjdGlvbk1hdHJpeCAoKSB7IHJldHVybiB0aGlzLl9wcm9qZWN0aW9uTWF0cml4IH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dHVyZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX1cbiAgICovXG4gIGdldFRleHR1cmUgKCkgeyByZXR1cm4gdGhpcy5fdGV4dHVyZSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYW1lXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfVxuICAgKi9cbiAgZ2V0RnJhbWUgKCkgeyByZXR1cm4gdGhpcy5fZnJhbWUgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmcmFtZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfSBmcmFtZVxuICAgKi9cbiAgc2V0RnJhbWUgKGZyYW1lKSB7IHRoaXMuX2ZyYW1lID0gZnJhbWUgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXIgc3RhY2tcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRGaWx0ZXJTdGFjayAoKSB7IHJldHVybiB0aGlzLl9maWx0ZXJTdGFjayB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGl4ZWwgcmF0aW9cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyAoKSB7IHJldHVybiB0aGlzLl9waXhlbFJhdGlvIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGl4ZWwgcmF0aW9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBpeGVsUmF0aW9cbiAgICovXG4gIHNldFBpeGVsUmF0aW8gKHBpeGVsUmF0aW8pIHtcbiAgICB0aGlzLl9waXhlbFJhdGlvID0gcGl4ZWxSYXRpb1xuXG4gICAgaWYgKCF0aGlzLl9pc1Jvb3QpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZVRleHR1cmUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYXNlIHRleHR1cmVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VUZXh0dXJlfVxuICAgKi9cbiAgZ2V0QmFzZVRleHR1cmUgKCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlVGV4dHVyZVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgV2ViR0xSZW5kZXJUYXJnZXRcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2xcbiAgICB0aGlzLl9iYXNlVGV4dHVyZS5kaXNwb3NlR0xUZXh0dXJlc0ZvclJlbmRlcmVyKHRoaXMuX3JlbmRlcmVyKVxuICAgIGdsLmRlbGV0ZVRleHR1cmUodGhpcy5fdGV4dHVyZSlcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLl9mcmFtZWJ1ZmZlcilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJHTFJlbmRlclRhcmdldFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL3V0aWxzL3dlYmdsLXJlbmRlci10YXJnZXQuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBDb2xvciBmcm9tICcuLi9jb2xvcidcblxuLypcbiAqIFsgYSwgYiwgYywgZCwgZSxcbiAqICAgZiwgZywgaCwgaSwgaixcbiAqICAgaywgbCwgbSwgbiwgbyxcbiAqICAgcCwgcSwgciwgcywgdCBdXG4gKlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIDQgYnkgNSBtYXRyaXggdGhhdCBpcyB1c2VkIHRvIHByZWZvcm0gY29sb3IgbWFuaXB1bGF0aW9ucy5cbiAqIFRoZSBtZW1iZXJzIGFyZSBuYW1lcyBhLCBiLCBjLC4uLHQuIFRoZSB2ZWN0b3IgZm9ybWVkIGJ5IGUsIGosIG8sIHRcbiAqIHJlcHJlc2VudHMgdGhlIG9mZnNldC5cbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk1hdGhcbiAqL1xuY2xhc3MgQ29sb3JNYXRyaXgge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29sb3IgbWF0cml4LCBhbmQgZGVmYXVsdHMgdGhlIHZhbHVlcyB0byB0aGUgaWRlbnRpdHkuXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguQ29sb3JNYXRyaXh9XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYSA9IDEsIGIgPSAwLCBjID0gMCwgZCA9IDAsIGUgPSAwLCBmID0gMCwgZyA9IDEsIGggPSAwLCBpID0gMCwgaiA9IDAsIGsgPSAwLCBsID0gMCwgbSA9IDEsIG4gPSAwLCBvID0gMCwgcCA9IDAsIHEgPSAwLCByID0gMCwgcyA9IDEsIHQgPSAwKSB7XG4gICAgdGhpcy5zZXQoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbywgcCwgcSwgciwgcywgdClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIGNvbG9yIG1hdHJpeC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBhXG4gICAqIEBwYXJhbSAge251bWJlcn0gYlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkXG4gICAqIEBwYXJhbSAge251bWJlcn0gZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGZcbiAgICogQHBhcmFtICB7bnVtYmVyfSBnXG4gICAqIEBwYXJhbSAge251bWJlcn0gaFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAgICogQHBhcmFtICB7bnVtYmVyfSBqXG4gICAqIEBwYXJhbSAge251bWJlcn0ga1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGxcbiAgICogQHBhcmFtICB7bnVtYmVyfSBtXG4gICAqIEBwYXJhbSAge251bWJlcn0gblxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IG9cbiAgICogQHBhcmFtICB7bnVtYmVyfSBwXG4gICAqIEBwYXJhbSAge251bWJlcn0gcVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzXG4gICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLkNvbG9yTWF0cml4fVxuICAgKi9cbiAgc2V0IChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvLCBwLCBxLCByLCBzLCB0KSB7XG4gICAgdGhpcy5hID0gYVxuICAgIHRoaXMuYiA9IGJcbiAgICB0aGlzLmMgPSBjXG4gICAgdGhpcy5kID0gZFxuICAgIHRoaXMuZSA9IGVcbiAgICB0aGlzLmYgPSBmXG4gICAgdGhpcy5nID0gZ1xuICAgIHRoaXMuaCA9IGhcbiAgICB0aGlzLmkgPSBpXG4gICAgdGhpcy5qID0galxuICAgIHRoaXMuayA9IGtcbiAgICB0aGlzLmwgPSBsXG4gICAgdGhpcy5tID0gbVxuICAgIHRoaXMubiA9IG5cbiAgICB0aGlzLm8gPSBvXG4gICAgdGhpcy5wID0gcFxuICAgIHRoaXMucSA9IHFcbiAgICB0aGlzLnIgPSByXG4gICAgdGhpcy5zID0gc1xuICAgIHRoaXMudCA9IHRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGlkZW50aXR5IGNvbG9yIG1hdHJpeC5cbiAgICogQHJldHVybiB7Q29sb3JNYXRyaXh9XG4gICAqL1xuICByZXNldCAoKSB7XG4gICAgdGhpcy5hID0gMVxuICAgIHRoaXMuYiA9IDBcbiAgICB0aGlzLmMgPSAwXG4gICAgdGhpcy5kID0gMFxuICAgIHRoaXMuZSA9IDBcblxuICAgIHRoaXMuZiA9IDBcbiAgICB0aGlzLmcgPSAxXG4gICAgdGhpcy5oID0gMFxuICAgIHRoaXMuaSA9IDBcbiAgICB0aGlzLmogPSAwXG5cbiAgICB0aGlzLmsgPSAwXG4gICAgdGhpcy5sID0gMFxuICAgIHRoaXMubSA9IDFcbiAgICB0aGlzLm4gPSAwXG4gICAgdGhpcy5vID0gMFxuXG4gICAgdGhpcy5wID0gMFxuICAgIHRoaXMucSA9IDBcbiAgICB0aGlzLnIgPSAwXG4gICAgdGhpcy5zID0gMVxuICAgIHRoaXMudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb2xvciBtYXRyaXggdG8gdGhlIGdpdmVuIGNvbG9yLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIGNvbG9yLlxuICAgKiBAcGFyYW0gIHtDb2xvcn0gY29sb3JcbiAgICogQHJldHVybiB7Q29sb3J9XG4gICAqL1xuICBhcHBseSAoY29sb3IpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIG11bHRpcGx5IHRoZSB0cmFuc2xhdGlvbiBieSAyNTUgc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBtYXRyaXggZm9yIGNhbnZhcyBhbmQgZ2wuXG4gICAgbGV0IHIgPSB0aGlzLmEgKiBjb2xvci5yICsgdGhpcy5iICogY29sb3IuZyArIHRoaXMuYyAqIGNvbG9yLmIgKyB0aGlzLmQgKiBjb2xvci5hICsgdGhpcy5lICogMjU1LjBcbiAgICBsZXQgZyA9IHRoaXMuZiAqIGNvbG9yLnIgKyB0aGlzLmcgKiBjb2xvci5nICsgdGhpcy5oICogY29sb3IuYiArIHRoaXMuaSAqIGNvbG9yLmEgKyB0aGlzLmogKiAyNTUuMFxuICAgIGxldCBiID0gdGhpcy5rICogY29sb3IuciArIHRoaXMubCAqIGNvbG9yLmcgKyB0aGlzLm0gKiBjb2xvci5iICsgdGhpcy5uICogY29sb3IuYSArIHRoaXMubyAqIDI1NS4wXG4gICAgbGV0IGEgPSB0aGlzLnAgKiBjb2xvci5yICsgdGhpcy5xICogY29sb3IuZyArIHRoaXMuciAqIGNvbG9yLmIgKyB0aGlzLnMgKiBjb2xvci5hICsgdGhpcy50ICogMjU1LjBcbiAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpXG4gIH1cblxuICAvKipcbiAgKiBNdWx0aXBsaWVzIHRoZSBnaXZlbiBtYXRyaXggd2l0aCB0aGlzIG1hdHJpeC5cbiAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLkNvbG9yTWF0cml4fSBtYXRyaXhcbiAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLkNvbG9yTWF0cml4fVxuICAqL1xuICBtdWx0aXBseSAobWF0cml4KSB7XG4gICAgbGV0IGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4sIG8sIHAsIHEsIHIsIHMsIHRcbiAgICAvLyBzdG9yZSBib3RoIGZhY3RvcnMsIHNvIHdlIGNhbiBzd2FwIHRoZW0gZWFzaWx5XG4gICAgbGV0IEEgPSBtYXRyaXhcbiAgICBsZXQgQiA9IHRoaXNcblxuICAgIC8vIHRyYW5zZm9ybWF0aW9uXG4gICAgYSA9IEEuYSAqIEIuYSArIEEuYiAqIEIuZiArIEEuYyAqIEIuayArIEEuZCAqIEIucFxuICAgIGIgPSBBLmEgKiBCLmIgKyBBLmIgKiBCLmcgKyBBLmMgKiBCLmwgKyBBLmQgKiBCLnFcbiAgICBjID0gQS5hICogQi5jICsgQS5iICogQi5oICsgQS5jICogQi5tICsgQS5kICogQi5yXG4gICAgZCA9IEEuYSAqIEIuZCArIEEuYiAqIEIuaSArIEEuYyAqIEIubiArIEEuZCAqIEIuc1xuXG4gICAgZiA9IEEuZiAqIEIuYSArIEEuZyAqIEIuZiArIEEuaCAqIEIuayArIEEuaSAqIEIucFxuICAgIGcgPSBBLmYgKiBCLmIgKyBBLmcgKiBCLmcgKyBBLmggKiBCLmwgKyBBLmkgKiBCLnFcbiAgICBoID0gQS5mICogQi5jICsgQS5nICogQi5oICsgQS5oICogQi5tICsgQS5pICogQi5yXG4gICAgaSA9IEEuZiAqIEIuZCArIEEuZyAqIEIuaSArIEEuaCAqIEIubiArIEEuaSAqIEIuc1xuXG4gICAgayA9IEEuayAqIEIuYSArIEEubCAqIEIuZiArIEEubSAqIEIuayArIEEubiAqIEIucFxuICAgIGwgPSBBLmsgKiBCLmIgKyBBLmwgKiBCLmcgKyBBLm0gKiBCLmwgKyBBLm4gKiBCLnFcbiAgICBtID0gQS5rICogQi5jICsgQS5sICogQi5oICsgQS5tICogQi5tICsgQS5uICogQi5yXG4gICAgbiA9IEEuayAqIEIuZCArIEEubCAqIEIuaSArIEEubSAqIEIubiArIEEubiAqIEIuc1xuXG4gICAgcCA9IEEucCAqIEIuYSArIEEucSAqIEIuZiArIEEuciAqIEIuayArIEEucyAqIEIucFxuICAgIHEgPSBBLnAgKiBCLmIgKyBBLnEgKiBCLmcgKyBBLnIgKiBCLmwgKyBBLnMgKiBCLnFcbiAgICByID0gQS5wICogQi5jICsgQS5xICogQi5oICsgQS5yICogQi5tICsgQS5zICogQi5yXG4gICAgcyA9IEEucCAqIEIuZCArIEEucSAqIEIuaSArIEEuciAqIEIubiArIEEucyAqIEIuc1xuXG4gICAgLy8gdHJhbnNsYXRpb25cbiAgICBlID0gQS5hICogQi5lICsgQS5iICogQi5qICsgQS5jICogQi5vICsgQS5kICogQi50ICsgQS5lXG4gICAgaiA9IEEuZiAqIEIuZSArIEEuZyAqIEIuaiArIEEuaCAqIEIubyArIEEuaSAqIEIudCArIEEualxuICAgIG8gPSBBLmsgKiBCLmUgKyBBLmwgKiBCLmogKyBBLm0gKiBCLm8gKyBBLm4gKiBCLnQgKyBBLm9cbiAgICB0ID0gQS5wICogQi5lICsgQS5xICogQi5qICsgQS5yICogQi5vICsgQS5zICogQi50ICsgQS50XG5cbiAgICB0aGlzLmEgPSBhXG4gICAgdGhpcy5iID0gYlxuICAgIHRoaXMuYyA9IGNcbiAgICB0aGlzLmQgPSBkXG4gICAgdGhpcy5lID0gZVxuICAgIHRoaXMuZiA9IGZcbiAgICB0aGlzLmcgPSBnXG4gICAgdGhpcy5oID0gaFxuICAgIHRoaXMuaSA9IGlcbiAgICB0aGlzLmogPSBqXG4gICAgdGhpcy5rID0ga1xuICAgIHRoaXMubCA9IGxcbiAgICB0aGlzLm0gPSBtXG4gICAgdGhpcy5uID0gblxuICAgIHRoaXMubyA9IG9cbiAgICB0aGlzLnAgPSBwXG4gICAgdGhpcy5xID0gcVxuICAgIHRoaXMuciA9IHJcbiAgICB0aGlzLnMgPSBzXG4gICAgdGhpcy50ID0gdFxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1bnMgYSBjbG9uZSBvZiB0aGUgY3VycmVudCBtYXRyaXgvXG4gICAqIEByZXR1cm4ge0NvbG9yTWF0cml4fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGxldCBtYXRyaXggPSBuZXcgQ29sb3JNYXRyaXgoKVxuICAgIG1hdHJpeC5zZXQodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLFxuICAgICAgdGhpcy5lLCB0aGlzLmYsIHRoaXMuZywgdGhpcy5oLCB0aGlzLmksXG4gICAgICB0aGlzLmosIHRoaXMuaywgdGhpcy5sLCB0aGlzLm0sIHRoaXMubixcbiAgICAgIHRoaXMubywgdGhpcy5wLCB0aGlzLnEsIHRoaXMuciwgdGhpcy5zLCB0aGlzLnQpXG4gICAgcmV0dXJuIG1hdHJpeFxuICB9XG5cbiAgZXF1YWxzIChtYXRyaXgpIHtcbiAgICByZXR1cm4gKHRoaXMuYSA9PT0gbWF0cml4LmEpICYmXG4gICAgICAodGhpcy5iID09PSBtYXRyaXguYikgJiZcbiAgICAgICh0aGlzLmMgPT09IG1hdHJpeC5jKSAmJlxuICAgICAgKHRoaXMuZCA9PT0gbWF0cml4LmQpICYmXG4gICAgICAodGhpcy5lID09PSBtYXRyaXguZSkgJiZcbiAgICAgICh0aGlzLmYgPT09IG1hdHJpeC5mKSAmJlxuICAgICAgKHRoaXMuZyA9PT0gbWF0cml4LmcpICYmXG4gICAgICAodGhpcy5oID09PSBtYXRyaXguaCkgJiZcbiAgICAgICh0aGlzLmkgPT09IG1hdHJpeC5pKSAmJlxuICAgICAgKHRoaXMuaiA9PT0gbWF0cml4LmopICYmXG4gICAgICAodGhpcy5rID09PSBtYXRyaXguaykgJiZcbiAgICAgICh0aGlzLmwgPT09IG1hdHJpeC5sKSAmJlxuICAgICAgKHRoaXMubSA9PT0gbWF0cml4Lm0pICYmXG4gICAgICAodGhpcy5uID09PSBtYXRyaXgubikgJiZcbiAgICAgICh0aGlzLm8gPT09IG1hdHJpeC5vKSAmJlxuICAgICAgKHRoaXMucCA9PT0gbWF0cml4LnApICYmXG4gICAgICAodGhpcy5xID09PSBtYXRyaXgucSkgJiZcbiAgICAgICh0aGlzLnIgPT09IG1hdHJpeC5yKSAmJlxuICAgICAgKHRoaXMucyA9PT0gbWF0cml4LnMpICYmXG4gICAgICAodGhpcy50ID09PSBtYXRyaXgudClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29sb3IgbWF0cml4XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gYENvbG9yTWF0cml4KCAke3RoaXMuYX0sICR7dGhpcy5ifSwgJHt0aGlzLmN9LCAke3RoaXMuZH0sICR7dGhpcy5lfSxcbiAgICAgICR7dGhpcy5mfSwgJHt0aGlzLmd9LCAke3RoaXMuaH0sICR7dGhpcy5pfSwgJHt0aGlzLmp9LFxuICAgICAgJHt0aGlzLmt9LCAke3RoaXMubH0sICR7dGhpcy5tfSwgJHt0aGlzLm59LCAke3RoaXMub30sXG4gICAgICAke3RoaXMucH0sICR7dGhpcy5xfSwgJHt0aGlzLnJ9LCAke3RoaXMuc30sICR7dGhpcy50fSApYFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJbXX1cbiAgICovXG4gIHRvQXJyYXkgKCkge1xuICAgIHJldHVybiAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5tYXAoKHYpID0+IHRoaXNbdl0pXG4gIH1cblxuICAvKipcbiAgICogVGhlIGlkZW50aXR5IG1hdHJpeFxuICAgKiBAc3RhdGljXG4gICAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5NYXRoLk1hdHJpeH1cbiAgICovXG4gIHN0YXRpYyBnZXQgSURFTlRJVFkgKCkgeyByZXR1cm4gbmV3IENvbG9yTWF0cml4KCkgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29sb3IgbWF0cml4IHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBicmlnaHRuZXNzLlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQnJpZ2h0bmVzc01hdHJpeCAoYnJpZ2h0bmVzcykge1xuICAgIGxldCBtYXRyaXggPSBuZXcgQ29sb3JNYXRyaXgoKVxuICAgIG1hdHJpeC5lID0gYnJpZ2h0bmVzc1xuICAgIG1hdHJpeC5qID0gYnJpZ2h0bmVzc1xuICAgIG1hdHJpeC5vID0gYnJpZ2h0bmVzc1xuICAgIHJldHVybiBtYXRyaXhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29sb3IgbWF0cml4IHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBjb250cmFzdC5cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3RcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVDb250cmFzdE1hdHJpeCAoY29udHJhc3QpIHtcbiAgICBsZXQgbWF0cml4ID0gbmV3IENvbG9yTWF0cml4KClcbiAgICBsZXQgdCA9ICgxLjAgLSBjb250cmFzdCkgLyAyLjBcbiAgICBtYXRyaXguYSA9IG1hdHJpeC5nID0gbWF0cml4Lm0gPSBjb250cmFzdFxuICAgIG1hdHJpeC5lID0gbWF0cml4LmogPSBtYXRyaXgubyA9IHRcbiAgICByZXR1cm4gbWF0cml4XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvbG9yIG1hdHJpeCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgc2F0dXJhdGlvbi5cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVNhdHVyYXRpb25NYXRyaXggKHNhdHVyYXRpb24gPSAxLjApIHtcbiAgICBsZXQgbWF0cml4ID0gbmV3IENvbG9yTWF0cml4KClcbiAgICBsZXQgaW52U2F0ID0gMSAtIHNhdHVyYXRpb25cbiAgICBsZXQgciA9IDAuMjEzICogaW52U2F0XG4gICAgbGV0IGcgPSAwLjcxNSAqIGludlNhdFxuICAgIGxldCBiID0gMC4wNzIgKiBpbnZTYXRcblxuICAgIC8vIGZpcnN0IHJvd1xuICAgIG1hdHJpeC5hID0gciArIHNhdHVyYXRpb25cbiAgICBtYXRyaXguYiA9IGdcbiAgICBtYXRyaXguYyA9IGJcbiAgICAvLyBzZWNvbmQgcm93XG4gICAgbWF0cml4LmYgPSByXG4gICAgbWF0cml4LmcgPSBnICsgc2F0dXJhdGlvblxuICAgIG1hdHJpeC5oID0gYlxuICAgIC8vIHRoaXJkIHJvd1xuICAgIG1hdHJpeC5rID0gclxuICAgIG1hdHJpeC5sID0gZ1xuICAgIG1hdHJpeC5tID0gYiArIHNhdHVyYXRpb25cbiAgICByZXR1cm4gbWF0cml4XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvbG9yIG1hdHJpeCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFwcGx5IGxpbmVhciBjaGFuZ2VzLlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzbG9wZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJjZXB0XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlTGluZWFyTWF0cml4IChzbG9wZSA9IDEuMCwgaW50ZXJjZXB0ID0gMC4wKSB7XG4gICAgbGV0IG1hdHJpeCA9IG5ldyBDb2xvck1hdHJpeCgpXG4gICAgbWF0cml4LmEgPSBtYXRyaXguZyA9IG1hdHJpeC5tID0gc2xvcGVcbiAgICBtYXRyaXguZSA9IG1hdHJpeC5qID0gbWF0cml4Lm8gPSBpbnRlcmNlcHRcbiAgICByZXR1cm4gbWF0cml4XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sb3JNYXRyaXhcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9tYXRoL2NvbG9yLW1hdHJpeC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvbWlzZSwgVmVjdG9yMiwgRW5naW5lLCBVdGlscywgQ29uZmlndXJhYmxlLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuY29uc3QgeyBSZW5kZXJlclR5cGUgfSA9IENvbnN0YW50c1xuXG5jbGFzcyBTcHJpdGUgZXh0ZW5kcyBDb25maWd1cmFibGUge1xuICBjb25zdHJ1Y3RvciAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgICB0aGlzLl9vcGVyYXRpb24gPSBvcGVyYXRpb25cbiAgICB0aGlzLl9kaXJ0aW5lc3MgPSB7fVxuICAgIHRoaXMuaWQgPSBVdGlscy5nZXRVVUlEKClcblxuICAgIHRoaXMuX3JlbmRlclRleHR1cmVzID0ge31cbiAgICB0aGlzLl9pZGVudGl0eVNwcml0ZSA9IG5ldyBFbmdpbmUuU3ByaXRlKClcbiAgICB0aGlzLl9zcHJpdGUgPSBuZXcgRW5naW5lLlNwcml0ZSgpXG4gICAgdGhpcy5fcmVuZGVyZXJzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgcm90YXRpb24gd2l0aCB0aGUgZ2l2ZW4gZGVncmVlc1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZXNcbiAgICovXG4gIGFwcGx5Um90YXRpb24gKGRlZ3JlZXMpIHtcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSB0aGlzLl9vcGVyYXRpb24uZ2V0SW5wdXREaW1lbnNpb25zKClcblxuICAgIC8vIFVwZGF0ZSBzcHJpdGUgcm90YXRpb25cbiAgICBsZXQgc3ByaXRlRGVncmVlcyA9IHRoaXMuZ2V0Um90YXRpb24oKSAqIDE4MCAvIE1hdGguUElcbiAgICBzcHJpdGVEZWdyZWVzICs9IGRlZ3JlZXNcbiAgICB0aGlzLnNldFJvdGF0aW9uKHNwcml0ZURlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwKVxuXG4gICAgY29uc3QgYWN0dWFsRGVncmVlcyA9IChkZWdyZWVzICsgMzYwKSAlIDM2MFxuICAgIGNvbnN0IHJhZGlhbnMgPSBhY3R1YWxEZWdyZWVzICogTWF0aC5QSSAvIDE4MFxuXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MocmFkaWFucylcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKVxuXG4gICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb24uY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KDAuNSlcbiAgICAgIC5tdWx0aXBseShpbnB1dERpbWVuc2lvbnMpXG5cbiAgICBjb25zdCBuZXdSZWxhdGl2ZVBvc2l0aW9uID0gbmV3IFZlY3RvcjIoXG4gICAgICByZWxhdGl2ZVBvc2l0aW9uLnggKiBjb3MgLSByZWxhdGl2ZVBvc2l0aW9uLnkgKiBzaW4sXG4gICAgICByZWxhdGl2ZVBvc2l0aW9uLnggKiBzaW4gKyByZWxhdGl2ZVBvc2l0aW9uLnkgKiBjb3NcbiAgICApLmRpdmlkZShpbnB1dERpbWVuc2lvbnMuY2xvbmUoKS5mbGlwKCkpXG5cbiAgICB0aGlzLnNldFBvc2l0aW9uKG5ldyBWZWN0b3IyKDAuNSwgMC41KS5hZGQobmV3UmVsYXRpdmVQb3NpdGlvbikpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBhIGZsaXAgaW4gdGhlIGdpdmVuIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKi9cbiAgYXBwbHlGbGlwIChkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oKS5jbG9uZSgpXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICBwb3NpdGlvbi54ID0gMSAtIHRoaXMuX29wdGlvbnMucG9zaXRpb24ueFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICBwb3NpdGlvbi55ID0gMSAtIHRoaXMuX29wdGlvbnMucG9zaXRpb24ueVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBhIGNyb3Agd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkNyb3BPcGVyYXRpb259IGNyb3BPcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBhcHBseUNyb3AgKGNyb3BPcGVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSBjcm9wT3BlcmF0aW9uLmdldElucHV0RGltZW5zaW9ucygpXG4gICAgY29uc3Qgcm90YXRpb25EZWx0YSA9IChvcHRpb25zLnJvdGF0aW9uIC0gY3JvcE9wZXJhdGlvbi5nZXRSb3RhdGlvbigpKVxuXG4gICAgY29uc3Qgb2xkQWJzb2x1dGVTaXplID0gY3JvcE9wZXJhdGlvbi5nZXRFbmQoKS5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QoY3JvcE9wZXJhdGlvbi5nZXRTdGFydCgpKVxuICAgICAgLm11bHRpcGx5KGlucHV0RGltZW5zaW9ucylcbiAgICBjb25zdCBuZXdBYnNvbHV0ZVNpemUgPSBvcHRpb25zLmVuZC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3Qob3B0aW9ucy5zdGFydClcbiAgICAgIC5tdWx0aXBseShpbnB1dERpbWVuc2lvbnMpXG4gICAgY29uc3QgYWJzb2x1dGVTdGFydERpZmYgPSBjcm9wT3BlcmF0aW9uLmdldFN0YXJ0KCkuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KG9wdGlvbnMuc3RhcnQpXG4gICAgICAubXVsdGlwbHkoaW5wdXREaW1lbnNpb25zKVxuICAgIGNvbnN0IHNjYWxlUmF0aW8gPSBvcHRpb25zLnNjYWxlIC8gY3JvcE9wZXJhdGlvbi5nZXRTY2FsZSgpXG4gICAgY29uc3QgYWJzb2x1dGVTdGFydCA9IGNyb3BPcGVyYXRpb24uZ2V0U3RhcnQoKS5jbG9uZSgpLm11bHRpcGx5KGlucHV0RGltZW5zaW9ucylcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb24gaW5wdXQgaW1hZ2VcbiAgICBjb25zdCBhYnNvbHV0ZVBvc2l0aW9uT25JbWFnZSA9IHRoaXMuZ2V0UG9zaXRpb24oKS5jbG9uZSgpXG4gICAgICAubXVsdGlwbHkob2xkQWJzb2x1dGVTaXplKSAvLyBDb21wZW5zYXRlIGNyb3Agc2l6ZVxuICAgICAgLmFkZChhYnNvbHV0ZVN0YXJ0KSAvLyBDb21wZW5zYXRlIGNyb3Agc3RhcnQgLyBvZmZzZXRcblxuICAgIC8vIFJlcG9zaXRpb24gc3ByaXRlXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gaW5wdXQgaW1hZ2UncyBjZW50ZXIgKGluIHBpeGVscylcbiAgICBjb25zdCBkZWx0YVRvQ2VudGVyID0gYWJzb2x1dGVQb3NpdGlvbk9uSW1hZ2UuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KGlucHV0RGltZW5zaW9ucy5jbG9uZSgpLm11bHRpcGx5KDAuNSkpXG5cbiAgICAvLyBSb3RhdGUgZGVsdGEgYXJvdW5kIGNlbnRlclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHJvdGF0aW9uRGVsdGEpXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocm90YXRpb25EZWx0YSlcbiAgICBjb25zdCBuZXdEZWx0YVRvQ2VudGVyID0gbmV3IFZlY3RvcjIoXG4gICAgICBkZWx0YVRvQ2VudGVyLnggKiBjb3MgLSBkZWx0YVRvQ2VudGVyLnkgKiBzaW4sXG4gICAgICBkZWx0YVRvQ2VudGVyLnggKiBzaW4gKyBkZWx0YVRvQ2VudGVyLnkgKiBjb3NcbiAgICApXG5cbiAgICAvLyBBcHBseSBzY2FsZSBjaGFuZ2UgdG8gZGVsdGFcbiAgICBuZXdEZWx0YVRvQ2VudGVyLm11bHRpcGx5KHNjYWxlUmF0aW8pXG5cbiAgICAvLyBDYWxjdWxhdGUgbmV3IHBvc2l0aW9uXG4gICAgLy8gaW1hZ2UgY2VudGVyICsgZGVsdGEgdG8gY2VudGVyIC0gb2xkIHN0YXJ0ICsgbmV3IHN0YXJ0XG4gICAgY29uc3QgcG9zaXRpb24gPSBpbnB1dERpbWVuc2lvbnMuY2xvbmUoKS5tdWx0aXBseSgwLjUpXG4gICAgICAuYWRkKG5ld0RlbHRhVG9DZW50ZXIpXG4gICAgICAuc3VidHJhY3QoYWJzb2x1dGVTdGFydClcbiAgICAgIC5hZGQoYWJzb2x1dGVTdGFydERpZmYpXG4gICAgICAuZGl2aWRlKG5ld0Fic29sdXRlU2l6ZSlcblxuICAgIC8vIENvbXBlbnNhdGUgc2NhbGVcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kaW1lbnNpb25zKSB7XG4gICAgICBjb25zdCBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCkuY2xvbmUoKS5tdWx0aXBseShzY2FsZVJhdGlvKVxuICAgICAgaWYgKG9wdGlvbnMudGV4dHVyZVNjYWxlKSB7XG4gICAgICAgIGRpbWVuc2lvbnMubXVsdGlwbHkob3B0aW9ucy50ZXh0dXJlU2NhbGUgLyBjcm9wT3BlcmF0aW9uLmdldFRleHR1cmVTY2FsZSgpKVxuICAgICAgfVxuICAgICAgdGhpcy5zZXQoeyBkaW1lbnNpb25zIH0sIGZhbHNlKVxuICAgIH1cblxuICAgIC8vIENvbXBlbnNhdGUgcm90YXRpb25cbiAgICBjb25zdCBpbnZlcnNlQ3JvcERlZ3JlZXMgPSByb3RhdGlvbkRlbHRhICogMTgwIC8gTWF0aC5QSVxuICAgIGNvbnN0IHNwcml0ZURlZ3JlZXMgPSB0aGlzLmdldFJvdGF0aW9uKCkgKiAxODAgLyBNYXRoLlBJICsgaW52ZXJzZUNyb3BEZWdyZWVzXG5cbiAgICB0aGlzLnNldCh7XG4gICAgICByb3RhdGlvbjogc3ByaXRlRGVncmVlcyAqIE1hdGguUEkgLyAxODAsXG4gICAgICBwb3NpdGlvblxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIERpc3BsYXlPYmplY3Qgb2YgdGhpcyBTcHJpdGVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlNwcml0ZX1cbiAgICovXG4gIGdldERpc3BsYXlPYmplY3QgKCkge1xuICAgIHJldHVybiB0aGlzLl9zcHJpdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0dXJlIGZvciB0aGUgc3ByaXRlIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIF9nZXRUZXh0dXJlICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nwcml0ZSNfZ2V0VGV4dHVyZSBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGNoaWxkIGNsYXNzLicpXG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgZm9yIHJlbmRlcmluZyB0aGlzIHNwcml0ZSB0byBhIHJlbmRlciB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVSZW5kZXJUZXh0dXJlIChzZGspIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlclRleHR1cmUpIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl9nZXRUZXh0dXJlKClcbiAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVDb250YWluZXIgPSBuZXcgRW5naW5lLkNvbnRhaW5lcigpXG4gICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlU3ByaXRlID0gbmV3IEVuZ2luZS5TcHJpdGUodGV4dHVyZSlcbiAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVDb250YWluZXIuYWRkQ2hpbGQodGhpcy5fcmVuZGVyVGV4dHVyZVNwcml0ZSlcbiAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUgPSB0aGlzLl9nZXRSZW5kZXJUZXh0dXJlKHNkay5nZXRSZW5kZXJlcigpLCB0ZXh0dXJlLmdldERpbWVuc2lvbnMoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5jbGVhcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHNwcml0ZSBzaG91bGQgYmUgcmVuZGVyZWQgdG8gYSByZW5kZXIgdGV4dHVyZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyc1RvUmVuZGVyVGV4dHVyZSAoc2RrKSB7XG4gICAgcmV0dXJuIHNkay5nZXRPcHRpb25zKCkuc21vb3RoRG93bnNjYWxpbmcgJiYgc2RrLmdldFJlbmRlcmVyKCkuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBzcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGlucHV0RGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgdXBkYXRlIChzZGssIGlucHV0RGltZW5zaW9ucykge1xuICAgIGlmICh0aGlzLl9yZW5kZXJzVG9SZW5kZXJUZXh0dXJlKHNkaykpIHtcbiAgICAgIHRoaXMuX3ByZXBhcmVSZW5kZXJUZXh0dXJlKHNkaylcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVTcHJpdGUoaW5wdXREaW1lbnNpb25zKVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlcnNUb1JlbmRlclRleHR1cmUoc2RrKSkge1xuICAgICAgdGhpcy5fcmVuZGVyVG9SZW5kZXJUZXh0dXJlKHNkaylcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzcHJpdGUncyBwcm9wZXJ0aWVzIGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gaW5wdXREaW1lbnNpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3ByaXRlIChpbnB1dERpbWVuc2lvbnMpIHtcbiAgICB0aGlzLl9zcHJpdGUuc2V0QW5jaG9yKHRoaXMuX29wdGlvbnMuYW5jaG9yKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRQb3NpdGlvbih0aGlzLl9vcHRpb25zLnBvc2l0aW9uLmNsb25lKCkubXVsdGlwbHkoaW5wdXREaW1lbnNpb25zKSlcblxuICAgIGxldCB7IGRpbWVuc2lvbnMgfSA9IHRoaXMuX29wdGlvbnNcbiAgICBpZiAoZGltZW5zaW9ucykge1xuICAgICAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMuY2xvbmUoKS5tdWx0aXBseSh0aGlzLl9vcGVyYXRpb24uZ2V0U0RLKCkuZ2V0VGV4dHVyZVNjYWxlKCkpXG4gICAgICB0aGlzLl9zcHJpdGUuc2V0V2lkdGgoZGltZW5zaW9ucy54KVxuICAgICAgdGhpcy5fc3ByaXRlLnNldEhlaWdodChkaW1lbnNpb25zLnkpXG4gICAgfVxuICAgIHRoaXMuX3Nwcml0ZS51cGRhdGVUcmFuc2Zvcm0oKVxuXG4gICAgY29uc3QgZnJhbWUgPSB0aGlzLl9zcHJpdGUuZ2V0VGV4dHVyZSgpLmdldEZyYW1lKClcbiAgICBjb25zdCBzcHJpdGVEaW1lbnNpb25zID0gbmV3IFZlY3RvcjIoZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodClcblxuICAgIHRoaXMuX3Nwcml0ZS5zZXRQaXZvdCh0aGlzLl9vcHRpb25zLnBpdm90LmNsb25lKCkubXVsdGlwbHkoc3ByaXRlRGltZW5zaW9ucykpXG4gICAgdGhpcy5fc3ByaXRlLnNldFJvdGF0aW9uKHRoaXMuX29wdGlvbnMucm90YXRpb24pXG4gICAgdGhpcy5fc3ByaXRlLnVwZGF0ZVRyYW5zZm9ybSgpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHNwcml0ZSB0byB0aGUgcmVuZGVyIHRleHR1cmUuIElmIHBvd2VyLW9mLXR3byB0ZXh0dXJlcyBhcmUgZW5mb3JjZWQsXG4gICAqIGl0IGF1dG9tYXRpY2FsbHkgcmVzaXplcyB0aGUgdGV4dHVyZSBhbmQgdXBkYXRlcyBpdHMgVVYgY29vcmRpbmF0ZXMgYWNjb3JkaW5nbHkuXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJUb1JlbmRlclRleHR1cmUgKHNkaykge1xuICAgIGNvbnN0IHRleHR1cmVEaW1lbnNpb25zID0gdGhpcy5fZ2V0VGV4dHVyZSgpLmdldERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSB0aGlzLl9nZXRSZW5kZXJUZXh0dXJlKHNkay5nZXRSZW5kZXJlcigpLCB0ZXh0dXJlRGltZW5zaW9ucylcblxuICAgIGNvbnN0IGZpbmFsRGltZW5zaW9ucyA9IHRleHR1cmVEaW1lbnNpb25zLmNsb25lKClcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zbW9vdGhEb3duc2NhbGluZykge1xuICAgICAgZmluYWxEaW1lbnNpb25zLnggPSBVdGlscy5uZXh0SGlnaGVzdFBPVChmaW5hbERpbWVuc2lvbnMueClcbiAgICAgIGZpbmFsRGltZW5zaW9ucy55ID0gVXRpbHMubmV4dEhpZ2hlc3RQT1QoZmluYWxEaW1lbnNpb25zLnkpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yZXNpemVUbyhmaW5hbERpbWVuc2lvbnMpXG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fcmVuZGVyVGV4dHVyZUNvbnRhaW5lcilcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNtb290aERvd25zY2FsaW5nKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZURpZmZlcmVuY2UgPSBmaW5hbERpbWVuc2lvbnMuY2xvbmUoKVxuICAgICAgICAuc3VidHJhY3QodGV4dHVyZURpbWVuc2lvbnMueCwgdGV4dHVyZURpbWVuc2lvbnMueSlcbiAgICAgICAgLmRpdmlkZShmaW5hbERpbWVuc2lvbnMpXG5cbiAgICAgIGNvbnN0IHV2cyA9IHJlbmRlclRleHR1cmUuZ2V0VVZzKCkuZ2V0VVZzKClcbiAgICAgIHV2c1swXS54ID0gdXZzWzNdLnggPSAwXG4gICAgICB1dnNbMV0ueCA9IHV2c1syXS54ID0gMSAtIHJlbGF0aXZlRGlmZmVyZW5jZS54XG4gICAgICB1dnNbMF0ueSA9IHV2c1sxXS55ID0gMFxuICAgICAgdXZzWzJdLnkgPSB1dnNbM10ueSA9IDEgLSByZWxhdGl2ZURpZmZlcmVuY2UueVxuICAgIH1cblxuICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKHJlbmRlclRleHR1cmUpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgb3BlcmF0aW9uIGlzIGRpcnR5IGZvciB0aGUgZ2l2ZW4gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gIHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0RpcnR5Rm9yUmVuZGVyZXIgKHJlbmRlcmVyKSB7XG4gICAgaWYgKCEocmVuZGVyZXIuaWQgaW4gdGhpcy5fZGlydGluZXNzKSkge1xuICAgICAgdGhpcy5fZGlydGluZXNzW3JlbmRlcmVyLmlkXSA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RpcnRpbmVzc1tyZW5kZXJlci5pZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkaXJ0aW5lc3MgZm9yIHRoZSBnaXZlbiByZW5kZXJlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHNldERpcnR5Rm9yUmVuZGVyZXIgKGRpcnR5LCByZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyc1tyZW5kZXJlci5pZF0gPSByZW5kZXJlclxuICAgIHRoaXMuX2RpcnRpbmVzc1tyZW5kZXJlci5pZF0gPSBkaXJ0eVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcnRpbmVzcyBmb3IgYWxsIHJlbmRlcmVyc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5XG4gICAqL1xuICBzZXREaXJ0eSAoZGlydHkpIHtcbiAgICBmb3IgKGxldCByZW5kZXJlcklkIGluIHRoaXMuX2RpcnRpbmVzcykge1xuICAgICAgdGhpcy5zZXREaXJ0eUZvclJlbmRlcmVyKGRpcnR5LCB0aGlzLl9yZW5kZXJlcnNbcmVuZGVyZXJJZF0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kL29yIHJldHVybnMgYSBSZW5kZXJUZXh0dXJlXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnMgPSBuZXcgVmVjdG9yKDEwMCwgMTAwKVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGV4dHVyZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSZW5kZXJUZXh0dXJlIChyZW5kZXJlciwgZGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKDEwMCwgMTAwKSkge1xuICAgIGlmICghdGhpcy5fcmVuZGVyVGV4dHVyZXNbcmVuZGVyZXIuaWRdKSB7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlc1tyZW5kZXJlci5pZF0gPVxuICAgICAgICBuZXcgRW5naW5lLlJlbmRlclRleHR1cmUocmVuZGVyZXIsIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55LCAxKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyVGV4dHVyZXNbcmVuZGVyZXIuaWRdXG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHRoaXMgU3ByaXRlXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICBmb3IgKGxldCByZW5kZXJlcklkIGluIHRoaXMuX3JlbmRlclRleHR1cmVzKSB7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlc1tyZW5kZXJlcklkXS5kaXNwb3NlKClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3ByaXRlXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL3Nwcml0ZXMvc3ByaXRlLmpzIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblwidXNlIHN0cmljdFwiO1xuLyohXG5TdGFja0JsdXIgLSBhIGZhc3QgYWxtb3N0IEdhdXNzaWFuIEJsdXIgRm9yIENhbnZhc1xuXG5WZXJzaW9uOiAgMC41XG5BdXRob3I6ICAgTWFyaW8gS2xpbmdlbWFublxuQ29udGFjdDogIG1hcmlvQHF1YXNpbW9uZG8uY29tXG5XZWJzaXRlOiAgaHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9TdGFja0JsdXJGb3JDYW52YXNcblR3aXR0ZXI6ICBAcXVhc2ltb25kb1xuXG5JbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cbkkgYW0gbm90IHRvdGFsbHkgdW5oYXBweSBmb3IgYSBzbWFsbCBkb25hdGlvbiB0byBteSBQYXlQYWwgYWNjb3VudFxubWFyaW9AcXVhc2ltb25kby5kZVxuXG5PciBzdXBwb3J0IG1lIG9uIGZsYXR0cjpcbmh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxub2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbmZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxucmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG5jb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG5Tb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG5PRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbkhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5GUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG5PVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5AbGljZW5zZVxuKi9cblxudmFyIG11bF90YWJsZSA9IFtcbiAgICAgICAgNTEyLDUxMiw0NTYsNTEyLDMyOCw0NTYsMzM1LDUxMiw0MDUsMzI4LDI3MSw0NTYsMzg4LDMzNSwyOTIsNTEyLFxuICAgICAgICA0NTQsNDA1LDM2NCwzMjgsMjk4LDI3MSw0OTYsNDU2LDQyMCwzODgsMzYwLDMzNSwzMTIsMjkyLDI3Myw1MTIsXG4gICAgICAgIDQ4Miw0NTQsNDI4LDQwNSwzODMsMzY0LDM0NSwzMjgsMzEyLDI5OCwyODQsMjcxLDI1OSw0OTYsNDc1LDQ1NixcbiAgICAgICAgNDM3LDQyMCw0MDQsMzg4LDM3NCwzNjAsMzQ3LDMzNSwzMjMsMzEyLDMwMiwyOTIsMjgyLDI3MywyNjUsNTEyLFxuICAgICAgICA0OTcsNDgyLDQ2OCw0NTQsNDQxLDQyOCw0MTcsNDA1LDM5NCwzODMsMzczLDM2NCwzNTQsMzQ1LDMzNywzMjgsXG4gICAgICAgIDMyMCwzMTIsMzA1LDI5OCwyOTEsMjg0LDI3OCwyNzEsMjY1LDI1OSw1MDcsNDk2LDQ4NSw0NzUsNDY1LDQ1NixcbiAgICAgICAgNDQ2LDQzNyw0MjgsNDIwLDQxMiw0MDQsMzk2LDM4OCwzODEsMzc0LDM2NywzNjAsMzU0LDM0NywzNDEsMzM1LFxuICAgICAgICAzMjksMzIzLDMxOCwzMTIsMzA3LDMwMiwyOTcsMjkyLDI4NywyODIsMjc4LDI3MywyNjksMjY1LDI2MSw1MTIsXG4gICAgICAgIDUwNSw0OTcsNDg5LDQ4Miw0NzUsNDY4LDQ2MSw0NTQsNDQ3LDQ0MSw0MzUsNDI4LDQyMiw0MTcsNDExLDQwNSxcbiAgICAgICAgMzk5LDM5NCwzODksMzgzLDM3OCwzNzMsMzY4LDM2NCwzNTksMzU0LDM1MCwzNDUsMzQxLDMzNywzMzIsMzI4LFxuICAgICAgICAzMjQsMzIwLDMxNiwzMTIsMzA5LDMwNSwzMDEsMjk4LDI5NCwyOTEsMjg3LDI4NCwyODEsMjc4LDI3NCwyNzEsXG4gICAgICAgIDI2OCwyNjUsMjYyLDI1OSwyNTcsNTA3LDUwMSw0OTYsNDkxLDQ4NSw0ODAsNDc1LDQ3MCw0NjUsNDYwLDQ1NixcbiAgICAgICAgNDUxLDQ0Niw0NDIsNDM3LDQzMyw0MjgsNDI0LDQyMCw0MTYsNDEyLDQwOCw0MDQsNDAwLDM5NiwzOTIsMzg4LFxuICAgICAgICAzODUsMzgxLDM3NywzNzQsMzcwLDM2NywzNjMsMzYwLDM1NywzNTQsMzUwLDM0NywzNDQsMzQxLDMzOCwzMzUsXG4gICAgICAgIDMzMiwzMjksMzI2LDMyMywzMjAsMzE4LDMxNSwzMTIsMzEwLDMwNywzMDQsMzAyLDI5OSwyOTcsMjk0LDI5MixcbiAgICAgICAgMjg5LDI4NywyODUsMjgyLDI4MCwyNzgsMjc1LDI3MywyNzEsMjY5LDI2NywyNjUsMjYzLDI2MSwyNTldO1xuXG5cbnZhciBzaGdfdGFibGUgPSBbXG4gICAgICAgOSwgMTEsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNyxcbiAgICAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOSxcbiAgICAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCxcbiAgICAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMSxcbiAgICAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSxcbiAgICAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcbiAgICAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcbiAgICAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMyxcbiAgICAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcbiAgICAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcbiAgICAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcbiAgICAyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcbiAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcbiAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcbiAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcbiAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0IF07XG5cbmZ1bmN0aW9uIHN0YWNrQmx1ckNhbnZhc1JHQkEoIGltYWdlRGF0YSwgdG9wX3gsIHRvcF95LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMgKVxue1xuICBpZiAoIGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDwgMSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmFkaXVzIHw9IDA7XG5cbiAgdmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhO1xuXG4gIHZhciB4LCB5LCBpLCBwLCB5cCwgeWksIHl3LCByX3N1bSwgZ19zdW0sIGJfc3VtLCBhX3N1bSxcbiAgcl9vdXRfc3VtLCBnX291dF9zdW0sIGJfb3V0X3N1bSwgYV9vdXRfc3VtLFxuICByX2luX3N1bSwgZ19pbl9zdW0sIGJfaW5fc3VtLCBhX2luX3N1bSxcbiAgcHIsIHBnLCBwYiwgcGEsIHJicztcblxuICB2YXIgZGl2ID0gcmFkaXVzICsgcmFkaXVzICsgMTtcbiAgdmFyIHdpZHRoTWludXMxICA9IHdpZHRoIC0gMTtcbiAgdmFyIGhlaWdodE1pbnVzMSA9IGhlaWdodCAtIDE7XG4gIHZhciByYWRpdXNQbHVzMSAgPSByYWRpdXMgKyAxO1xuICB2YXIgc3VtRmFjdG9yID0gcmFkaXVzUGx1czEgKiAoIHJhZGl1c1BsdXMxICsgMSApIC8gMjtcblxuICB2YXIgc3RhY2tTdGFydCA9IG5ldyBCbHVyU3RhY2soKTtcbiAgdmFyIHN0YWNrRW5kO1xuICB2YXIgc3RhY2sgPSBzdGFja1N0YXJ0O1xuICBmb3IgKCBpID0gMTsgaSA8IGRpdjsgaSsrIClcbiAge1xuICAgIHN0YWNrID0gc3RhY2submV4dCA9IG5ldyBCbHVyU3RhY2soKTtcbiAgICBpZiAoIGkgPT0gcmFkaXVzUGx1czEgKSBzdGFja0VuZCA9IHN0YWNrO1xuICB9XG4gIHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuICB2YXIgc3RhY2tJbiA9IG51bGw7XG4gIHZhciBzdGFja091dCA9IG51bGw7XG5cbiAgeXcgPSB5aSA9IDA7XG5cbiAgdmFyIG11bF9zdW0gPSBtdWxfdGFibGVbcmFkaXVzXTtcbiAgdmFyIHNoZ19zdW0gPSBzaGdfdGFibGVbcmFkaXVzXTtcblxuICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrIClcbiAge1xuICAgIHJfaW5fc3VtID0gZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSAwO1xuXG4gICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSApO1xuICAgIGdfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwZyA9IHBpeGVsc1t5aSsxXSApO1xuICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYiA9IHBpeGVsc1t5aSsyXSApO1xuICAgIGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYSA9IHBpeGVsc1t5aSszXSApO1xuXG4gICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG4gICAgZ19zdW0gKz0gc3VtRmFjdG9yICogcGc7XG4gICAgYl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG4gICAgYV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG5cbiAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cbiAgICBmb3IoIGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKyApXG4gICAge1xuICAgICAgc3RhY2suciA9IHByO1xuICAgICAgc3RhY2suZyA9IHBnO1xuICAgICAgc3RhY2suYiA9IHBiO1xuICAgICAgc3RhY2suYSA9IHBhO1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuICAgIGZvciggaSA9IDE7IGkgPCByYWRpdXNQbHVzMTsgaSsrIClcbiAgICB7XG4gICAgICBwID0geWkgKyAoKCB3aWR0aE1pbnVzMSA8IGkgPyB3aWR0aE1pbnVzMSA6IGkgKSA8PCAyICk7XG4gICAgICByX3N1bSArPSAoIHN0YWNrLnIgPSAoIHByID0gcGl4ZWxzW3BdKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xuICAgICAgZ19zdW0gKz0gKCBzdGFjay5nID0gKCBwZyA9IHBpeGVsc1twKzFdKSkgKiByYnM7XG4gICAgICBiX3N1bSArPSAoIHN0YWNrLmIgPSAoIHBiID0gcGl4ZWxzW3ArMl0pKSAqIHJicztcbiAgICAgIGFfc3VtICs9ICggc3RhY2suYSA9ICggcGEgPSBwaXhlbHNbcCszXSkpICogcmJzO1xuXG4gICAgICByX2luX3N1bSArPSBwcjtcbiAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICBhX2luX3N1bSArPSBwYTtcblxuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuXG4gICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcbiAgICBmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKVxuICAgIHtcbiAgICAgIHBpeGVsc1t5aSszXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgIGlmICggcGEgIT09IDAgKVxuICAgICAge1xuICAgICAgICBwYSA9IDI1NSAvIHBhO1xuICAgICAgICBwaXhlbHNbeWldICAgPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgcGl4ZWxzW3lpKzFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgIHBpeGVsc1t5aSsyXSA9ICgoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl4ZWxzW3lpXSA9IHBpeGVsc1t5aSsxXSA9IHBpeGVsc1t5aSsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJfc3VtIC09IHJfb3V0X3N1bTtcbiAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgIGJfc3VtIC09IGJfb3V0X3N1bTtcbiAgICAgIGFfc3VtIC09IGFfb3V0X3N1bTtcblxuICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgIGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG4gICAgICBiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgcCA9ICAoIHl3ICsgKCAoIHAgPSB4ICsgcmFkaXVzICsgMSApIDwgd2lkdGhNaW51czEgPyBwIDogd2lkdGhNaW51czEgKSApIDw8IDI7XG5cbiAgICAgIHJfaW5fc3VtICs9ICggc3RhY2tJbi5yID0gcGl4ZWxzW3BdKTtcbiAgICAgIGdfaW5fc3VtICs9ICggc3RhY2tJbi5nID0gcGl4ZWxzW3ArMV0pO1xuICAgICAgYl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCsyXSk7XG4gICAgICBhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twKzNdKTtcblxuICAgICAgcl9zdW0gKz0gcl9pbl9zdW07XG4gICAgICBnX3N1bSArPSBnX2luX3N1bTtcbiAgICAgIGJfc3VtICs9IGJfaW5fc3VtO1xuICAgICAgYV9zdW0gKz0gYV9pbl9zdW07XG5cbiAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cbiAgICAgIHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xuICAgICAgZ19vdXRfc3VtICs9ICggcGcgPSBzdGFja091dC5nICk7XG4gICAgICBiX291dF9zdW0gKz0gKCBwYiA9IHN0YWNrT3V0LmIgKTtcbiAgICAgIGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xuXG4gICAgICByX2luX3N1bSAtPSBwcjtcbiAgICAgIGdfaW5fc3VtIC09IHBnO1xuICAgICAgYl9pbl9zdW0gLT0gcGI7XG4gICAgICBhX2luX3N1bSAtPSBwYTtcblxuICAgICAgc3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG4gICAgICB5aSArPSA0O1xuICAgIH1cbiAgICB5dyArPSB3aWR0aDtcbiAgfVxuXG5cbiAgZm9yICggeCA9IDA7IHggPCB3aWR0aDsgeCsrIClcbiAge1xuICAgIGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfaW5fc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gcl9zdW0gPSAwO1xuXG4gICAgeWkgPSB4IDw8IDI7XG4gICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSk7XG4gICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBnID0gcGl4ZWxzW3lpKzFdKTtcbiAgICBiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGIgPSBwaXhlbHNbeWkrMl0pO1xuICAgIGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYSA9IHBpeGVsc1t5aSszXSk7XG5cbiAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICBnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcbiAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgIHN0YWNrID0gc3RhY2tTdGFydDtcblxuICAgIGZvciggaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrIClcbiAgICB7XG4gICAgICBzdGFjay5yID0gcHI7XG4gICAgICBzdGFjay5nID0gcGc7XG4gICAgICBzdGFjay5iID0gcGI7XG4gICAgICBzdGFjay5hID0gcGE7XG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgfVxuXG4gICAgeXAgPSB3aWR0aDtcblxuICAgIGZvciggaSA9IDE7IGkgPD0gcmFkaXVzOyBpKysgKVxuICAgIHtcbiAgICAgIHlpID0gKCB5cCArIHggKSA8PCAyO1xuXG4gICAgICByX3N1bSArPSAoIHN0YWNrLnIgPSAoIHByID0gcGl4ZWxzW3lpXSkpICogKCByYnMgPSByYWRpdXNQbHVzMSAtIGkgKTtcbiAgICAgIGdfc3VtICs9ICggc3RhY2suZyA9ICggcGcgPSBwaXhlbHNbeWkrMV0pKSAqIHJicztcbiAgICAgIGJfc3VtICs9ICggc3RhY2suYiA9ICggcGIgPSBwaXhlbHNbeWkrMl0pKSAqIHJicztcbiAgICAgIGFfc3VtICs9ICggc3RhY2suYSA9ICggcGEgPSBwaXhlbHNbeWkrM10pKSAqIHJicztcblxuICAgICAgcl9pbl9zdW0gKz0gcHI7XG4gICAgICBnX2luX3N1bSArPSBwZztcbiAgICAgIGJfaW5fc3VtICs9IHBiO1xuICAgICAgYV9pbl9zdW0gKz0gcGE7XG5cbiAgICAgIHN0YWNrID0gc3RhY2submV4dDtcblxuICAgICAgaWYoIGkgPCBoZWlnaHRNaW51czEgKVxuICAgICAge1xuICAgICAgICB5cCArPSB3aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB5aSA9IHg7XG4gICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcbiAgICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrIClcbiAgICB7XG4gICAgICBwID0geWkgPDwgMjtcbiAgICAgIHBpeGVsc1twKzNdID0gcGEgPSAoYV9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuICAgICAgaWYgKCBwYSA+IDAgKVxuICAgICAge1xuICAgICAgICBwYSA9IDI1NSAvIHBhO1xuICAgICAgICBwaXhlbHNbcF0gICA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcbiAgICAgICAgcGl4ZWxzW3ArMV0gPSAoKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSApICogcGE7XG4gICAgICAgIHBpeGVsc1twKzJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl4ZWxzW3BdID0gcGl4ZWxzW3ArMV0gPSBwaXhlbHNbcCsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJfc3VtIC09IHJfb3V0X3N1bTtcbiAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgIGJfc3VtIC09IGJfb3V0X3N1bTtcbiAgICAgIGFfc3VtIC09IGFfb3V0X3N1bTtcblxuICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgIGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG4gICAgICBiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgcCA9ICggeCArICgoICggcCA9IHkgKyByYWRpdXNQbHVzMSkgPCBoZWlnaHRNaW51czEgPyBwIDogaGVpZ2h0TWludXMxICkgKiB3aWR0aCApKSA8PCAyO1xuXG4gICAgICByX3N1bSArPSAoIHJfaW5fc3VtICs9ICggc3RhY2tJbi5yID0gcGl4ZWxzW3BdKSk7XG4gICAgICBnX3N1bSArPSAoIGdfaW5fc3VtICs9ICggc3RhY2tJbi5nID0gcGl4ZWxzW3ArMV0pKTtcbiAgICAgIGJfc3VtICs9ICggYl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCsyXSkpO1xuICAgICAgYV9zdW0gKz0gKCBhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twKzNdKSk7XG5cbiAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cbiAgICAgIHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xuICAgICAgZ19vdXRfc3VtICs9ICggcGcgPSBzdGFja091dC5nICk7XG4gICAgICBiX291dF9zdW0gKz0gKCBwYiA9IHN0YWNrT3V0LmIgKTtcbiAgICAgIGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xuXG4gICAgICByX2luX3N1bSAtPSBwcjtcbiAgICAgIGdfaW5fc3VtIC09IHBnO1xuICAgICAgYl9pbl9zdW0gLT0gcGI7XG4gICAgICBhX2luX3N1bSAtPSBwYTtcblxuICAgICAgc3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG4gICAgICB5aSArPSB3aWR0aDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmx1clN0YWNrKClcbntcbiAgdGhpcy5yID0gMDtcbiAgdGhpcy5nID0gMDtcbiAgdGhpcy5iID0gMDtcbiAgdGhpcy5hID0gMDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0YWNrQmx1ckNhbnZhc1JHQkE6IHN0YWNrQmx1ckNhbnZhc1JHQkFcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi92ZW5kb3Ivc3RhY2stYmx1ci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXhpZi1qcy9leGlmLWpzIGJ5IEphY29iIFNlaWRlbGluXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqIEBsaWNlbnNlXG4gKi9cblxuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgQmFzZTY0IGZyb20gJy4vYmFzZTY0J1xuXG5jb25zdCBFWElGX1RBR1MgPSB7XG4gIDB4MDEwMDogJ0ltYWdlV2lkdGgnLFxuICAweDAxMDE6ICdJbWFnZUhlaWdodCcsXG4gIDB4ODc2OTogJ0V4aWZJRkRQb2ludGVyJyxcbiAgMHg4ODI1OiAnR1BTSW5mb0lGRFBvaW50ZXInLFxuICAweEEwMDU6ICdJbnRlcm9wZXJhYmlsaXR5SUZEUG9pbnRlcicsXG4gIDB4MDEwMjogJ0JpdHNQZXJTYW1wbGUnLFxuICAweDAxMDM6ICdDb21wcmVzc2lvbicsXG4gIDB4MDEwNjogJ1Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb24nLFxuICAweDAxMTI6ICdPcmllbnRhdGlvbicsXG4gIDB4MDExNTogJ1NhbXBsZXNQZXJQaXhlbCcsXG4gIDB4MDExQzogJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAweDAyMTI6ICdZQ2JDclN1YlNhbXBsaW5nJyxcbiAgMHgwMjEzOiAnWUNiQ3JQb3NpdGlvbmluZycsXG4gIDB4MDExQTogJ1hSZXNvbHV0aW9uJyxcbiAgMHgwMTFCOiAnWVJlc29sdXRpb24nLFxuICAweDAxMjg6ICdSZXNvbHV0aW9uVW5pdCcsXG4gIDB4MDExMTogJ1N0cmlwT2Zmc2V0cycsXG4gIDB4MDExNjogJ1Jvd3NQZXJTdHJpcCcsXG4gIDB4MDExNzogJ1N0cmlwQnl0ZUNvdW50cycsXG4gIDB4MDIwMTogJ0pQRUdJbnRlcmNoYW5nZUZvcm1hdCcsXG4gIDB4MDIwMjogJ0pQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aCcsXG4gIDB4MDEyRDogJ1RyYW5zZmVyRnVuY3Rpb24nLFxuICAweDAxM0U6ICdXaGl0ZVBvaW50JyxcbiAgMHgwMTNGOiAnUHJpbWFyeUNocm9tYXRpY2l0aWVzJyxcbiAgMHgwMjExOiAnWUNiQ3JDb2VmZmljaWVudHMnLFxuICAweDAyMTQ6ICdSZWZlcmVuY2VCbGFja1doaXRlJyxcbiAgMHgwMTMyOiAnRGF0ZVRpbWUnLFxuICAweDAxMEU6ICdJbWFnZURlc2NyaXB0aW9uJyxcbiAgMHgwMTBGOiAnTWFrZScsXG4gIDB4MDExMDogJ01vZGVsJyxcbiAgMHgwMTMxOiAnU29mdHdhcmUnLFxuICAweDAxM0I6ICdBcnRpc3QnLFxuICAweDgyOTg6ICdDb3B5cmlnaHQnXG59XG5cbmNvbnN0IERBVEFfSlBFR19QUkVGSVggPSAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnXG5jb25zdCBKUEVHX1JFR0VYID0gbmV3IFJlZ0V4cChgXiR7REFUQV9KUEVHX1BSRUZJWH1gLCAnaScpXG5cbmltcG9ydCBBcnJheVN0cmVhbSBmcm9tICcuL2FycmF5LXN0cmVhbSdcblxuLyoqXG4gKiBSZWFkcyBFWElGIHRhZ3MgZnJvbSB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSBhbmQgcmVzdG9yZXMgdGhlbVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgRVhJRiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEVYSUYgb2JqZWN0XG4gICAqIEBwYXJhbSAge0FycmF5fSBidWZcbiAgICovXG4gIGNvbnN0cnVjdG9yIChidWYpIHtcbiAgICB0aGlzLl9idWYgPSBidWZcbiAgICB0aGlzLl9zdHJlYW0gPSBuZXcgQXJyYXlTdHJlYW0odGhpcy5fYnVmKVxuICAgIHRoaXMuX3N0cmVhbS5zZXRIZWFkKDApXG5cbiAgICB0aGlzLl9zZWdtZW50cyA9IHRoaXMuX3NsaWNlSW50b1NlZ21lbnRzKHRoaXMuX2J1ZilcbiAgICB0aGlzLl9leGlmQnVmZmVyID0gdGhpcy5fZ2V0RXhpZkJ1ZmZlcigpXG4gICAgdGhpcy5fZXhpZlN0cmVhbSA9IG5ldyBBcnJheVN0cmVhbSh0aGlzLl9leGlmQnVmZmVyKVxuICAgIHRoaXMuX3BhcnNlRXhpZigpXG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGV4aWYgdGFncyBpbnRvIHRoZSBnaXZlbiBkYXRhIHVybFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NFN0cmluZ1xuICAgKi9cbiAgcmVzdG9yZUV4aWZUYWdzIChiYXNlNjRTdHJpbmcpIHtcbiAgICAvLyBGaXJzdCwgbWFrZSB0aGUgZ2l2ZW4gc3RyaW5nIGEgZGF0YSBhcnJheVxuICAgIGNvbnN0IHJhdyA9IGJhc2U2NFN0cmluZy5yZXBsYWNlKERBVEFfSlBFR19QUkVGSVgsICcnKVxuICAgIGNvbnN0IGRhdGEgPSBCYXNlNjQuZGVjb2RlKHJhdylcblxuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5fc2xpY2VJbnRvU2VnbWVudHMoZGF0YSlcbiAgICBjb25zdCBzZWdtZW50U3RhcnQgPSBzZWdtZW50c1sxXVswXVxuICAgIGNvbnN0IGRhdGFCZWZvcmUgPSBkYXRhLnNsaWNlKDAsIHNlZ21lbnRTdGFydClcbiAgICBjb25zdCBkYXRhQWZ0ZXIgPSBkYXRhLnNsaWNlKHNlZ21lbnRTdGFydClcblxuICAgIGxldCBuZXdEYXRhID0gZGF0YUJlZm9yZS5jb25jYXQodGhpcy5fZXhpZkJ1ZmZlcilcbiAgICBuZXdEYXRhID0gbmV3RGF0YS5jb25jYXQoZGF0YUFmdGVyKVxuXG4gICAgLy8gTWFrZSBpdCBhIGJhc2U2NCBzdHJpbmcgYWdhaW5cbiAgICByZXR1cm4gREFUQV9KUEVHX1BSRUZJWCArIEJhc2U2NC5lbmNvZGUobmV3RGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIHRoZSBvcmllbnRhdGlvbiB3aXRoIHRoZSBnaXZlbiAxNiBiaXQgaW50ZWdlclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3JpZW50YXRpb25cbiAgICovXG4gIHNldE9yaWVudGF0aW9uIChvcmllbnRhdGlvbikge1xuICAgIGlmICh0aGlzLl90YWdEYXRhLk9yaWVudGF0aW9uKSB7XG4gICAgICBjb25zdCB7IGVudHJ5T2Zmc2V0IH0gPSB0aGlzLl90YWdEYXRhLk9yaWVudGF0aW9uXG4gICAgICAvLyBSZXBsYWNlIHZhbHVlIGluIGJ1ZmZlclxuICAgICAgdGhpcy5fZXhpZlN0cmVhbS5zZXRIZWFkKGVudHJ5T2Zmc2V0ICsgOClcbiAgICAgIHRoaXMuX2V4aWZTdHJlYW0ud3JpdGVJbnQxNihvcmllbnRhdGlvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGJhc2U2NCBkYXRhIHVybCBpcyBhIGpwZWcgaW1hZ2VcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgYmFzZTY0U3RyaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNKUEVHIChiYXNlNjRTdHJpbmcpIHtcbiAgICByZXR1cm4gSlBFR19SRUdFWC50ZXN0KGJhc2U2NFN0cmluZylcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEV4aWYgZnJvbSB0aGUgZ2l2ZW4gYmFzZTY0LWVuY29kZWRcbiAgICogc3RyaW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYmFzZTY0U3RyaW5nXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkV4aWZ9XG4gICAqL1xuICBzdGF0aWMgZnJvbUJhc2U2NFN0cmluZyAoYmFzZTY0U3RyaW5nKSB7XG4gICAgY29uc3QgcmF3ID0gYmFzZTY0U3RyaW5nLnJlcGxhY2UoREFUQV9KUEVHX1BSRUZJWCwgJycpXG4gICAgY29uc3QgZGF0YSA9IEJhc2U2NC5kZWNvZGUocmF3KVxuICAgIHJldHVybiBuZXcgRVhJRihkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZXhpZiB0YWdzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYXJzZUV4aWYgKCkge1xuICAgIHRoaXMuX2V4aWZTdHJlYW0uc2V0SGVhZCgwKVxuICAgIC8vIFNraXAgbWFya2VyXG4gICAgdGhpcy5fZXhpZlN0cmVhbS5yZWFkSW50MTYoKVxuICAgIC8vIFNraXAgbGVuZ3RoXG4gICAgdGhpcy5fZXhpZlN0cmVhbS5yZWFkSW50MTYoKVxuXG4gICAgY29uc3QgaGVhZGVyID0gdGhpcy5fZXhpZlN0cmVhbS5yZWFkU3RyaW5nKDQpXG4gICAgaWYgKGhlYWRlciAhPT0gJ0V4aWYnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBTa2lwIDIgYnl0ZXNcbiAgICB0aGlzLl9leGlmU3RyZWFtLnJlYWRJbnQxNigpXG5cbiAgICBjb25zdCB0aWZmT2Zmc2V0ID0gdGhpcy5fZXhpZlN0cmVhbS5nZXRIZWFkKClcblxuICAgIC8vIEZpbmQgZW5kaWFuIHR5cGVcbiAgICBsZXQgYmlnRW5kaWFuID0gZmFsc2VcbiAgICBjb25zdCBlbmRpYW4gPSB0aGlzLl9leGlmU3RyZWFtLnJlYWRJbnQxNigpXG4gICAgaWYgKGVuZGlhbiA9PT0gMHg0OTQ5KSB7XG4gICAgICBiaWdFbmRpYW4gPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAweDRkNGQpIHtcbiAgICAgIGJpZ0VuZGlhbiA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFRJRkYgZGF0YTogTm8gZW5kaWFuIHR5cGUgZm91bmQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9leGlmU3RyZWFtLnJlYWRJbnQxNighYmlnRW5kaWFuKSAhPT0gMHgwMDJBKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVElGRiBkYXRhOiBObyAweDAwMkEnKVxuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0SUZET2Zmc2V0ID0gdGhpcy5fZXhpZlN0cmVhbS5yZWFkSW50MzIoIWJpZ0VuZGlhbilcbiAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPCA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVElGRiBkYXRhOiBGaXJzdCBJRkQgb2Zmc2V0IDwgOCcpXG4gICAgfVxuXG4gICAgY29uc3QgaWZkT2Zmc2V0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0XG4gICAgY29uc3QgdGFncyA9IHRoaXMuX3JlYWRUYWdzKHRoaXMuX2V4aWZTdHJlYW0sIHRpZmZPZmZzZXQsIGlmZE9mZnNldCwgYmlnRW5kaWFuKVxuICAgIHRoaXMuX3RhZ3MgPSB0YWdzLnRhZ3NcbiAgICB0aGlzLl90YWdEYXRhID0gdGFncy50YWdEYXRhXG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIFRJRkYgdGFncyBmcm9tIHRoZSBzdHJlYW1cbiAgICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9IHN0cmVhbVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpZmZTdGFydCBUaGUgcG9zaXRpb24gd2hlcmUgdGlmZiBkYXRhIHN0YXJ0c1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlmZFN0YXJ0ICBUaGUgcG9zaXRpb24gd2hlcmUgdGhlIElGRCBzdGFydHNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gYmlnRW5kaWFuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZWFkVGFncyAoc3RyZWFtLCB0aWZmU3RhcnQsIGlmZFN0YXJ0LCBiaWdFbmRpYW4pIHtcbiAgICBzdHJlYW0uc2V0SGVhZChpZmRTdGFydClcbiAgICBjb25zdCBlbnRyaWVzQ291bnQgPSBzdHJlYW0ucmVhZEludDE2KCFiaWdFbmRpYW4pXG4gICAgbGV0IHRhZ3MgPSB7fVxuICAgIGxldCB0YWdEYXRhID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5T2Zmc2V0ID0gaWZkU3RhcnQgKyBpICogMTIgKyAyXG4gICAgICBzdHJlYW0uc2V0SGVhZChlbnRyeU9mZnNldClcbiAgICAgIGxldCB0YWcgPSBzdHJlYW0ucmVhZEludDE2KCFiaWdFbmRpYW4pXG4gICAgICBsZXQgdHlwZVxuICAgICAgbGV0IG51bVZhbHVlc1xuICAgICAgbGV0IHZhbHVlT2Zmc2V0XG4gICAgICBpZiAoRVhJRl9UQUdTW3RhZ10pIHtcbiAgICAgICAgdGFnID0gRVhJRl9UQUdTW3RhZ11cbiAgICAgICAgdHlwZSA9IHN0cmVhbS5yZWFkSW50MTYoIWJpZ0VuZGlhbilcbiAgICAgICAgbnVtVmFsdWVzID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICB2YWx1ZU9mZnNldCA9IHN0cmVhbS5yZWFkSW50MzIoIWJpZ0VuZGlhbikgKyB0aWZmU3RhcnRcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbFxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgMTogLy8gYnl0ZSwgOC1iaXQgdW5zaWduZWQgaW50XG4gICAgICAgICAgY2FzZSA3OiAvLyB1bmRlZmluZWQsIDgtYml0IGJ5dGUsIHZhbHVlIGRlcGVuZGluZyBvbiBmaWVsZFxuICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmVhbS5yZWFkSW50OCghYmlnRW5kaWFuKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBbXVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChzdHJlYW0ucmVhZEludDgoIWJpZ0VuZGlhbikpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAyOiAvLyA4LWJpdCBhc2NpaSBjaGFyXG4gICAgICAgICAgICBzdHJlYW0uc2V0SGVhZChudW1WYWx1ZXMgPiA0ID8gdmFsdWVPZmZzZXQgOiAoZW50cnlPZmZzZXQgKyA4KSlcbiAgICAgICAgICAgIHZhbHVlID0gc3RyZWFtLnJlYWRTdHJpbmcobnVtVmFsdWVzKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIDM6IC8vIHNob3J0XG4gICAgICAgICAgICBzdHJlYW0uc2V0SGVhZChudW1WYWx1ZXMgPiAyID8gdmFsdWVPZmZzZXQgOiAoZW50cnlPZmZzZXQgKyA4KSlcbiAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdHJlYW0ucmVhZEludDE2KCFiaWdFbmRpYW4pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IFtdXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmFsdWVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHN0cmVhbS5yZWFkSW50MTYoIWJpZ0VuZGlhbikpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSA0OiAvLyBsb25nXG4gICAgICAgICAgY2FzZSA5OiAvLyBzbG9uZ1xuICAgICAgICAgICAgc3RyZWFtLnNldEhlYWQobnVtVmFsdWVzID4gMSA/IHZhbHVlT2Zmc2V0IDogKGVudHJ5T2Zmc2V0ICsgOCkpXG4gICAgICAgICAgICBpZiAobnVtVmFsdWVzID09PSAxKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBbXVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChzdHJlYW0ucmVhZEludDMyKCFiaWdFbmRpYW4pKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgNTogLy8gcmF0aW9uYWwgKHR3byBsb25nIHZhbHVlcywgZmlyc3QgbnVtZXJhdG9yLCBzZWNvbmQgZGVub21pbmF0b3IpXG4gICAgICAgICAgY2FzZSAxMDogLy8gcmF0aW9uYWwgKHR3byBzbG9uZ3MpXG4gICAgICAgICAgICBzdHJlYW0uc2V0SGVhZCh2YWx1ZU9mZnNldClcbiAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgbnVtZXJhdG9yID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICAgICAgICBjb25zdCBkZW5vbWluYXRvciA9IHN0cmVhbS5yZWFkSW50MzIoIWJpZ0VuZGlhbilcbiAgICAgICAgICAgICAgdmFsdWUgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBbXVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtZXJhdG9yID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yXG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaCh2YWwpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICB0YWdzW3RhZ10gPSB2YWx1ZVxuICAgICAgICB0YWdEYXRhW3RhZ10gPSB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbnVtVmFsdWVzLFxuICAgICAgICAgIGVudHJ5T2Zmc2V0LFxuICAgICAgICAgIHZhbHVlT2Zmc2V0LFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHRhZ3MsIHRhZ0RhdGEgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIEV4aWYgc2VnbWVudFxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRFeGlmQnVmZmVyICgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gc2VnbWVudHNbaV1bMF1cbiAgICAgIGNvbnN0IGVuZCA9IHNlZ21lbnRzW2ldWzFdXG4gICAgICB0aGlzLl9zdHJlYW0uc2V0SGVhZChvZmZzZXQpXG4gICAgICBjb25zdCBtYXJrZXIgPSB0aGlzLl9zdHJlYW0ucGVla0ludDE2KClcbiAgICAgIGlmIChtYXJrZXIgPT09IDB4ZmZlMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmLnNsaWNlKG9mZnNldCwgZW5kKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTbGljZXMgdGhlIGFycmF5IGludG8gc2VnbWVudHNcbiAgICogQHBhcmFtICB7QXJyYXkuPE51bWJlcj59IGJ1ZlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zbGljZUludG9TZWdtZW50cyAoYnVmKSB7XG4gICAgbGV0IHN0cmVhbSA9IG5ldyBBcnJheVN0cmVhbShidWYpXG4gICAgbGV0IHNlZ21lbnRzID0gW11cbiAgICB3aGlsZSAoc3RyZWFtLmdldEhlYWQoKSA8IGJ1Zi5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1hcmtlciA9IHN0cmVhbS5yZWFkSW50MTYoKVxuICAgICAgaWYgKG1hcmtlciA9PT0gMHhmZmQ4KSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IC8vIFNPSVxuICAgICAgaWYgKG1hcmtlciA9PT0gMHhmZmRhKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IC8vIFNPUyBNYXJrZXJcblxuICAgICAgaWYgKG1hcmtlciA+PSAweGZmMDAgJiYgbWFya2VyIDw9IDB4ZmZmZikge1xuICAgICAgICAvLyBNYXJrZXIgKEZGLVhYLUhMLUxMKVxuICAgICAgICBjb25zdCBsZW5ndGggPSBzdHJlYW0ucmVhZEludDE2KClcbiAgICAgICAgY29uc3QgZW5kID0gc3RyZWFtLmdldEhlYWQoKSArIGxlbmd0aCAtIDJcbiAgICAgICAgc2VnbWVudHMucHVzaChbc3RyZWFtLmdldEhlYWQoKSAtIDQsIGVuZF0pXG4gICAgICAgIHN0cmVhbS5zZXRIZWFkKGVuZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXJrZXI6IDB4JyArIG1hcmtlci50b1N0cmluZygxNikpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyZWFtLnNldEhlYWQoMClcblxuICAgIHJldHVybiBzZWdtZW50c1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhZ3NcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0VGFncyAoKSB7IHJldHVybiB0aGlzLl90YWdzIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFnIGRhdGEgKGtleSwgdmFsdWUsIGJ5dGUgcG9zaXRpb24gZXRjLilcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRUYWdEYXRhICgpIHsgcmV0dXJuIHRoaXMuX3RhZ0RhdGEgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIEVYSUYgb2JqZWN0XG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9idWYgPSBbXVxuICAgIHRoaXMuX2V4aWZCdWZmZXIgPSBbXVxuICAgIHRoaXMuX3NlZ21lbnRzID0gW11cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFWElGXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvZXhpZi5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nLCBNYXRyaXgsIFZlY3RvcjIsIFJlY3RhbmdsZSB9IGZyb20gJy4uL2dsb2JhbHMnXG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBvYmplY3RzIHRoYXQgY2FuIGJlIGRpc3BsYXllZFxuICogb24gdGhlIHNjcmVlblxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIERpc3BsYXlPYmplY3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIERpc3BsYXlPYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IG5ldyBWZWN0b3IyKDAsIDApXG4gICAgdGhpcy5fc2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKVxuICAgIHRoaXMuX3Bpdm90ID0gbmV3IFZlY3RvcjIoMCwgMClcbiAgICB0aGlzLl9yb3RhdGlvbiA9IDBcbiAgICB0aGlzLl9sYXN0Um90YXRpb24gPSBudWxsXG4gICAgdGhpcy5fYWxwaGEgPSAxXG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWVcbiAgICB0aGlzLl93b3JsZFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKVxuICAgIHRoaXMuX3BhcmVudCA9IG51bGxcbiAgICB0aGlzLl9zaGFkZXJzID0gW11cbiAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgMSwgMSlcbiAgICB0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEsIDEpXG4gICAgdGhpcy5fdGludCA9IDB4ZmZmZmZmXG4gICAgdGhpcy5fZmlsdGVyUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBEaXNwbGF5T2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBXZWJHTFJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHJlbmRlcldlYkdMIChyZW5kZXJlcikge1xuICAgIExvZy53YXJuKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ2ByZW5kZXJXZWJHTGAgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBEaXNwbGF5T2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBDYW52YXNSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgcmVuZGVyQ2FudmFzIChyZW5kZXJlcikge1xuICAgIExvZy53YXJuKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ2ByZW5kZXJDYW52YXNgIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzJylcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB3b3JsZCB0cmFuc2Zvcm0gZm9yIHRoaXMgRGlzcGxheU9iamVjdFxuICAgKi9cbiAgdXBkYXRlVHJhbnNmb3JtICgpIHtcbiAgICBjb25zdCBwYXJlbnRUcmFuc2Zvcm0gPSB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZ2V0V29ybGRUcmFuc2Zvcm0oKSA6IE1hdHJpeC5JREVOVElUWVxuICAgIGNvbnN0IHdvcmxkVHJhbnNmb3JtID0gdGhpcy5fd29ybGRUcmFuc2Zvcm1cblxuICAgIC8vIE9ubHkgYnVpbGQgcm90YXRpb24gbWF0cml4IGlmIHJvdGF0aW9uIGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgdXBkYXRlXG4gICAgY29uc3Qgcm90YXRpb25DaGFuZ2VkID0gdGhpcy5fcm90YXRpb24gIT09IHRoaXMuX2xhc3RSb3RhdGlvblxuICAgIGlmIChyb3RhdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3NpblJvdGF0aW9uID0gTWF0aC5zaW4odGhpcy5fcm90YXRpb24pXG4gICAgICB0aGlzLl9jb3NSb3RhdGlvbiA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uKVxuICAgICAgdGhpcy5fbGFzdFJvdGF0aW9uID0gdGhpcy5fcm90YXRpb25cbiAgICB9XG5cbiAgICB3b3JsZFRyYW5zZm9ybS5hID0gdGhpcy5fY29zUm90YXRpb24gKiB0aGlzLl9zY2FsZS54XG4gICAgd29ybGRUcmFuc2Zvcm0uYiA9IHRoaXMuX3NpblJvdGF0aW9uICogdGhpcy5fc2NhbGUueFxuICAgIHdvcmxkVHJhbnNmb3JtLmMgPSAtdGhpcy5fc2luUm90YXRpb24gKiB0aGlzLl9zY2FsZS55XG4gICAgd29ybGRUcmFuc2Zvcm0uZCA9IHRoaXMuX2Nvc1JvdGF0aW9uICogdGhpcy5fc2NhbGUueVxuICAgIHdvcmxkVHJhbnNmb3JtLnR4ID0gdGhpcy5fcG9zaXRpb24ueFxuICAgIHdvcmxkVHJhbnNmb3JtLnR5ID0gdGhpcy5fcG9zaXRpb24ueVxuXG4gICAgaWYgKHRoaXMuX3Bpdm90LnggfHwgdGhpcy5fcGl2b3QueSkge1xuICAgICAgd29ybGRUcmFuc2Zvcm0udHggLT0gdGhpcy5fcGl2b3QueCAqIHdvcmxkVHJhbnNmb3JtLmEgKyB0aGlzLl9waXZvdC55ICogd29ybGRUcmFuc2Zvcm0uY1xuICAgICAgd29ybGRUcmFuc2Zvcm0udHkgLT0gdGhpcy5fcGl2b3QueCAqIHdvcmxkVHJhbnNmb3JtLmIgKyB0aGlzLl9waXZvdC55ICogd29ybGRUcmFuc2Zvcm0uZFxuICAgIH1cblxuICAgIC8vIEZsb29yXG4gICAgd29ybGRUcmFuc2Zvcm0udHggfD0gMFxuICAgIHdvcmxkVHJhbnNmb3JtLnR5IHw9IDBcblxuICAgIHdvcmxkVHJhbnNmb3JtLm11bHRpcGx5KHBhcmVudFRyYW5zZm9ybSlcblxuICAgIHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgdGhpcy5fbG9jYWxCb3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU0hBREVSU1xuXG4gIC8qKlxuICAgKiBQdXNoZXMgdGhlIGdpdmVuIHNoYWRlciB0byB0aGUgbGlzdCBvZiBzaGFkZXJzXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlNoYWRlcn0gc2hhZGVyXG4gICAqL1xuICBhZGRTaGFkZXIgKHNoYWRlcikge1xuICAgIHRoaXMuX3NoYWRlcnMucHVzaChzaGFkZXIpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gc2hhZGVyIGZyb20gdGhlIGxpc3Qgb2Ygc2hhZGVyc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU2hhZGVyfSBzaGFkZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHJlbW92ZVNoYWRlciAoc2hhZGVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9zaGFkZXJzLmluZGV4T2Yoc2hhZGVyKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX3NoYWRlcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc2hhZGVyIGF0IHRoZSBnaXZlbiBpbmRleCBmcm9tIHRoZSBsaXN0IG9mIHNoYWRlcnNcbiAgICogQHBhcmFtICB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgcmVtb3ZlU2hhZGVyQXQgKGluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9zaGFkZXJzW2luZGV4XSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMuX3NoYWRlcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmRzIGZvciB0aGlzIERpc3BsYXlPYmplY3RcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9XG4gICAqL1xuICBnZXRCb3VuZHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9ib3VuZHMuY2xvbmUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gR0VUVEVSUyAvIFNFVFRFUlNcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRQb3NpdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wb3NpdGlvbiB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ8TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeV1cbiAgICovXG4gIHNldFBvc2l0aW9uIChwb3NpdGlvbiwgeSkge1xuICAgIGlmIChwb3NpdGlvbiBpbnN0YW5jZW9mIFZlY3RvcjIpIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uLmNvcHkocG9zaXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uLnNldChwb3NpdGlvbiwgeSlcbiAgICB9XG4gICAgdGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgICB0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzY2FsZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRTY2FsZSAoKSB7IHJldHVybiB0aGlzLl9zY2FsZSB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjYWxlIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ8TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeV1cbiAgICovXG4gIHNldFNjYWxlIChzY2FsZSwgeSkge1xuICAgIGlmIChzY2FsZSBpbnN0YW5jZW9mIFZlY3RvcjIpIHtcbiAgICAgIHRoaXMuX3NjYWxlLmNvcHkoc2NhbGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NjYWxlLnNldChzY2FsZSwgeSlcbiAgICB9XG4gICAgdGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgICB0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwaXZvdCAoVGhlIHBvaW50IHRoYXQgdGhpcyBEaXNwbGF5b2JqZWN0IHJvdGF0ZXMgYXJvdW5kKVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRQaXZvdCAoKSB7IHJldHVybiB0aGlzLl9waXZvdCB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBpdm90IChUaGUgcG9pbnQgdGhhdCB0aGlzIERpc3BsYXlPYmplY3Qgcm90YXRlcyBhcm91bmQpXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfE51bWJlcn0gcGl2b3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5XVxuICAgKi9cbiAgc2V0UGl2b3QgKHBpdm90LCB5KSB7XG4gICAgaWYgKHBpdm90IGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy5fcGl2b3QuY29weShwaXZvdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGl2b3Quc2V0KHBpdm90LCB5KVxuICAgIH1cbiAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIHRoaXMuX2xvY2FsQm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJvdGF0aW9uIGluIHJhZGlhbnNcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0Um90YXRpb24gKCkgeyByZXR1cm4gdGhpcy5fcm90YXRpb24gfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgb2JqZWN0J3Mgcm90YXRpb24gKGluIHJhZGlhbnMpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuICAgKi9cbiAgc2V0Um90YXRpb24gKHJvdGF0aW9uKSB7XG4gICAgdGhpcy5fcm90YXRpb24gPSByb3RhdGlvblxuICAgIHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgdGhpcy5fbG9jYWxCb3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYWxwaGEgKDAuLi4xKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRBbHBoYSAoKSB7IHJldHVybiB0aGlzLl9hbHBoYSB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFscGhhICgwLi4uMSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhXG4gICAqL1xuICBzZXRBbHBoYSAoYWxwaGEpIHsgdGhpcy5fYWxwaGEgPSBhbHBoYSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIGFscGhhIG9mIHRoaXMgRGlzcGxheU9iamVjdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRXb3JsZEFscGhhICgpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50LmdldEFscGhhKCkgKiB0aGlzLl9hbHBoYVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWxwaGFcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB3b3JsZCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5NYXRyaXh9XG4gICAqL1xuICBnZXRXb3JsZFRyYW5zZm9ybSAoKSB7IHJldHVybiB0aGlzLl93b3JsZFRyYW5zZm9ybSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvYmplY3RcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkRpc3BsYXlPYmplY3R9XG4gICAqL1xuICBnZXRQYXJlbnQgKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50IH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG9iamVjdCdzIHBhcmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gcGFyZW50XG4gICAqL1xuICBzZXRQYXJlbnQgKHBhcmVudCkgeyB0aGlzLl9wYXJlbnQgPSBwYXJlbnQgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXIgcmVjdGFuZ2xlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfSByZWN0YW5nbGVcbiAgICovXG4gIGdldEZpbHRlclJlY3RhbmdsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlclJlY3RhbmdsZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbHRlciByZWN0YW5nbGVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX0gcmVjdGFuZ2xlXG4gICAqL1xuICBzZXRGaWx0ZXJSZWN0YW5nbGUgKHJlY3RhbmdsZSkge1xuICAgIHRoaXMuX2ZpbHRlclJlY3RhbmdsZS5jb3B5KHJlY3RhbmdsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbnQgY29sb3JcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VGludCAoKSB7IHJldHVybiB0aGlzLl90aW50IH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGludCBjb2xvclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGludFxuICAgKi9cbiAgc2V0VGludCAodGludCkgeyB0aGlzLl90aW50ID0gdGludCB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIGN1cnJlbnRseSB2aXNpYmxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGlzVmlzaWJsZSAoKSB7IHJldHVybiB0aGlzLl92aXNpYmxlIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG9iamVjdCdzIHZpc2liaWxpdHlcbiAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlXG4gICAqL1xuICBzZXRWaXNpYmxlICh2aXNpYmxlKSB7IHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlzcGxheU9iamVjdFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL2Rpc3BsYXkvZGlzcGxheS1vYmplY3QuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IExvZywgQ29uc3RhbnRzIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBDb25maWd1cmFibGUgZnJvbSAnLi4vLi4vbGliL2NvbmZpZ3VyYWJsZSdcbmltcG9ydCBTaGFkZXIgZnJvbSAnLi4vc2hhZGVycy9zaGFkZXInXG5pbXBvcnQgVGV4dHVyZVNoYWRlciBmcm9tICcuLi9zaGFkZXJzL3RleHR1cmUtc2hhZGVyJ1xuY29uc3QgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSwgUmVuZGVyZXJUeXBlIH0gPSBDb25zdGFudHNcblxuLyoqXG4gKiBBIGZpbHRlciBjYW4gYmUgYXR0YWNoZWQgdG8gYSBEaXNwbGF5T2JqZWN0IGFuZCBhZmZlY3RzIHRoZSB3YXkgaXQgaXMgZGlzcGxheWVkLlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5Db25maWd1cmFibGVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuY2xhc3MgRmlsdGVyIGV4dGVuZHMgQ29uZmlndXJhYmxlIHtcbiAgLyoqXG4gICAqIEdvZXMgdGhyb3VnaCB0aGUgYXZhaWxhYmxlIG9wdGlvbnMsIHNldHMgX29wdGlvbnMgZGVmYXVsdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPcHRpb25zXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfaW5pdE9wdGlvbnMgKHVzZXJPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9zaGFkZXJzID0gW11cbiAgICB0aGlzLl9hdmFpbGFibGVVbmlmb3JtcyA9IFRleHR1cmVTaGFkZXIuZGVmYXVsdFVuaWZvcm1zXG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IFRleHR1cmVTaGFkZXIuZGVmYXVsdEF0dHJpYnV0ZXNcbiAgICB0aGlzLl92ZXJ0ZXhTb3VyY2UgPSBUZXh0dXJlU2hhZGVyLmRlZmF1bHRWZXJ0ZXhTb3VyY2VcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IFRleHR1cmVTaGFkZXIuZGVmYXVsdEZyYWdtZW50U291cmNlXG5cbiAgICB0aGlzLl9pbml0VW5pZm9ybXMoKVxuICAgIHN1cGVyLl9pbml0T3B0aW9ucyh1c2VyT3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgdW5pZm9ybXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0VW5pZm9ybXMgKCkge1xuICAgIHRoaXMuX3VuaWZvcm1zID0ge31cbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX2F2YWlsYWJsZVVuaWZvcm1zKSB7XG4gICAgICBjb25zdCB1bmlmb3JtID0gdGhpcy5fYXZhaWxhYmxlVW5pZm9ybXNbbmFtZV1cbiAgICAgIHRoaXMuX3VuaWZvcm1zW25hbWVdID0ge1xuICAgICAgICB0eXBlOiB1bmlmb3JtLnR5cGUsXG4gICAgICAgIHZhbHVlOiB1bmlmb3JtLmRlZmF1bHQgfHwgbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wdGlvbnMgYXJlIGFsc28gdHVybmVkIGludG8gdW5pZm9ybXNcbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHRoaXMuYXZhaWxhYmxlT3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uQ29uZmlnID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdXG5cbiAgICAgIGlmICghb3B0aW9uQ29uZmlnLnVuaWZvcm1UeXBlKSB7XG4gICAgICAgIExvZy50cmFjZSh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIGBPcHRpb24gXFxgJHtvcHRpb25OYW1lfVxcYCBpcyBtaXNzaW5nIGEgXFxgdW5pZm9ybVR5cGVcXGAhYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zW2B1XyR7b3B0aW9uTmFtZX1gXSA9IHtcbiAgICAgICAgICB0eXBlOiBvcHRpb25Db25maWcudW5pZm9ybVR5cGUsXG4gICAgICAgICAgdmFsdWU6IG9wdGlvbkNvbmZpZy5kZWZhdWx0IHx8IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9wdGlvbiwgdmFsaWRhdGVzIGl0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25OYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSB1cGRhdGUgPSB0cnVlXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0T3B0aW9uIChvcHRpb25OYW1lLCB2YWx1ZSwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIHN1cGVyLnNldE9wdGlvbihvcHRpb25OYW1lLCB2YWx1ZSwgdXBkYXRlKVxuXG4gICAgbGV0IHVuaWZvcm1WYWx1ZSA9IHZhbHVlXG4gICAgY29uc3Qgb3B0aW9uQ29uZmlnID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdXG5cbiAgICBpZiAoIW9wdGlvbkNvbmZpZy51bmlmb3JtVHlwZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHVuaWZvcm1OYW1lID0gYHVfJHtvcHRpb25OYW1lfWBcblxuICAgIHN3aXRjaCAob3B0aW9uQ29uZmlnLnR5cGUpIHtcbiAgICAgIGNhc2UgT3B0aW9uVHlwZS5DT0xPUjpcbiAgICAgICAgaWYgKG9wdGlvbkNvbmZpZy51bmlmb3JtVHlwZSA9PT0gVW5pZm9ybVR5cGUuRkxPQVQ0KSB7XG4gICAgICAgICAgdW5pZm9ybVZhbHVlID0gdmFsdWUudG9HTENvbG9yKClcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25Db25maWcudW5pZm9ybVR5cGUgPT09IFVuaWZvcm1UeXBlLkZMT0FUMykge1xuICAgICAgICAgIHVuaWZvcm1WYWx1ZSA9IHZhbHVlLnRvUkdCR0xDb2xvcigpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgT3B0aW9uVHlwZS5WRUNUT1IyOlxuICAgICAgICB1bmlmb3JtVmFsdWUgPSBbdmFsdWUueCwgdmFsdWUueV1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgT3B0aW9uVHlwZS5DT0xPUl9NQVRSSVg6XG4gICAgICAgIC8vIGEgY29sb3IgbWF0cml4IHNwbGl0cyBpbnRvIDR4NCBtYXRyaXggYW5kIHRyYW5sYXRpb24gdmVjdG9yXG4gICAgICAgIHVuaWZvcm1WYWx1ZSA9IFt2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLFxuICAgICAgICAgIHZhbHVlLmYsIHZhbHVlLmcsIHZhbHVlLmgsIHZhbHVlLmksXG4gICAgICAgICAgdmFsdWUuaywgdmFsdWUubCwgdmFsdWUubSwgdmFsdWUubixcbiAgICAgICAgICB2YWx1ZS5wLCB2YWx1ZS5xLCB2YWx1ZS5yLCB2YWx1ZS5zXVxuICAgICAgICBsZXQgdmVjdG9yVmFsdWUgPSBbdmFsdWUuZSwgdmFsdWUuaiwgdmFsdWUubywgdmFsdWUudF1cbiAgICAgICAgdGhpcy5fdW5pZm9ybXNbdW5pZm9ybU5hbWUgKyAnX3ZlYyddID0ge1xuICAgICAgICAgIHZhbHVlOiB2ZWN0b3JWYWx1ZSxcbiAgICAgICAgICB0eXBlOiBVbmlmb3JtVHlwZS5GTE9BVDRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0VW5pZm9ybSh1bmlmb3JtTmFtZSwgdW5pZm9ybVZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIHVuaWZvcm0gdG8gdGhlIGdpdmVuIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBzeW5jID0gZmFsc2VcbiAgICovXG4gIHNldFVuaWZvcm0gKG5hbWUsIHZhbHVlLCBzeW5jID0gZmFsc2UpIHtcbiAgICB0aGlzLl91bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gdW5pZm9ybXMgdG8gdGhlaXIgdmFsdWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgdW5pZm9ybXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBzeW5jID0gZmFsc2VcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHNldFVuaWZvcm1zICh1bmlmb3Jtcywgc3luYyA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB1bmlmb3Jtcykge1xuICAgICAgdGhpcy5fdW5pZm9ybXNbbmFtZV0udmFsdWUgPSB1bmlmb3Jtc1tuYW1lXVxuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgdGhpcy5zeW5jVW5pZm9ybShuYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgdGhlIHVuaWZvcm0gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHN5bmNVbmlmb3JtIChuYW1lKSB7XG4gICAgdGhpcy5fc2hhZGVycy5mb3JFYWNoKChzaGFkZXIpID0+IHtcbiAgICAgIHNoYWRlci5zeW5jVW5pZm9ybShuYW1lKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25pemVzIGFsbCB1bmlmb3JtcyB3aXRoIFdlYkdMXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBzeW5jVW5pZm9ybXMgKCkge1xuICAgIHRoaXMuX3NoYWRlcnMuZm9yRWFjaCgoc2hhZGVyKSA9PiB7XG4gICAgICBzaGFkZXIuc3luY1VuaWZvcm1zKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNoYWRlciBmb3IgdGhlIGdpdmVuIHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU2hhZGVyfVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0U2hhZGVyRm9yUmVuZGVyZXIgKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICBsZXQgc2hhZGVyID0gdGhpcy5fc2hhZGVyc1tnbC5pZF1cblxuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICBzaGFkZXIgPSBuZXcgU2hhZGVyKHJlbmRlcmVyLFxuICAgICAgICB0aGlzLl92ZXJ0ZXhTb3VyY2UsXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U291cmNlLFxuICAgICAgICB0aGlzLl91bmlmb3JtcyxcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlc1xuICAgICAgKVxuXG4gICAgICB0aGlzLl9zaGFkZXJzW2dsLmlkXSA9IHNoYWRlclxuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqL1xuICBhcHBseSAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKSkge1xuICAgICAgdGhpcy5fYXBwbHlXZWJHTChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIpXG4gICAgfSBlbHNlIGlmIChyZW5kZXJlci5pc09mVHlwZShSZW5kZXJlclR5cGUuQ0FOVkFTKSkge1xuICAgICAgdGhpcy5fYXBwbHlDYW52YXMocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBXZWJHTFJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuV2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF9hcHBseVdlYkdMIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5nZXRTaGFkZXJGb3JSZW5kZXJlcihyZW5kZXJlcilcblxuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChvdXRwdXRUYXJnZXQpXG4gICAgaWYgKGNsZWFyKSB7XG4gICAgICBvdXRwdXRUYXJnZXQuY2xlYXIoKVxuICAgIH1cblxuICAgIHJlbmRlcmVyLnNldFNoYWRlcihzaGFkZXIpXG5cbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gcmVuZGVyZXIuZ2V0Q3VycmVudFJlbmRlclRhcmdldCgpLmdldFByb2plY3Rpb25NYXRyaXgoKS50b0FycmF5KClcbiAgICBzaGFkZXIuc2V0VW5pZm9ybSgndV9wcm9qTWF0cml4JywgcHJvamVjdGlvbk1hdHJpeClcbiAgICBzaGFkZXIuc3luY1VuaWZvcm1zKClcblxuICAgIC8vIFJlbmRlciFcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0VGFyZ2V0LmdldFRleHR1cmUoKSlcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDYW52YXMgKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhciA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnYF9hcHBseUNhbnZhc2AgaXMgbm90IGltcGxlbWVudGVkLiBKdXN0IGNvcHlpbmcgaW1hZ2UgZGF0YSBmcm9tIGBpbnB1dFRhcmdldGAgdG8gYG91dHB1dFRhcmdldGAuJylcblxuICAgIG91dHB1dENvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICBvdXRwdXRDb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIDAsIDApXG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBGaWx0ZXJcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHRoaXMuX3NoYWRlcnMuZm9yRWFjaCgoc2hhZGVyKSA9PiBzaGFkZXIuZGlzcG9zZSgpKVxuICAgIHRoaXMuX3NoYWRlcnMgPSBbXVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL2ZpbHRlcnMvZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IENhbnZhc1JlbmRlclRhcmdldCBmcm9tICcuLi91dGlscy9jYW52YXMtcmVuZGVyLXRhcmdldCdcblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBmaWx0ZXJzIGZvciBhIHtAbGluayBQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyZXJ9XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuY2xhc3MgQ2FudmFzRmlsdGVyTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yIChyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXJcbiAgICB0aGlzLl9maWx0ZXJTdGFjayA9IFt7XG4gICAgICByZW5kZXJUYXJnZXQ6IHJlbmRlcmVyLmdldEN1cnJlbnRSZW5kZXJUYXJnZXQoKSxcbiAgICAgIGZpbHRlcnM6IFtdXG4gICAgfV1cblxuICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IG51bGxcbiAgICB0aGlzLl90ZXh0dXJlcyA9IFtdXG4gICAgdGhpcy5fdGV4dHVyZUZyYW1lID0gbmV3IFJlY3RhbmdsZShcbiAgICAgIDAsIDAsXG4gICAgICByZW5kZXJlci5nZXRXaWR0aCgpLCByZW5kZXJlci5nZXRIZWlnaHQoKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoaXMgRmlsdGVyTWFuYWdlciBhbmQgaXRzIHRleHR1cmVzIHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLl90ZXh0dXJlRnJhbWUud2lkdGggPSBkaW1lbnNpb25zLnhcbiAgICB0aGlzLl90ZXh0dXJlRnJhbWUuaGVpZ2h0ID0gZGltZW5zaW9ucy55XG5cbiAgICB0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLnJlc2l6ZVRvKGRpbWVuc2lvbnMpKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2hlcyB0aGUgZ2l2ZW4gZmlsdGVycyB0byB0aGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtICB7QXJyYXkuPEZpbHRlcj59IGZpbHRlcnNcbiAgICovXG4gIHB1c2hGaWx0ZXJzIChkaXNwbGF5T2JqZWN0LCBmaWx0ZXJzKSB7XG4gICAgY29uc3QgYm91bmRzID0gZGlzcGxheU9iamVjdC5nZXRCb3VuZHMoKVxuICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IGJvdW5kc1xuXG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5fZ2V0T3JDcmVhdGVSZW5kZXJUYXJnZXQoKVxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpXG4gICAgdGhpcy5fZmlsdGVyU3RhY2sucHVzaCh7IHJlbmRlclRhcmdldCwgZmlsdGVycyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMsIGFwcGxpZXMgYW5kIHJldHVybnMgdGhlIGxhc3QgZmlsdGVycyBmcm9tIHRoZSBzdGFja1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBwb3BGaWx0ZXJzICgpIHtcbiAgICBjb25zdCB7IGZpbHRlcnMsIHJlbmRlclRhcmdldCB9ID0gdGhpcy5fZmlsdGVyU3RhY2sucG9wKClcbiAgICBjb25zdCBsYXN0RmlsdGVyID0gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2subGVuZ3RoIC0gMV1cblxuICAgIGNvbnN0IGlucHV0UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0XG4gICAgY29uc3Qgb3V0cHV0UmVuZGVyVGFyZ2V0ID0gbGFzdEZpbHRlci5yZW5kZXJUYXJnZXRcblxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsdGVyc1swXS5hcHBseSh0aGlzLl9yZW5kZXJlciwgaW5wdXRSZW5kZXJUYXJnZXQsIG91dHB1dFJlbmRlclRhcmdldClcbiAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2goaW5wdXRSZW5kZXJUYXJnZXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FwcGx5RmlsdGVycyhmaWx0ZXJzLCBpbnB1dFJlbmRlclRhcmdldCwgb3V0cHV0UmVuZGVyVGFyZ2V0KVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyc1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIGZpbHRlcnMgdG8gdGhlIGdpdmVuIGlucHV0UmVuZGVyVGFyZ2V0IGFuZCBvdXRwdXRzXG4gICAqIHRoZSBmaWx0ZXJlZCBjb250ZW50IHRvIHRoZSBvdXRwdXRSZW5kZXJUYXJnZXRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkZpbHRlcltdfSBmaWx0ZXJzXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5DYW52YXNSZW5kZXJUYXJnZXR9IGlucHV0UmVuZGVyVGFyZ2V0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5DYW52YXNSZW5kZXJUYXJnZXR9IG91dHB1dFJlbmRlclRhcmdldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5RmlsdGVycyAoZmlsdGVycywgaW5wdXRSZW5kZXJUYXJnZXQsIG91dHB1dFJlbmRlclRhcmdldCkge1xuICAgIGxldCBmbGlwUmVuZGVyVGFyZ2V0ID0gaW5wdXRSZW5kZXJUYXJnZXRcbiAgICBsZXQgZmxvcFJlbmRlclRhcmdldCA9IHRoaXMuX2dldE9yQ3JlYXRlUmVuZGVyVGFyZ2V0KHRydWUpXG5cbiAgICBjb25zdCBsYXN0RmlsdGVyID0gZmlsdGVyc1tmaWx0ZXJzLmxlbmd0aCAtIDFdXG4gICAgZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIsIGkpID0+IHtcbiAgICAgIGNvbnN0IGlzTGFzdEZpbHRlciA9IGZpbHRlciA9PT0gbGFzdEZpbHRlclxuXG4gICAgICBpZiAoIWlzTGFzdEZpbHRlcikge1xuICAgICAgICAvLyBSZW5kZXIgZnJvbSBmbGlwIHRvIGZsb3Agd2l0aCBmaWx0ZXJcbiAgICAgICAgZmlsdGVyLmFwcGx5KHRoaXMuX3JlbmRlcmVyLCBmbGlwUmVuZGVyVGFyZ2V0LCBmbG9wUmVuZGVyVGFyZ2V0KVxuXG4gICAgICAgIC8vIEZsaXAgdGhlIHJlbmRlciBidWZmZXJzXG4gICAgICAgIGxldCB0ZW1wID0gZmxpcFJlbmRlclRhcmdldFxuICAgICAgICBmbGlwUmVuZGVyVGFyZ2V0ID0gZmxvcFJlbmRlclRhcmdldFxuICAgICAgICBmbG9wUmVuZGVyVGFyZ2V0ID0gdGVtcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVuZGVyIHRvIG91dHB1dFxuICAgICAgICBmaWx0ZXIuYXBwbHkodGhpcy5fcmVuZGVyZXIsIGZsaXBSZW5kZXJUYXJnZXQsIG91dHB1dFJlbmRlclRhcmdldClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gUHVzaCB0aGUgdGV4dHVyZXMgYmFjayBpbnRvIHRoZSB0ZXh0dXJlIHBvb2wgdG8gdXNlIHRoZW0gYWdhaW4gbGF0ZXJcbiAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKGZsaXBSZW5kZXJUYXJnZXQpXG4gICAgdGhpcy5fdGV4dHVyZXMucHVzaChmbG9wUmVuZGVyVGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZW5kZXIgYnVmZmVyIGZyb20gdGhlIHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmVcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXJcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRleHR1cmV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0T3JDcmVhdGVSZW5kZXJUYXJnZXQgKGNsZWFyKSB7XG4gICAgbGV0IHJlbmRlclRhcmdldCA9IHRoaXMuX3RleHR1cmVzLnBvcCgpXG4gICAgaWYgKCFyZW5kZXJUYXJnZXQpIHtcbiAgICAgIHJlbmRlclRhcmdldCA9IG5ldyBDYW52YXNSZW5kZXJUYXJnZXQodGhpcy5fdGV4dHVyZUZyYW1lLndpZHRoLFxuICAgICAgICB0aGlzLl90ZXh0dXJlRnJhbWUuaGVpZ2h0LFxuICAgICAgICAxKVxuICAgIH1cblxuICAgIGlmIChjbGVhcikge1xuICAgICAgcmVuZGVyVGFyZ2V0LmNsZWFyKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsdGVyIHN0YWNrIHRvIHRoZSBnaXZlbiBzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdFtdfSBmaWx0ZXJTdGFja1xuICAgKi9cbiAgc2V0RmlsdGVyU3RhY2sgKGZpbHRlclN0YWNrKSB7XG4gICAgdGhpcy5fZmlsdGVyU3RhY2sgPSBmaWx0ZXJTdGFja1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgQ2FudmFzRmlsdGVyTWFuYWdlclxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNGaWx0ZXJNYW5hZ2VyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvbWFuYWdlcnMvY2FudmFzLWZpbHRlci1tYW5hZ2VyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWN0YW5nbGUsIENvbnN0YW50cyB9IGZyb20gJy4uL2dsb2JhbHMnXG5jb25zdCB7IFJlbmRlcmVyVHlwZSB9ID0gQ29uc3RhbnRzXG5pbXBvcnQgV2ViR0xSZW5kZXJUYXJnZXQgZnJvbSAnLi4vdXRpbHMvd2ViZ2wtcmVuZGVyLXRhcmdldCdcbmltcG9ydCBRdWFkIGZyb20gJy4uL3V0aWxzL3F1YWQnXG5cbi8qKlxuICogTWFuYWdlcyB0aGUgZmlsdGVycyBmb3IgYSB7QGxpbmsgUGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyZXJ9XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIFdlYkdMRmlsdGVyTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yIChyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXJcbiAgICB0aGlzLl9maWx0ZXJTdGFjayA9IFt7XG4gICAgICBmaWx0ZXJzOiBbXVxuICAgIH1dXG5cbiAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSBudWxsXG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0cyA9IFtdXG4gICAgdGhpcy5fdGV4dHVyZUZyYW1lID0gbmV3IFJlY3RhbmdsZSgwLCAwLCByZW5kZXJlci5nZXRXaWR0aCgpLCByZW5kZXJlci5nZXRIZWlnaHQoKSlcblxuICAgIHRoaXMuX29uQ29udGV4dENoYW5nZSA9IHRoaXMuX29uQ29udGV4dENoYW5nZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVuZGVyZXIub24oJ2NvbnRleHQnLCB0aGlzLl9vbkNvbnRleHRDaGFuZ2UpXG5cbiAgICAvLyBJbml0aWFsIGNvbnRleHRcbiAgICB0aGlzLl9vbkNvbnRleHRDaGFuZ2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhpcyBGaWx0ZXJNYW5hZ2VyIGFuZCBpdHMgdGV4dHVyZXMgdG8gdGhlIGdpdmVuIGRpbWVuc2lvbnNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBkaW1lbnNpb25zXG4gICAqL1xuICByZXNpemVUbyAoZGltZW5zaW9ucykge1xuICAgIHRoaXMuX3RleHR1cmVGcmFtZS53aWR0aCA9IGRpbWVuc2lvbnMueFxuICAgIHRoaXMuX3RleHR1cmVGcmFtZS5oZWlnaHQgPSBkaW1lbnNpb25zLnlcblxuICAgIHRoaXMuX3JlbmRlclRhcmdldHMuZm9yRWFjaCgodGV4dHVyZSkgPT4gdGV4dHVyZS5yZXNpemVUbyhkaW1lbnNpb25zKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXIgc3RhY2tcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRGaWx0ZXJTdGFjayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlclN0YWNrXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsdGVyIHN0YWNrIHRvIHRoZSBnaXZlbiBzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdFtdfSBmaWx0ZXJTdGFja1xuICAgKi9cbiAgc2V0RmlsdGVyU3RhY2sgKGZpbHRlclN0YWNrKSB7XG4gICAgdGhpcy5fZmlsdGVyU3RhY2sgPSBmaWx0ZXJTdGFja1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZW5kZXIgdGFyZ2V0IGZyb20gdGhlIHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmVcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXJcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyVGFyZ2V0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE9yQ3JlYXRlUmVuZGVyVGFyZ2V0IChjbGVhcikge1xuICAgIGxldCByZW5kZXJUYXJnZXQgPSB0aGlzLl9yZW5kZXJUYXJnZXRzLnBvcCgpXG4gICAgaWYgKCFyZW5kZXJUYXJnZXQpIHtcbiAgICAgIHJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCh0aGlzLl9yZW5kZXJlcixcbiAgICAgICAgdGhpcy5fdGV4dHVyZUZyYW1lLndpZHRoLFxuICAgICAgICB0aGlzLl90ZXh0dXJlRnJhbWUuaGVpZ2h0LFxuICAgICAgICAxKVxuICAgIH1cbiAgICByZW5kZXJUYXJnZXQuc2V0RnJhbWUodGhpcy5fY3VycmVudEZyYW1lKVxuXG4gICAgaWYgKGNsZWFyKSB7XG4gICAgICByZW5kZXJUYXJnZXQuY2xlYXIoKVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJUYXJnZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoZXMgdGhlIGdpdmVuIGZpbHRlcnMgdG8gdGhlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5GaWx0ZXJbXX0gZmlsdGVyc1xuICAgKi9cbiAgcHVzaEZpbHRlcnMgKGRpc3BsYXlPYmplY3QsIGZpbHRlcnMpIHtcbiAgICBjb25zdCBib3VuZHMgPSBkaXNwbGF5T2JqZWN0LmdldEJvdW5kcygpXG4gICAgdGhpcy5fY3VycmVudEZyYW1lID0gYm91bmRzXG5cbiAgICBjb25zdCBmaWx0ZXJSZWN0YW5nbGUgPSBkaXNwbGF5T2JqZWN0LmdldEZpbHRlclJlY3RhbmdsZSgpXG4gICAgaWYgKGZpbHRlclJlY3RhbmdsZS53aWR0aCA+IDAgJiYgZmlsdGVyUmVjdGFuZ2xlLmhlaWdodCA+IDApIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IGZpbHRlclJlY3RhbmdsZVxuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMuX2dldE9yQ3JlYXRlUmVuZGVyVGFyZ2V0KClcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KVxuICAgIHJlbmRlclRhcmdldC5jbGVhcigpXG5cbiAgICB0aGlzLl9maWx0ZXJTdGFjay5wdXNoKHsgcmVuZGVyVGFyZ2V0LCBmaWx0ZXJzIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcywgYXBwbGllcyBhbmQgcmV0dXJucyB0aGUgbGFzdCBmaWx0ZXJzIGZyb20gdGhlIHN0YWNrXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHBvcEZpbHRlcnMgKCkge1xuICAgIGNvbnN0IHsgZmlsdGVycywgcmVuZGVyVGFyZ2V0IH0gPSB0aGlzLl9maWx0ZXJTdGFjay5wb3AoKVxuICAgIGNvbnN0IGxhc3RGaWx0ZXIgPSB0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFjay5sZW5ndGggLSAxXVxuXG4gICAgY29uc3QgaW5wdXRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRcbiAgICBjb25zdCBvdXRwdXRSZW5kZXJUYXJnZXQgPSBsYXN0RmlsdGVyLnJlbmRlclRhcmdldFxuXG4gICAgLy8gVXBkYXRlIHRoZSBRdWFkJ3MgYnVmZmVyc1xuICAgIHRoaXMuX3F1YWQubWFwKHRoaXMuX3RleHR1cmVGcmFtZSwgaW5wdXRSZW5kZXJUYXJnZXQuZ2V0RnJhbWUoKSlcblxuICAgIGNvbnN0IHNoYWRlciA9IGZpbHRlcnNbMF0uZ2V0U2hhZGVyRm9yUmVuZGVyZXIodGhpcy5fcmVuZGVyZXIpXG4gICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5fcXVhZC5nZXRWZXJ0ZXhCdWZmZXIoKVxuICAgIGNvbnN0IGluZGV4QnVmZmVyID0gdGhpcy5fcXVhZC5nZXRJbmRleEJ1ZmZlcigpXG5cbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXIpXG5cbiAgICBjb25zdCBhdHRyaWJ1dGVMb2NhdGlvbnMgPSBzaGFkZXIuZ2V0QXR0cmlidXRlTG9jYXRpb25zKClcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJpYnV0ZUxvY2F0aW9ucy5hX3Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGVMb2NhdGlvbnMuYV90ZXhDb29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAyICogNCAqIDQpXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGVMb2NhdGlvbnMuYV9jb2xvciwgNCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCA0ICogNCAqIDQpXG5cbiAgICB0aGlzLl9yZW5kZXJlci51cGRhdGVUZXh0dXJlKGlucHV0UmVuZGVyVGFyZ2V0LmdldEJhc2VUZXh0dXJlKCksIGZhbHNlKVxuXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBmaWx0ZXJzWzBdLmFwcGx5KHRoaXMuX3JlbmRlcmVyLCBpbnB1dFJlbmRlclRhcmdldCwgb3V0cHV0UmVuZGVyVGFyZ2V0KVxuICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0cy5wdXNoKGlucHV0UmVuZGVyVGFyZ2V0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hcHBseUZpbHRlcnMoZmlsdGVycywgaW5wdXRSZW5kZXJUYXJnZXQsIG91dHB1dFJlbmRlclRhcmdldClcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdGVyc1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIGZpbHRlcnMgdG8gdGhlIGdpdmVuIGlucHV0UmVuZGVyVGFyZ2V0IGFuZCBvdXRwdXRzXG4gICAqIHRoZSBmaWx0ZXJlZCBjb250ZW50IHRvIHRoZSBvdXRwdXRSZW5kZXJUYXJnZXRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkZpbHRlcltdfSBmaWx0ZXJzXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlclRhcmdldH0gaW5wdXRSZW5kZXJUYXJnZXRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRSZW5kZXJUYXJnZXRcbiAgICovXG4gIF9hcHBseUZpbHRlcnMgKGZpbHRlcnMsIGlucHV0UmVuZGVyVGFyZ2V0LCBvdXRwdXRSZW5kZXJUYXJnZXQpIHtcbiAgICBsZXQgZmxpcFJlbmRlclRhcmdldCA9IGlucHV0UmVuZGVyVGFyZ2V0XG4gICAgbGV0IGZsb3BSZW5kZXJUYXJnZXQgPSB0aGlzLl9nZXRPckNyZWF0ZVJlbmRlclRhcmdldCh0cnVlKVxuXG4gICAgdGhpcy5fcmVuZGVyZXIudXBkYXRlVGV4dHVyZShmbG9wUmVuZGVyVGFyZ2V0LmdldEJhc2VUZXh0dXJlKCksIGZhbHNlKVxuXG4gICAgY29uc3QgbGFzdEZpbHRlciA9IGZpbHRlcnNbZmlsdGVycy5sZW5ndGggLSAxXVxuICAgIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyLCBpKSA9PiB7XG4gICAgICBjb25zdCBpc0xhc3RGaWx0ZXIgPSBmaWx0ZXIgPT09IGxhc3RGaWx0ZXJcblxuICAgICAgaWYgKCFpc0xhc3RGaWx0ZXIpIHtcbiAgICAgICAgLy8gUmVuZGVyIGZyb20gZmxpcCB0byBmbG9wIHdpdGggZmlsdGVyXG4gICAgICAgIGZpbHRlci5hcHBseSh0aGlzLl9yZW5kZXJlciwgZmxpcFJlbmRlclRhcmdldCwgZmxvcFJlbmRlclRhcmdldClcblxuICAgICAgICAvLyBGbGlwIHRoZSByZW5kZXIgdGFyZ2V0c1xuICAgICAgICBsZXQgdGVtcCA9IGZsaXBSZW5kZXJUYXJnZXRcbiAgICAgICAgZmxpcFJlbmRlclRhcmdldCA9IGZsb3BSZW5kZXJUYXJnZXRcbiAgICAgICAgZmxvcFJlbmRlclRhcmdldCA9IHRlbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbmRlciB0byBvdXRwdXRcbiAgICAgICAgZmlsdGVyLmFwcGx5KHRoaXMuX3JlbmRlcmVyLCBmbGlwUmVuZGVyVGFyZ2V0LCBvdXRwdXRSZW5kZXJUYXJnZXQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFB1c2ggdGhlIHRleHR1cmVzIGJhY2sgaW50byB0aGUgdGV4dHVyZSBwb29sIHRvIHVzZSB0aGVtIGFnYWluIGxhdGVyXG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0cy5wdXNoKGZsaXBSZW5kZXJUYXJnZXQpXG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0cy5wdXNoKGZsb3BSZW5kZXJUYXJnZXQpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgV2ViR0wgY29udGV4dCBoYXMgYmVlbiBjaGFuZ2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db250ZXh0Q2hhbmdlICgpIHtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXRzLmxlbmd0aCA9IDBcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0aGlzLl9yZW5kZXJlci5pc09mVHlwZShSZW5kZXJlclR5cGUuV0VCR0wpKSB7XG4gICAgICBpZiAodGhpcy5fcXVhZCkgeyB0aGlzLl9xdWFkLmRpc3Bvc2UoKSB9XG4gICAgICB0aGlzLl9xdWFkID0gbmV3IFF1YWQodGhpcy5fcmVuZGVyZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgV2ViR0xGaWx0ZXJNYW5hZ2VyXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5vZmYoJ2NvbnRleHQnLCB0aGlzLl9vbkNvbnRleHRDaGFuZ2UpXG4gICAgaWYgKHRoaXMuX3F1YWQpIHtcbiAgICAgIHRoaXMuX3F1YWQuZGlzcG9zZSgpXG4gICAgfVxuICAgIHRoaXMuX3JlbmRlclRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB7XG4gICAgICB0YXJnZXQuZGlzcG9zZSgpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJHTEZpbHRlck1hbmFnZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS9tYW5hZ2Vycy93ZWJnbC1maWx0ZXItbWFuYWdlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEdsb2JhbHMgZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCB7IFVuaWZvcm1UeXBlIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJ1xuY29uc3QgeyBMb2csIFV0aWxzIH0gPSBHbG9iYWxzXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIFdlYkdMIHNoYWRlciB3aXRoIGEgdmVydGV4IHNoYWRlciwgYSBmcmFnbWVudCBzaGFkZXIsIHVuaWZvcm1zIGFuZCBhdHRyaWJ1dGVzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIFNoYWRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2hhZGVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdmVydGV4U291cmNlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZnJhZ21lbnRTb3VyY2VcbiAgICogQHBhcmFtICB7T2JqZWN0fSB1bmlmb3Jtc1xuICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gYXR0cmlidXRlc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHJlbmRlcmVyLCB2ZXJ0ZXhTb3VyY2UsIGZyYWdtZW50U291cmNlLCB1bmlmb3JtcywgYXR0cmlidXRlcykge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXJcbiAgICB0aGlzLl92ZXJ0ZXhTb3VyY2UgPSB2ZXJ0ZXhTb3VyY2VcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlXG4gICAgdGhpcy5fdW5pZm9ybXMgPSB1bmlmb3JtcyB8fCB7fVxuICAgIHRoaXMuX3VuaWZvcm1Mb2NhdGlvbnMgPSB7fVxuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IFtdXG4gICAgdGhpcy5fYXR0cmlidXRlTG9jYXRpb25zID0ge31cblxuICAgIHRoaXMuX29uQ29udGV4dENoYW5nZSA9IHRoaXMuX29uQ29udGV4dENoYW5nZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVuZGVyZXIub24oJ2NvbnRleHQnLCB0aGlzLl9vbkNvbnRleHRDaGFuZ2UpXG5cbiAgICB0aGlzLl9pbml0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlcyB0aGlzIHNoYWRlciBhbmQgY2FjaGVzIHRoZSB1bmlmb3JtIGxvY2F0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQgKCkge1xuICAgIHRoaXMuX2NvbXBpbGUoKVxuXG4gICAgY29uc3QgZ2wgPSB0aGlzLl9yZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICBnbC51c2VQcm9ncmFtKHRoaXMuX3Byb2dyYW0pXG5cbiAgICB0aGlzLl9jYWNoZVVuaWZvcm1Mb2NhdGlvbnMoKVxuICAgIHRoaXMuX2NhY2hlQXR0cmlidXRlTG9jYXRpb25zKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBhdHRhY2hlZCBSZW5kZXJlciBjaGFuZ2VzIGl0cyBjb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db250ZXh0Q2hhbmdlICgpIHtcbiAgICB0aGlzLl9pbml0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgZ2l2ZW4gYnVmZmVycyBmb3IgdGhpcyBzaGFkZXJcbiAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gdmVydGV4QnVmZmVyXG4gICAqIEBwYXJhbSB7V2ViR0xCdWZmZXJ9IGluZGV4QnVmZmVyXG4gICAqL1xuICBzZXR1cEJ1ZmZlcnMgKHZlcnRleEJ1ZmZlciwgaW5kZXhCdWZmZXIpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXIpXG5cbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYnV0ZUxvY2F0aW9ucy5hX3Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIEdsb2JhbHMuVkVSVEVYX0JZVEVfU0laRSwgMClcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYnV0ZUxvY2F0aW9ucy5hX3RleENvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIEdsb2JhbHMuVkVSVEVYX0JZVEVfU0laRSwgMiAqIDQpXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWJ1dGVMb2NhdGlvbnMuYV9jb2xvciwgNCwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgR2xvYmFscy5WRVJURVhfQllURV9TSVpFLCA0ICogNClcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgYWxsIHVuaWZvcm1zIHdpdGggV2ViR0xcbiAgICovXG4gIHN5bmNVbmlmb3JtcyAoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fdW5pZm9ybXMpXG4gICAgICAuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHRoaXMuc3luY1VuaWZvcm0oa2V5KVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgdGhlIHVuaWZvcm0gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIHN5bmNVbmlmb3JtIChuYW1lKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9yZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICBjb25zdCB1bmlmb3JtID0gdGhpcy5fdW5pZm9ybXNbbmFtZV1cbiAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX3VuaWZvcm1Mb2NhdGlvbnNbbmFtZV1cbiAgICBzd2l0Y2ggKHVuaWZvcm0udHlwZSkge1xuICAgICAgY2FzZSBVbmlmb3JtVHlwZS5TQU1QTEVSMkQ6XG4gICAgICBjYXNlIFVuaWZvcm1UeXBlLklOVDpcbiAgICAgIGNhc2UgVW5pZm9ybVR5cGUuSU5UMTpcbiAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBVbmlmb3JtVHlwZS5GTE9BVDpcbiAgICAgIGNhc2UgVW5pZm9ybVR5cGUuRkxPQVQxOlxuICAgICAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHVuaWZvcm0udmFsdWUpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFVuaWZvcm1UeXBlLkZMT0FUMjpcbiAgICAgICAgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlWzBdLCB1bmlmb3JtLnZhbHVlWzFdKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBVbmlmb3JtVHlwZS5GTE9BVDM6XG4gICAgICAgIGdsLnVuaWZvcm0zZihsb2NhdGlvbiwgdW5pZm9ybS52YWx1ZVswXSwgdW5pZm9ybS52YWx1ZVsxXSwgdW5pZm9ybS52YWx1ZVsyXSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgVW5pZm9ybVR5cGUuRkxPQVQ0OlxuICAgICAgICBnbC51bmlmb3JtNGYobG9jYXRpb24sIHVuaWZvcm0udmFsdWVbMF0sIHVuaWZvcm0udmFsdWVbMV0sIHVuaWZvcm0udmFsdWVbMl0sIHVuaWZvcm0udmFsdWVbM10pXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFVuaWZvcm1UeXBlLkZMT0FUX1ZFQ1RPUjI6XG4gICAgICAgIGdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHVuaWZvcm0udmFsdWUpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFVuaWZvcm1UeXBlLk1BVDM6XG4gICAgICBjYXNlIFVuaWZvcm1UeXBlLk1BVDNGVjpcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0udmFsdWUpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFVuaWZvcm1UeXBlLk1BVDQ6XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLnZhbHVlKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBgVW5rbm93biB1bmlmb3JtIHR5cGU6ICR7dW5pZm9ybS50eXBlfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhY2hlcyB0aGUgbG9jYXRpb25zIGZvciBhbGwgYXR0cmlidXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhY2hlQXR0cmlidXRlTG9jYXRpb25zICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIHRoaXMuX2F0dHJpYnV0ZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgdGhpcy5fYXR0cmlidXRlTG9jYXRpb25zW25hbWVdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgbmFtZSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENhY2hlcyB0aGUgbG9jYXRpb25zIGZvciBhbGwgdW5pZm9ybXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWNoZVVuaWZvcm1Mb2NhdGlvbnMgKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX3VuaWZvcm1zKVxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLl91bmlmb3JtTG9jYXRpb25zW2tleV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwga2V5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgcHJlZmVycmVkIHByZWNpc2lvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlIHRvIHRoZSBnaXZlbiBzaGFkZXIgc291cmNlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc291cmNlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF9hZGRQcmVjaXNpb25Ub1NvdXJjZSAoc291cmNlKSB7XG4gICAgY29uc3QgbWF4RmxvYXRQcmVjaXNpb24gPSB0aGlzLl9yZW5kZXJlci5nZXRNYXhGbG9hdFByZWNpc2lvbigpXG5cbiAgICBsZXQgcHJlY2lzaW9uID0gJ21lZGl1bXAnXG4gICAgaWYgKFV0aWxzLmlzTW9iaWxlKCkgJiYgbWF4RmxvYXRQcmVjaXNpb24gPT09ICdoaWdocCcpIHtcbiAgICAgIHByZWNpc2lvbiA9ICdoaWdocCdcbiAgICB9XG5cbiAgICByZXR1cm4gYHByZWNpc2lvbiAke3ByZWNpc2lvbn0gZmxvYXQ7XFxuJHtzb3VyY2V9YFxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGVzIHRoZSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNvdXJjZXMgb2YgdGhpcyBzaGFkZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21waWxlICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5fY29tcGlsZVNoYWRlcihnbC5WRVJURVhfU0hBREVSLCB0aGlzLl92ZXJ0ZXhTb3VyY2UpXG4gICAgdGhpcy5fdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyXG5cbiAgICBjb25zdCBmcmFnbWVudFNvdXJjZSA9IHRoaXMuX2FkZFByZWNpc2lvblRvU291cmNlKHRoaXMuX2ZyYWdtZW50U291cmNlKVxuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5fY29tcGlsZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U291cmNlKVxuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXJcblxuICAgIC8vIENyZWF0ZSB0aGUgV2ViR0wgcHJvZ3JhbSBhbmQgYXR0YWNoIHRoZSBzaGFkZXJzXG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxuXG4gICAgLy8gTGluayB0aGUgcHJvZ3JhbVxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pXG5cbiAgICAvLyBDaGVjayBsaW5raW5nIHN0YXR1c1xuICAgIC8vIENoZWNrIGxpbmtpbmcgc3RhdHVzXG4gICAgY29uc3QgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUylcbiAgICBpZiAoIWxpbmtlZCkge1xuICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSBlcnJvck1lc3NhZ2UgPSAnV2ViR0wgY29udGV4dCBsb3N0J1xuICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKVxuICAgICAgTG9nLmVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSwgYFdlYkdMIHByb2dyYW0gbGlua2luZyBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9ncmFtID0gcHJvZ3JhbVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGNvbXBpbGVzIGEgc2hhZGVyIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIHNvdXJjZVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNoYWRlclR5cGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzaGFkZXJTb3VyY2VcbiAgICogQHJldHVybiB7V2ViR0xTaGFkZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcGlsZVNoYWRlciAoc2hhZGVyVHlwZSwgc2hhZGVyU291cmNlKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9yZW5kZXJlci5nZXRDb250ZXh0KClcblxuICAgIC8vIENyZWF0ZSB0aGUgc2hhZGVyIGFuZCBjb21waWxlIGl0XG4gICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKVxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKVxuXG4gICAgLy8gQ2hlY2sgY29tcGlsYXRpb24gc3RhdHVzXG4gICAgY29uc3QgY29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUylcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICBsZXQgZXJyb3JNZXNzYWdlID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpXG4gICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSBlcnJvck1lc3NhZ2UgPSAnV2ViR0wgY29udGV4dCBsb3N0J1xuICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcilcbiAgICAgIExvZy5lcnJvcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIGBXZWJHTCBzaGFkZXIgY29tcGlsYXRpb24gZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlclxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIHVuaWZvcm0gdG8gdGhlIGdpdmVuIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBzeW5jID0gZmFsc2VcbiAgICovXG4gIHNldFVuaWZvcm0gKG5hbWUsIHZhbHVlLCBzeW5jID0gZmFsc2UpIHtcbiAgICB0aGlzLl91bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IHZhbHVlXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHRoaXMuc3luY1VuaWZvcm0obmFtZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gdW5pZm9ybXMgdG8gdGhlaXIgdmFsdWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgdW5pZm9ybXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBzeW5jID0gZmFsc2VcbiAgICovXG4gIHNldFVuaWZvcm1zICh1bmlmb3Jtcywgc3luYyA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB1bmlmb3Jtcykge1xuICAgICAgdGhpcy5fdW5pZm9ybXNbbmFtZV0udmFsdWUgPSB1bmlmb3Jtc1tuYW1lXVxuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgdGhpcy5zeW5jVW5pZm9ybShuYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmlmb3Jtc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRVbmlmb3JtcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VuaWZvcm1zXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXR0cmlidXRlc1xuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKCkgeyByZXR1cm4gdGhpcy5fYXR0cmlidXRlcyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGF0dHJpYnV0ZSBsb2NhdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlTG9jYXRpb25zICgpIHsgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZUxvY2F0aW9ucyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBzaGFkZXIncyBXZWJHTCBwcm9ncmFtXG4gICAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbX1cbiAgICovXG4gIGdldFByb2dyYW0gKCkgeyByZXR1cm4gdGhpcy5fcHJvZ3JhbSB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGlzIHNoYWRlclxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9yZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMuX3Byb2dyYW0pXG5cbiAgICBnbC5kZWxldGVTaGFkZXIodGhpcy5fdmVydGV4U2hhZGVyKVxuICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLl9mcmFnbWVudFNoYWRlcilcblxuICAgIHRoaXMuX3VuaWZvcm1zID0gbnVsbFxuICAgIHRoaXMuX3VuaWZvcm1Mb2NhdGlvbnMgPSBudWxsXG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IG51bGxcbiAgICB0aGlzLl9hdHRyaWJ1dGVMb2NhdGlvbnMgPSBudWxsXG5cbiAgICB0aGlzLl9yZW5kZXJlci5vZmYoJ2NvbnRleHQnLCB0aGlzLl9vbkNvbnRleHRDaGFuZ2UpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2hhZGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvc2hhZGVycy9zaGFkZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IE1hdHJpeCwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vZ2xvYmFscydcbmNvbnN0IHsgVW5pZm9ybVR5cGUgfSA9IENvbnN0YW50c1xuaW1wb3J0IFNoYWRlciBmcm9tICcuL3NoYWRlcidcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB0ZXh0dXJlIHNoYWRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5FbmdpbmUuU2hhZGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jbGFzcyBUZXh0dXJlU2hhZGVyIGV4dGVuZHMgU2hhZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBUZXh0dXJlU2hhZGVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdmVydGV4U291cmNlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZnJhZ21lbnRTb3VyY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yIChyZW5kZXJlciwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZSkge1xuICAgIHZlcnRleFNvdXJjZSA9IHZlcnRleFNvdXJjZSB8fCBUZXh0dXJlU2hhZGVyLmRlZmF1bHRWZXJ0ZXhTb3VyY2VcbiAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlIHx8IFRleHR1cmVTaGFkZXIuZGVmYXVsdEZyYWdtZW50U291cmNlXG5cbiAgICBzdXBlcihyZW5kZXJlciwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZSxcbiAgICAgIFRleHR1cmVTaGFkZXIuZGVmYXVsdFVuaWZvcm1zLFxuICAgICAgVGV4dHVyZVNoYWRlci5kZWZhdWx0QXR0cmlidXRlcylcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHZlcnRleCBzaGFkZXIgc291cmNlIGNvZGVcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblRleHR1cmVTaGFkZXIuZGVmYXVsdFZlcnRleFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuL3NvdXJjZS90ZXh0dXJlLnZlcnQnKVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2UgY29kZVxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuVGV4dHVyZVNoYWRlci5kZWZhdWx0RnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi9zb3VyY2UvdGV4dHVyZS5mcmFnJylcblxuY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgdW5pZm9ybXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblRleHR1cmVTaGFkZXIuZGVmYXVsdFVuaWZvcm1zID0ge1xuICB1X2ltYWdlOiB7XG4gICAgdHlwZTogVW5pZm9ybVR5cGUuU0FNUExFUjJELFxuICAgIHZhbHVlOiAwXG4gIH0sXG4gIHVfcHJvak1hdHJpeDoge1xuICAgIHR5cGU6IFVuaWZvcm1UeXBlLk1BVDMsXG4gICAgdmFsdWU6IG1hdHJpeC50b0FycmF5KClcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IFdlYkdMIGF0dHJpYnV0ZXNcbiAqIEB0eXBlIHtTdHJpbmdbXX1cbiAqL1xuVGV4dHVyZVNoYWRlci5kZWZhdWx0QXR0cmlidXRlcyA9IFtcbiAgJ2FfcG9zaXRpb24nLFxuICAnYV90ZXhDb29yZCcsXG4gICdhX2NvbG9yJ1xuXVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0dXJlU2hhZGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvc2hhZGVycy90ZXh0dXJlLXNoYWRlci5qcyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuL3ZlY3RvcjInXG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4vcmVjdGFuZ2xlJ1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuL21hdHJpeCdcbmltcG9ydCBDb2xvck1hdHJpeCBmcm9tICcuL2NvbG9yLW1hdHJpeCdcblxuLyoqXG4gKiBTb21lIGNsYXNzZXMgdGhhdCBoZWxwIHVzIGRvIHRoZSBtYXRoXG4gKiBAbmFtZXNwYWNlIFBob3RvRWRpdG9yU0RLLk1hdGhcbiAqL1xuZXhwb3J0IHtcbiAgVmVjdG9yMiwgUmVjdGFuZ2xlLCBNYXRyaXgsIENvbG9yTWF0cml4XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvbWF0aC9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nLCBDb25zdGFudHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vdmVuZG9yL3Byb21pc2UnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vZXZlbnQtZW1pdHRlcidcblxuLyoqXG4gKiBIb2xkcyBhbiBhcnJheSBvZiB7QGxpbmsgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBpbnN0YW5jZXMgYW5kIGhhbmRsZXMgdGhlaXIgZGlydGluZXNzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICovXG5jbGFzcyBPcGVyYXRpb25zU3RhY2sgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBPcGVyYXRpb25zU3RhY2tcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uW119IFtvcGVyYXRpb25zID0gW11dXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3BlcmF0aW9ucyA9IFtdKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUgPSB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9jYWNoZUVuYWJsZWQgPSB0cnVlXG4gICAgdGhpcy5fc3RhY2sgPSBvcGVyYXRpb25zXG4gICAgdGhpcy5fc3RhY2suZm9yRWFjaCgob3BlcmF0aW9uKSA9PiB7XG4gICAgICBvcGVyYXRpb24ub24oJ3VwZGF0ZScsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoaXMgb3BlcmF0aW9ucyBzdGFja1xuICAgKi9cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuZm9yRWFjaCgob3BlcmF0aW9uKSA9PlxuICAgICAgdGhpcy5yZW1vdmUob3BlcmF0aW9uKSlcbiAgICB0aGlzLl9zdGFjayA9IFtdXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaXMgYWJvdXQgdG8gYmUgdXBkYXRlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblVwZGF0ZSAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbWl0KENvbnN0YW50cy5FdmVudHMuT1BFUkFUSU9OX1VQREFURUQsIG9wZXJhdGlvbiwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBjYWNoZSBvbiBhbGwgb3BlcmF0aW9uc1xuICAgKi9cbiAgZW5hYmxlQ2FjaGUgKCkge1xuICAgIHRoaXMuX2NhY2hlRW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgY2FjaGUgb24gYWxsIG9wZXJhdGlvbnNcbiAgICovXG4gIGRpc2FibGVDYWNoZSAoKSB7XG4gICAgdGhpcy5fY2FjaGVFbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzZXMgQXJyYXkjZm9yRWFjaFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBmb3JFYWNoIChpdGVyYXRvcikge1xuICAgIHJldHVybiB0aGlzLl9zdGFja1xuICAgICAgLmZpbHRlcigob3ApID0+ICEhb3ApXG4gICAgICAuZm9yRWFjaChpdGVyYXRvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGFsbCBvcGVyYXRpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlRleHR1cmV9IGlucHV0VGV4dHVyZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChzZGssIGlucHV0VGV4dHVyZSkge1xuICAgIGxldCBjdXJyZW50VGV4dHVyZSA9IGlucHV0VGV4dHVyZVxuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSB0aGlzLl9zdGFja1xuICAgICAgLmZpbHRlcigob3ApID0+ICEhb3ApXG4gICAgICAuZmlsdGVyKChvcCkgPT4gb3AuZ2V0RW5hYmxlZCgpKVxuXG4gICAgLy8gRmluZCBmaXJzdCBvcGVyYXRpb24gZnJvbSBlbmQgb2YgYXJyYXkgdGhhdCBpcyBub3QgZGlydHlcbiAgICBvcGVyYXRpb25zLnJldmVyc2UoKVxuICAgIGxldCBmaXJzdFVuZGlydHlPcGVyYXRpb24gPSBvcGVyYXRpb25zLmZpbHRlcigobykgPT5cbiAgICAgICFvLmlzRGlydHlGb3JSZW5kZXJlcihzZGsuZ2V0UmVuZGVyZXIoKSlcbiAgICApWzBdXG4gICAgbGV0IGZpcnN0VW5kaXJ0eUluZGV4ID0gb3BlcmF0aW9ucy5pbmRleE9mKGZpcnN0VW5kaXJ0eU9wZXJhdGlvbilcblxuICAgIG9wZXJhdGlvbnMucmV2ZXJzZSgpXG5cbiAgICAvLyBTa2lwIG9wZXJhdGlvbnMgdGhhdCB3b3VsZCBiZSBvdmVyd3JpdHRlbiBieSBzdWNjZWVkaW5nIG9wZXJhdGlvbnNcbiAgICBsZXQgc3RhcnRJbmRleCA9IDBcbiAgICBpZiAoZmlyc3RVbmRpcnR5SW5kZXggIT09IC0xKSB7XG4gICAgICBzdGFydEluZGV4ID0gb3BlcmF0aW9ucy5sZW5ndGggLSBmaXJzdFVuZGlydHlJbmRleCAtIDFcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc3RhcnRJbmRleDsgaW5kZXgrKykge1xuICAgICAgTG9nLmluZm8odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBgU2tpcHBpbmcgJHtvcGVyYXRpb25zW2luZGV4XS5jb25zdHJ1Y3Rvci5uYW1lfWApXG4gICAgfVxuXG4gICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY3VycmVudFRleHR1cmUpXG4gICAgZm9yIChsZXQgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8IG9wZXJhdGlvbnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSBvcGVyYXRpb25zW2luZGV4XVxuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbigoaW5wdXRUZXh0dXJlKSA9PiB7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb24ucmVuZGVyKGlucHV0VGV4dHVyZSlcbiAgICAgICAgICAudGhlbigob3BlcmF0aW9uT3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBjYWNoZSBpcyBkaXNhYmxlZCwgZmx1c2ggdGV4dHVyZXMgb2YgcHJldmlvdXMgb3BlcmF0aW9uXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmICF0aGlzLl9jYWNoZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgb3BlcmF0aW9uc1tpbmRleCAtIDFdLmRpc3Bvc2VSZW5kZXJUZXh0dXJlcygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uT3V0cHV0XG4gICAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIHNldHRpbmdzIG9mIGFsbCBvcGVyYXRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB2YWxpZGF0ZVNldHRpbmdzICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLl9zdGFja1xuICAgICAgICAuZmlsdGVyKChvcCkgPT4gISFvcClcbiAgICAgICAgLm1hcCgob3ApID0+IG9wLnZhbGlkYXRlU2V0dGluZ3MoKSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbGwgb3BlcmF0aW9ucyB0byBkaXJ0eVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpbWVuc2lvbnNDaGFuZ2VkID0gZmFsc2VzXG4gICAqL1xuICBzZXRBbGxUb0RpcnR5IChkaW1lbnNpb25zQ2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5mb3JFYWNoKChvcCkgPT4gb3Auc2V0RGlydHkodHJ1ZSwgZGltZW5zaW9uc0NoYW5nZWQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCBkaXJ0eSBvcGVyYXRpb24gYW5kIHNldHMgYWxsIGZvbGxvd2luZyBvcGVyYXRpb25zIHRvIGRpcnR5XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHVwZGF0ZURpcnRpbmVzc0ZvclJlbmRlcmVyIChyZW5kZXJlcikge1xuICAgIGxldCBkaXJ0eUZvdW5kID0gZmFsc2VcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3BlcmF0aW9uID0gdGhpcy5fc3RhY2tbaV1cbiAgICAgIGlmICghb3BlcmF0aW9uKSBjb250aW51ZVxuICAgICAgaWYgKG9wZXJhdGlvbi5pc0RpcnR5Rm9yUmVuZGVyZXIocmVuZGVyZXIpKSB7XG4gICAgICAgIGRpcnR5Rm91bmQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eUZvdW5kKSB7XG4gICAgICAgIG9wZXJhdGlvbi5zZXREaXJ0eUZvclJlbmRlcmVyKHRydWUsIHJlbmRlcmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBvcGVyYXRpb24gdG8gdGhpcyBzdGFja1xuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqL1xuICBwdXNoIChvcGVyYXRpb24pIHtcbiAgICB0aGlzLl9zdGFjay5wdXNoKG9wZXJhdGlvbilcbiAgICBvcGVyYXRpb24ub24oJ3VwZGF0ZScsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIG9wZXJhdGlvbiBiZWZvcmUgYWxsIGV4aXN0aW5nIG9wZXJhdGlvbnNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICovXG4gIHVuc2hpZnQgKG9wZXJhdGlvbikge1xuICAgIHRoaXMuX3N0YWNrLnVuc2hpZnQob3BlcmF0aW9uKVxuICAgIG9wZXJhdGlvbi5vbigndXBkYXRlJywgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lZCBpbnN0YW5jZSBvZiB0aGlzIHN0YWNrXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNTdGFja31cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IE9wZXJhdGlvbnNTdGFjayh0aGlzLl9zdGFjay5zbGljZSgwKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcGVyYXRpb24gYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufVxuICAgKi9cbiAgZ2V0IChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFja1tpbmRleF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcGVyYXRpb24gYXQgdGhlIGdpdmVuIGluZGV4IHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtICB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKi9cbiAgc2V0IChpbmRleCwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3N0YWNrW2luZGV4XSkge1xuICAgICAgdGhpcy5fc3RhY2tbaW5kZXhdLm9mZigndXBkYXRlJywgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUpXG4gICAgICB0aGlzLl9zdGFja1tpbmRleF0uZGlzcG9zZSgpXG4gICAgfVxuICAgIHRoaXMuX3N0YWNrW2luZGV4XSA9IG9wZXJhdGlvblxuICAgIG9wZXJhdGlvbi5vbigndXBkYXRlJywgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqL1xuICByZW1vdmUgKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc3RhY2suaW5kZXhPZihvcGVyYXRpb24pXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLl9zdGFja1tpbmRleF0pIHtcbiAgICAgIHRoaXMuX3N0YWNrW2luZGV4XS5vZmYoJ3VwZGF0ZScsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICAgICAgdGhpcy5fc3RhY2tbaW5kZXhdLmRpc3Bvc2UoKVxuICAgIH1cbiAgICB0aGlzLl9zdGFjay5zcGxpY2UoaW5kZXgsIDEpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgb3BlcmF0aW9uIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuICByZW1vdmVBdCAoaW5kZXgpIHtcbiAgICBpZiAodGhpcy5fc3RhY2tbaW5kZXhdKSB7XG4gICAgICB0aGlzLl9zdGFja1tpbmRleF0ub2ZmKCd1cGRhdGUnLCB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZSlcbiAgICAgIHRoaXMuX3N0YWNrW2luZGV4XS5kaXNwb3NlKClcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX3N0YWNrW2luZGV4XVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YWNrXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbltdfVxuICAgKi9cbiAgZ2V0U3RhY2sgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFja1xuICB9XG5cbiAgZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5mb3JFYWNoKChvcGVyYXRpb24pID0+IHtcbiAgICAgIG9wZXJhdGlvbi5kaXNwb3NlKClcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9wZXJhdGlvbnNTdGFja1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL29wZXJhdGlvbnMtc3RhY2suanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zXG4gKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsdGVyT3BlcmF0aW9uIH0gZnJvbSAnLi9maWx0ZXItb3BlcmF0aW9uJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDcm9wT3BlcmF0aW9uIH0gZnJvbSAnLi9jcm9wLW9wZXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT3JpZW50YXRpb25PcGVyYXRpb24gfSBmcm9tICcuL29yaWVudGF0aW9uLW9wZXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQWRqdXN0bWVudHNPcGVyYXRpb24gfSBmcm9tICcuL2FkanVzdG1lbnRzLW9wZXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGluZWFyRm9jdXNPcGVyYXRpb24gfSBmcm9tICcuL2xpbmVhci1mb2N1cy1vcGVyYXRpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJhZGlhbEZvY3VzT3BlcmF0aW9uIH0gZnJvbSAnLi9yYWRpYWwtZm9jdXMtb3BlcmF0aW9uJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGcmFtZU9wZXJhdGlvbiB9IGZyb20gJy4vZnJhbWUtb3BlcmF0aW9uJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTcHJpdGVPcGVyYXRpb24gfSBmcm9tICcuL3Nwcml0ZS1vcGVyYXRpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIFdhdGVybWFya09wZXJhdGlvbiB9IGZyb20gJy4vd2F0ZXJtYXJrLW9wZXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXhpZk9yaWVudGF0aW9uT3BlcmF0aW9uIH0gZnJvbSAnLi9leGlmLW9yaWVudGF0aW9uLW9wZXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VsZWN0aXZlQmx1ck9wZXJhdGlvbiB9IGZyb20gJy4vc2VsZWN0aXZlLWJsdXItb3BlcmF0aW9uJ1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcIm5hbWVcIjogXCJwaG90b2VkaXRvcnNka1wiLFxuXHRcInZlcnNpb25cIjogXCIzLjYuOVwiLFxuXHRcImRlc2NyaXB0aW9uXCI6IFwiVGhlIG1vc3QgY29tcHJlaGVuc2l2ZSBwaG90byBlZGl0b3IgU0RLIGZvciBIVE1MNVwiLFxuXHRcInJlcG9zaXRvcnlcIjogXCJodHRwOi8vZ2l0aHViLmNvbS9pbWdseS9wZXNkay1odG1sNVwiLFxuXHRcImF1dGhvclwiOiBcIlBob3RvIEVkaXRvciBTREsgPGNvbnRhY3RAcGhvdG9lZGl0b3JzZGsuY29tPlwiLFxuXHRcImxpY2Vuc2VcIjogXCJTRUUgTElDRU5TRSBJTiBMSUNFTlNFLm1kXCIsXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJyZW5kZXItZmlsdGVyLXByZXZpZXdzXCI6IFwiYmFiZWwtbm9kZSBzY3JpcHRzL3JlbmRlci1maWx0ZXItcHJldmlld3NcIixcblx0XHRcInJlbGVhc2VcIjogXCJFTlY9cHJvZHVjdGlvbiBub2RlX21vZHVsZXMvLmJpbi9ndWxwIHJlbGVhc2VcIixcblx0XHRcInJlbGVhc2U6dGVzdFwiOiBcIkVOVj10ZXN0IG5vZGVfbW9kdWxlcy8uYmluL2d1bHAgcmVsZWFzZVwiLFxuXHRcdFwicmVsZWFzZTpkZXZcIjogXCJFTlY9ZGV2ZWxvcG1lbnQgbm9kZV9tb2R1bGVzLy5iaW4vZ3VscCByZWxlYXNlXCIsXG5cdFx0XCJ0ZXN0XCI6IFwiRU5WPXRlc3Qgbm9kZV9tb2R1bGVzLy5iaW4vbW9jaGEgLS1yZXF1aXJlIHRlc3Qvc3VwcG9ydC9ub2RlIHRlc3Qvc2RrIHRlc3QvdWlcIixcblx0XHRcInRlc3Q6Y2xpZW50XCI6IFwiRU5WPXRlc3QgUkVNT1RFPXRydWUgZ3VscCB0ZXN0OmNsaWVudFwiLFxuXHRcdFwidGVzdDpjbGllbnQ6bG9jYWxcIjogXCJFTlY9dGVzdCBub2RlIC0tc3RhY2stc2l6ZT02NTUwMCBub2RlX21vZHVsZXMvLmJpbi9ndWxwIHRlc3Q6Y2xpZW50XCIsXG5cdFx0XCJ0ZXN0OndlYmdsXCI6IFwibm9kZV9tb2R1bGVzLy5iaW4vbW9jaGEgdGVzdC13ZWJnbFwiLFxuXHRcdFwiY292ZXJhbGxzXCI6IFwibnBtIHJ1biBjb3ZlcmFnZSAmJiBjYXQgLi9jb3ZlcmFnZS9sY292LmluZm8gfCBub2RlX21vZHVsZXMvLmJpbi9jb3ZlcmFsbHMgJiYgcm0gLXJmIC4vY292ZXJhZ2VcIixcblx0XHRcImNvdmVyYWdlXCI6IFwiTk9ERV9FTlY9dGVzdCBub2RlX21vZHVsZXMvLmJpbi9pc3RhbmJ1bCBjb3ZlciBub2RlX21vZHVsZXMvLmJpbi9fbW9jaGEgLS1yZXF1aXJlIHRlc3Qvc3VwcG9ydC9ub2RlIHRlc3Qvc2RrIHRlc3QvdWlcIlxuXHR9LFxuXHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJhanZcIjogXCJeNC40LjBcIixcblx0XHRcImJhYmVsLWNvcmVcIjogXCJeNi4yMy4xXCIsXG5cdFx0XCJiYWJlbC1sb2FkZXJcIjogXCJeNi4zLjJcIixcblx0XHRcImJhYmVsLXBsdWdpbi1leHRlcm5hbC1oZWxwZXJzLTJcIjogXCJeNi4zLjEzXCIsXG5cdFx0XCJiYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWVzMjAxNS1jbGFzc2VzXCI6IFwiXjYuNi40XCIsXG5cdFx0XCJiYWJlbC1wbHVnaW4tdHJhbnNmb3JtLXJ1bnRpbWVcIjogXCJeNi42LjBcIixcblx0XHRcImJhYmVsLXByZXNldC1lczIwMTVcIjogXCJeNi42LjBcIixcblx0XHRcImJhYmVsLXByZXNldC1yZWFjdFwiOiBcIl42LjUuMFwiLFxuXHRcdFwiYmFiZWwtcmVnaXN0ZXJcIjogXCJeNi42LjBcIixcblx0XHRcImJhYmVsLXJ1bnRpbWVcIjogXCJeNi42LjFcIixcblx0XHRcImJhYmlsaVwiOiBcIl4wLjAuMTFcIixcblx0XHRcImNoYWlcIjogXCJeMy40LjBcIixcblx0XHRcImNoYWktYXMtcHJvbWlzZWRcIjogXCJeNS4xLjBcIixcblx0XHRcImNocm9tZWRyaXZlclwiOiBcIl4yLjIzLjFcIixcblx0XHRcImNsYXNzbmFtZXNcIjogXCJeMi4xLjNcIixcblx0XHRcImNvbXBhc3MtbWl4aW5zXCI6IFwiXjAuMTIuOFwiLFxuXHRcdFwiY292ZXJhbGxzXCI6IFwiXjIuMTEuMlwiLFxuXHRcdFwiZGVsXCI6IFwiXjIuMC4wXCIsXG5cdFx0XCJndWxwXCI6IFwiXjMuOC4xMFwiLFxuXHRcdFwiZ3VscC05ZS1zYXNzLWxpbnRcIjogXCIwLjAuOFwiLFxuXHRcdFwiZ3VscC1iYWJlbFwiOiBcIl42LjEuMlwiLFxuXHRcdFwiZ3VscC1jaGFuZ2VkXCI6IFwiXjEuMy4wXCIsXG5cdFx0XCJndWxwLWpzZG9jM1wiOiBcIl4wLjIuMFwiLFxuXHRcdFwiZ3VscC1tb2NoYVwiOiBcIl4yLjIuMFwiLFxuXHRcdFwiZ3VscC1ub3RpZnlcIjogXCJeMS4zLjFcIixcblx0XHRcImd1bHAtcmVuYW1lXCI6IFwifjEuMi4wXCIsXG5cdFx0XCJndWxwLXNhc3NcIjogXCJeMi4wLjRcIixcblx0XHRcImd1bHAtc2VxdWVuY2VcIjogXCJeMC40LjFcIixcblx0XHRcImd1bHAtc291cmNlbWFwc1wiOiBcIl4xLjUuMlwiLFxuXHRcdFwiZ3VscC1zdGFuZGFyZFwiOiBcIl44LjAuMlwiLFxuXHRcdFwiZ3VscC11dGlsXCI6IFwifjIuMi4xNlwiLFxuXHRcdFwiZ3VscC13YXRjaFwiOiBcIl40LjMuNVwiLFxuXHRcdFwiZ3VscC13ZWJzZXJ2ZXJcIjogXCJeMC45LjFcIixcblx0XHRcImd1bHAteXVpY29tcHJlc3NvclwiOiBcIjAuMC4zXCIsXG5cdFx0XCJpbnF1aXJlclwiOiBcIl4wLjExLjRcIixcblx0XHRcImlucXVpcmVyLXBhdGhcIjogXCJeMS4wLjAtYWxwaGE1XCIsXG5cdFx0XCJpc3RhbmJ1bFwiOiBcIl4xLjEuMC1hbHBoYS4xXCIsXG5cdFx0XCJqYWd1YXJqcy1qc2RvY1wiOiBcImdpdDovL2dpdGh1Yi5jb20vaW1nbHkvamFndWFyanMtanNkb2MuZ2l0I21hc3RlclwiLFxuXHRcdFwianNkb2NcIjogXCJnaXQ6Ly9naXRodWIuY29tL2pzZG9jMy9qc2RvYy5naXQjbWFzdGVyXCIsXG5cdFx0XCJqc29uLWxvYWRlclwiOiBcIl4wLjUuMlwiLFxuXHRcdFwibW9jaGFcIjogXCJeMi4zLjNcIixcblx0XHRcIm1vY2hhLWxjb3YtcmVwb3J0ZXJcIjogXCIwLjAuMVwiLFxuXHRcdFwibmlnaHR3YXRjaFwiOiBcImdpdDovL2dpdGh1Yi5jb20vc2FzY2hhZ2VobGljaC9uaWdodHdhdGNoLmdpdCNmZWF0dXJlL3VwbG9hZC1maWxlXCIsXG5cdFx0XCJwZXJmb3JtYW5jZS1ub3dcIjogXCJeMC4yLjBcIixcblx0XHRcInByZXByb2Nlc3MtbG9hZGVyXCI6IFwiXjAuMi4wXCIsXG5cdFx0XCJwcmV0dHktZXJyb3JcIjogXCJeMi4wLjBcIixcblx0XHRcInByb21wdFwiOiBcIl4xLjAuMFwiLFxuXHRcdFwicmF3LWxvYWRlclwiOiBcIl4wLjUuMVwiLFxuXHRcdFwicmVhY3RcIjogXCJeMTUuMS4wXCIsXG5cdFx0XCJyZWFjdC1kb21cIjogXCJeMTUuMS4wXCIsXG5cdFx0XCJyZW1icmFuZHRcIjogXCJeMC4wLjhcIixcblx0XHRcInJlcXVpcmUtZGlyXCI6IFwiXjAuMy4wXCIsXG5cdFx0XCJydW4tc2VxdWVuY2VcIjogXCJ+MC4zLjZcIixcblx0XHRcInNlbGVuaXVtLXNlcnZlci1zdGFuZGFsb25lLWphclwiOiBcIl4yLjUzLjFcIixcblx0XHRcInNob3VsZFwiOiBcIl40LjMuMFwiLFxuXHRcdFwic2lub25cIjogXCJeMS4xNy4zXCIsXG5cdFx0XCJzaW5vbi1jaGFpXCI6IFwiXjIuOC4wXCIsXG5cdFx0XCJzdGF0cy5qc1wiOiBcIl4wLjE2LjBcIixcblx0XHRcInRlcm0taW1nMlwiOiBcIl4yLjAuMVwiLFxuXHRcdFwidHJhbnNmb3JtLWxvYWRlclwiOiBcIl4wLjIuMlwiLFxuXHRcdFwidmlueWwtc291cmNlLXN0cmVhbVwiOiBcIjAuMS4xXCIsXG5cdFx0XCJ3ZWJwYWNrXCI6IFwiMi4xLjAtYmV0YS4yNVwiLFxuXHRcdFwid2VicGFjay1ub3RpZmllclwiOiBcIl4xLjIuMVwiXG5cdH0sXG5cdFwic3RhbmRhcmRcIjoge1xuXHRcdFwiZ2xvYmFsc1wiOiBbXG5cdFx0XHRcImRlc2NyaWJlXCIsXG5cdFx0XHRcImNvbnRleHRcIixcblx0XHRcdFwiYmVmb3JlXCIsXG5cdFx0XHRcImJlZm9yZUVhY2hcIixcblx0XHRcdFwiYWZ0ZXJcIixcblx0XHRcdFwiYWZ0ZXJFYWNoXCIsXG5cdFx0XHRcIml0XCIsXG5cdFx0XHRcImV4cGVjdFwiXG5cdFx0XVxuXHR9LFxuXHRcImRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJjYW52YXNcIjogXCJeMS4zLjEyXCIsXG5cdFx0XCJnbFwiOiBcIl40LjAuM1wiLFxuXHRcdFwicmVxdWVzdFwiOiBcIl4yLjc5LjBcIlxuXHR9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9wYWNrYWdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gJy4vZGlzcGxheS1vYmplY3QnXG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIERpc3BsYXlPYmplY3QgaW5zdGFuY2VzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0XG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIERpc3BsYXlPYmplY3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIENvbnRhaW5lclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2NoaWxkcmVuID0gW11cbiAgICB0aGlzLl9maWx0ZXJzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBmaWx0ZXIgdG8gdGhlIGZpbHRlciBzdGFja1xuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5GaWx0ZXJ9IGZpbHRlclxuICAgKi9cbiAgYWRkRmlsdGVyIChmaWx0ZXIpIHtcbiAgICB0aGlzLl9maWx0ZXJzLnB1c2goZmlsdGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2tcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkZpbHRlcn0gZmlsdGVyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gV2hldGhlciB0aGUgZmlsdGVyIGhhcyBiZWVuIHJlbW92ZWRcbiAgICovXG4gIHJlbW92ZUZpbHRlciAoZmlsdGVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9maWx0ZXJzLmluZGV4T2YoZmlsdGVyKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsdGVyc1xuICAgKiBAcGFyYW0ge0FycmF5LjxQaG90b0VkaXRvclNESy5FbmdpbmUuRmlsdGVyPn0gZmlsdGVyc1xuICAgKi9cbiAgc2V0RmlsdGVycyAoZmlsdGVycykge1xuICAgIHRoaXMuX2ZpbHRlcnMgPSBmaWx0ZXJzXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gRGlzcGxheU9iamVjdCB0byB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBjaGlsZFxuICAgKi9cbiAgYWRkQ2hpbGQgKGNoaWxkKSB7XG4gICAgLy8gUmVtb3ZlIGZyb20gcHJldmlvdXMgcGFyZW50XG4gICAgY29uc3Qgb3JpZ2luYWxQYXJlbnQgPSBjaGlsZC5nZXRQYXJlbnQoKVxuICAgIGlmIChvcmlnaW5hbFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgb3JpZ2luYWxQYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpXG4gICAgfVxuICAgIGNoaWxkLnNldFBhcmVudCh0aGlzKVxuXG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gRGlzcGxheU9iamVjdCB0byB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gY2hpbGRcbiAgICovXG4gIHByZXBlbmRDaGlsZCAoY2hpbGQpIHtcbiAgICAvLyBSZW1vdmUgZnJvbSBwcmV2aW91cyBwYXJlbnRcbiAgICBjb25zdCBvcmlnaW5hbFBhcmVudCA9IGNoaWxkLmdldFBhcmVudCgpXG4gICAgaWYgKG9yaWdpbmFsUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBvcmlnaW5hbFBhcmVudC5yZW1vdmVDaGlsZChjaGlsZClcbiAgICB9XG4gICAgY2hpbGQuc2V0UGFyZW50KHRoaXMpXG5cbiAgICB0aGlzLl9jaGlsZHJlbi51bnNoaWZ0KGNoaWxkKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgY29udGFpbmVyIGhhcyB0aGUgZ2l2ZW4gY2hpbGRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkRpc3BsYXlPYmplY3R9ICBjaGlsZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaGFzQ2hpbGQgKGNoaWxkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKVxuICAgIHJldHVybiBpbmRleCAhPT0gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBvYmplY3QgZnJvbSB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gY2hpbGRcbiAgICovXG4gIHJlbW92ZUNoaWxkIChjaGlsZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihjaGlsZClcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICBjaGlsZC5zZXRQYXJlbnQobnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nLmluZm8odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnVHJpZWQgdG8gcmVtb3ZlIGEgY2hpbGQgdGhhdCBkb2VzIG5vdCBleGlzdCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuXG4gICAqL1xuICBjbGVhckNoaWxkcmVuICgpIHtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIERpc3BsYXlPYmplY3QgdXNpbmcgdGhlIGdpdmVuIFdlYkdMUmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLl92aXNpYmxlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJNYW5hZ2VyID0gcmVuZGVyZXIuZ2V0RmlsdGVyTWFuYWdlcigpXG4gICAgaWYgKHRoaXMuX2ZpbHRlcnMgJiYgdGhpcy5fZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIGZpbHRlck1hbmFnZXIucHVzaEZpbHRlcnModGhpcywgdGhpcy5fZmlsdGVycylcbiAgICB9XG5cbiAgICByZW5kZXJlci5nZXRDdXJyZW50T2JqZWN0UmVuZGVyZXIoKS5zdGFydCgpXG5cbiAgICB0aGlzLl9yZW5kZXJXZWJHTChyZW5kZXJlcilcblxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC5yZW5kZXJXZWJHTChyZW5kZXJlcilcbiAgICB9KVxuXG4gICAgcmVuZGVyZXIuZ2V0Q3VycmVudE9iamVjdFJlbmRlcmVyKCkuZmx1c2goKVxuXG4gICAgaWYgKHRoaXMuX2ZpbHRlcnMgJiYgdGhpcy5fZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIGZpbHRlck1hbmFnZXIucG9wRmlsdGVycygpXG4gICAgfVxuICAgIHJlbmRlcmVyLmdldEN1cnJlbnRPYmplY3RSZW5kZXJlcigpLnN0YXJ0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250ZW50cyBvZiB0aGlzIGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgRGlzcGxheU9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICBpZiAoIXRoaXMuX3Zpc2libGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlck1hbmFnZXIgPSByZW5kZXJlci5nZXRGaWx0ZXJNYW5hZ2VyKClcbiAgICBpZiAodGhpcy5fZmlsdGVycyAmJiB0aGlzLl9maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZmlsdGVyTWFuYWdlci5wdXNoRmlsdGVycyh0aGlzLCB0aGlzLl9maWx0ZXJzKVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlckNhbnZhcyhyZW5kZXJlcilcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgY2hpbGQucmVuZGVyQ2FudmFzKHJlbmRlcmVyKVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5fZmlsdGVycyAmJiB0aGlzLl9maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZmlsdGVyTWFuYWdlci5wb3BGaWx0ZXJzKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udGVudHMgb2YgdGhpcyBjb250YWluZXJcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKHJlbmRlcmVyKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB3b3JsZCB0cmFuc2Zvcm0gZm9yIHRoaXMgRGlzcGxheU9iamVjdFxuICAgKi9cbiAgdXBkYXRlVHJhbnNmb3JtICgpIHtcbiAgICBzdXBlci51cGRhdGVUcmFuc2Zvcm0oKVxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC51cGRhdGVUcmFuc2Zvcm0oKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9uLWdsb2JhbCBib3VuZHMgb2YgdGhpcyBEaXNwbGF5T2JqZWN0XG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfVxuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMgKCkge1xuICAgIGlmICh0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUpIHtcbiAgICAgIC8vIEBUT0RPIENhbGN1bGF0ZSBib3VuZHMgYnkgbG9va2luZyBhdCBjaGlsZHJlblxuICAgICAgdGhpcy5fbG9jYWxCb3VuZHNOZWVkVXBkYXRlID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsQm91bmRzLmNsb25lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZHMgZm9yIHRoaXMgRGlzcGxheU9iamVjdFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX1cbiAgICovXG4gIGdldEJvdW5kcyAoKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kc05lZWRVcGRhdGUpIHtcbiAgICAgIC8vIEBUT0RPIENhbGN1bGF0ZSBib3VuZHMgYnkgbG9va2luZyBhdCBjaGlsZHJlblxuICAgICAgdGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ib3VuZHMuY2xvbmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBDb250YWluZXIncyBjaGlsZHJlblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdFtdfVxuICAgKi9cbiAgZ2V0Q2hpbGRyZW4gKCkgeyByZXR1cm4gdGhpcy5fY2hpbGRyZW4gfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgQ29udGFpbmVyJ3MgZmlsdGVyc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRmlsdGVyW119XG4gICAqL1xuICBnZXRGaWx0ZXJzICgpIHsgcmV0dXJuIHRoaXMuX2ZpbHRlcnMgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIENvbnRhaW5lclxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS9kaXNwbGF5L2NvbnRhaW5lci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nLCBWZWN0b3IyLCBFdmVudEVtaXR0ZXIsIENvbG9yIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscydcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIHJlbmRlcmVyc1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIEJhc2VSZW5kZXJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBCYXNlUmVuZGVyZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGhlaWdodFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgPSB7fVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnBpeGVsUmF0aW8gPSAxXVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5Db2xvcn0gW29wdGlvbnMuY2xlYXJDb2xvciA9IFBob3RvRWRpdG9yU0RLLkNvbG9yLlRSQU5TUEFSRU5UXVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5kZWJ1ZyA9IGZhbHNlXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX29wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBwaXhlbFJhdGlvOiAxLFxuICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgY2xlYXJDb2xvcjogQ29sb3IuQkxBQ0ssXG4gICAgICBkZWJ1ZzogZmFsc2VcbiAgICB9KVxuXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMClcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoIHx8IDgwMFxuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodCB8fCA2MDBcbiAgICB0aGlzLl9kaW1lbnNpb25zID0gbmV3IFZlY3RvcjIodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodClcbiAgICB0aGlzLl9tYXhUZXh0dXJlU2l6ZSA9IG51bGxcbiAgICB0aGlzLl9waXhlbFJhdGlvID0gdGhpcy5fb3B0aW9ucy5waXhlbFJhdGlvXG4gICAgdGhpcy5fY2xlYXJDb2xvciA9IHRoaXMuX29wdGlvbnMudHJhbnNwYXJlbnRcbiAgICAgID8gQ29sb3IuVFJBTlNQQVJFTlRcbiAgICAgIDogKHRoaXMuX29wdGlvbnMuY2xlYXJDb2xvciB8fCBDb2xvci5CTEFDSylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjYW52YXMgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICovXG4gIHNldENhbnZhcyAoY2FudmFzKSB7XG4gICAgY29uc3QgcHJldmlvdXNDYW52YXMgPSB0aGlzLl9jYW52YXNcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXNcblxuICAgIGlmIChwcmV2aW91c0NhbnZhcyAhPT0gY2FudmFzKSB7XG4gICAgICB0aGlzLl9jcmVhdGVDb250ZXh0KClcbiAgICAgIHRoaXMuX29uQmVmb3JlQ29udGV4dCgpXG4gICAgICB0aGlzLl9zZXR1cENvbnRleHQoKVxuICAgIH1cblxuICAgIHRoaXMucmVzaXplVG8obmV3IFZlY3RvcjIodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBjYW52YXNcbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAqL1xuICBnZXRDYW52YXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBiZWZvcmUgdGhlIGNvbnRleHQgaGFzIGJlZW4gc2V0IHVwXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbkJlZm9yZUNvbnRleHQgKCkge1xuXG4gIH1cblxuICAvKipcbiAgICogUmVzaXplcyB0aGUgY29udGV4dCBhbmQgdmlldyB0byB0aGUgZ2l2ZW4gc2l6ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gcmVzaXplQ2FudmFzID0gdHJ1ZVxuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMsIHJlc2l6ZUNhbnZhcyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fd2lkdGggPSBkaW1lbnNpb25zLnggKiB0aGlzLl9waXhlbFJhdGlvXG4gICAgdGhpcy5faGVpZ2h0ID0gZGltZW5zaW9ucy55ICogdGhpcy5fcGl4ZWxSYXRpb1xuXG4gICAgaWYgKHJlc2l6ZUNhbnZhcykge1xuICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gdGhpcy5fd2lkdGhcbiAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHRcblxuICAgICAgaWYgKHRoaXMuX2NhbnZhcy5zdHlsZSkge1xuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSBgJHt0aGlzLl93aWR0aCAvIHRoaXMuX3BpeGVsUmF0aW99cHhgXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLl9oZWlnaHQgLyB0aGlzLl9waXhlbFJhdGlvfXB4YFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2RpbWVuc2lvbnMgPSBkaW1lbnNpb25zLmNsb25lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgdGhpcyByZW5kZXJlclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgX2NyZWF0ZUNvbnRleHQgKCkge1xuICAgIExvZy53YXJuKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ2BfY3JlYXRlQ29udGV4dGAgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MnKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIHJlbmRlcmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBfc2V0dXBDb250ZXh0ICgpIHtcbiAgICBMb2cud2Fybih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsICdgX3NldHVwQ29udGV4dGAgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIGRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3RcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZW5kZXIgKGRpc3BsYXlPYmplY3QpIHtcbiAgICBMb2cud2Fybih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsICdgcmVuZGVyYCBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGluaGVyaXRlZCBjbGFzcycpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldE1heERpbWVuc2lvbnMgKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcmV0dXJuIHtSZW5kZXJpbmdDb250ZXh0fVxuICAgKi9cbiAgZ2V0Q29udGV4dCAoKSB7IHJldHVybiB0aGlzLl9jb250ZXh0IH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB3aWR0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCAoKSB7IHJldHVybiB0aGlzLl9kaW1lbnNpb25zLnggfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGhlaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRIZWlnaHQgKCkgeyByZXR1cm4gdGhpcy5fZGltZW5zaW9ucy55IH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldERpbWVuc2lvbnMgKCkgeyByZXR1cm4gdGhpcy5fZGltZW5zaW9ucyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGl4ZWwgcmF0aW9cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyAoKSB7IHJldHVybiB0aGlzLl9waXhlbFJhdGlvIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGl4ZWwgcmF0aW9cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgc2V0UGl4ZWxSYXRpbyAocGl4ZWxSYXRpbykge1xuICAgIHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvXG4gICAgaWYgKHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQuc2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHRleHR1cmUgc2l6ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRNYXhUZXh0dXJlU2l6ZSAoKSB7IHJldHVybiB0aGlzLl9tYXhUZXh0dXJlU2l6ZSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZmlsdGVyIG1hbmFnZXJcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkZpbHRlck1hbmFnZXJ9XG4gICAqL1xuICBnZXRGaWx0ZXJNYW5hZ2VyICgpIHsgcmV0dXJuIHRoaXMuX2ZpbHRlck1hbmFnZXIgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWx0ZXIgbWFuYWdlclxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5GaWx0ZXJNYW5hZ2VyfSBmaWx0ZXJNYW5hZ2VyXG4gICAqL1xuICBzZXRGaWx0ZXJNYW5hZ2VyIChmaWx0ZXJNYW5hZ2VyKSB7IHRoaXMuX2ZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgcmVuZGVyZXIgaXMgc3VwcG9ydGVkIG9uIHRoZSBjdXJyZW50IGRldmljZSBhbmQgYnJvd3NlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzU3VwcG9ydGVkICgpIHsgcmV0dXJuIHRydWUgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyByZW5kZXJlcidzIHR5cGUgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICB0eXBlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc09mVHlwZSAodHlwZSkge1xuICAgIHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBSZW5kZXJlclxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIExvZy53YXJuKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ2BkaXNwb3NlYCBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGluaGVyaXRlZCBjbGFzcycpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVJlbmRlcmVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvcmVuZGVyZXJzL2Jhc2UtcmVuZGVyZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBPYmplY3RSZW5kZXJlciBjbGFzc2VzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIE9iamVjdFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gT2JqZWN0UmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXJcblxuICAgIHRoaXMuX29uQ29udGV4dENoYW5nZSA9IHRoaXMuX29uQ29udGV4dENoYW5nZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVuZGVyZXIub24oJ2NvbnRleHQnLCB0aGlzLl9vbkNvbnRleHRDaGFuZ2UpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgcmVuZGVyaW5nIGNvbnRleHQgY2hhbmdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ29udGV4dENoYW5nZSAoKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IHJlbmRlcmVyIGlzIGFjdGl2YXRlZFxuICAgKi9cbiAgc3RhcnQgKCkge1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIG9iamVjdCByZW5kZXJlciBpcyBkZWFjdGl2YXRlZFxuICAgKi9cbiAgc3RvcCAoKSB7XG4gICAgdGhpcy5mbHVzaCgpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB3aGF0ZXZlciBoYXMgYmVlbiBxdWV1ZWRcbiAgICovXG4gIGZsdXNoICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgT2JqZWN0UmVuZGVyZXJcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHRoaXMuX3JlbmRlcmVyLm9mZignY29udGV4dCcsIHRoaXMuX29uQ29udGV4dENoYW5nZSlcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3RSZW5kZXJlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL3JlbmRlcmVycy93ZWJnbC9vYmplY3QtcmVuZGVyZXJzL29iamVjdC1yZW5kZXJlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVmVjdG9yMiwgUmVjdGFuZ2xlLCBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IEJhc2VUZXh0dXJlIGZyb20gJy4vYmFzZS10ZXh0dXJlJ1xuaW1wb3J0IFRleHR1cmVVVnMgZnJvbSAnLi4vdXRpbHMvdGV4dHVyZS11dnMnXG5cbi8qKlxuICogQSB0ZXh0dXJlIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gYSB7QGxpbmsgUGhvdG9FZGl0b3JTREsuRW5naW5lLlNwcml0ZX1cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIFRleHR1cmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoYmFzZVRleHR1cmUsIGZyYW1lKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKCEoYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBCYXNlVGV4dHVyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGJhc2VUZXh0dXJlYCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgQmFzZVRleHR1cmUnKVxuICAgIH1cblxuICAgIHRoaXMuX3V2cyA9IG5ldyBUZXh0dXJlVVZzKClcbiAgICB0aGlzLl9mcmFtZSA9IGZyYW1lID8gZnJhbWUuY2xvbmUoKSA6IG51bGxcbiAgICB0aGlzLl9mcmFtZUxvY2tlZCA9ICEhZnJhbWVcblxuICAgIC8vIEJpbmQgZXZlbnQgaGFuZGxlcnNcbiAgICB0aGlzLl9vbkJhc2VUZXh0dXJlTG9hZGVkID0gdGhpcy5fb25CYXNlVGV4dHVyZUxvYWRlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25CYXNlVGV4dHVyZVVwZGF0ZWQgPSB0aGlzLl9vbkJhc2VUZXh0dXJlVXBkYXRlZC5iaW5kKHRoaXMpXG5cbiAgICAvLyBBIHRleHR1cmUgTkVFRFMgdG8gaGF2ZSBhIGZyYW1lXG4gICAgaWYgKCF0aGlzLl9mcmFtZSkge1xuICAgICAgdGhpcy5fZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEsIDEpXG4gICAgfVxuICAgIHRoaXMuc2V0QmFzZVRleHR1cmUoYmFzZVRleHR1cmUpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRleHR1cmUgZnJvbSB0aGUgZ2l2ZW4gaW1hZ2VcbiAgICogQHBhcmFtICB7SW1hZ2V9IGltYWdlXG4gICAqL1xuICBzdGF0aWMgZnJvbUltYWdlIChpbWFnZSkge1xuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKGltYWdlKVxuICAgIHJldHVybiBuZXcgVGV4dHVyZShiYXNlVGV4dHVyZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGV4dHVyZSBmcm9tIHRoZSBnaXZlbiBjYW52YXNcbiAgICogQHBhcmFtICB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKi9cbiAgc3RhdGljIGZyb21DYW52YXMgKGNhbnZhcykge1xuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKGNhbnZhcylcbiAgICByZXR1cm4gbmV3IFRleHR1cmUoYmFzZVRleHR1cmUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYmFzZSB0ZXh0dXJlIGhhcyBiZWVuIGxvYWRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFzZVRleHR1cmVMb2FkZWQgKCkge1xuICAgIGlmICghdGhpcy5fZnJhbWVMb2NrZWQpIHtcbiAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5fYmFzZVRleHR1cmUuZ2V0RnJhbWUoKS5jbG9uZSgpXG4gICAgICB0aGlzLnNldEZyYW1lKGZyYW1lKVxuICAgIH1cblxuICAgIHRoaXMuX2Jhc2VUZXh0dXJlLm9uKCd1cGRhdGUnLCB0aGlzLl9vbkJhc2VUZXh0dXJlVXBkYXRlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBiYXNlIHRleHR1cmUgaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFzZVRleHR1cmVVcGRhdGVkICgpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX2Jhc2VUZXh0dXJlLmdldEZyYW1lKClcbiAgICB0aGlzLl9mcmFtZS53aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFVWIGNvb3JkaW5hdGVzIG9mIHRoaXMgdGV4dHVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVVWcyAoKSB7XG4gICAgdGhpcy5fdXZzLnVwZGF0ZShcbiAgICAgIHRoaXMuX2ZyYW1lLFxuICAgICAgdGhpcy5fYmFzZVRleHR1cmUuZ2V0RnJhbWUoKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYXNlIHRleHR1cmVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VUZXh0dXJlfVxuICAgKi9cbiAgZ2V0QmFzZVRleHR1cmUgKCkgeyByZXR1cm4gdGhpcy5fYmFzZVRleHR1cmUgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBiYXNlIHRleHR1cmVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlXG4gICAqL1xuICBzZXRCYXNlVGV4dHVyZSAoYmFzZVRleHR1cmUpIHtcbiAgICB0aGlzLl9iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlXG5cbiAgICBpZiAoIXRoaXMuX2Jhc2VUZXh0dXJlLmlzTG9hZGVkKCkpIHtcbiAgICAgIHRoaXMuX2Jhc2VUZXh0dXJlLm9uY2UoJ2xvYWRlZCcsIHRoaXMuX29uQmFzZVRleHR1cmVMb2FkZWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYmFzZVRleHR1cmUuZ2V0RnJhbWUoKVxuICAgICAgaWYgKCF0aGlzLl9mcmFtZUxvY2tlZCkge1xuICAgICAgICB0aGlzLl9mcmFtZSA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgIH1cbiAgICAgIHRoaXMuX29uQmFzZVRleHR1cmVMb2FkZWQoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX1cbiAgICovXG4gIGdldEZyYW1lICgpIHsgcmV0dXJuIHRoaXMuX2ZyYW1lIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZnJhbWVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX0gZnJhbWVcbiAgICovXG4gIHNldEZyYW1lIChmcmFtZSkge1xuICAgIHRoaXMuX2ZyYW1lID0gZnJhbWVcbiAgICB0aGlzLl91cGRhdGVVVnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFdpZHRoICgpIHsgcmV0dXJuIHRoaXMuX2ZyYW1lLndpZHRoIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldEhlaWdodCAoKSB7IHJldHVybiB0aGlzLl9mcmFtZS5oZWlnaHQgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0dXJlIFVWc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZVVWc31cbiAgICovXG4gIGdldFVWcyAoKSB7IHJldHVybiB0aGlzLl91dnMgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIHRoaXMgdGV4dHVyZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXREaW1lbnNpb25zICgpIHsgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMuX2ZyYW1lLndpZHRoLCB0aGlzLl9mcmFtZS5oZWlnaHQpIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyB0ZXh0dXJlXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGJhc2VUZXh0dXJlXG4gICAqL1xuICBkaXNwb3NlIChiYXNlVGV4dHVyZSA9IHRydWUpIHtcbiAgICBiYXNlVGV4dHVyZSAmJiB0aGlzLl9iYXNlVGV4dHVyZS5kaXNwb3NlKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0dXJlXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvdGV4dHVyZXMvdGV4dHVyZS5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nIH0gZnJvbSAnLi4vZ2xvYmFscydcbmNvbnN0IG5vdyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3aW5kb3cucGVyZm9ybWFuY2UpXG4gIDogcmVxdWlyZSgncGVyZm9ybWFuY2Utbm93JykpXG5cbi8qKlxuICogSG9va3MgaW50byBhIHJlbmRlcmluZyBjb250ZXh0IChXZWJHTFJlbmRlcmluZ0NvbnRleHQgb3IgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSxcbiAqIG1vY2tzIGl0cyBtZXRob2RzIGFuZCBtZWFzdXJlcyB0aGUgdGltZSBjb25zdW1lZCBieSB0aGUgbWV0aG9kIGNhbGxzLiBXaGVuIGBlbmRGcmFtZWBcbiAqIGlzIGNhbGxlZCwgaXQgcHJpbnRzIGEgcGVyZm9ybWFuY2UgcmVwb3J0XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgQ29udGV4dFBlcmZvcm1hbmNlSG9vayB7XG4gIGNvbnN0cnVjdG9yIChjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHRcbiAgICB0aGlzLl90cmFja2luZyA9IGZhbHNlXG5cbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGZvciAobGV0IGtleSBpbiBjb250ZXh0KSB7XG4gICAgICBsZXQgdmFsdWUgPSBjb250ZXh0W2tleV1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICBjb25zdCBmbiA9IGNvbnRleHRba2V5XVxuICAgICAgICAgIGlmICghc2VsZi5fdHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KClcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbi5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgICAgIGNvbnN0IHRpbWUgPSBub3coKSAtIHN0YXJ0XG5cbiAgICAgICAgICBjb25zdCBjYWxsID0ge1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBrZXksXG4gICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGltZVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLl90cmFja2VkQ2FsbHMucHVzaChjYWxsKVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYWtlUHJvcGVydHlXcmFwcGVyKGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZVByb3BlcnR5V3JhcHBlciAocHJvcGVydHkpIHtcbiAgICBjb25zdCBpbnNlY3VyZVByb3BlcnRpZXMgPSBbXG4gICAgICAnX2NvbnRleHQnLCAnX3RyYWNrZWRDYWxscycsICdfdHJhY2tpbmcnXG4gICAgXVxuICAgIGlmIChpbnNlY3VyZVByb3BlcnRpZXMuaW5kZXhPZihwcm9wZXJ0eSkgIT09IC0xKSByZXR1cm5cblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0XG5cbiAgICB0aGlzLl9fZGVmaW5lR2V0dGVyX18ocHJvcGVydHksICgpID0+IHtcbiAgICAgIHJldHVybiBjb250ZXh0W3Byb3BlcnR5XVxuICAgIH0pXG5cbiAgICB0aGlzLl9fZGVmaW5lU2V0dGVyX18ocHJvcGVydHksICh2YWx1ZSkgPT4ge1xuICAgICAgY29udGV4dFtwcm9wZXJ0eV0gPSB2YWx1ZVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRyYWNraW5nIGEgZnJhbWVcbiAgICovXG4gIHN0YXJ0RnJhbWUgKCkge1xuICAgIHRoaXMuX3RyYWNraW5nID0gdHJ1ZVxuICAgIHRoaXMuX3RyYWNrZWRDYWxscyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgdHJhY2tpbmcgYSBmcmFtZSBhbmQgcHJpbnRzIGEgcGVyZm9ybWFuY2UgcmVwb3J0XG4gICAqL1xuICBlbmRGcmFtZSAoKSB7XG4gICAgY29uc3QgdGFnID0gJ1JlbmRlcmluZydcbiAgICBMb2cubG9nKHRhZywgJ0ZyYW1lIHJlbmRlcmluZyByZXN1bHRzOicpXG4gICAgTG9nLmxvZyh0YWcsIGBDb250ZXh0IGNhbGxzOiAke3RoaXMuX3RyYWNrZWRDYWxscy5sZW5ndGh9YClcblxuICAgIGNvbnN0IGdyb3VwZWRDYWxscyA9IHt9XG4gICAgdGhpcy5fdHJhY2tlZENhbGxzLmZvckVhY2goKHsgZnVuY3Rpb25OYW1lLCBkdXJhdGlvbiB9KSA9PiB7XG4gICAgICBncm91cGVkQ2FsbHNbZnVuY3Rpb25OYW1lXSA9IGdyb3VwZWRDYWxsc1tmdW5jdGlvbk5hbWVdIHx8IHtcbiAgICAgICAgdG90YWxEdXJhdGlvbjogMCxcbiAgICAgICAgY2FsbHM6IDBcbiAgICAgIH1cblxuICAgICAgZ3JvdXBlZENhbGxzW2Z1bmN0aW9uTmFtZV0udG90YWxEdXJhdGlvbiArPSBkdXJhdGlvblxuICAgICAgZ3JvdXBlZENhbGxzW2Z1bmN0aW9uTmFtZV0uY2FsbHMrK1xuICAgIH0pXG5cbiAgICBsZXQgY2FsbHNBcnJheSA9IFtdXG4gICAgZm9yIChsZXQga2V5IGluIGdyb3VwZWRDYWxscykge1xuICAgICAgY29uc3QgZGF0YSA9IGdyb3VwZWRDYWxsc1trZXldXG4gICAgICBkYXRhLmF2ZXJhZ2VEdXJhdGlvbiA9IGRhdGEudG90YWxEdXJhdGlvbiAvIGRhdGEuY2FsbHNcblxuICAgICAgY2FsbHNBcnJheS5wdXNoKHsgZnVuY3Rpb25OYW1lOiBrZXksIGRhdGEgfSlcbiAgICB9XG5cbiAgICBjYWxsc0FycmF5LnNvcnQoKGEsIGIpID0+IGIuZGF0YS50b3RhbER1cmF0aW9uIC0gYS5kYXRhLnRvdGFsRHVyYXRpb24pXG4gICAgY2FsbHNBcnJheSA9IGNhbGxzQXJyYXkuc2xpY2UoMCwgMylcblxuICAgIGNhbGxzQXJyYXkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgTG9nLmxvZyh0YWcsIGAke2l0ZW0uZnVuY3Rpb25OYW1lfTogJHtpdGVtLmRhdGEuY2FsbHN9IGNhbGxzLCAke2l0ZW0uZGF0YS50b3RhbER1cmF0aW9uLnRvRml4ZWQoMil9bXNgKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udGV4dFBlcmZvcm1hbmNlSG9va1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL3V0aWxzL2NvbnRleHQtcGVyZm9ybWFuY2UtaG9vay5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhbiBpbWFnZSBpbiBwaXhlbCBhcnJheSBmb3JtLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaXhlbEFycmF5SW1hZ2Uge1xuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGhlaWdodFxuICAgKiBAcGFyYW0gIHtVSW50OEFycmF5fSBkYXRhXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHdpZHRoLCBoZWlnaHQsIGRhdGEpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUGl4ZWxBcnJheUltYWdlIGZyb20gdGhlIGdpdmVuIGBub2RlLWNhbnZhc2AgSW1hZ2Ugb2JqZWN0IGJ5IHJlbmRlcmluZyB0aGUgaW1hZ2VcbiAgICogdG8gYSBjYW52YXMgYW5kIHJlYWRpbmcgdGhlIHBpeGVsIGRhdGFcbiAgICogQHBhcmFtICB7Q2FudmFzLkltYWdlfSBpbWFnZVxuICAgKiBAcmV0dXJuIHtQaXhlbEFycmF5SW1hZ2V9XG4gICAqL1xuICBzdGF0aWMgZnJvbU5vZGVDYW52YXNJbWFnZSAoaW1hZ2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBuZXcgQ2FudmFzKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMClcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KVxuICAgIHJldHVybiBuZXcgUGl4ZWxBcnJheUltYWdlKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlRGF0YS5kYXRhKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvdXRpbHMvcGl4ZWwtYXJyYXktaW1hZ2UuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBMb2cgZnJvbSAnLi4vLi4vc2hhcmVkL2xvZydcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudGx5IGJvdW5kIGZyYW1lYnVmZmVyIGlzIGNvbXBsZXRlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdGFnXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAgICovXG4gIGNoZWNrRnJhbWVidWZmZXJTdGF0dXMgKHRhZywgZ2wpIHtcbiAgICBjb25zdCBmYm9TdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKVxuXG4gICAgY29uc3QgcG9zc2libGVTdGF0dXNlcyA9IHtcbiAgICAgIFtnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRdOiAnSW5jb21wbGV0ZSBhdHRhY2htZW50JyxcbiAgICAgIFtnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVF06ICdNaXNzaW5nIGF0dGFjaG1lbnQnLFxuICAgICAgW2dsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU106ICdJbmNvbXBsZXRlIGRpbWVuc2lvbnMnLFxuICAgICAgW2dsLkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXTogJ0ZyYW1lYnVmZmVyIHVuc3VwcG9ydGVkJ1xuICAgIH1cblxuICAgIGlmIChmYm9TdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG4gICAgICBMb2cud2Fybih0YWcsIGBGcmFtZWJ1ZmZlciBpbmNvbXBsZXRlOiAke3Bvc3NpYmxlU3RhdHVzZXNbZmJvU3RhdHVzXX1gKVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL2dsLXV0aWxzLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuL3ZlY3RvcjInXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIDMtZGltZW5zaW9uYWwgbWF0cml4XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5NYXRoXG4gKi9cbmNsYXNzIE1hdHJpeCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTWF0cml4XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5NYXRyaXh9IG1hdHJpeFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLk1hdHJpeH1cbiAgICovXG4gIG11bHRpcGx5IChtYXRyaXgpIHtcbiAgICBsZXQgYSwgYiwgYywgZCwgdHgsIHR5XG4gICAgYSA9IHRoaXMuYSAqIG1hdHJpeC5hICsgdGhpcy5iICogbWF0cml4LmNcbiAgICBiID0gdGhpcy5hICogbWF0cml4LmIgKyB0aGlzLmIgKiBtYXRyaXguZFxuICAgIGMgPSB0aGlzLmMgKiBtYXRyaXguYSArIHRoaXMuZCAqIG1hdHJpeC5jXG4gICAgZCA9IHRoaXMuYyAqIG1hdHJpeC5iICsgdGhpcy5kICogbWF0cml4LmRcbiAgICB0eCA9IHRoaXMudHggKiBtYXRyaXguYSArIHRoaXMudHkgKiBtYXRyaXguYyArIG1hdHJpeC50eFxuICAgIHR5ID0gdGhpcy50eCAqIG1hdHJpeC5iICsgdGhpcy50eSAqIG1hdHJpeC5kICsgbWF0cml4LnR5XG5cbiAgICB0aGlzLmEgPSBhXG4gICAgdGhpcy5iID0gYlxuICAgIHRoaXMuYyA9IGNcbiAgICB0aGlzLmQgPSBkXG4gICAgdGhpcy50eCA9IHR4XG4gICAgdGhpcy50eSA9IHR5XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgbWF0cml4IHRvIHRoZSBnaXZlbiB2ZWN0b3JcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBhcHBseVRvVmVjdG9yIChwb3NpdGlvbikge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9zaXRpb25cbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKClcbiAgICBwb3NpdGlvbi54ID0gdGhpcy5hICogeCArIHRoaXMuYyAqIHkgKyB0aGlzLnR4XG4gICAgcG9zaXRpb24ueSA9IHRoaXMuYiAqIHggKyB0aGlzLmQgKiB5ICsgdGhpcy50eFxuICAgIHJldHVybiBwb3NpdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXggdG8gdGhlIGdpdmVuIHZlY3RvclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGFwcGx5SW52ZXJzZVRvVmVjdG9yIChwb3NpdGlvbikge1xuICAgIGNvbnN0IGRldGVybWluYW50ID0gMSAvICh0aGlzLmEgKiB0aGlzLmQgKyB0aGlzLmMgKiAtdGhpcy5iKVxuXG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb3NpdGlvblxuICAgIHBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKVxuICAgIHBvc2l0aW9uLnggPSB0aGlzLmQgKiBkZXRlcm1pbmFudCAqIHggK1xuICAgICAgLXRoaXMuYyAqIGRldGVybWluYW50ICogeSArXG4gICAgICAodGhpcy50eSAqIHRoaXMuYyAtIHRoaXMudHggKiB0aGlzLmQpICogZGV0ZXJtaW5hbnRcbiAgICBwb3NpdGlvbi55ID0gdGhpcy5hICogZGV0ZXJtaW5hbnQgKiB5ICtcbiAgICAgIC10aGlzLmIgKiBkZXRlcm1pbmFudCAqIHggK1xuICAgICAgKC10aGlzLnR5ICogdGhpcy5hICsgdGhpcy50eCAqIHRoaXMuYikgKiBkZXRlcm1pbmFudFxuXG4gICAgcmV0dXJuIHBvc2l0aW9uXG4gIH1cblxuICAvKipcbiAgICogVHVybnMgdGhlIGdpdmVuIHJlY3RhbmdsZSBpbnRvIHZlY3RvciBjb29yZGluYXRlcyBieSBhcHBseWluZyB0aGlzIE1hdHJpeFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX0gcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gYW5jaG9yXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMltdfVxuICAgKi9cbiAgcmVjdGFuZ2xlVG9Db29yZGluYXRlcyAocmVjdGFuZ2xlLCBhbmNob3IgPSBuZXcgVmVjdG9yMigwLCAwKSkge1xuICAgIC8vIEFuY2hvciBvZmZzZXRzICh3MCA9IHJpZ2h0LCB3MSA9IGxlZnQsIGgwID0gdXAsIGgxID0gZG93bilcbiAgICBjb25zdCB3MCA9IHJlY3RhbmdsZS53aWR0aCAqICgxIC0gYW5jaG9yLngpXG4gICAgY29uc3QgdzEgPSByZWN0YW5nbGUud2lkdGggKiAtYW5jaG9yLnhcbiAgICBjb25zdCBoMCA9IHJlY3RhbmdsZS5oZWlnaHQgKiAoMSAtIGFuY2hvci55KVxuICAgIGNvbnN0IGgxID0gcmVjdGFuZ2xlLmhlaWdodCAqIC1hbmNob3IueVxuXG4gICAgbGV0IHBvc2l0aW9ucyA9IFtdXG5cbiAgICAvLyBCb3R0b20gTGVmdFxuICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBWZWN0b3IyKFxuICAgICAgdGhpcy5hICogdzEgKyB0aGlzLmMgKiBoMSArIHRoaXMudHgsXG4gICAgICB0aGlzLmQgKiBoMSArIHRoaXMuYiAqIHcxICsgdGhpcy50eVxuICAgICkpXG5cbiAgICAvLyBCb3R0b20gUmlnaHRcbiAgICBwb3NpdGlvbnMucHVzaChuZXcgVmVjdG9yMihcbiAgICAgIHRoaXMuYSAqIHcwICsgdGhpcy5jICogaDEgKyB0aGlzLnR4LFxuICAgICAgdGhpcy5kICogaDEgKyB0aGlzLmIgKiB3MCArIHRoaXMudHlcbiAgICApKVxuXG4gICAgLy8gVG9wIFJpZ2h0XG4gICAgcG9zaXRpb25zLnB1c2gobmV3IFZlY3RvcjIoXG4gICAgICB0aGlzLmEgKiB3MCArIHRoaXMuYyAqIGgwICsgdGhpcy50eCxcbiAgICAgIHRoaXMuZCAqIGgwICsgdGhpcy5iICogdzAgKyB0aGlzLnR5XG4gICAgKSlcblxuICAgIC8vIFRvcCBMZWZ0XG4gICAgcG9zaXRpb25zLnB1c2gobmV3IFZlY3RvcjIoXG4gICAgICB0aGlzLmEgKiB3MSArIHRoaXMuYyAqIGgwICsgdGhpcy50eCxcbiAgICAgIHRoaXMuZCAqIGgwICsgdGhpcy5iICogdzEgKyB0aGlzLnR5XG4gICAgKSlcblxuICAgIHJldHVybiBwb3NpdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhpcyBtYXRyaXggdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICAgKi9cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMuYSA9IDFcbiAgICB0aGlzLmIgPSAwXG4gICAgdGhpcy5jID0gMFxuICAgIHRoaXMuZCA9IDFcbiAgICB0aGlzLnR4ID0gMFxuICAgIHRoaXMudHkgPSAwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxuICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9XG4gICAqL1xuICB0b0FycmF5ICgpIHtcbiAgICBjb25zdCBhcnIgPSBbXG4gICAgICB0aGlzLmEsIHRoaXMuYiwgMCxcbiAgICAgIHRoaXMuYywgdGhpcy5kLCAwLFxuICAgICAgdGhpcy50eCwgdGhpcy50eSwgMVxuICAgIF1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGFyclxuICAgIH1cbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShhcnIpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIGBNYXRyaXgoeyBhOiAke3RoaXMuYX0sIGI6ICR7dGhpcy5ifSwgYzogJHt0aGlzLmN9LCBkOiAke3RoaXMuZH0sIHR4OiAke3RoaXMudHh9LCB0eTogJHt0aGlzLnR5fSB9KWBcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpdHkgbWF0cml4XG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLk1hdGguTWF0cml4fVxuICAgKi9cbiAgc3RhdGljIGdldCBJREVOVElUWSAoKSB7IHJldHVybiBuZXcgTWF0cml4KCkgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXRyaXhcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9tYXRoL21hdHJpeC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgUmVjdGFuZ2xlXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5NYXRoXG4gKi9cbmNsYXNzIFJlY3RhbmdsZSB7XG4gIC8qKlxuICAgKiBDcmVhcnRlcyBhIFJlY3RhbmdsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ggPSAwXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3kgPSAwXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoICA9IDBdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0ID0gMF1cbiAgICovXG4gIGNvbnN0cnVjdG9yICh4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgIHRoaXMueCA9IHhcbiAgICB0aGlzLnkgPSB5XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9XG4gICAqL1xuICBzZXQgKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnggPSB4XG4gICAgdGhpcy55ID0geVxuICAgIHRoaXMud2lkdGggPSB3aWR0aFxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyByZWN0YW5nbGVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9IG90aGVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfVxuICAgKi9cbiAgY29weSAob3RoZXIpIHtcbiAgICB0aGlzLnggPSBvdGhlci54XG4gICAgdGhpcy55ID0gb3RoZXIueVxuICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aFxuICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHJlY3RhbmdsZSdzIHZhbHVlcyBhcmUgdGhlIHNhbWUgYXMgdGhlIGdpdmVuIG9uZXNcbiAgICogQHBhcmFtICB7KE51bWJlcnxQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZSl9IHJlY3RcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5XG4gICAqIEBwYXJhbSAge051bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBoZWlnaHRcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGVxdWFscyAocmVjdCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmIChyZWN0IGluc3RhbmNlb2YgUmVjdGFuZ2xlKSB7XG4gICAgICByZXR1cm4gcmVjdC54ID09PSB0aGlzLnggJiZcbiAgICAgICAgcmVjdC55ID09PSB0aGlzLnkgJiZcbiAgICAgICAgcmVjdC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJlxuICAgICAgICByZWN0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeCA9IHJlY3RcbiAgICAgIHJldHVybiB4ID09PSB0aGlzLnggJiZcbiAgICAgICAgeSA9PT0gdGhpcy55ICYmXG4gICAgICAgIHdpZHRoID09PSB0aGlzLndpZHRoICYmXG4gICAgICAgIGhlaWdodCA9PT0gdGhpcy5oZWlnaHRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUm91bmRzIHRoaXMgcmVjdGFuZ2xlJ3MgdmFsdWVzXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfVxuICAgKi9cbiAgcm91bmQgKCkge1xuICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KVxuICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KVxuICAgIHRoaXMud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGgpXG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIGBSZWN0YW5nbGUoeyB4OiAke3RoaXMueH0sIHk6ICR7dGhpcy55fSwgd2lkdGg6ICR7dGhpcy53aWR0aH0sIGhlaWdodDogJHt0aGlzLmhlaWdodH0gfSlgXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVjdGFuZ2xlXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvbWF0aC9yZWN0YW5nbGUuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IExvZyB9IGZyb20gJy4uL2dsb2JhbHMnXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3Qgbm93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSlcbiAgOiByZXF1aXJlKCdwZXJmb3JtYW5jZS1ub3cnKSlcblxuLyoqXG4gKiBBIHNpbXBsZSBjbGFzcyB0aGF0IHRyYWNrcyB0aGUgdGltZSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgYW5kIHJlbmRlcnMgaXQgYXMgRlBTXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICogQGlnbm9yZVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY2xhc3MgUGVyZm9ybWFuY2VUZXN0IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJmb3JtYW5jZVRlc3RcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0YWdcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGFnLCBuYW1lKSB7XG4gICAgdGhpcy5fdGFnID0gdGFnXG4gICAgdGhpcy5fbmFtZSA9IG5hbWVcbiAgICB0aGlzLl9zdGFydCA9IG5vdygpXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgdGhlIHBlcmZvcm1hbmNlIHRlc3QgYW5kIHByaW50cyB0aGUgcmVzdWx0XG4gICAqL1xuICBzdG9wICgpIHtcbiAgICBjb25zdCBlbmQgPSBub3coKVxuICAgIGNvbnN0IG1zID0gZW5kIC0gdGhpcy5fc3RhcnRcbiAgICBjb25zdCBmcHMgPSBNYXRoLnJvdW5kKDEwMDAgLyBtcylcbiAgICBMb2cuaW5mbyh0aGlzLl90YWcsIGAke3RoaXMuX25hbWV9IHRvb2sgJHttcy50b0ZpeGVkKDIpfW1zICgke2Zwc30gRlBTKWApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGVyZm9ybWFuY2VUZXN0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvcGVyZm9ybWFuY2UtdGVzdC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgRW5naW5lLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuY29uc3QgeyBVbmlmb3JtVHlwZSwgT3B0aW9uVHlwZSB9ID0gQ29uc3RhbnRzXG5cbmNsYXNzIEFkanVzdG1lbnRzRmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vc2hhZGVycy9nZW5lcmljL2FkanVzdG1lbnRzLmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGxldCB7IGJyaWdodG5lc3MsIHNhdHVyYXRpb24sIGNvbnRyYXN0LCBnYW1tYSwgZXhwb3N1cmUsIHNoYWRvd3MsIGhpZ2hsaWdodHMgfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIGNvbnN0IGFwcGx5QnJpZ2h0bmVzcyA9IGJyaWdodG5lc3MgIT09IDBcbiAgICBjb25zdCBhcHBseVNhdHVyYXRpb24gPSBzYXR1cmF0aW9uICE9PSAxXG4gICAgY29uc3QgYXBwbHlDb250cmFzdCA9IGNvbnRyYXN0ICE9PSAxXG4gICAgY29uc3QgYXBwbHlFeHBvc3VyZSA9IGV4cG9zdXJlICE9PSAwXG4gICAgY29uc3QgYXBwbHlHYW1tYSA9IGdhbW1hICE9PSAxXG4gICAgY29uc3QgYXBwbHlTaGFkb3dzQW5kSGlnaGxpZ2h0cyA9IChzaGFkb3dzICE9PSAwIHx8IGhpZ2hsaWdodHMgIT09IDEpXG5cbiAgICBsZXQgZXhwb3N1cmVGYWN0b3IgPSBNYXRoLnBvdygyLjAsIGV4cG9zdXJlKVxuXG4gICAgYnJpZ2h0bmVzcyA9IGJyaWdodG5lc3MgKiAyNTVcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0XG4gICAgICBsZXQgciA9IGltYWdlRGF0YS5kYXRhW2luZGV4XVxuICAgICAgbGV0IGcgPSBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdXG4gICAgICBsZXQgYiA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl1cblxuICAgICAgLy8gR2FtbWFcbiAgICAgIGlmIChhcHBseUdhbW1hKSB7XG4gICAgICAgIHIgPSBNYXRoLnBvdyhyIC8gMjU1LCAxLjAgLyBnYW1tYSkgKiAyNTVcbiAgICAgICAgZyA9IE1hdGgucG93KGcgLyAyNTUsIDEuMCAvIGdhbW1hKSAqIDI1NVxuICAgICAgICBiID0gTWF0aC5wb3coYiAvIDI1NSwgMS4wIC8gZ2FtbWEpICogMjU1XG4gICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvclxuICAgICAgaWYgKGFwcGx5RXhwb3N1cmUgfHwgYXBwbHlTaGFkb3dzQW5kSGlnaGxpZ2h0cykge1xuICAgICAgICByIC89IDI1NS4wXG4gICAgICAgIGcgLz0gMjU1LjBcbiAgICAgICAgYiAvPSAyNTUuMFxuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBFeHBvc3VyZVxuICAgICAgaWYgKGFwcGx5RXhwb3N1cmUpIHtcbiAgICAgICAgciAqPSBleHBvc3VyZUZhY3RvclxuICAgICAgICBnICo9IGV4cG9zdXJlRmFjdG9yXG4gICAgICAgIGIgKj0gZXhwb3N1cmVGYWN0b3JcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgc2hhZG93cyBhbmQgaGlnaGxpZ2h0c1xuICAgICAgaWYgKGFwcGx5U2hhZG93c0FuZEhpZ2hsaWdodHMpIHtcbiAgICAgICAgY29uc3QgbHVtaW5hbmNlID0gciAqIDAuMjEyNSArIGcgKiAwLjcxNTQgKyBiICogMC4wNzIxXG4gICAgICAgIGxldCBzaGFkb3cgPSAoTWF0aC5wb3cobHVtaW5hbmNlLCAxLjAgLyAoc2hhZG93cyArIDEuMCkpICsgLTAuNzYgKiBNYXRoLnBvdyhsdW1pbmFuY2UsIDIuMCAvIChzaGFkb3dzICsgMS4wKSkpIC0gbHVtaW5hbmNlXG4gICAgICAgIHNoYWRvdyA9IE1hdGgubWF4KHNoYWRvdywgMC4wKVxuICAgICAgICBzaGFkb3cgPSBNYXRoLm1pbihzaGFkb3csIDEuMClcbiAgICAgICAgbGV0IGhpZ2hsaWdodCA9ICgxLjAgLSAoTWF0aC5wb3coMS4wIC0gbHVtaW5hbmNlLCAxLjAgLyAoMi4wIC0gaGlnaGxpZ2h0cykpICsgLTAuOCAqIE1hdGgucG93KDEuMCAtIGx1bWluYW5jZSwgMi4wIC8gKDIuMCAtIGhpZ2hsaWdodHMpKSkpIC0gbHVtaW5hbmNlXG4gICAgICAgIGhpZ2hsaWdodCA9IE1hdGgubWF4KGhpZ2hsaWdodCwgLTEuMClcbiAgICAgICAgaGlnaGxpZ2h0ID0gTWF0aC5taW4oaGlnaGxpZ2h0LCAwLjApXG4gICAgICAgIGxldCBvZmZzZXQgPSBsdW1pbmFuY2UgKyBzaGFkb3cgKyBoaWdobGlnaHRcbiAgICAgICAgciA9IChvZmZzZXQgKiByIC8gbHVtaW5hbmNlKVxuICAgICAgICBnID0gKG9mZnNldCAqIGcgLyBsdW1pbmFuY2UpXG4gICAgICAgIGIgPSAob2Zmc2V0ICogYiAvIGx1bWluYW5jZSlcbiAgICAgIH1cblxuICAgICAgLy8gRGVub3JtYWxpemUgY29sb3JcbiAgICAgIGlmIChhcHBseUV4cG9zdXJlIHx8IGFwcGx5U2hhZG93c0FuZEhpZ2hsaWdodHMpIHtcbiAgICAgICAgciAqPSAyNTUuMFxuICAgICAgICBnICo9IDI1NS4wXG4gICAgICAgIGIgKj0gMjU1LjBcbiAgICAgIH1cblxuICAgICAgLy8gQnJpZ2h0bmVzc1xuICAgICAgaWYgKGFwcGx5QnJpZ2h0bmVzcykge1xuICAgICAgICByID0gciArIGJyaWdodG5lc3NcbiAgICAgICAgZyA9IGcgKyBicmlnaHRuZXNzXG4gICAgICAgIGIgPSBiICsgYnJpZ2h0bmVzc1xuICAgICAgfVxuXG4gICAgICAvLyBTYXR1cmF0aW9uXG4gICAgICBpZiAoYXBwbHlTYXR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGx1bWluYW5jZSA9IHIgKiAwLjIxMjUgKyBnICogMC43MTU0ICsgYiAqIDAuMDcyMVxuICAgICAgICByID0gbHVtaW5hbmNlICogKDEgLSBzYXR1cmF0aW9uKSArIChyICogc2F0dXJhdGlvbilcbiAgICAgICAgZyA9IGx1bWluYW5jZSAqICgxIC0gc2F0dXJhdGlvbikgKyAoZyAqIHNhdHVyYXRpb24pXG4gICAgICAgIGIgPSBsdW1pbmFuY2UgKiAoMSAtIHNhdHVyYXRpb24pICsgKGIgKiBzYXR1cmF0aW9uKVxuICAgICAgfVxuXG4gICAgICAvLyBDb250cmFzdFxuICAgICAgaWYgKGFwcGx5Q29udHJhc3QpIHtcbiAgICAgICAgciA9IChyIC0gMTI3KSAqIGNvbnRyYXN0ICsgMTI3XG4gICAgICAgIGcgPSAoZyAtIDEyNykgKiBjb250cmFzdCArIDEyN1xuICAgICAgICBiID0gKGIgLSAxMjcpICogY29udHJhc3QgKyAxMjdcbiAgICAgIH1cblxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gclxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGdcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBiXG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbkFkanVzdG1lbnRzRmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBicmlnaHRuZXNzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQgfSxcbiAgc2F0dXJhdGlvbjogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMSwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUIH0sXG4gIGNvbnRyYXN0OiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAxLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQgfSxcbiAgZ2FtbWE6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDEsIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5GTE9BVCB9LFxuICBleHBvc3VyZTogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMCwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUIH0sXG4gIHNoYWRvd3M6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDAsIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5GTE9BVCB9LFxuICBoaWdobGlnaHRzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAxLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBZGp1c3RtZW50c0ZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9hZGp1c3RtZW50cy9hZGp1c3RtZW50cy1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFByb21pc2UgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcblxuLyoqXG4gKiBJZGVudGl0eSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBJZGVudGl0eUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtFbmdpbmUuUmVuZGVyVGV4dHVyZX1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAoc2RrLCByZW5kZXJUZXh0dXJlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cbn1cblxuSWRlbnRpdHlGaWx0ZXIuaXNJZGVudGl0eSA9IHRydWVcbklkZW50aXR5RmlsdGVyLmRpc3BsYXlOYW1lID0gJ09yaWdpbmFsJ1xuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbklkZW50aXR5RmlsdGVyLmlkZW50aWZpZXIgPSAnaWRlbnRpdHknXG5cbmV4cG9ydCBkZWZhdWx0IElkZW50aXR5RmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvaWRlbnRpdHktZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5jb25zdCBURVhUVVJFX0dMX1VOSVQgPSAzXG5cbmltcG9ydCBFbmdpbmUgZnJvbSAnLi4vLi4vLi4vZW5naW5lLydcbmltcG9ydCBQcmltaXRpdmUgZnJvbSAnLi9wcmltaXRpdmUnXG5pbXBvcnQgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSwgUmVuZGVyZXJUeXBlIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzJ1xuXG5jbGFzcyBMb29rdXBUYWJsZUZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uLy4uL3NoYWRlcnMvcHJpbWl0aXZlcy9sb29rdXAtdGFibGUuZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl9vcHRpb25zLmxvb2t1cFRhYmxlRGF0YVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0XG5cbiAgICAgIHZhciByID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdXG4gICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSB0YWJsZVtyICogNF1cbiAgICAgIHZhciBnID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXVxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IHRhYmxlWzEgKyBnICogNF1cbiAgICAgIHZhciBiID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXVxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IHRhYmxlWzIgKyBiICogNF1cbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuTG9va3VwVGFibGVGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGxvb2t1cFRhYmxlOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiBURVhUVVJFX0dMX1VOSVQsIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5JTlQgfSxcbiAgbG9va3VwVGFibGVEYXRhOiB7IHR5cGU6IE9wdGlvblR5cGUuQVJSQVksIGRlZmF1bHQ6IFtdIH1cbn1cblxuLyoqXG4gKiBTdG9yZXMgYSAyNTYgYnl0ZSBsb25nIGxvb2t1cCB0YWJsZSBpbiBhIDJkIHRleHR1cmUgd2hpY2ggd2lsbCBiZVxuICogdXNlZCB0byBsb29rIHVwIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciBlYWNoIGNoYW5uZWwuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlcnMuUHJpbWl0aXZlXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5jbGFzcyBMb29rdXBUYWJsZSBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBMb29rdXBUYWJsZUZpbHRlcigpXG4gICAgdGhpcy5fdGV4dHVyZXMgPSB7fVxuICAgIHRoaXMuX3JlbmRlcmVycyA9IHt9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYmVmb3JlIHRoaXMgcHJpbWl0aXZlJ3MgZmlsdGVyIGlzIGJlaW5nIGFwcGxpZWRcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqL1xuICB1cGRhdGUgKHNkaykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gc2RrLmdldFJlbmRlcmVyKClcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2ViR0xUZXh0dXJlKHNkaylcbiAgICB9IGVsc2UgaWYgKHJlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5DQU5WQVMpKSB7XG4gICAgICB0aGlzLl9maWx0ZXIuc2V0TG9va3VwVGFibGVEYXRhKHRoaXMuX29wdGlvbnMuZGF0YSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9va3VwIHRhYmxlIHRleHR1cmUgKFdlYkdMIG9ubHkpXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgX3VwZGF0ZVdlYkdMVGV4dHVyZSAoc2RrKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvb2t1cFRhYmxlOiBObyBkYXRhIHNwZWNpZmllZC4nKVxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLl9vcHRpb25zLmRhdGEpXG5cbiAgICBjb25zdCByZW5kZXJlciA9IHNkay5nZXRSZW5kZXJlcigpXG4gICAgY29uc3QgeyBpZCB9ID0gcmVuZGVyZXJcbiAgICB0aGlzLl9yZW5kZXJlcnNbaWRdID0gcmVuZGVyZXJcbiAgICBpZiAoIXRoaXMuX3RleHR1cmVzW2lkXSkge1xuICAgICAgdGhpcy5fdGV4dHVyZXNbaWRdID0gbmV3IEVuZ2luZS5CYXNlVGV4dHVyZSgpXG4gICAgfVxuXG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmVzW2lkXVxuICAgIGNvbnN0IHBpeGVsQXJyYXlJbWFnZSA9IG5ldyBFbmdpbmUuUGl4ZWxBcnJheUltYWdlKDI1NiwgMSwgZGF0YSlcbiAgICB0ZXh0dXJlLnNldFNvdXJjZShwaXhlbEFycmF5SW1hZ2UpXG4gICAgdGV4dHVyZS5zZXRHTFVuaXQoVEVYVFVSRV9HTF9VTklUKVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAocmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKSkge1xuICAgICAgcmVuZGVyZXIudXBkYXRlVGV4dHVyZSh0ZXh0dXJlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhpcyBwcmltaXRpdmVcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICAgIGZvciAobGV0IGlkIGluIHRoaXMuX3RleHR1cmVzKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlc1tpZF0uZGlzcG9zZSgpXG4gICAgICBkZWxldGUgdGhpcy5fdGV4dHVyZXNbaWRdXG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9vcHRpb25zLmRhdGFcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb29rdXBUYWJsZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvbG9va3VwLXRhYmxlLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBVdGlscywgRW5naW5lLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuY29uc3QgeyBPcHRpb25UeXBlLCBSZW5kZXJlclR5cGUgfSA9IENvbnN0YW50c1xuaW1wb3J0IFBhdGggZnJvbSAnLi9icnVzaC9wYXRoJ1xuaW1wb3J0IFNwcml0ZSBmcm9tICcuL3Nwcml0ZSdcblxuLyoqXG4gKiBBIEJydXNoIHRoYXQgY2FuIGJlIGRyYXduIGJ5IFNwcml0ZU9wZXJhdGlvbi4gU2hvdWxkIG9ubHkgYmUgY3JlYXRlZCB2aWEge0BsaW5rIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uI2NyZWF0ZUJydXNofVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb25cbiAqL1xuY2xhc3MgQnJ1c2ggZXh0ZW5kcyBTcHJpdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTdGlja2VyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3BlcnNpc3RlZFBhdGhzID0gW11cbiAgICB0aGlzLl9vdXRwdXRDYW52YXNEaXJ0eSA9IHRydWVcbiAgICB0aGlzLl9vdXRwdXRDYW52YXMgPSBVdGlscy5jcmVhdGVDYW52YXMoKVxuICAgIHRoaXMuX291dHB1dENvbnRleHQgPSB0aGlzLl9vdXRwdXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIHRoaXMuX3BlcnNpc3RDYW52YXMgPSBVdGlscy5jcmVhdGVDYW52YXMoKVxuICAgIHRoaXMuX3BlcnNpc3RDb250ZXh0ID0gdGhpcy5fcGVyc2lzdENhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgdGhpcy5fbmV4dENhbnZhcyA9IFV0aWxzLmNyZWF0ZUNhbnZhcygpXG5cbiAgICB0aGlzLl90ZXh0dXJlID0gRW5naW5lLlRleHR1cmUuZnJvbUNhbnZhcyh0aGlzLl9vdXRwdXRDYW52YXMpXG4gICAgdGhpcy5fc3ByaXRlLnNldFRleHR1cmUodGhpcy5fdGV4dHVyZSlcblxuICAgIHRoaXMuX29uUGF0aFVwZGF0ZSA9IHRoaXMuX29uUGF0aFVwZGF0ZS5iaW5kKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBhIGZsaXAgaW4gdGhlIGdpdmVuIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKi9cbiAgYXBwbHlGbGlwIChkaXJlY3Rpb24pIHtcbiAgICB0aGlzLl9vcHRpb25zLnBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIHBhdGguZm9yRWFjaENvbnRyb2xQb2ludCgoY29udHJvbFBvaW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gY29udHJvbFBvaW50LmdldFBvc2l0aW9uKCkuY2xvbmUoKVxuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICAgICAgcG9zaXRpb24ueCA9IDEgLSBwb3NpdGlvbi54XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICAgIHBvc2l0aW9uLnkgPSAxIC0gcG9zaXRpb24ueVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sUG9pbnQuc2V0UG9zaXRpb24ocG9zaXRpb24pXG4gICAgICB9KVxuICAgICAgcGF0aC5zZXREaXJ0eSh0cnVlKVxuICAgIH0pXG5cbiAgICB0aGlzLl9yZXNldCgpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBhIHJvdGF0aW9uIHdpdGggdGhlIGdpdmVuIGRlZ3JlZXNcbiAgICogQHBhcmFtICB7TnVtYmVyfSBkZWdyZWVzXG4gICAqL1xuICBhcHBseVJvdGF0aW9uIChkZWdyZWVzKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5wYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICBwYXRoLmZvckVhY2hDb250cm9sUG9pbnQoKGNvbnRyb2xQb2ludCkgPT4ge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGNvbnRyb2xQb2ludC5nZXRQb3NpdGlvbigpLmNsb25lKClcbiAgICAgICAgaWYgKGRlZ3JlZXMgPT09IDkwKSB7XG4gICAgICAgICAgcG9zaXRpb24uZmxpcCgpXG4gICAgICAgICAgcG9zaXRpb24ueCA9IDEgLSBwb3NpdGlvbi54XG4gICAgICAgIH0gZWxzZSBpZiAoZGVncmVlcyA9PT0gLTkwKSB7XG4gICAgICAgICAgcG9zaXRpb24uZmxpcCgpXG4gICAgICAgICAgcG9zaXRpb24ueSA9IDEgLSBwb3NpdGlvbi55XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbFBvaW50LnNldFBvc2l0aW9uKHBvc2l0aW9uKVxuICAgICAgfSlcblxuICAgICAgcGF0aC5zZXREaXJ0eSh0cnVlKVxuICAgIH0pXG5cbiAgICB0aGlzLl9yZXNldCgpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZ2l2ZW4gY3JvcCBjaGFuZ2VcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5Dcm9wT3BlcmF0aW9ufSBjcm9wT3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXBwbHlDcm9wIChjcm9wT3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fcmVzZXQoKVxuXG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gY3JvcE9wZXJhdGlvbi5nZXRJbnB1dERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IHJvdGF0aW9uRGVsdGEgPSAob3B0aW9ucy5yb3RhdGlvbiAtIGNyb3BPcGVyYXRpb24uZ2V0Um90YXRpb24oKSlcblxuICAgIGNvbnN0IG9sZEFic29sdXRlU2l6ZSA9IGNyb3BPcGVyYXRpb24uZ2V0RW5kKCkuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KGNyb3BPcGVyYXRpb24uZ2V0U3RhcnQoKSlcbiAgICAgIC5tdWx0aXBseShpbnB1dERpbWVuc2lvbnMpXG4gICAgY29uc3QgbmV3QWJzb2x1dGVTaXplID0gb3B0aW9ucy5lbmQuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KG9wdGlvbnMuc3RhcnQpXG4gICAgICAubXVsdGlwbHkoaW5wdXREaW1lbnNpb25zKVxuICAgIGNvbnN0IGFic29sdXRlU3RhcnREaWZmID0gY3JvcE9wZXJhdGlvbi5nZXRTdGFydCgpLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdChvcHRpb25zLnN0YXJ0KVxuICAgICAgLm11bHRpcGx5KGlucHV0RGltZW5zaW9ucylcbiAgICBjb25zdCBzY2FsZVJhdGlvID0gb3B0aW9ucy5zY2FsZSAvIGNyb3BPcGVyYXRpb24uZ2V0U2NhbGUoKVxuICAgIGNvbnN0IGFic29sdXRlU3RhcnQgPSBjcm9wT3BlcmF0aW9uLmdldFN0YXJ0KCkuY2xvbmUoKS5tdWx0aXBseShpbnB1dERpbWVuc2lvbnMpXG5cbiAgICB0aGlzLl9vcHRpb25zLnBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIHBhdGguZm9yRWFjaENvbnRyb2xQb2ludCgoY29udHJvbFBvaW50KSA9PiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb24gaW5wdXQgaW1hZ2VcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbk9uSW1hZ2UgPSBjb250cm9sUG9pbnQuZ2V0UG9zaXRpb24oKS5jbG9uZSgpXG4gICAgICAgICAgLm11bHRpcGx5KG9sZEFic29sdXRlU2l6ZSkgLy8gQ29tcGVuc2F0ZSBjcm9wIHNpemVcbiAgICAgICAgICAuYWRkKGFic29sdXRlU3RhcnQpIC8vIENvbXBlbnNhdGUgY3JvcCBzdGFydCAvIG9mZnNldFxuXG4gICAgICAgIC8vIFJlcG9zaXRpb24gc3ByaXRlXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIGlucHV0IGltYWdlJ3MgY2VudGVyIChpbiBwaXhlbHMpXG4gICAgICAgIGNvbnN0IGRlbHRhVG9DZW50ZXIgPSBhYnNvbHV0ZVBvc2l0aW9uT25JbWFnZS5jbG9uZSgpXG4gICAgICAgICAgLnN1YnRyYWN0KGlucHV0RGltZW5zaW9ucy5jbG9uZSgpLm11bHRpcGx5KDAuNSkpXG5cbiAgICAgICAgLy8gUm90YXRlIGRlbHRhIGFyb3VuZCBjZW50ZXJcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3Mocm90YXRpb25EZWx0YSlcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocm90YXRpb25EZWx0YSlcbiAgICAgICAgY29uc3QgbmV3RGVsdGFUb0NlbnRlciA9IG5ldyBWZWN0b3IyKFxuICAgICAgICAgIGRlbHRhVG9DZW50ZXIueCAqIGNvcyAtIGRlbHRhVG9DZW50ZXIueSAqIHNpbixcbiAgICAgICAgICBkZWx0YVRvQ2VudGVyLnggKiBzaW4gKyBkZWx0YVRvQ2VudGVyLnkgKiBjb3NcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIEFwcGx5IHNjYWxlIGNoYW5nZSB0byBkZWx0YVxuICAgICAgICBuZXdEZWx0YVRvQ2VudGVyLm11bHRpcGx5KHNjYWxlUmF0aW8pXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBwb3NpdGlvblxuICAgICAgICAvLyBpbWFnZSBjZW50ZXIgKyBkZWx0YSB0byBjZW50ZXIgLSBvbGQgc3RhcnQgKyBuZXcgc3RhcnRcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbnB1dERpbWVuc2lvbnMuY2xvbmUoKS5tdWx0aXBseSgwLjUpXG4gICAgICAgICAgLmFkZChuZXdEZWx0YVRvQ2VudGVyKVxuICAgICAgICAgIC5zdWJ0cmFjdChhYnNvbHV0ZVN0YXJ0KVxuICAgICAgICAgIC5hZGQoYWJzb2x1dGVTdGFydERpZmYpXG4gICAgICAgICAgLmRpdmlkZShuZXdBYnNvbHV0ZVNpemUpXG5cbiAgICAgICAgY29udHJvbFBvaW50LnNldFBvc2l0aW9uKHBvc2l0aW9uKVxuICAgICAgfSlcblxuICAgICAgY29uc3QgbmV3UmVsYXRpdmVUaGlja25lc3MgPSBwYXRoLmdldFRoaWNrbmVzcygpICogb2xkQWJzb2x1dGVTaXplLm1pbigpIC8gbmV3QWJzb2x1dGVTaXplLm1pbigpXG4gICAgICBwYXRoLnNldFRoaWNrbmVzcyhuZXdSZWxhdGl2ZVRoaWNrbmVzcyAqIHNjYWxlUmF0aW8pXG4gICAgICBwYXRoLnNldERpcnR5KHRydWUpXG4gICAgfSlcblxuICAgIC8vIFVwZGF0ZVxuICAgIHRoaXMuX3Jlc2V0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNhbnZhc1xuICAgKi9cbiAgY2xlYXJDYW52YXMgKCkge1xuICAgIGlmICghdGhpcy5fb3V0cHV0Q2FudmFzKSB7XG4gICAgICAvLyBgY2xlYXJDYW52YXNgIGlzIGNhbGxlZCB3aGVuIHBhdGhzIGFyZSBzZXQgaW4gU3ByaXRlJ3MgY29uc3RydWN0b3IuIEF0IHRoaXNcbiAgICAgIC8vIHBvaW50LCBgdGhpcy5fb3V0cHV0Q2FudmFzYCBkb2VzIG5vdCBleGlzdCB5ZXQuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9vdXRwdXRDYW52YXNEaXJ0eSA9IHRydWVcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5fb3V0cHV0Q2FudmFzXG4gICAgdGhpcy5fb3V0cHV0Q29udGV4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHBlcnNpc3QgY2FudmFzXG4gICAqL1xuICBjbGVhclBlcnNpc3RDYW52YXMgKCkge1xuICAgIGlmICghdGhpcy5fcGVyc2lzdENhbnZhcykge1xuICAgICAgLy8gYGNsZWFyQ2FudmFzYCBpcyBjYWxsZWQgd2hlbiBwYXRocyBhcmUgc2V0IGluIFNwcml0ZSdzIGNvbnN0cnVjdG9yLiBBdCB0aGlzXG4gICAgICAvLyBwb2ludCwgYHRoaXMuX3BlcnNpc3RDYW52YXNgIGRvZXMgbm90IGV4aXN0IHlldC5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5fcGVyc2lzdENhbnZhc1xuICAgIHRoaXMuX3BlcnNpc3RDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhpcyBjb25maWd1cmFibGVcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRvT2JqZWN0ID0gZmFsc2VcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc2VyaWFsaXplT3B0aW9ucyAoa2V5cywgdG9PYmplY3QgPSBmYWxzZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzdXBlci5zZXJpYWxpemVPcHRpb25zKGtleXMsIHRvT2JqZWN0KVxuICAgIGlmICgha2V5cykgb3B0aW9ucy50eXBlID0gJ2JydXNoJ1xuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgYWRkcyBhIG5ldyBwYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlja25lc3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhhcmRuZXNzXG4gICAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuQnJ1c2hPcGVyYXRpb24uUGF0aH1cbiAgICovXG4gIGNyZWF0ZVBhdGggKHRoaWNrbmVzcywgaGFyZG5lc3MsIGNvbG9yKSB7XG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKHRoaXMuX29wZXJhdGlvbiwgeyB0aGlja25lc3MsIGhhcmRuZXNzLCBjb2xvciB9LCB0aGlzLl9uZXh0Q2FudmFzKVxuICAgIHBhdGgub24oJ3VwZGF0ZScsIHRoaXMuX29uUGF0aFVwZGF0ZSlcbiAgICB0aGlzLl9vcHRpb25zLnBhdGhzLnB1c2gocGF0aClcbiAgICB0aGlzLnNldERpcnR5KHRydWUpXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgcGF0aCBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25QYXRoVXBkYXRlICgpIHtcbiAgICB0aGlzLl9vcGVyYXRpb24uc2V0RGlydHkodHJ1ZSlcbiAgICB0aGlzLnNldERpcnR5KHRydWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIHBhdGggaGFzIGJlZW4gY2xvc2VkIC8gcGVyc2lzdGVkXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLkJydXNoLlBhdGh9IHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblBhdGhQZXJzaXN0IChwYXRoKSB7XG4gICAgcGF0aC5yZW5kZXJUb0NhbnZhcyh0aGlzLl9wZXJzaXN0Q2FudmFzKVxuICAgIHRoaXMuX25leHRDYW52YXMgPSBwYXRoLmdldENhbnZhcygpXG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fbmV4dENhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fbmV4dENhbnZhcy53aWR0aCwgdGhpcy5fbmV4dENhbnZhcy5oZWlnaHQpXG5cbiAgICB0aGlzLl9wZXJzaXN0ZWRQYXRocy5wdXNoKHBhdGgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVGV4dHVyZSBmb3IgdGhlIHNwcml0ZSB0aGF0IHNob3VsZCBiZSByZW5kZXJlZFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX1cbiAgICogQHByaXZhdGVcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBfZ2V0VGV4dHVyZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkaXJ0aW5lc3MgZm9yIHRoZSBnaXZlbiByZW5kZXJlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBkaW1lbnNpb25zQ2hhbmdlZCA9IGZhbHNlXG4gICAqL1xuICBzZXREaXJ0eUZvclJlbmRlcmVyIChkaXJ0eSwgcmVuZGVyZXIsIGRpbWVuc2lvbnNDaGFuZ2VkID0gZmFsc2UpIHtcbiAgICBzdXBlci5zZXREaXJ0eUZvclJlbmRlcmVyKGRpcnR5LCByZW5kZXJlciwgZGltZW5zaW9uc0NoYW5nZWQpXG4gICAgaWYgKGRpcnR5ICYmIGRpbWVuc2lvbnNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9wZXJzaXN0ZWRQYXRocyA9IFtdXG4gICAgICB0aGlzLl9vcHRpb25zLnBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgcGF0aC5zZXREaXJ0eSh0cnVlKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIGJydXNoIHRvIGRpcnR5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBkaW1lbnNpb25zQ2hhbmdlZCA9IGZhbHNlXG4gICAqL1xuICBzZXREaXJ0eSAoZGlydHksIGRpbWVuc2lvbnNDaGFuZ2VkID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCByZW5kZXJlcklkIGluIHRoaXMuX2RpcnRpbmVzcykge1xuICAgICAgdGhpcy5zZXREaXJ0eUZvclJlbmRlcmVyKGRpcnR5LCB0aGlzLl9yZW5kZXJlcnNbcmVuZGVyZXJJZF0sIGRpbWVuc2lvbnNDaGFuZ2VkKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGFsbCBwYXRocyB0byB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBpbnB1dERpbWVuc2lvbnNcbiAgICovXG4gIHJlbmRlciAoaW5wdXREaW1lbnNpb25zKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9vcGVyYXRpb24uZ2V0U0RLKCkuZ2V0UmVuZGVyZXIoKVxuXG4gICAgaWYgKCF0aGlzLmlzRGlydHlGb3JSZW5kZXJlcihyZW5kZXJlcikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIFV0aWxzLmVuc3VyZUNhbnZhc0RpbWVuc2lvbnModGhpcy5fb3V0cHV0Q2FudmFzLCBpbnB1dERpbWVuc2lvbnMpXG4gICAgVXRpbHMuZW5zdXJlQ2FudmFzRGltZW5zaW9ucyh0aGlzLl9wZXJzaXN0Q2FudmFzLCBpbnB1dERpbWVuc2lvbnMpXG5cbiAgICAvLyBNYWtlIHN1cmUgYWxsIHBhdGhzIGFyZSByZW5kZXJlZCB0byB0aGVpciBjYW52YXNlc1xuICAgIHRoaXMuX29wdGlvbnMucGF0aHNcbiAgICAgIC5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgIHBhdGgucmVuZGVyKGlucHV0RGltZW5zaW9ucylcblxuICAgICAgICBpZiAocGF0aC5nZXRDbG9zZWQoKSAmJiB0aGlzLl9wZXJzaXN0ZWRQYXRocy5pbmRleE9mKHBhdGgpID09PSAtMSkge1xuICAgICAgICAgIHRoaXMuX29uUGF0aFBlcnNpc3QocGF0aClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIC8vIFJlbmRlciBwZXJzaXN0ZWQgcGF0aHMgdG8gb3V0cHV0IGluIG9uZSBnb1xuICAgIHRoaXMuY2xlYXJDYW52YXMoKVxuICAgIHRoaXMuX291dHB1dENvbnRleHQuZHJhd0ltYWdlKHRoaXMuX3BlcnNpc3RDYW52YXMsIDAsIDApXG5cbiAgICAvLyBSZW5kZXIgdW5wZXJzaXN0ZWQgcGF0aHMgdG8gb3V0cHV0XG4gICAgdGhpcy5fb3B0aW9ucy5wYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICBpZiAoIXBhdGguZ2V0Q2xvc2VkKCkpIHtcbiAgICAgICAgcGF0aC5yZW5kZXJUb0NhbnZhcyh0aGlzLl9vdXRwdXRDYW52YXMpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuc2V0RGlydHlGb3JSZW5kZXJlcihmYWxzZSwgcmVuZGVyZXIpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIHNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gaW5wdXREaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB1cGRhdGUgKHNkaywgaW5wdXREaW1lbnNpb25zKSB7XG4gICAgaWYgKGlucHV0RGltZW5zaW9ucykge1xuICAgICAgVXRpbHMuZW5zdXJlQ2FudmFzRGltZW5zaW9ucyh0aGlzLl9vdXRwdXRDYW52YXMsIGlucHV0RGltZW5zaW9ucylcbiAgICAgIFV0aWxzLmVuc3VyZUNhbnZhc0RpbWVuc2lvbnModGhpcy5fcGVyc2lzdENhbnZhcywgaW5wdXREaW1lbnNpb25zKVxuXG4gICAgICAvLyBVcGRhdGUgdGV4dHVyZSBkaW1lbnNpb25zXG4gICAgICB0aGlzLl90ZXh0dXJlLmdldEJhc2VUZXh0dXJlKCkudXBkYXRlKClcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgcGF0aHMgYW5kIGNvbnRyb2wgcG9pbnRzXG4gICAgdGhpcy5yZW5kZXIoaW5wdXREaW1lbnNpb25zKVxuXG4gICAgLy8gVXBsb2FkIGNhbnZhcyB0byB0ZXh0dXJlXG4gICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHJlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5XRUJHTCkpIHtcbiAgICAgIHJlbmRlcmVyLnVwZGF0ZVRleHR1cmUodGhpcy5fdGV4dHVyZS5nZXRCYXNlVGV4dHVyZSgpKVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci51cGRhdGUoc2RrLCBpbnB1dERpbWVuc2lvbnMpXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgYnJ1c2ggc28gdGhhdCBpdCBjYW4gYmUgcmUtcmVuZGVyZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldCAoKSB7XG4gICAgdGhpcy5fcGVyc2lzdGVkUGF0aHMgPSBbXVxuICAgIGlmICh0aGlzLl9vcGVyYXRpb24pIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvbi5zZXREaXJ0eSh0cnVlKVxuICAgIH1cbiAgICB0aGlzLnNldERpcnR5KHRydWUpXG4gICAgdGhpcy5jbGVhckNhbnZhcygpXG4gICAgdGhpcy5jbGVhclBlcnNpc3RDYW52YXMoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gR0VUVEVSUyAvIFNFVFRFUlNcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2FudmFzIHdlJ3JlIHJlbmRlcmluZyBicnVzaGVzIHRvXG4gICAqIEByZXR1cm4ge0NhbnZhc0VsZW1lbnR9XG4gICAqL1xuICBnZXRDYW52YXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vdXRwdXRDYW52YXNcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIERJU1BPU0FMXG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgQnJ1c2hcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICAgIHRoaXMuX3RleHR1cmUuZ2V0QmFzZVRleHR1cmUoKS5kaXNwb3NlKClcbiAgfVxufVxuXG5CcnVzaC5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgaWQ6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIGRlZmF1bHQ6ICgpID0+IFV0aWxzLmdldFVVSUQoKSB9LFxuICBwb3NpdGlvbjogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDAsIDApIH0sXG4gIHNjYWxlOiB7IHR5cGU6IE9wdGlvblR5cGUuVkVDVE9SMiwgZGVmYXVsdDogbmV3IFZlY3RvcjIoMS4wLCAxLjApIH0sXG4gIGFuY2hvcjogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDAuMCwgMC4wKSB9LFxuICBwaXZvdDogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDAuMCwgMC4wKSB9LFxuICByb3RhdGlvbjogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMCB9LFxuICBwYXRoczoge1xuICAgIHR5cGU6IE9wdGlvblR5cGUuQVJSQVksXG4gICAgZGVmYXVsdDogW10sXG4gICAgc2V0dGVyOiBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgcGF0aC5zZXREaXJ0eSh0cnVlKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5fcmVzZXQoKVxuICAgICAgcmV0dXJuIHBhdGhzXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJydXNoXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL3Nwcml0ZXMvYnJ1c2guanMiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcElFICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBnZXROYW5vU2Vjb25kcywgaHJ0aW1lLCBsb2FkVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBsb2FkVGltZSkgLyAxZTY7XG4gICAgfTtcbiAgICBocnRpbWUgPSBwcm9jZXNzLmhydGltZTtcbiAgICBnZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhyO1xuICAgICAgaHIgPSBocnRpbWUoKTtcbiAgICAgIHJldHVybiBoclswXSAqIDFlOSArIGhyWzFdO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBnZXROYW5vU2Vjb25kcygpO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJZGVudGl0eUZpbHRlciB9IGZyb20gJy4vaWRlbnRpdHktZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBMTVGaWx0ZXIgfSBmcm9tICcuL2ExNS1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJyZWV6ZUZpbHRlciB9IGZyb20gJy4vYnJlZXplLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQldGaWx0ZXIgfSBmcm9tICcuL2J3LWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQldIYXJkRmlsdGVyIH0gZnJvbSAnLi9id2hhcmQtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDZWxzaXVzRmlsdGVyIH0gZnJvbSAnLi9jZWxzaXVzLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hlc3RGaWx0ZXIgfSBmcm9tICcuL2NoZXN0LWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRml4aWVGaWx0ZXIgfSBmcm9tICcuL2ZpeGllLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRm9vZEZpbHRlciB9IGZyb20gJy4vZm9vZC1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIEZyaWRnZUZpbHRlciB9IGZyb20gJy4vZnJpZGdlLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnJvbnRGaWx0ZXIgfSBmcm9tICcuL2Zyb250LWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR2xhbUZpbHRlciB9IGZyb20gJy4vZ2xhbS1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIEdvYmJsaW5GaWx0ZXIgfSBmcm9tICcuL2dvYmJsaW4tZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBLMUZpbHRlciB9IGZyb20gJy4vazEtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBLMkZpbHRlciB9IGZyb20gJy4vazItZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBLNkZpbHRlciB9IGZyb20gJy4vazYtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBLRHluYW1pY0ZpbHRlciB9IGZyb20gJy4va2R5bmFtaWMtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMZW5pbkZpbHRlciB9IGZyb20gJy4vbGVuaW4tZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMb21vRmlsdGVyIH0gZnJvbSAnLi9sb21vLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWVsbG93RmlsdGVyIH0gZnJvbSAnLi9tZWxsb3ctZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNZXRhbEZpbHRlciB9IGZyb20gJy4vbWV0YWwtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNb3JuaW5nRmlsdGVyIH0gZnJvbSAnLi9tb3JuaW5nLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT3JjaGlkRmlsdGVyIH0gZnJvbSAnLi9vcmNoaWQtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2xhRmlsdGVyIH0gZnJvbSAnLi9wb2xhLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9sYTY2OUZpbHRlciB9IGZyb20gJy4vcG9sYTY2OS1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIFF1b3ppRmlsdGVyIH0gZnJvbSAnLi9xdW96aS1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlbWlyZWRGaWx0ZXIgfSBmcm9tICcuL3NlbWlyZWQtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdW5ueUZpbHRlciB9IGZyb20gJy4vc3VubnktZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXhhc0ZpbHRlciB9IGZyb20gJy4vdGV4YXMtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBYNDAwRmlsdGVyIH0gZnJvbSAnLi94NDAwLWZpbHRlcidcblxuLy8gU3BlY2lhbCBsb29rdXAgdGFibGUgZmlsdGVyXG5leHBvcnQgeyBkZWZhdWx0IGFzIExVVEZpbHRlciB9IGZyb20gJy4vbHV0LWZpbHRlcidcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKiBAbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIGdsb2JhbHMgZnJvbSAnLi9nbG9iYWxzJ1xuY29uc3QgeyBSZWN0YW5nbGUsIENvbnN0YW50cywgRW5naW5lLCBVdGlscywgRXZlbnRFbWl0dGVyLCBWZWN0b3IyLCBMb2csIEJhc2U2NCB9ID0gZ2xvYmFsc1xuaW1wb3J0ICogYXMgT3BlcmF0aW9ucyBmcm9tICcuL29wZXJhdGlvbnMvJ1xuaW1wb3J0IE9wZXJhdGlvbnNTdGFjayBmcm9tICcuL2xpYi9vcGVyYXRpb25zLXN0YWNrJ1xuaW1wb3J0IFZlcnNpb25DaGVja2VyIGZyb20gJy4vbGliL3ZlcnNpb24tY2hlY2tlcidcbmltcG9ydCBFeGlmIGZyb20gJy4vbGliL2V4aWYnXG5pbXBvcnQgSW1hZ2VFeHBvcnRlciBmcm9tICcuL2xpYi9pbWFnZS1leHBvcnRlcidcbmltcG9ydCBQZXJmb3JtYW5jZVRlc3QgZnJvbSAnLi9saWIvcGVyZm9ybWFuY2UtdGVzdCdcbmNvbnN0IGJkID0gKHN0cikgPT4gVXRpbHMuYnl0ZUFycmF5VG9TdHJpbmcoQmFzZTY0LmRlY29kZShzdHIpKVxuXG5jb25zdCB7IFJlbmRlclR5cGUsIEltYWdlRm9ybWF0LCBFdmVudHMsIFJlbmRlcmVyVHlwZSB9ID0gQ29uc3RhbnRzXG5cbi8qKlxuICogVGhlIG1haW4gU0RLIGNsYXNzIHdoaWNoIGhhbmRsZXMgcmVuZGVyaW5nIGFuZCBtYW5hZ2VzXG4gKiBvcGVyYXRpb25zLlxuICogQGNsYXNzXG4gKiBAYWxpYXMgUGhvdG9FZGl0b3JTREtcbiAqL1xuY2xhc3MgUGhvdG9FZGl0b3JTREsgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBob3RvRWRpdG9yU0RLIGluc3RhbmNlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW3ByZWZlcnJlZFJlbmRlcmVyID0gd2ViZ2xdIC0gYHdlYmdsYCBvciBgY2FudmFzYFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBvcHRpb25zLmFwaUtleSAtIFlvdXIgQVBJIGtleVxuICAgKiBAcGFyYW0gIHtJbWFnZX0gW29wdGlvbnMuaW1hZ2VdIC0gVGhlIGltYWdlIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMucmVuZGVyTW9kZSA9IGR5bmFtaWNdIC0gYGR5bmFtaWNgIG9yIGBleHBvcnRgXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnZlcnNpb25DaGVjayA9IHRydWVdIC0gU2hvdWxkIGEgdmVyc2lvbiBjaGVjayBiZSBwZXJmb3JtZWQ/XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmRpc3BsYXlXZWxjb21lTWVzc2FnZSA9IHRydWVdIC0gU2hvdWxkIGEgd2VsY29tZSBtZXNzYWdlIGJlIHByaW50ZWRcbiAgICogICBpbiB0aGUgY29uc29sZT9cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNwYXJlbnQgPSBmYWxzZV0gLSBTaG91bGQgdGhlIGNhbnZhcyBiYWNrZ3JvdW5kIGJlIHRyYW5zcGFyZW50P1xuICAgKiBAcGFyYW0gIHtIVE1MQ2FudmFzRWxlbWVudH0gW29wdGlvbnMuY2FudmFzXSAtIFRoZSBjYW52YXMgZWxlbWVudCB0aGUgU0RLIHNob3VsZCByZW5kZXIgdG9cbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy56b29tID0gMV0gLSBUaGUgem9vbSBsZXZlbC4gT25seSBhdmFpbGFibGUgaW4gYGR5bmFtaWNgIG1vZGVcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zcHJpdGVTY2FsZSA9IDFdIC0gVGhlIG91dHB1dCBzcHJpdGUncyBzY2FsZS4gT25seSBhdmFpbGFibGUgaW4gYGR5bmFtaWNgIG1vZGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5sb2dMZXZlbCA9IHdhcm5dIC0gYHRyYWNlYCwgYGluZm9gLCBgd2FybmAsIGBlcnJvcmAgb3IgYGxvZ2BcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5waXhlbFJhdGlvID0gMV0gLSBJZiBub25lIGlzIGdpdmVuLCBQaG90b0VkaXRvclNESyBhdXRvbWF0aWNhbGx5XG4gICAqICAgZGV0ZWN0cyB0aGUgY3VycmVudCBkZXZpY2UncyBwaXhlbCByYXRpb1xuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zbW9vdGhEb3duc2NhbGluZyA9IGZhbHNlXSAtIFRvZ2dsZXMgc21vb3RoIGRvd25zY2FsaW5nXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNtb290aFVwc2NhbGluZyA9IGZhbHNlXSAtIFRvZ2dsZXMgc21vb3RoIHVwc2NhbGluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHByZWZlcnJlZFJlbmRlcmVyLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZSA9IHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlLmJpbmQodGhpcylcbiAgICB0aGlzLl9vbkNvbnRleHRSZXN0b3JlZCA9IHRoaXMuX29uQ29udGV4dFJlc3RvcmVkLmJpbmQodGhpcylcblxuICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJylcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uXG5cbiAgICB0aGlzW2JkKCdWRzA0WjFsSFJuZGhWWFJzWlZkQloySXpRakJoVnpsMVNVZGtjR1J0Vm5VPScpXSA9IHRydWVcbiAgICB0aGlzLl9wcmVmZXJyZWRSZW5kZXJlciA9IHByZWZlcnJlZFJlbmRlcmVyXG4gICAgdGhpcy5fb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIGV4dGVuc2lvbnM6IHt9LFxuICAgICAgcmVuZGVyTW9kZTogJ2R5bmFtaWMnLFxuICAgICAgdmVyc2lvbkNoZWNrOiB0cnVlLFxuICAgICAgZGlzcGxheVdlbGNvbWVNZXNzYWdlOiB0cnVlLFxuICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICBjYW52YXM6IG51bGwsXG4gICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICB0ZXh0dXJlUXVhbGl0eTogMSxcbiAgICAgIHpvb206IDEsXG4gICAgICBzcHJpdGVTY2FsZTogMSxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgc21vb3RoRG93bnNjYWxpbmc6IGZhbHNlLFxuICAgICAgc21vb3RoVXBzY2FsaW5nOiBmYWxzZSxcbiAgICAgIGxvZ0xldmVsOiAnd2FybicsXG4gICAgICBwaXhlbFJhdGlvOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDFcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc21vb3RoVXBzY2FsaW5nKSB7XG4gICAgICBFbmdpbmUuQmFzZVRleHR1cmUuRGVmYXVsdE1hZ0ZpbHRlciA9IEVuZ2luZS5CYXNlVGV4dHVyZS5MaW5lYXJGaWx0ZXJcbiAgICB9XG5cbiAgICB0aGlzLl9vcHRpb25zLmV4dGVuc2lvbnMgPSBVdGlscy5kZWZhdWx0cyh0aGlzLl9vcHRpb25zLmV4dGVuc2lvbnMsIHtcbiAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgY29udHJvbHM6IFtdLFxuICAgICAgbGFuZ3VhZ2VzOiBbXVxuICAgIH0pXG5cbiAgICBMb2cuc2V0TGV2ZWwodGhpcy5fb3B0aW9ucy5sb2dMZXZlbClcblxuICAgIGlmICghdGhpcy5fdigpKSByZXR1cm5cblxuICAgIHRoaXMuX2RlZmF1bHRSZW5kZXJNb2RlID0gdGhpcy5fb3B0aW9ucy5yZW5kZXJNb2RlXG4gICAgdGhpcy5fcmVuZGVyTW9kZSA9IHRoaXMuX29wdGlvbnMucmVuZGVyTW9kZVxuXG4gICAgdGhpcy5fdGV4dHVyZVF1YWxpdHkgPSB0aGlzLl9vcHRpb25zLnRleHR1cmVRdWFsaXR5XG4gICAgdGhpcy5fb2Zmc2V0ID0gbmV3IFZlY3RvcjIoKVxuICAgIHRoaXMuX3pvb20gPSB0aGlzLl9vcHRpb25zLnpvb21cbiAgICB0aGlzLl9zcHJpdGVTY2FsZSA9IHRoaXMuX29wdGlvbnMuc3ByaXRlU2NhbGVcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHRoaXMuX29wdGlvbnMucm90YXRpb25cbiAgICB0aGlzLl9vcGVyYXRpb25zID0ge31cbiAgICB0aGlzLl9vcGVyYXRpb25zU3RhY2sgPSBudWxsXG4gICAgdGhpcy5zZXRPcGVyYXRpb25zU3RhY2sobmV3IE9wZXJhdGlvbnNTdGFjaygpKVxuXG4gICAgLy8gRW5naW5lIHN0dWZmXG4gICAgdGhpcy5fY29udGFpbmVyID0gbmV3IEVuZ2luZS5Db250YWluZXIoKVxuICAgIHRoaXMuX3Nwcml0ZSA9IG5ldyBFbmdpbmUuU3ByaXRlKClcbiAgICB0aGlzLl9jb250YWluZXIuYWRkQ2hpbGQodGhpcy5fc3ByaXRlKVxuXG4gICAgdGhpcy5faW5wdXRCYXNlVGV4dHVyZSA9IG51bGxcbiAgICB0aGlzLl9pbnB1dFRleHR1cmUgPSBudWxsXG4gICAgdGhpcy5fY3VycmVudElucHV0VGV4dHVyZSA9IG51bGxcbiAgICB0aGlzLl9jdXJyZW50VGV4dHVyZSA9IG51bGxcblxuICAgIHRoaXMuX3Jlc2l6ZWRUZXh0dXJlID0gbnVsbFxuICAgIHRoaXMuX3Jlc2l6ZWRDb250YWluZXIgPSBuZXcgRW5naW5lLkNvbnRhaW5lcigpXG4gICAgdGhpcy5fcmVzaXplZFNwcml0ZSA9IG5ldyBFbmdpbmUuU3ByaXRlKClcbiAgICB0aGlzLl9yZXNpemVkQ29udGFpbmVyLmFkZENoaWxkKHRoaXMuX3Jlc2l6ZWRTcHJpdGUpXG5cbiAgICB0aGlzLnNldFNtb290aERvd25zY2FsaW5nKHRoaXMuX29wdGlvbnMuc21vb3RoRG93bnNjYWxpbmcpXG5cbiAgICB0aGlzLl9jaGVja0ZvclVwZGF0ZXMoKVxuICAgIHRoaXMuX3JlZ2lzdGVyT3BlcmF0aW9ucygpXG4gICAgdGhpcy5faW5pdFJlbmRlcmVyKClcblxuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIuY29uc3RydWN0b3IudHlwZVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmRpc3BsYXlXZWxjb21lTWVzc2FnZSkge1xuICAgICAgTG9nLmxvZygnWW8hJywgYFZlcnNpb246ICR7dGhpcy52ZXJzaW9ufSAoJHtyZW5kZXJlcn0pIC0gaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tYClcbiAgICB9XG5cbiAgICAvLyBBc3luYyBpbWFnZSBoYW5kbGluZ1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmltYWdlKSB7XG4gICAgICB0aGlzLnNldEltYWdlKHRoaXMuX29wdGlvbnMuaW1hZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBwcmVzZW5jZSBvZiB0aGUgQVBJIGtleSwgaW5pdGlhbGl6ZXMgdGhlIGBMaWNlbnNlYCBjbGFzcyBhbmQgY2hlY2tzIGZvciBhIHZhbGlkXG4gICAqIGxpY2Vuc2UuIEluIGNhc2UgdGhlIGxpY2Vuc2UgaXMgaW52YWxpZCwgdGhlIGBUbThnWUdGd2FVdGxlV0FnYjNCMGFXOXVJR2RwZG1WdWAgcHJvcGVydHkgaXMgc2V0IHRvIGZhbHNlIGFuZFxuICAgKiBzdWJzZXF1ZW50IGV4cG9ydHMgd2lsbCBmYWlsLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3YgKCkge1xuICAgIC8vIHRoaXMuX29wdGlvbnMuYXBpS2V5XG4gICAgaWYgKCF0aGlzW2JkKCdYMjl3ZEdsdmJuTT0nKV1bYmQoJ1lYQnBTMlY1JyldKSB7XG4gICAgICAvLyBMb2cuZXJyb3IoJ2FwaUtleScsICdObyBgYXBpS2V5YCBvcHRpb24gZ2l2ZW4uJylcbiAgICAgIExvZy5lcnJvcihiZCgnWVhCcFMyVjUnKSwgYmQoJ1RtOGdZR0Z3YVV0bGVXQWdiM0IwYVc5dUlHZHBkbVZ1TGc9PScpKVxuICAgICAgTG9nLmVycm9yKGJkKCdZWEJwUzJWNScpLCBiZCgnU1c0Z1kyRnpaU0I1YjNVZ1pHOXVKM1FnYUdGMlpTQmhiaUJCVUVrZ2EyVjVJSGxsZEN3Z2NHeGxZWE5sSUdOdmJuUmhZM1FnYjNWeUlITmhiR1Z6SUhOMFlXWm1JR0YwSUhOaGJHVnpRSEJvYjNSdlpXUnBkRzl5YzJSckxtTnZiU0IwYnlCdlluUmhhVzRnWVNCc2FXTmxibk5sSUc5eUlHeHZaeUJwYmlCMGJ5QjViM1Z5SUdOMWMzUnZiV1Z5SUdSaGMyaGliMkZ5WkM0PScpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIGNvbnN0IEwgPSBnbG9iYWxzLkxpY2Vuc2luZ1xuICAgIGNvbnN0IEwgPSBnbG9iYWxzW2JkKCdUR2xqWlc1emFXNW4nKV1cbiAgICAvLyB0aGl1cy5fbGljID0gbmV3IExpY2Vuc2luZyh0aGlzLl9vcHRpb25zLmFwaUtleSlcbiAgICB0aGlzLl9saWMgPSBuZXcgTCh0aGlzW2JkKCdYMjl3ZEdsdmJuTT0nKV1bYmQoJ1lYQnBTMlY1JyldKVxuICAgIHRoaXMuX2xpYy5jKClcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB0aGlzW2JkKCdWRzA0WjFsSFJuZGhWWFJzWlZkQloySXpRakJoVnpsMVNVZGtjR1J0Vm5VPScpXSA9IGZhbHNlXG4gICAgICAgIC8vIExvZy5lcnJvcignTGljZW5zaW5nJywgJ0ludmFsaWQgQVBJIGtleScpXG4gICAgICAgIExvZy5lcnJvcihiZCgnVEdsalpXNXphVzVuJyksIGJkKCdTVzUyWVd4cFpDQnNhV05sYm5ObElHdGxlUT09JykpXG4gICAgICAgIExvZy5lcnJvcihiZCgnVEdsalpXNXphVzVuJyksIGJkKCdTVzRnWTJGelpTQjViM1VnWkc5dUozUWdhR0YyWlNCaGJpQkJVRWtnYTJWNUlIbGxkQ3dnY0d4bFlYTmxJR052Ym5SaFkzUWdiM1Z5SUhOaGJHVnpJSE4wWVdabUlHRjBJSE5oYkdWelFIQm9iM1J2WldScGRHOXljMlJyTG1OdmJTQjBieUJ2WW5SaGFXNGdZU0JzYVdObGJuTmxJRzl5SUd4dlp5QnBiaUIwYnlCNWIzVnlJR04xYzNSdmJXVnlJR1JoYzJoaWIyRnlaQzQ9JykpXG4gICAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGZvciB2YWxpZCBsaWNlbnNlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3YgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyAhdGhpcy5UbThnWUdGd2FVdGxlV0FnYjNCMGFXOXVJR2RwZG1WdVxuICAgICAgaWYgKCF0aGlzW2JkKCdWRzA0WjFsSFJuZGhWWFJzWlZkQloySXpRakJoVnpsMVNVZGtjR1J0Vm5VPScpXSkge1xuICAgICAgICAvLyBuZXcgRXJyb3IoJ0ludmFsaWQgbGljZW5zZSBrZXknKVxuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihiZCgnU1c1MllXeHBaQ0JzYVdObGJuTmxJR3RsZVE9PScpKSlcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIGFuIGV4cG9ydCAvIGVkaXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90ICgpIHtcbiAgICB0aGlzLl9saWMudCgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaXMgdXBkYXRlZC4gRGVsZWdhdGVzIHRoZSBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblVwZGF0ZSAoLi4uYXJncykge1xuICAgIHRoaXMuZW1pdChFdmVudHMuT1BFUkFUSU9OX1VQREFURUQsIC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgV2ViR0wgY29udGV4dCBoYXMgYmVlbiByZXN0b3JlZC4gUmUtdHJpZ2dlcnMgYSByZW5kZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBfb25Db250ZXh0UmVzdG9yZWQgKCkge1xuICAgIExvZy53YXJuKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ1RyeWluZyB0byByZS1yZW5kZXIgYWZ0ZXIgV2ViR0wgY29udGV4dCBoYXMgYmVlbiByZXN0b3JlZC4nKVxuICAgIHRoaXMuc2V0QWxsT3BlcmF0aW9uc1RvRGlydHkoKVxuICAgIHRoaXMuX29wZXJhdGlvbnNTdGFjay5mb3JFYWNoKChvcGVyYXRpb24pID0+IHtcbiAgICAgIG9wZXJhdGlvbi5kaXNwb3NlUmVuZGVyVGV4dHVyZXMoKVxuICAgIH0pXG4gICAgdGhpcy5yZW5kZXIoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUkVOREVSSU5HXG5cbiAgLyoqXG4gICAqIEV4cG9ydHMgdGhlIGltYWdlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuIFJlc3VsdCBvZiB0aGUgUHJvbWlzZSBpcyB0aGUgZXhwb3J0ZWQgaW1hZ2Ugb3IgZGF0YSB1cmwuXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlJlbmRlclR5cGV9IFtyZW5kZXJUeXBlPVBob3RvRWRpdG9yU0RLLlJlbmRlclR5cGUuREFUQVVSTF0gLSBUaGUgb3V0cHV0IHR5cGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuSW1hZ2VGb3JtYXR9IFtpbWFnZUZvcm1hdD1QaG90b0VkaXRvclNESy5JbWFnZUZvcm1hdC5QTkddIC0gVGhlIG91dHB1dCBpbWFnZSBmb3JtYXRcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbcXVhbGl0eT0wLjhdIC0gVGhlIGltYWdlIHF1YWxpdHksIGJldHdlZW4gMCBhbmQgMVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgZXhwb3J0IChyZW5kZXJUeXBlID0gUmVuZGVyVHlwZS5EQVRBVVJMLCBpbWFnZUZvcm1hdCA9IEltYWdlRm9ybWF0LlBORywgcXVhbGl0eSA9IDAuOCkge1xuICAgIHJldHVybiB0aGlzLl9jdigpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX3QoKVxuICAgICAgICBjb25zdCBpbWFnZUV4cG9ydGVyID0gbmV3IEltYWdlRXhwb3J0ZXIodGhpcywge1xuICAgICAgICAgIHJlbmRlclR5cGUsIGltYWdlRm9ybWF0LCBxdWFsaXR5XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBpbWFnZUV4cG9ydGVyLmV4cG9ydCgpXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgaW1hZ2UgdG8gdGhlIGNhbnZhc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyICgpIHtcbiAgICBpZiAoIXRoaXMuX2ltYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHNldCBhbiBpbWFnZSBiZWZvcmUgY2FsbGluZyBQaG90b0VkaXRvclNESyNyZW5kZXIuJylcbiAgICB9XG5cbiAgICBsZXQgY29udGV4dCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIGlmIChjb250ZXh0LnN0YXJ0RnJhbWUpIHtcbiAgICAgIGNvbnRleHQuc3RhcnRGcmFtZSgpXG4gICAgfVxuXG4gICAgbGV0IHBlcmZUZXN0XG4gICAgaWYgKExvZy5jYW5Mb2coJ2luZm8nKSkge1xuICAgICAgcGVyZlRlc3QgPSBuZXcgUGVyZm9ybWFuY2VUZXN0KCfimqHimqHimqEnLCAnRnJhbWUgcmVuZGVyaW5nJylcbiAgICB9XG4gICAgTG9nLmluZm8oJ+KaoeKaoeKaoScsICdSZW5kZXJpbmcgc3RhcnRzJylcblxuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5fb3BlcmF0aW9uc1N0YWNrXG4gICAgc3RhY2sudXBkYXRlRGlydGluZXNzRm9yUmVuZGVyZXIodGhpcy5fcmVuZGVyZXIpXG5cbiAgICByZXR1cm4gdGhpcy5fcHJlcGFyZVRleHR1cmUoKVxuICAgICAgLnRoZW4oKHRleHR1cmUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlck1vZGUgPT09ICdleHBvcnQnKSB7XG4gICAgICAgICAgdGV4dHVyZSA9IHRoaXMuX2lucHV0VGV4dHVyZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3VycmVudFRleHR1cmUgPSB0ZXh0dXJlXG4gICAgICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKHRleHR1cmUpXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci51cGRhdGVUcmFuc2Zvcm0oKVxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHN0YWNrLnZhbGlkYXRlU2V0dGluZ3MoKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHN0YWNrLnJlbmRlcih0aGlzLCB0aGlzLl9jdXJyZW50VGV4dHVyZSlcbiAgICAgIH0pXG4gICAgICAudGhlbigob3V0cHV0VGV4dHVyZSkgPT4ge1xuICAgICAgICAvLyBJbnB1dCB0ZXh0dXJlIGhhcyBiZWVuIHBhc3NlZCB0aHJvdWdoIGFsbCBvcGVyYXRpb25zIHdoaWNoIHJldHVyblxuICAgICAgICAvLyBhIG5ldyBSZW5kZXJUZXh0dXJlLiBVc2UgdGhpcyB0ZXh0dXJlIGZvciB0aGUgU3ByaXRlIGFuZCByZW5kZXIgaXRcbiAgICAgICAgLy8gdG8gdGhlIG91dHB1dCBjYW52YXMuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUZXh0dXJlID0gb3V0cHV0VGV4dHVyZVxuICAgICAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZSh0aGlzLl9jdXJyZW50VGV4dHVyZSlcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuX3JlbmRlck1vZGUpIHtcbiAgICAgICAgICBjYXNlICdkeW5hbWljJzpcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjZW50ZXIgaW1hZ2UsIHNldCBzY2FsZSB0byB6b29tIGxldmVsXG4gICAgICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9yZW5kZXJlci5nZXREaW1lbnNpb25zKClcbiAgICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAgICAgICAuYWRkKHRoaXMuX29mZnNldClcblxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnNldFNjYWxlKFxuICAgICAgICAgICAgICB0aGlzLl96b29tIC8gdGhpcy5nZXRUZXh0dXJlU2NhbGUoKSxcbiAgICAgICAgICAgICAgdGhpcy5fem9vbSAvIHRoaXMuZ2V0VGV4dHVyZVNjYWxlKClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zZXRQb3NpdGlvbihjZW50ZXIpXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUuc2V0QW5jaG9yKDAuNSwgMC41KVxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlLnNldFNjYWxlKHRoaXMuX3Nwcml0ZVNjYWxlLCB0aGlzLl9zcHJpdGVTY2FsZSlcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS5zZXRSb3RhdGlvbih0aGlzLl9yb3RhdGlvbilcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgICAgIC8vIE1vdmUgc3ByaXRlIHRvIHVwcGVyIGxlZnQgaGFuZCBjb3JuZXIsIHJlbmRlciBhdCBmdWxsIHNjYWxlXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc2V0U2NhbGUoMSwgMSlcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zZXRQb3NpdGlvbigwLCAwKVxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlLnNldEFuY2hvcigwLCAwKVxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlLnNldFBvc2l0aW9uKDAsIDApXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUuc2V0U2NhbGUodGhpcy5fc3ByaXRlU2NhbGUsIHRoaXMuX3Nwcml0ZVNjYWxlKVxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlLnNldFJvdGF0aW9uKDApXG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyByZW5kZXJzIHRvIHRoZSBvdXRwdXRcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKHRoaXMuX2NvbnRhaW5lcilcblxuICAgICAgICByZXR1cm4gb3V0cHV0VGV4dHVyZVxuICAgICAgfSlcbiAgICAgIC50aGVuKCh0ZXh0dXJlKSA9PiB7XG4gICAgICAgIGlmIChwZXJmVGVzdCkge1xuICAgICAgICAgIHBlcmZUZXN0LnN0b3AoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LmVuZEZyYW1lKSB7XG4gICAgICAgICAgY29udGV4dC5lbmRGcmFtZSgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHR1cmVcbiAgICAgIH0pXG4gIH1cblxuICBnZXRUZXh0dXJlU2NhbGUgKCkge1xuICAgIHJldHVybiBNYXRoLm1pbigxLCB0aGlzLl90ZXh0dXJlUXVhbGl0eSAqIHRoaXMuX29wdGlvbnMucGl4ZWxSYXRpbylcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgaW5wdXQgdGV4dHVyZSBmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVUZXh0dXJlICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGV4dHVyZVNjYWxlID0gdGhpcy5nZXRUZXh0dXJlU2NhbGUoKVxuICAgICAgaWYgKHRoaXMuX3RleHR1cmVRdWFsaXR5ID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMuX2lucHV0VGV4dHVyZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuZ2V0SW5wdXREaW1lbnNpb25zKClcbiAgICAgICAgLm11bHRpcGx5KHRleHR1cmVTY2FsZSlcbiAgICAgICAgLmZsb29yKClcblxuICAgICAgbGV0IG5lZWRzUmVyZW5kZXJcbiAgICAgIGlmICghdGhpcy5fcmVzaXplZFRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplZFRleHR1cmUgPSBuZXcgRW5naW5lLlJlbmRlclRleHR1cmUodGhpcy5fcmVuZGVyZXIsIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55KVxuICAgICAgICBuZWVkc1JlcmVuZGVyID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fcmVzaXplZFRleHR1cmUuZ2V0RGltZW5zaW9ucygpLmVxdWFscyhkaW1lbnNpb25zKSkge1xuICAgICAgICB0aGlzLl9yZXNpemVkVGV4dHVyZS5yZXNpemVUbyhkaW1lbnNpb25zKVxuICAgICAgICBuZWVkc1JlcmVuZGVyID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAobmVlZHNSZXJlbmRlcikge1xuICAgICAgICB0aGlzLl9yZXNpemVkU3ByaXRlLnNldFNjYWxlKHRleHR1cmVTY2FsZSwgdGV4dHVyZVNjYWxlKVxuICAgICAgICB0aGlzLl9yZXNpemVkU3ByaXRlLnNldFRleHR1cmUodGhpcy5faW5wdXRUZXh0dXJlKVxuICAgICAgICB0aGlzLl9yZXNpemVkVGV4dHVyZS5yZW5kZXIodGhpcy5fcmVzaXplZENvbnRhaW5lcilcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSh0aGlzLl9yZXNpemVkVGV4dHVyZSlcbiAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gT1BFUkFUSU9OU1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYWxsIGRlZmF1bHQgb3BlcmF0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZ2lzdGVyT3BlcmF0aW9ucyAoKSB7XG4gICAgdGhpcy5fb3BlcmF0aW9ucyA9IHt9XG5cbiAgICBmb3IgKGxldCBvcGVyYXRpb25OYW1lIGluIE9wZXJhdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IE9wZXJhdGlvbnNbb3BlcmF0aW9uTmFtZV1cbiAgICAgIHRoaXMuX29wZXJhdGlvbnNbb3BlcmF0aW9uLmlkZW50aWZpZXJdID0gb3BlcmF0aW9uXG4gICAgfVxuXG4gICAgdGhpcy5fb3BlcmF0aW9ucyA9IFV0aWxzLmV4dGVuZCh0aGlzLl9vcGVyYXRpb25zLFxuICAgICAgdGhpcy5fb3B0aW9ucy5leHRlbnNpb25zLm9wZXJhdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbGwgb3BlcmF0aW9ucyBpbiB0aGUgc3RhY2sgdG8gZGlydHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBkaW1lbnNpb25zQ2hhbmdlZCA9IGZhbHNlXG4gICAqL1xuICBzZXRBbGxPcGVyYXRpb25zVG9EaXJ0eSAoZGltZW5zaW9uc0NoYW5nZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuX29wZXJhdGlvbnNTdGFjay5zZXRBbGxUb0RpcnR5KGRpbWVuc2lvbnNDaGFuZ2VkKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb3BlcmF0aW9uIHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zID0ge31dXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FkZFRvU3RhY2sgPSB0cnVlXVxuICAgKiBAcmV0dXJucyB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufVxuICAgKi9cbiAgY3JlYXRlT3BlcmF0aW9uIChpZGVudGlmaWVyLCBvcHRpb25zID0ge30sIGFkZFRvU3RhY2sgPSB0cnVlKSB7XG4gICAgY29uc3QgT3BlcmF0aW9uID0gdGhpcy5fb3BlcmF0aW9uc1tpZGVudGlmaWVyXVxuICAgIGlmICghT3BlcmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG9wZXJhdGlvbiB3aXRoIGlkZW50aWZpZXIgXFxgJHtpZGVudGlmaWVyfVxcYCBmb3VuZC5gKVxuICAgIH1cblxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG5ldyBPcGVyYXRpb24odGhpcywgb3B0aW9ucylcbiAgICBpZiAoYWRkVG9TdGFjaykge1xuICAgICAgdGhpcy5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uIHRvIHRoZSBvcGVyYXRpb25zIHN0YWNrXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICovXG4gIGFkZE9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5fb3BlcmF0aW9uc1N0YWNrLnB1c2gob3BlcmF0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIG9wZXJhdGlvbiBmcm9tIHRoZSBvcGVyYXRpb25zIHN0YWNrXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqL1xuICByZW1vdmVPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIHRoaXMuX29wZXJhdGlvbnNTdGFjay5yZW1vdmUob3BlcmF0aW9uKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRElNRU5TSU9OU1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIGltYWdlIGRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0SW5wdXREaW1lbnNpb25zICgpIHtcbiAgICBjb25zdCBmcmFtZSA9IHRoaXMuX2lucHV0VGV4dHVyZS5nZXRGcmFtZSgpXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmluYWwgZGltZW5zaW9ucyB0aGF0IHRoZSBpbnB1dCBpbWFnZSB3b3VsZCBoYXZlXG4gICAqIGFmdGVyIGFsbCBleGlzdGluZyBvcGVyYXRpb25zIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jb3Jwb3JhdGVTcHJpdGVTY2FsZSA9IGZhbHNlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldEZpbmFsRGltZW5zaW9ucyAoaW5jb3Jwb3JhdGVTcHJpdGVTY2FsZSA9IGZhbHNlKSB7XG4gICAgbGV0IGRpbWVuc2lvbnMgPSB0aGlzLmdldElucHV0RGltZW5zaW9ucygpXG4gICAgY29uc3Qgb3BlcmF0aW9uc1N0YWNrID0gdGhpcy5fb3BlcmF0aW9uc1N0YWNrXG5cbiAgICBvcGVyYXRpb25zU3RhY2suZm9yRWFjaCgob3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAoIW9wZXJhdGlvbi5nZXRFbmFibGVkKCkpIHJldHVyblxuICAgICAgZGltZW5zaW9ucyA9IG9wZXJhdGlvbi5nZXROZXdEaW1lbnNpb25zKGRpbWVuc2lvbnMpXG4gICAgfSlcblxuICAgIGlmIChpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlKSB7XG4gICAgICBkaW1lbnNpb25zLm11bHRpcGx5KHRoaXMuX3Nwcml0ZVNjYWxlKVxuICAgIH1cblxuICAgIHJldHVybiBkaW1lbnNpb25zLmZsb29yKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNwcml0ZSBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jb3Jwb3JhdGVTcHJpdGVTY2FsZSA9IGZhbHNlXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqL1xuICBnZXRPdXRwdXREaW1lbnNpb25zIChpbmNvcnBvcmF0ZVNwcml0ZVNjYWxlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaW5hbERpbWVuc2lvbnMoaW5jb3Jwb3JhdGVTcHJpdGVTY2FsZSkuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KHRoaXMuX3pvb20pXG4gICAgICAuZmxvb3IoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG91dHB1dCB0ZXh0dXJlXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGluY29ycG9yYXRlU3ByaXRlU2NhbGUgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0T3V0cHV0VGV4dHVyZURpbWVuc2lvbnMgKGluY29ycG9yYXRlU3ByaXRlU2NhbGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRleHR1cmVTY2FsZSA9IHRoaXMuZ2V0VGV4dHVyZVNjYWxlKClcbiAgICBsZXQgZGltZW5zaW9ucyA9IHRoaXMuZ2V0SW5wdXREaW1lbnNpb25zKClcbiAgICAgIC5tdWx0aXBseSh0ZXh0dXJlU2NhbGUpXG4gICAgICAuZmxvb3IoKVxuICAgIHRoaXMuX29wZXJhdGlvbnNTdGFjay5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgZGltZW5zaW9ucyA9IG9wLmdldE5ld0RpbWVuc2lvbnMoZGltZW5zaW9ucylcbiAgICB9KVxuICAgIHJldHVybiBkaW1lbnNpb25zXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3IgdmVyc2lvbiB1cGRhdGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tGb3JVcGRhdGVzICgpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy52ZXJzaW9uQ2hlY2spIHtcbiAgICAgIHRoaXMuX3ZlcnNpb25DaGVja2VyID0gbmV3IFZlcnNpb25DaGVja2VyKHRoaXMudmVyc2lvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHJlbmRlcmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFJlbmRlcmVyICgpIHtcbiAgICBjb25zdCByZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICBjYW52YXM6IHRoaXMuX29wdGlvbnMuY2FudmFzLFxuICAgICAgcGl4ZWxSYXRpbzogdGhpcy5fb3B0aW9ucy5waXhlbFJhdGlvLFxuICAgICAgZGVidWc6IHRoaXMuX29wdGlvbnMuZGVidWcsXG4gICAgICB0cmFuc3BhcmVudDogdGhpcy5fb3B0aW9ucy50cmFuc3BhcmVudFxuICAgIH1cblxuICAgIGxldCB3aWR0aCwgaGVpZ2h0XG4gICAgaWYgKHRoaXMuX3JlbmRlck1vZGUgPT09ICdkeW5hbWljJyAmJiB0aGlzLl9vcHRpb25zLmNhbnZhcykge1xuICAgICAgY29uc3QgeyBjYW52YXMgfSA9IHRoaXMuX29wdGlvbnNcbiAgICAgIHdpZHRoID0gY2FudmFzLndpZHRoXG4gICAgICBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pbWFnZSkge1xuICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RmluYWxEaW1lbnNpb25zKClcbiAgICAgIHdpZHRoID0gZGltZW5zaW9ucy54XG4gICAgICBoZWlnaHQgPSBkaW1lbnNpb25zLnlcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3ByZWZlcnJlZFJlbmRlcmVyKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgY2FzZSBSZW5kZXJlclR5cGUuV0VCR0w6XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gRW5naW5lLmF1dG9EZXRlY3RSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCByZW5kZXJlck9wdGlvbnMpXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLm9uKCdjb250ZXh0LXJlc3RvcmVkJywgdGhpcy5fb25Db250ZXh0UmVzdG9yZWQpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFJlbmRlcmVyVHlwZS5DQU5WQVM6XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gbmV3IEVuZ2luZS5DYW52YXNSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCByZW5kZXJlck9wdGlvbnMpXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLm9uKCdjb250ZXh0LXJlc3RvcmVkJywgdGhpcy5fb25Db250ZXh0UmVzdG9yZWQpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBMb2cud2FybignUGhvdG9FZGl0b3JTREsnLCBgUGhvdG9FZGl0b3JTREsgRXJyb3I6IFJlbmRlcmVyIFxcYCR7dGhpcy5fcHJlZmVycmVkUmVuZGVyZXJ9XFxgIG5vdCBzdXBwb3J0ZWQuIEZhbGxpbmcgYmFjayB0byBhdXRvbWF0aWNhbGx5IGRldGVjdGVkIHJlbmRlcmVyLmApXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gRW5naW5lLmF1dG9EZXRlY3RSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCByZW5kZXJlck9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIHJlbmRlcmVyIHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZXNpemVUbyhkaW1lbnNpb25zLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBhbGwgY3VzdG9tIGFuZCBzZWxlY3RlZCBvcGVyYXRpb25zXG4gICAqL1xuICByZXNldCAoKSB7XG4gICAgdGhpcy5fb3BlcmF0aW9uc1N0YWNrLmNsZWFyKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVYSUZcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBleGlmIGRhdGEgYW5kIGZpeGVzIHRoZSBvcmllbnRhdGlvbiBpZiBuZWNlc3NhcnlcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICogQHByaXZhdGVcbiAgICogQFRPRE8gTW92ZSB0aGlzIHNvbWV3aGVyZSBlbHNlXG4gICAqL1xuICBwYXJzZUV4aWYgKGltYWdlKSB7XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxldCB7IHNyYyB9ID0gaW1hZ2VcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgICBpZiAoRXhpZi5pc0pQRUcoc3JjKSkge1xuICAgICAgbGV0IGV4aWYgPSBudWxsXG4gICAgICB0cnkge1xuICAgICAgICBleGlmID0gRXhpZi5mcm9tQmFzZTY0U3RyaW5nKHNyYylcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICBpZiAoIWV4aWYpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGlmXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBFWElGIG9yaWVudGF0aW9uIHRhZyBhbmQgZml4ZXMgaXQgd2l0aCB0aGUgT3JpZW50YXRpb25PcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVFeGlmT3JpZW50YXRpb24gKCkge1xuICAgIGxldCBleGlmVGFncyA9IHRoaXMuX2V4aWYuZ2V0VGFncygpXG5cbiAgICBpZiAoZXhpZlRhZ3MgJiYgZXhpZlRhZ3MuT3JpZW50YXRpb24pIHtcbiAgICAgIGNvbnN0IHJvdGF0aW9uTmVlZHNDaGFuZ2UgPSBleGlmVGFncy5PcmllbnRhdGlvbiAhPT0gMSAmJlxuICAgICAgICBleGlmVGFncy5PcmllbnRhdGlvbiAhPT0gMlxuICAgICAgY29uc3QgZmxpcE5lZWRzQ2hhbmdlID0gWzIsIDQsIDUsIDddLmluZGV4T2YoZXhpZlRhZ3MuT3JpZW50YXRpb24pICE9PSAtMVxuXG4gICAgICBpZiAocm90YXRpb25OZWVkc0NoYW5nZSB8fCBmbGlwTmVlZHNDaGFuZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9leGlmT3BlcmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fZXhpZk9wZXJhdGlvbiA9IHRoaXMuY3JlYXRlT3BlcmF0aW9uKCdleGlmLW9yaWVudGF0aW9uJylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9leGlmT3BlcmF0aW9uLnNldFRhZ3MoZXhpZlRhZ3MpXG5cbiAgICAgICAgLy8gV2UgZml4ZWQgdGhlIG9yaWVudGF0aW9uLCBuZXcgRVhJRiBvcmllbnRhdGlvbiBpcyAxXG4gICAgICAgIHRoaXMuX2V4aWYuc2V0T3JpZW50YXRpb24oMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBHRVRURVJTIC8gU0VUVEVSU1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW4gaW1hZ2UgaXMgcHJvdmlkZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgaGFzSW1hZ2UgKCkge1xuICAgIHJldHVybiAodGhpcy5faW1hZ2UgIT09IG51bGwgJiYgdHlwZW9mIHRoaXMuX2ltYWdlICE9PSAndW5kZWZpbmVkJylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZVxuICAgKiBAcmV0dXJuIHtJbWFnZX1cbiAgICovXG4gIGdldEltYWdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbWFnZSBhbmQgcGFyc2VzIHRoZSBleGlmIGRhdGFcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FeGlmfSBbZXhpZiA9IG51bGxdXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBbZGltZW5zaW9uc11cbiAgICovXG4gIHNldEltYWdlIChpbWFnZSwgZXhpZiA9IG51bGwsIGRpbWVuc2lvbnMgPSBudWxsKSB7XG4gICAgLy8gUmVzZXQgZXhpZiBvcmllbnRhdGlvbiBjb21wZW5zYXRpb25cbiAgICBpZiAodGhpcy5fZXhpZk9wZXJhdGlvbikge1xuICAgICAgdGhpcy5yZW1vdmVPcGVyYXRpb24odGhpcy5fZXhpZk9wZXJhdGlvbilcbiAgICAgIHRoaXMuX2V4aWZPcGVyYXRpb24gPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5fb3B0aW9ucy5pbWFnZSA9IGltYWdlXG4gICAgdGhpcy5faW1hZ2UgPSBpbWFnZVxuXG4gICAgdGhpcy5fZXhpZiA9IGV4aWYgfHwgdGhpcy5wYXJzZUV4aWYoaW1hZ2UpXG4gICAgaWYgKHRoaXMuX2V4aWYpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUV4aWZPcmllbnRhdGlvbigpXG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBuZXcgRW5naW5lLkJhc2VUZXh0dXJlKHRoaXMuX2ltYWdlKVxuICAgIGNvbnN0IGZyYW1lID0gbmV3IFJlY3RhbmdsZSgwLCAwLCB0aGlzLl9pbWFnZS53aWR0aCwgdGhpcy5faW1hZ2UuaGVpZ2h0KVxuICAgIGlmIChkaW1lbnNpb25zKSB7XG4gICAgICBmcmFtZS53aWR0aCA9IGRpbWVuc2lvbnMueFxuICAgICAgZnJhbWUuaGVpZ2h0ID0gZGltZW5zaW9ucy55XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jlc2l6ZWRUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9yZXNpemVkVGV4dHVyZS5kaXNwb3NlKClcbiAgICB9XG4gICAgdGhpcy5fcmVzaXplZFRleHR1cmUgPSBudWxsXG5cbiAgICBpZiAodGhpcy5faW5wdXRUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9pbnB1dFRleHR1cmUuZ2V0QmFzZVRleHR1cmUoKS5kaXNwb3NlKClcbiAgICB9XG4gICAgdGhpcy5faW5wdXRUZXh0dXJlID0gbmV3IEVuZ2luZS5UZXh0dXJlKGJhc2VUZXh0dXJlLCBmcmFtZSlcbiAgICB0aGlzLl9jdXJyZW50VGV4dHVyZSA9IHRoaXMuX2lucHV0VGV4dHVyZVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKHRoaXMuX2lucHV0VGV4dHVyZSlcblxuICAgIHRoaXMuc2V0QWxsT3BlcmF0aW9uc1RvRGlydHkodHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjYW52YXNcbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAqL1xuICBnZXRDYW52YXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5nZXRDYW52YXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICovXG4gIHNldENhbnZhcyAoY2FudmFzKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0Q2FudmFzKGNhbnZhcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzcHJpdGVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlNwcml0ZX1cbiAgICovXG4gIGdldFNwcml0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nwcml0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ29udGFpbmVyfVxuICAgKi9cbiAgZ2V0Q29udGFpbmVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3BlcmF0aW9uIHN0YWNrXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNTdGFja31cbiAgICovXG4gIGdldE9wZXJhdGlvbnNTdGFjayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wZXJhdGlvbnNTdGFja1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9wZXJhdGlvbnMgc3RhY2tcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zU3RhY2t9IG9wZXJhdGlvbnNTdGFja1xuICAgKi9cbiAgc2V0T3BlcmF0aW9uc1N0YWNrIChvcGVyYXRpb25zU3RhY2spIHtcbiAgICBpZiAodGhpcy5fb3BlcmF0aW9uc1N0YWNrKSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25zU3RhY2sub2ZmKEV2ZW50cy5PUEVSQVRJT05fVVBEQVRFRCwgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUpXG4gICAgfVxuXG4gICAgdGhpcy5fb3BlcmF0aW9uc1N0YWNrID0gb3BlcmF0aW9uc1N0YWNrXG4gICAgdGhpcy5fb3BlcmF0aW9uc1N0YWNrLm9uKEV2ZW50cy5PUEVSQVRJT05fVVBEQVRFRCwgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXZhaWxhYmxlIG9wZXJhdGlvbnNcbiAgICogQHJldHVybiB7T3BlcmF0aW9uW119XG4gICAqL1xuICBnZXRPcGVyYXRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3BlcmF0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9XG4gICAqL1xuICBnZXRSZW5kZXJlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVuZGVyaW5nIG9mZnNldFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXJpbmcgb2Zmc2V0XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfE51bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqL1xuICBzZXRPZmZzZXQgKG9mZnNldCwgeSkge1xuICAgIGlmIChvZmZzZXQgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XG4gICAgICB0aGlzLl9vZmZzZXQuY29weShvZmZzZXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29mZnNldC5zZXQob2Zmc2V0LCB5KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlbmRlciBtb2RlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldFJlbmRlck1vZGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJNb2RlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyIG1vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlbmRlck1vZGVcbiAgICovXG4gIHNldFJlbmRlck1vZGUgKHJlbmRlck1vZGUpIHtcbiAgICB0aGlzLl9yZW5kZXJNb2RlID0gcmVuZGVyTW9kZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHpvb20gbGV2ZWxcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0Wm9vbSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvb21cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB6b29tIGxldmVsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB6b29tXG4gICAqL1xuICBzZXRab29tICh6b29tKSB7XG4gICAgdGhpcy5fem9vbSA9IHpvb21cbiAgICB0aGlzLl9jb250YWluZXIuc2V0U2NhbGUodGhpcy5fem9vbSwgdGhpcy5fem9vbSlcbiAgICB0aGlzLl9jb250YWluZXIudXBkYXRlVHJhbnNmb3JtKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0dXJlIHF1YWxpdHlcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VGV4dHVyZVF1YWxpdHkgKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJNb2RlID09PSAnZXhwb3J0Jykge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVF1YWxpdHlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0dXJlIHF1YWxpdHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRleHR1cmVRdWFsaXR5XG4gICAqL1xuICBzZXRUZXh0dXJlUXVhbGl0eSAodGV4dHVyZVF1YWxpdHkpIHtcbiAgICBpZiAodGV4dHVyZVF1YWxpdHkgIT09IHRoaXMuX3RleHR1cmVRdWFsaXR5KSB7XG4gICAgICB0aGlzLnNldEFsbE9wZXJhdGlvbnNUb0RpcnR5KHRydWUpXG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmVRdWFsaXR5ID0gTWF0aC5taW4oMSwgdGV4dHVyZVF1YWxpdHkpXG5cbiAgICAvLyBDbGVhbiB1cCByZXNpemVkIHRleHR1cmUsIG5vdCBuZWVkZWQgcmlnaHQgbm93XG4gICAgaWYgKHRoaXMuX3RleHR1cmVRdWFsaXR5ID09PSAxICYmIHRoaXMuX3Jlc2l6ZWRUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9yZXNpemVkVGV4dHVyZS5kaXNwb3NlKClcbiAgICAgIHRoaXMuX3Jlc2l6ZWRUZXh0dXJlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdXRwdXQgc3ByaXRlJ3Mgc2NhbGVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0U3ByaXRlU2NhbGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zcHJpdGVTY2FsZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNwcml0ZSBzY2FsZSB0byB0aGUgZ2l2ZW4gdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNwcml0ZVNjYWxlXG4gICAqL1xuICBzZXRTcHJpdGVTY2FsZSAoc3ByaXRlU2NhbGUpIHtcbiAgICB0aGlzLl9zcHJpdGVTY2FsZSA9IHNwcml0ZVNjYWxlXG4gICAgdGhpcy5fc3ByaXRlLnNldFNjYWxlKHNwcml0ZVNjYWxlLCBzcHJpdGVTY2FsZSlcbiAgICB0aGlzLl9zcHJpdGUudXBkYXRlVHJhbnNmb3JtKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaXhlbCByYXRpb1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRQaXhlbFJhdGlvICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5waXhlbFJhdGlvXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgRXhpZiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FeGlmfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBnZXRFeGlmICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhpZlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnB1dCB0ZXh0dXJlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfVxuICAgKi9cbiAgZ2V0SW5wdXRUZXh0dXJlICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXRUZXh0dXJlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc21vb3RoIGRvd25zY2FsaW5nIGZsYWcgZm9yIHRoZSBvdXRwdXQgc3ByaXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc21vb3RoRG93bnNjYWxpbmdcbiAgICovXG4gIHNldFNtb290aERvd25zY2FsaW5nIChzbW9vdGhEb3duc2NhbGluZykge1xuICAgIHRoaXMuX29wdGlvbnMuc21vb3RoRG93bnNjYWxpbmcgPSBzbW9vdGhEb3duc2NhbGluZ1xuICAgIHRoaXMuX3Nwcml0ZS5zZXRTbW9vdGhEb3duc2NhbGluZyhzbW9vdGhEb3duc2NhbGluZylcbiAgICB0aGlzLl9yZXNpemVkU3ByaXRlLnNldFNtb290aERvd25zY2FsaW5nKHNtb290aERvd25zY2FsaW5nKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJvdGF0aW9uIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cbiAgICovXG4gIHNldFJvdGF0aW9uIChyb3RhdGlvbikge1xuICAgIHRoaXMuX3JvdGF0aW9uID0gcm90YXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJvdGF0aW9uXG4gICAqL1xuICBnZXRSb3RhdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBESVNQT1NBTFxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGUgU0RLXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9vcGVyYXRpb25zU3RhY2suZGlzcG9zZSgpXG4gICAgdGhpcy5fcmVuZGVyZXIuZGlzcG9zZSgpXG4gICAgaWYgKHRoaXMuX2V4aWYpIHtcbiAgICAgIHRoaXMuX2V4aWYuZGlzcG9zZSgpXG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXNpemVkVGV4dHVyZSkge1xuICAgICAgdGhpcy5fcmVzaXplZFRleHR1cmUuZGlzcG9zZSgpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBob3RvRWRpdG9yU0RLXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zZGsuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cywgQ29sb3IgfSBmcm9tICcuLi9nbG9iYWxzJ1xuY29uc3QgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSB9ID0gQ29uc3RhbnRzXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY2xhc3MgQ29sb3JPdmVybGF5RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4vc291cmNlL2NvbG9yLW92ZXJsYXkuZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIG91dHB1dENvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgMCwgMClcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgZmlsdGVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5Db2xvck92ZXJsYXlGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGNvbG9yOiB7IHR5cGU6IE9wdGlvblR5cGUuQ09MT1IsIGRlZmF1bHQ6IENvbG9yLldISVRFLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQ0IH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sb3JPdmVybGF5RmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvZmlsdGVycy9jb2xvci1vdmVybGF5LWZpbHRlci5qcyIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XHJcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcclxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXHJcbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XHJcbiAqXHJcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIFBob3RvRWRpdG9yU0RLLkVuZ2luZS5GaWx0ZXJzXHJcbiAqL1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFVucHJlbXVsdGlwbHlGaWx0ZXIgfSBmcm9tICcuL3VucHJlbXVsdGlwbHktZmlsdGVyJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbG9yT3ZlcmxheUZpbHRlciB9IGZyb20gJy4vY29sb3Itb3ZlcmxheS1maWx0ZXInXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS9maWx0ZXJzL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5wcmVtdWx0aXBseUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi9zb3VyY2UvdW5wcmVtdWx0aXBseS5mcmFnJylcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL2ZpbHRlcnMvdW5wcmVtdWx0aXBseS1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFV0aWxzLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuY29uc3QgeyBSZW5kZXJlclR5cGUgfSA9IENvbnN0YW50c1xuaW1wb3J0IENvbnRleHRQZXJmb3JtYW5jZUhvb2sgZnJvbSAnLi4vLi4vdXRpbHMvY29udGV4dC1wZXJmb3JtYW5jZS1ob29rJ1xuaW1wb3J0IEJhc2VSZW5kZXJlciBmcm9tICcuLi9iYXNlLXJlbmRlcmVyJ1xuaW1wb3J0IENhbnZhc1JlbmRlclRhcmdldCBmcm9tICcuLi8uLi91dGlscy9jYW52YXMtcmVuZGVyLXRhcmdldCdcbmltcG9ydCBDYW52YXNGaWx0ZXJNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXJzL2NhbnZhcy1maWx0ZXItbWFuYWdlcidcblxuLyoqXG4gKiBUaGUgcmVuZGVyZXIgdGhhdCBpcyB1c2VkIGZvciBDYW52YXMyRCByZW5kZXJpbmdcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG5jbGFzcyBDYW52YXNSZW5kZXJlciBleHRlbmRzIEJhc2VSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ2FudmFzUmVuZGVyZXJcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fdHlwZSA9IFJlbmRlcmVyVHlwZS5DQU5WQVNcblxuICAgIHRoaXMuc2V0Q2FudmFzKHRoaXMuX29wdGlvbnMuY2FudmFzIHx8IHRoaXMuX2NyZWF0ZUNhbnZhcygpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYW52YXMgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQ2FudmFzICgpIHtcbiAgICByZXR1cm4gVXRpbHMuY3JlYXRlQ2FudmFzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgdGhpcyByZW5kZXJlclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZUNvbnRleHQgKCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2NhbnZhc1xuICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZGVidWcpIHtcbiAgICAgIGN0eCA9IG5ldyBDb250ZXh0UGVyZm9ybWFuY2VIb29rKGN0eClcbiAgICB9XG5cbiAgICB0aGlzLmlkID0gY3R4LmlkID0gQ2FudmFzUmVuZGVyZXIuY29udGV4dElkKytcbiAgICB0aGlzLl9jb250ZXh0ID0gY3R4XG4gICAgY3R4LnJlbmRlcmVyID0gdGhpc1xuXG4gICAgdGhpcy5lbWl0KCdjb250ZXh0JywgY3R4KVxuXG4gICAgcmV0dXJuIGN0eFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIHJlbmRlcmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBDb250ZXh0ICgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jb250ZXh0XG5cbiAgICAvLyBFbmFibGUgaW1hZ2Ugc21vb3RoaW5nIGlmIGF2YWlsYWJsZVxuICAgIGlmICghKCdpbWFnZVNtb290aGluZ0VuYWJsZWQnIGluIGN0eCkpIHtcbiAgICAgIFsnbW96JywgJ3dlYmtpdCcsICdtcyddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKGN0eFtwcm9wXSkge1xuICAgICAgICAgIGN0eFtwcm9wXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWVcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZhdWx0UmVuZGVyVGFyZ2V0ID0gbmV3IENhbnZhc1JlbmRlclRhcmdldCh0aGlzLl93aWR0aCxcbiAgICAgIHRoaXMuX2hlaWdodCxcbiAgICAgIHRoaXMuX3BpeGVsUmF0aW8sXG4gICAgICB0aGlzLl9jYW52YXMsXG4gICAgICB0aGlzLl9jb250ZXh0KVxuICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQpXG5cbiAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyID0gbmV3IENhbnZhc0ZpbHRlck1hbmFnZXIodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBEaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0XG4gICAqL1xuICByZW5kZXIgKGRpc3BsYXlPYmplY3QpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9yZW5kZXJUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICAvLyBTaW5jZSB0aGUgZ2l2ZW4gZGlzcGxheU9iamVjdCBpcyB0aGUgXCJyb290XCIgb2JqZWN0XG4gICAgLy8gcmlnaHQgbm93LCB3ZSBuZWVkIHRvIGdpdmUgaXQgYSBkdW1teSAvIGZha2Ugb2JqZWN0XG4gICAgLy8gYXMgcGFyZW50IHdpdGggdGhlIGRlZmF1bHQgd29ybGQgdHJhbnNmb3JtIGFuZCBhbHBoYVxuICAgIGNvbnN0IG9yaWdpbmFsUGFyZW50ID0gZGlzcGxheU9iamVjdC5nZXRQYXJlbnQoKVxuICAgIGRpc3BsYXlPYmplY3Quc2V0UGFyZW50KHRoaXMuX2Zha2VPYmplY3QpXG5cbiAgICAvLyBVcGRhdGUgdHJhbnNmb3JtcyBhbmQgcmVuZGVyIHRoaXMgb2JqZWN0XG4gICAgZGlzcGxheU9iamVjdC51cGRhdGVUcmFuc2Zvcm0oKVxuXG4gICAgLy8gUmVzZXQgcGFyZW50XG4gICAgZGlzcGxheU9iamVjdC5zZXRQYXJlbnQob3JpZ2luYWxQYXJlbnQpXG5cbiAgICAvLyBSZXNldCB0cmFuc2Zvcm1cbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG5cbiAgICAvLyBSZXNldCBhbHBoYVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcblxuICAgIC8vIENsZWFyIHRoZSB2aWV3XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLl9jYW52YXNcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpXG4gICAgaWYgKHRoaXMuX2NsZWFyQ29sb3IuYSAhPT0gMCkge1xuICAgICAgY3R4LnNhdmUoKVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NsZWFyQ29sb3IudG9SR0JBKClcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgY3R4LnJlc3RvcmUoKVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCB0aGlzLl9yZW5kZXJUYXJnZXQpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gRGlzcGxheU9iamVjdFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGFyZ2V0fSByZW5kZXJUYXJnZXRcbiAgICovXG4gIHJlbmRlckRpc3BsYXlPYmplY3QgKGRpc3BsYXlPYmplY3QsIHJlbmRlclRhcmdldCkge1xuICAgIGNvbnN0IG9yaWdpbmFsUmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGFyZ2V0XG4gICAgdGhpcy5fZmlsdGVyTWFuYWdlci5zZXRGaWx0ZXJTdGFjayhyZW5kZXJUYXJnZXQuZ2V0RmlsdGVyU3RhY2soKSlcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpXG4gICAgZGlzcGxheU9iamVjdC5yZW5kZXJDYW52YXModGhpcylcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldChvcmlnaW5hbFJlbmRlclRhcmdldClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlbmRlciB0YXJnZXRcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRhcmdldH1cbiAgICovXG4gIGdldEN1cnJlbnRSZW5kZXJUYXJnZXQgKCkgeyByZXR1cm4gdGhpcy5fcmVuZGVyVGFyZ2V0IH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyIHRhcmdldFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IHJlbmRlclRhcmdldFxuICAgKi9cbiAgc2V0UmVuZGVyVGFyZ2V0IChyZW5kZXJUYXJnZXQpIHtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XG4gICAqIEByZXR1cm4ge1JlbmRlcmluZ0NvbnRleHR9XG4gICAqL1xuICBnZXRDb250ZXh0ICgpIHsgcmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldC5nZXRDb250ZXh0KCkgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIFJlbmRlcmVyXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyLmRpc3Bvc2UoKVxuICB9XG59XG5cbkNhbnZhc1JlbmRlcmVyLmNvbnRleHRJZCA9IDBcbkNhbnZhc1JlbmRlcmVyLnR5cGUgPSAnQ2FudmFzMkQnXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1JlbmRlcmVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvcmVuZGVyZXJzL2NhbnZhcy9jYW52YXMtcmVuZGVyZXIuanMiLCIvKiBlc2xpbnQgY29uc3RydWN0b3Itc3VwZXI6IDAgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEdsb2JhbHMgZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBPYmplY3RSZW5kZXJlciBmcm9tICcuL29iamVjdC1yZW5kZXJlcidcblxuLyoqXG4gKiBUaGUgT2JqZWN0UmVuZGVyZXIgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIFNwcml0ZSBpbnN0YW5jZXNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRW5naW5lLk9iamVjdFJlbmRlcmVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jbGFzcyBTcHJpdGVSZW5kZXJlciBleHRlbmRzIE9iamVjdFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTcHJpdGVSZW5kZXJlclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX21heEJhdGNoU2l6ZSA9IEdsb2JhbHMuQkFUQ0hfU0laRVxuICAgIHRoaXMuX3ZlcnRpY2VzID0gbmV3IEFycmF5QnVmZmVyKEdsb2JhbHMuQkFUQ0hfU0laRSAqIDQgKiBHbG9iYWxzLlZFUlRFWF9CWVRFX1NJWkUpXG4gICAgdGhpcy5fcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl92ZXJ0aWNlcylcbiAgICB0aGlzLl9jb2xvcnMgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fdmVydGljZXMpXG4gICAgdGhpcy5faW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShHbG9iYWxzLkJBVENIX1NJWkUgKiA2KVxuXG4gICAgLy8gRmlsbCB2ZXJ0ZXggcG9zaXRpb24gaW5kaWNlc1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IEdsb2JhbHMuQkFUQ0hfU0laRSAqIDY7IGkgKz0gNiwgaiArPSA0KSB7XG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyAwXSA9IGogKyAwXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyAxXSA9IGogKyAxXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyAyXSA9IGogKyAyXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyAzXSA9IGogKyAwXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyA0XSA9IGogKyAyXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyA1XSA9IGogKyAzXG4gICAgfVxuXG4gICAgdGhpcy5fc2hhZGVycyA9IFtdXG4gICAgdGhpcy5fc3ByaXRlcyA9IFtdXG5cbiAgICB0aGlzLl9jdXJyZW50QmF0Y2hTaXplID0gMFxuICAgIHRoaXMuX2N1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGxcblxuICAgIHRoaXMuX29uQ29udGV4dENoYW5nZSgpXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gc3ByaXRlIHRvIHRoZSBiYXRjaFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU3ByaXRlfSBzcHJpdGVcbiAgICovXG4gIHJlbmRlciAoc3ByaXRlKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHNwcml0ZS5nZXRUZXh0dXJlKClcbiAgICBjb25zdCB0ZXh0dXJlRnJhbWUgPSB0ZXh0dXJlLmdldEZyYW1lKClcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IHRleHR1cmUuZ2V0QmFzZVRleHR1cmUoKVxuXG4gICAgLy8gSGFzIHRoZSBtYXhpbXVtIGJhdGNoIHNpemUgYmVlbiByZWFjaGVkPyBGbHVzaCFcbiAgICBpZiAodGhpcy5fY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLl9tYXhCYXRjaFNpemUpIHtcbiAgICAgIHRoaXMuZmx1c2goKVxuICAgICAgdGhpcy5fY3VycmVudEJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmVcbiAgICB9XG5cbiAgICAvLyBObyB1cGRhdGVkIFVWcyA9PiBObyByZW5kZXJpbmdcbiAgICBjb25zdCB1dnMgPSB0ZXh0dXJlLmdldFVWcygpXG4gICAgaWYgKCF1dnMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpbGwgcG9zaXRpb25zIGFycmF5XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9jdXJyZW50QmF0Y2hTaXplICogR2xvYmFscy5WRVJURVhfQllURV9TSVpFXG4gICAgdGhpcy5fYWRkVmVydGV4Q29vcmRpbmF0ZXMoc3ByaXRlLCBpbmRleCwgdGV4dHVyZUZyYW1lKVxuICAgIHRoaXMuX2FkZFRleHR1cmVVVnMoc3ByaXRlLCBpbmRleCwgdXZzKVxuICAgIHRoaXMuX2FkZENvbG9ycyhzcHJpdGUsIGluZGV4KVxuXG4gICAgLy8gQWRkIHRoZSBzcHJpdGUgdG8gdGhlIGxpc3Qgb2Ygc3ByaXRlc1xuICAgIHRoaXMuX3Nwcml0ZXNbdGhpcy5fY3VycmVudEJhdGNoU2l6ZV0gPSBzcHJpdGVcbiAgICB0aGlzLl9jdXJyZW50QmF0Y2hTaXplKytcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBjb2xvciB0byB0aGUgcG9zaXRpb25zIGFycmF5IGZvciB0aGUgZ2l2ZW4gc3ByaXRlXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlNwcml0ZX0gc3ByaXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZENvbG9ycyAoc3ByaXRlLCBpbmRleCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuX2NvbG9yc1xuICAgIGNvbnN0IHRpbnQgPSBzcHJpdGUuZ2V0VGludCgpXG4gICAgY29uc3QgY29sb3IgPSAodGludCA+PiAxNikgKyAodGludCAmIDB4ZmYwMCkgKyAoKHRpbnQgJiAweGZmKSA8PCAxNikgKyAoc3ByaXRlLmdldFdvcmxkQWxwaGEoKSAqIDI1NSA8PCAyNClcbiAgICBjb2xvcnNbaW5kZXggKyA0XSA9XG4gICAgICBjb2xvcnNbaW5kZXggKyA5XSA9XG4gICAgICBjb2xvcnNbaW5kZXggKyAxNF0gPVxuICAgICAgY29sb3JzW2luZGV4ICsgMTldID0gY29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSB0ZXh0dXJlIFVWIGNvb3JkaW5hdGVzIHRvIHRoZSBwb3NpdGlvbnMgYXJyYXkgZm9yIHRoZSBnaXZlbiBzcHJpdGVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU3ByaXRlfSBzcHJpdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlRleHR1cmVVVnN9IHV2c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZFRleHR1cmVVVnMgKHNwcml0ZSwgaW5kZXgsIHV2cykge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuX3Bvc2l0aW9uc1xuXG4gICAgLy8gQWRkIFVWc1xuICAgIGxldCB1dkNvb3JkcyA9IHV2cy5nZXRVVnNBdCgwKVxuICAgIHBvc2l0aW9uc1tpbmRleCArIDJdID0gdXZDb29yZHMueFxuICAgIHBvc2l0aW9uc1tpbmRleCArIDNdID0gdXZDb29yZHMueVxuXG4gICAgdXZDb29yZHMgPSB1dnMuZ2V0VVZzQXQoMSlcbiAgICBwb3NpdGlvbnNbaW5kZXggKyA3XSA9IHV2Q29vcmRzLnhcbiAgICBwb3NpdGlvbnNbaW5kZXggKyA4XSA9IHV2Q29vcmRzLnlcblxuICAgIHV2Q29vcmRzID0gdXZzLmdldFVWc0F0KDIpXG4gICAgcG9zaXRpb25zW2luZGV4ICsgMTJdID0gdXZDb29yZHMueFxuICAgIHBvc2l0aW9uc1tpbmRleCArIDEzXSA9IHV2Q29vcmRzLnlcblxuICAgIHV2Q29vcmRzID0gdXZzLmdldFVWc0F0KDMpXG4gICAgcG9zaXRpb25zW2luZGV4ICsgMTddID0gdXZDb29yZHMueFxuICAgIHBvc2l0aW9uc1tpbmRleCArIDE4XSA9IHV2Q29vcmRzLnlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSB2ZXJ0ZXggY29vcmRpbmF0ZXMgdG8gdGhlIHBvc2l0aW9ucyBhcnJheSBmb3IgdGhlIGdpdmVuXG4gICAqIHNwcml0ZSBhbmQgdGV4dHVyZSBmcmFtZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5TcHJpdGV9IHNwcml0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX0gdGV4dHVyZUZyYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkVmVydGV4Q29vcmRpbmF0ZXMgKHNwcml0ZSwgaW5kZXgsIHRleHR1cmVGcmFtZSkge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuX3Bvc2l0aW9uc1xuICAgIGNvbnN0IHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLmdldFdvcmxkVHJhbnNmb3JtKClcblxuICAgIC8vIFRyYW5zZm9ybSBzcHJpdGUgY29vcmRzIHdpdGggYW5jaG9yIGluIG1pbmRcbiAgICBjb25zdCBhbmNob3IgPSBzcHJpdGUuZ2V0QW5jaG9yKClcbiAgICBjb25zdCByZWN0UG9zaXRpb25zID0gd29ybGRUcmFuc2Zvcm0ucmVjdGFuZ2xlVG9Db29yZGluYXRlcyh0ZXh0dXJlRnJhbWUsIGFuY2hvcilcblxuICAgIGNvbnN0IHN0cmlkZSA9IDVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgcG9zaXRpb25zW2luZGV4ICsgaSAqIHN0cmlkZV0gPSByZWN0UG9zaXRpb25zW2ldLnhcbiAgICAgIHBvc2l0aW9uc1tpbmRleCArIGkgKiBzdHJpZGUgKyAxXSA9IHJlY3RQb3NpdGlvbnNbaV0ueVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSByZW5kZXJpbmcgY29udGV4dCBjaGFuZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db250ZXh0Q2hhbmdlICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuXG4gICAgdGhpcy5fc2hhZGVyID0gdGhpcy5fcmVuZGVyZXIuc2hhZGVycy5kZWZhdWx0XG5cbiAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICAgIHRoaXMuX2luZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2luZGV4QnVmZmVyKVxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2luZGljZXMsIGdsLlNUQVRJQ19EUkFXKVxuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX3ZlcnRleEJ1ZmZlcilcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fdmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IHJlbmRlcmVyIGlzIGFjdGl2YXRlZFxuICAgKi9cbiAgc3RhcnQgKCkge1xuICAgIHRoaXMuX3NoYWRlci5zZXR1cEJ1ZmZlcnModGhpcy5fdmVydGV4QnVmZmVyLCB0aGlzLl9pbmRleEJ1ZmZlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBxdWV1ZWQgc3ByaXRlcyBpbiBiYXRjaGVzLCBldmVyeSB0aW1lIHRoZSBiYXNlIHRleHR1cmUgaGFzIGNoYW5nZWQsXG4gICAqIGl0IGZsdXNoZXMgdGhlIGN1cnJlbnQgYmF0Y2ggdG8gdGhlIGdyYXBoaWNzIGNhcmRcbiAgICovXG4gIGZsdXNoICgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyXG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KClcblxuICAgIGlmICh0aGlzLl9jdXJyZW50QmF0Y2hTaXplID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3VycmVudEJhdGNoU2l6ZSA+IEdsb2JhbHMuQkFUQ0hfU0laRSAqIDAuNSkge1xuICAgICAgLy8gVXBsb2FkIHdob2xlIEFycmF5QnVmZmVyXG4gICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy5fdmVydGljZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgdXBsb2FkIHN1YiBhcnJheVxuICAgICAgY29uc3Qgc3ViQXJyYXkgPSB0aGlzLl9wb3NpdGlvbnMuc3ViYXJyYXkoMCwgdGhpcy5fY3VycmVudEJhdGNoU2l6ZSAqIEdsb2JhbHMuVkVSVEVYX0JZVEVfU0laRSlcbiAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCBzdWJBcnJheSlcbiAgICB9XG5cbiAgICAvLyBJbml0IHZhcmlhYmxlc1xuICAgIGxldCBjdXJyZW50QmF0Y2hTaXplID0gMFxuICAgIGxldCBjdXJyZW50QmFzZVRleHR1cmUgPSBudWxsXG4gICAgbGV0IG5leHRCYXNlVGV4dHVyZSA9IG51bGxcbiAgICBsZXQgY3VycmVudFNoYWRlciA9IG51bGxcbiAgICBsZXQgbmV4dFNoYWRlciA9IG51bGxcbiAgICBsZXQgc2hhZGVyQ2hhbmdlZCA9IGZhbHNlXG4gICAgbGV0IHRleHR1cmVDaGFuZ2VkID0gZmFsc2VcbiAgICBsZXQgc3ByaXRlID0gbnVsbFxuICAgIGxldCBiYXRjaFN0YXJ0SW5kZXggPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuX2N1cnJlbnRCYXRjaFNpemU7IGkgPCBqOyBpKyspIHtcbiAgICAgIHNwcml0ZSA9IHRoaXMuX3Nwcml0ZXNbaV1cblxuICAgICAgbmV4dEJhc2VUZXh0dXJlID0gc3ByaXRlLmdldFRleHR1cmUoKS5nZXRCYXNlVGV4dHVyZSgpXG4gICAgICBuZXh0U2hhZGVyID0gc3ByaXRlLmdldFNoYWRlcigpIHx8IHRoaXMuX3NoYWRlclxuICAgICAgc2hhZGVyQ2hhbmdlZCA9IGN1cnJlbnRTaGFkZXIgIT09IG5leHRTaGFkZXJcbiAgICAgIHRleHR1cmVDaGFuZ2VkID0gY3VycmVudEJhc2VUZXh0dXJlICE9PSBuZXh0QmFzZVRleHR1cmVcblxuICAgICAgaWYgKHRleHR1cmVDaGFuZ2VkIHx8IHNoYWRlckNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyQmF0Y2goY3VycmVudEJhc2VUZXh0dXJlLCBjdXJyZW50QmF0Y2hTaXplLCBiYXRjaFN0YXJ0SW5kZXgpXG5cbiAgICAgICAgYmF0Y2hTdGFydEluZGV4ID0gaVxuICAgICAgICBjdXJyZW50QmF0Y2hTaXplID0gMFxuICAgICAgICBjdXJyZW50QmFzZVRleHR1cmUgPSBuZXh0QmFzZVRleHR1cmVcblxuICAgICAgICAvLyBTaGFkZXIgaGFzIGNoYW5nZWQsIHNldCBpdFxuICAgICAgICBpZiAoc2hhZGVyQ2hhbmdlZCkge1xuICAgICAgICAgIGN1cnJlbnRTaGFkZXIgPSBuZXh0U2hhZGVyXG4gICAgICAgICAgcmVuZGVyZXIuc2V0U2hhZGVyKGN1cnJlbnRTaGFkZXIpXG5cbiAgICAgICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0KClcbiAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gcmVuZGVyVGFyZ2V0LmdldFByb2plY3Rpb25NYXRyaXgoKS50b0FycmF5KClcbiAgICAgICAgICBjdXJyZW50U2hhZGVyLnNldFVuaWZvcm0oJ3VfcHJvak1hdHJpeCcsIHByb2plY3Rpb25NYXRyaXgpXG4gICAgICAgICAgY3VycmVudFNoYWRlci5zeW5jVW5pZm9ybXMoKVxuXG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50QmF0Y2hTaXplKytcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXJCYXRjaChjdXJyZW50QmFzZVRleHR1cmUsIGN1cnJlbnRCYXRjaFNpemUsIGJhdGNoU3RhcnRJbmRleClcblxuICAgIC8vIFJlc2V0IHRoZSBiYXRjaFxuICAgIHRoaXMuX2N1cnJlbnRCYXRjaFNpemUgPSAwXG4gICAgdGhpcy5fc3ByaXRlcyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY3VycmVudCBiYXRjaFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlXG4gICAqIEBwYXJhbSAge051bWJlcn0gYmF0Y2hTaXplXG4gICAqIEBwYXJhbSAge051bWJlcn0gYmF0Y2hTdGFydEluZGV4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQmF0Y2ggKGJhc2VUZXh0dXJlLCBiYXRjaFNpemUsIGJhdGNoU3RhcnRJbmRleCkge1xuICAgIGlmIChiYXRjaFNpemUgPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKVxuXG4gICAgbGV0IGdsVGV4dHVyZSA9IGJhc2VUZXh0dXJlLmdldEdMVGV4dHVyZUZvclJlbmRlcmVyKHJlbmRlcmVyKVxuICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICBnbFRleHR1cmUgPSByZW5kZXJlci5nZXRPckNyZWF0ZUdMVGV4dHVyZShiYXNlVGV4dHVyZSlcbiAgICB9XG5cbiAgICBpZiAoYmFzZVRleHR1cmUuaXNEaXJ0eSgpKSB7XG4gICAgICByZW5kZXJlci51cGRhdGVUZXh0dXJlKGJhc2VUZXh0dXJlKVxuICAgICAgYmFzZVRleHR1cmUuc2V0RGlydHkoZmFsc2UpXG4gICAgfVxuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGJhc2VUZXh0dXJlLmdldEdMVW5pdCgpKVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSlcblxuICAgIGNvbnN0IHZlcnRpY2VzQ291bnQgPSBiYXRjaFNpemUgKiA2XG4gICAgY29uc3QgdmVydGV4T2Zmc2V0ID0gYmF0Y2hTdGFydEluZGV4ICogNiAqIDJcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB2ZXJ0aWNlc0NvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgdmVydGV4T2Zmc2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgT2JqZWN0UmVuZGVyZXJcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKVxuXG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX3ZlcnRleEJ1ZmZlcilcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5faW5kZXhCdWZmZXIpXG5cbiAgICB0aGlzLl92ZXJ0aWNlcyA9IG51bGxcbiAgICB0aGlzLl9wb3NpdGlvbnMgPSBudWxsXG4gICAgdGhpcy5fY29sb3JzID0gbnVsbFxuICAgIHRoaXMuX2luZGljZXMgPSBudWxsXG5cbiAgICBzdXBlci5kaXNwb3NlKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTcHJpdGVSZW5kZXJlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL3JlbmRlcmVycy93ZWJnbC9vYmplY3QtcmVuZGVyZXJzL3Nwcml0ZS1yZW5kZXJlci5qcyIsIi8qIGdsb2JhbCBJbWFnZSwgSFRNTEltYWdlRWxlbWVudCwgV0VCUEFDSyAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBMb2csIFV0aWxzLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuY29uc3QgeyBSZW5kZXJlclR5cGUgfSA9IENvbnN0YW50c1xuaW1wb3J0IEJhc2VSZW5kZXJlciBmcm9tICcuLi9iYXNlLXJlbmRlcmVyJ1xuaW1wb3J0IFdlYkdMUmVuZGVyVGFyZ2V0IGZyb20gJy4uLy4uL3V0aWxzL3dlYmdsLXJlbmRlci10YXJnZXQnXG5pbXBvcnQgT2JqZWN0UmVuZGVyZXIgZnJvbSAnLi9vYmplY3QtcmVuZGVyZXJzL29iamVjdC1yZW5kZXJlcidcbmltcG9ydCBTcHJpdGVSZW5kZXJlciBmcm9tICcuL29iamVjdC1yZW5kZXJlcnMvc3ByaXRlLXJlbmRlcmVyJ1xuaW1wb3J0IFRleHR1cmVTaGFkZXIgZnJvbSAnLi4vLi4vc2hhZGVycy90ZXh0dXJlLXNoYWRlcidcbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gJy4uLy4uL2Rpc3BsYXkvZGlzcGxheS1vYmplY3QnXG5pbXBvcnQgV2ViR0xGaWx0ZXJNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXJzL3dlYmdsLWZpbHRlci1tYW5hZ2VyJ1xuaW1wb3J0IENvbnRleHRQZXJmb3JtYW5jZUhvb2sgZnJvbSAnLi4vLi4vdXRpbHMvY29udGV4dC1wZXJmb3JtYW5jZS1ob29rJ1xuaW1wb3J0IFdlYkdMTWVtb3J5TWFuYWdlciBmcm9tICcuLi8uLi91dGlscy93ZWJnbC93ZWJnbC1tZW1vcnktbWFuYWdlci5qcydcbmltcG9ydCBQaXhlbEFycmF5SW1hZ2UgZnJvbSAnLi4vLi4vdXRpbHMvcGl4ZWwtYXJyYXktaW1hZ2UnXG5cbi8vIEZvciBzZXJ2ZXItc2lkZSBlbnZpcm9ubWVudHNcblxuLyoqXG4gKiBUaGUgcmVuZGVyZXIgdGhhdCBpcyB1c2VkIGZvciBXZWJHTCByZW5kZXJpbmdcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY2xhc3MgV2ViR0xSZW5kZXJlciBleHRlbmRzIEJhc2VSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgV2ViR0xSZW5kZXJlclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl90eXBlID0gUmVuZGVyZXJUeXBlLldFQkdMXG5cbiAgICB0aGlzLl90ZXh0dXJlcyA9IFtdXG4gICAgdGhpcy5fZmFrZU9iamVjdCA9IG5ldyBEaXNwbGF5T2JqZWN0KClcbiAgICB0aGlzLl9vbkNvbnRleHRMb3N0ID0gdGhpcy5fb25Db250ZXh0TG9zdC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25Db250ZXh0UmVzdG9yZWQgPSB0aGlzLl9vbkNvbnRleHRSZXN0b3JlZC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLnNldENhbnZhcyh0aGlzLl9vcHRpb25zLmNhbnZhcyB8fCBVdGlscy5jcmVhdGVDYW52YXMoKSlcblxuICAgIHRoaXMuc2hhZGVycyA9IHRoaXMuX2luaXRTaGFkZXJzKClcbiAgICB0aGlzLnJlbmRlcmVycyA9IHRoaXMuX2luaXRSZW5kZXJlcnMoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ09OVEVYVCBMT1NTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIFdlYkdMIGNvbnRleHQgaGFzIGJlZW4gbG9zdFxuICAgKiBAcGFyYW0gIHtFdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ29udGV4dExvc3QgKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBMb2cud2Fybih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsICdXZWJHTCBjb250ZXh0IGhhcyBiZWVuIGxvc3QgLSB0cnlpbmcgdG8gcmVzdG9yZS4nKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIFdlYkdMIGNvbnRleHQgY291bGQgbm90IGJlIGNyZWF0ZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db250ZXh0Q3JlYXRpb25FcnJvciAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIExvZy53YXJuKHRoaXMuY29uc3RydWN0b3IubmFtZSwgYEZhaWxlZCB0byBjcmVhdGUgV2ViR0wgY29udGV4dDogJHtlLnN0YXR1c01lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgV2ViR0wgY29udGV4dCBoYXMgYmVlbiByZXN0b3JlZC4gQ2xlYW5zIHVwIGFuZCByZXNldHMgZXZlcnl0aGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNvbnRleHRSZXN0b3JlZCAoKSB7XG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnV2ViR0wgY29udGV4dCBoYXMgYmVlbiByZXN0b3JlZC4gQ2xlYXJpbmcgYWxsIHRleHR1cmVzLicpXG5cbiAgICB0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB7XG4gICAgICB0ZXh0dXJlLmRpc3Bvc2VHTFRleHR1cmVzRm9yUmVuZGVyZXIodGhpcylcbiAgICB9KVxuXG4gICAgdGhpcy5fY3JlYXRlQ29udGV4dCgpXG4gICAgdGhpcy5fc2V0dXBDb250ZXh0KClcbiAgICB0aGlzLmVtaXQoJ2NvbnRleHQtcmVzdG9yZWQnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGJlZm9yZSB0aGUgY29udGV4dCBoYXMgYmVlbiBzZXQgdXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJlZm9yZUNvbnRleHQgKCkge1xuICAgIGlmICh0aGlzLl9maWx0ZXJNYW5hZ2VyKSB7XG4gICAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyLmRpc3Bvc2UoKVxuICAgIH1cbiAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyID0gbmV3IFdlYkdMRmlsdGVyTWFuYWdlcih0aGlzKVxuICAgIHRoaXMuX2N1cnJlbnRPYmplY3RSZW5kZXJlciA9IG5ldyBPYmplY3RSZW5kZXJlcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIHNoYWRlciB0byBhY3RpdmVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU2hhZGVyfSBzaGFkZXJcbiAgICovXG4gIHNldFNoYWRlciAoc2hhZGVyKSB7XG4gICAgdGhpcy5fY3VycmVudFNoYWRlciA9IHNoYWRlclxuICAgIHRoaXMuX2NvbnRleHQudXNlUHJvZ3JhbShzaGFkZXIuZ2V0UHJvZ3JhbSgpKVxuICAgIHRoaXMuX3NldEF0dHJpYnV0ZXNGb3JTaGFkZXIoc2hhZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNhbnZhcyB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKi9cbiAgc2V0Q2FudmFzIChjYW52YXMpIHtcbiAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX29uQ29udGV4dExvc3QpXG4gICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLl9vbkNvbnRleHRSZXN0b3JlZClcbiAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yJywgdGhpcy5fb25Db250ZXh0Q3JlYXRpb25FcnJvcilcbiAgICB9XG5cbiAgICBpZiAoY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIpIHsgLy8gbm9kZS1jYW52YXMgZG9lc24ndCBoYXZlIGV2ZW50c1xuICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLl9vbkNvbnRleHRMb3N0KVxuICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgdGhpcy5fb25Db250ZXh0UmVzdG9yZWQpXG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcicsIHRoaXMuX29uQ29udGV4dENyZWF0aW9uRXJyb3IpXG4gICAgfVxuXG4gICAgc3VwZXIuc2V0Q2FudmFzKGNhbnZhcylcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSBnaXZlbiBzaGFkZXIncyBhdHRyaWJ1dGVzIHRvIHRoZSBHUFVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU2hhZGVyfSBzaGFkZXJcbiAgICovXG4gIF9zZXRBdHRyaWJ1dGVzRm9yU2hhZGVyIChzaGFkZXIpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2NvbnRleHRcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gc2hhZGVyLmdldEF0dHJpYnV0ZXMoKVxuICAgIGNvbnN0IGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHNoYWRlci5nZXRBdHRyaWJ1dGVMb2NhdGlvbnMoKVxuXG4gICAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyaWJ1dGVOYW1lKSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVMb2NhdGlvbiA9IGF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyaWJ1dGVOYW1lXVxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlidXRlTG9jYXRpb24pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZGVmYXVsdCBzaGFkZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0U2hhZGVycyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlZmF1bHQ6IG5ldyBUZXh0dXJlU2hhZGVyKHRoaXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBhdmFpbGFibGUgb2JqZWN0IHJlbmRlcmVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFJlbmRlcmVycyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNwcml0ZTogbmV3IFNwcml0ZVJlbmRlcmVyKHRoaXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIHJlbmRlcmVyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQ29udGV4dCAoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY2FudmFzXG4gICAgbGV0IGdsID0gbnVsbFxuXG4gICAgY29uc3QgY29udGV4dE9wdGlvbnMgPSB7XG4gICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFdFQlBBQ0sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGNvbnRleHRPcHRpb25zKSB8fFxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgY29udGV4dE9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gSG9vayB1cCBXZWJHTERlYnVnVXRpbHMgaWYgcHJlc2VudFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuV2ViR0xEZWJ1Z1V0aWxzICYmIHRoaXMuX29wdGlvbnMuZGVidWcpIHtcbiAgICAgIGNvbnN0IGxvZ0dMID0gKGZ1bmN0aW9uTmFtZSwgYXJncykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdnbC4nICsgZnVuY3Rpb25OYW1lICsgJygnICtcbiAgICAgICAgICB3aW5kb3cuV2ViR0xEZWJ1Z1V0aWxzLmdsRnVuY3Rpb25BcmdzVG9TdHJpbmcoZnVuY3Rpb25OYW1lLCBhcmdzKSArICcpJylcbiAgICAgIH1cbiAgICAgIGdsID0gd2luZG93LldlYkdMRGVidWdVdGlscy5tYWtlRGVidWdDb250ZXh0KGdsLCBudWxsLCBsb2dHTClcbiAgICB9XG5cbiAgICAvLyBIb29rIHVwIENvbnRleHRQZXJmb3JtYW5jZUhvb2sgaWYgZGVidWcgaXMgZW5hYmxlZFxuICAgIGlmICh0aGlzLl9vcHRpb25zLmRlYnVnKSB7XG4gICAgICBnbCA9IG5ldyBDb250ZXh0UGVyZm9ybWFuY2VIb29rKGdsKVxuICAgICAgZ2wgPSBuZXcgV2ViR0xNZW1vcnlNYW5hZ2VyKGdsKVxuICAgIH1cblxuICAgIHRoaXMuaWQgPSBnbC5pZCA9IFdlYkdMUmVuZGVyZXIuY29udGV4dElkKytcbiAgICB0aGlzLl9jb250ZXh0ID0gZ2xcbiAgICBnbC5yZW5kZXJlciA9IHRoaXNcblxuICAgIHRoaXMuX21heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpXG5cbiAgICB0aGlzLmVtaXQoJ2NvbnRleHQnLCBnbClcblxuICAgIHJldHVybiBnbFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIHJlbmRlcmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBDb250ZXh0ICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2NvbnRleHRcblxuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVClcbiAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSlcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSlcblxuICAgIHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQodGhpcyxcbiAgICAgIHRoaXMuX3dpZHRoLFxuICAgICAgdGhpcy5faGVpZ2h0LFxuICAgICAgdGhpcy5fcGl4ZWxSYXRpbyxcbiAgICAgIHRydWUpXG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQodGhpcy5fZGVmYXVsdFJlbmRlclRhcmdldClcbiAgICB0aGlzLl9nZXRNYXhQcmVjaXNpb24oKVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBtYXhpbXVtIGludCAvIGZsb2F0IHByZWNpc2lvbiBmb3IgdGhpcyBkZXZpY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRNYXhQcmVjaXNpb24gKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fY29udGV4dFxuICAgIGNvbnN0IGhpZ2hGbG9hdCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpXG4gICAgdGhpcy5fbWF4RmxvYXRQcmVjaXNpb24gPSBoaWdoRmxvYXQucHJlY2lzaW9uICE9PSAwID8gJ2hpZ2hwJyA6ICdtZWRpdW1wJ1xuXG4gICAgY29uc3QgaGlnaEludCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfSU5UKVxuICAgIHRoaXMuX21heEludFByZWNpc2lvbiA9IGhpZ2hJbnQucmFuZ2VNYXggIT09IDAgPyAnaGlnaHAnIDogJ2xvd3AnXG4gIH1cblxuICAvKipcbiAgICogUmVzaXplcyB0aGUgY29udGV4dCBhbmQgdmlldyB0byB0aGUgZ2l2ZW4gc2l6ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gcmVzaXplQ2FudmFzID0gdHJ1ZVxuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMsIHJlc2l6ZUNhbnZhcyA9IHRydWUpIHtcbiAgICBzdXBlci5yZXNpemVUbyhkaW1lbnNpb25zLCByZXNpemVDYW52YXMpXG5cbiAgICBpZiAodGhpcy5fY3VycmVudFJlbmRlclRhcmdldCkge1xuICAgICAgdGhpcy5fY3VycmVudFJlbmRlclRhcmdldC5yZXNpemVUbyhkaW1lbnNpb25zKVxuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldCB0byB0aGUgcGFzc2VkIG9uZSBhbmQgYWN0aXZhdGVzXG4gICAqIGl0IGZvciByZW5kZXJpbmdcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGFyZ2V0fSByZW5kZXJUYXJnZXRcbiAgICovXG4gIHNldFJlbmRlclRhcmdldCAocmVuZGVyVGFyZ2V0ID0gdGhpcy5fZGVmYXVsdFJlbmRlclRhcmdldCkge1xuICAgIHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRcbiAgICB0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0LmFjdGl2YXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IG9iamVjdCByZW5kZXJlciB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLk9iamVjdFJlbmRlcmVyfSBvYmplY3RSZW5kZXJlclxuICAgKi9cbiAgc2V0T2JqZWN0UmVuZGVyZXIgKG9iamVjdFJlbmRlcmVyKSB7XG4gICAgdGhpcy5fY3VycmVudE9iamVjdFJlbmRlcmVyLnN0b3AoKVxuICAgIHRoaXMuX2N1cnJlbnRPYmplY3RSZW5kZXJlciA9IG9iamVjdFJlbmRlcmVyXG4gICAgdGhpcy5fY3VycmVudE9iamVjdFJlbmRlcmVyLnN0YXJ0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBEaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0XG4gICAqL1xuICByZW5kZXIgKGRpc3BsYXlPYmplY3QpIHtcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldCh0aGlzLl9kZWZhdWx0UmVuZGVyVGFyZ2V0KVxuICAgIHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQuY2xlYXIodGhpcy5fY2xlYXJDb2xvcilcblxuICAgIC8vIFNpbmNlIHRoZSBnaXZlbiBkaXNwbGF5T2JqZWN0IGlzIHRoZSBcInJvb3RcIiBvYmplY3RcbiAgICAvLyByaWdodCBub3csIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIGR1bW15IC8gZmFrZSBvYmplY3RcbiAgICAvLyBhcyBwYXJlbnQgd2l0aCB0aGUgZGVmYXVsdCB3b3JsZCB0cmFuc2Zvcm0gYW5kIGFscGhhXG4gICAgY29uc3Qgb3JpZ2luYWxQYXJlbnQgPSBkaXNwbGF5T2JqZWN0LmdldFBhcmVudCgpXG4gICAgZGlzcGxheU9iamVjdC5zZXRQYXJlbnQodGhpcy5fZmFrZU9iamVjdClcblxuICAgIC8vIFVwZGF0ZSB0cmFuc2Zvcm1zIGFuZCByZW5kZXIgdGhpcyBvYmplY3RcbiAgICBkaXNwbGF5T2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpXG5cbiAgICAvLyBSZXNldCBwYXJlbnRcbiAgICBkaXNwbGF5T2JqZWN0LnNldFBhcmVudChvcmlnaW5hbFBhcmVudClcblxuICAgIHRoaXMucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCB0aGlzLl9kZWZhdWx0UmVuZGVyVGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIERpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0XG4gICAqL1xuICByZW5kZXJEaXNwbGF5T2JqZWN0IChkaXNwbGF5T2JqZWN0LCByZW5kZXJUYXJnZXQpIHtcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpXG4gICAgdGhpcy5fZmlsdGVyTWFuYWdlci5zZXRGaWx0ZXJTdGFjayhyZW5kZXJUYXJnZXQuZ2V0RmlsdGVyU3RhY2soKSlcbiAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcldlYkdMKHRoaXMpXG4gICAgdGhpcy5fY3VycmVudE9iamVjdFJlbmRlcmVyLmZsdXNoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNvbnRleHRcbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2NvbnRleHRcblxuICAgIGdsLmNsZWFyQ29sb3IuYXBwbHkoZ2wsIHRoaXMuX2NsZWFyQ29sb3IudG9HTENvbG9yKCkpXG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgcmVuZGVyZXIgc3RhdGUgYW5kIHJldHVybnMgdGhlIHN0YXRlIG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzYXZlICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyVGFyZ2V0OiB0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0LFxuICAgICAgb2JqZWN0UmVuZGVyZXI6IHRoaXMuX2N1cnJlbnRPYmplY3RSZW5kZXJlcixcbiAgICAgIGZpbHRlclN0YWNrOiB0aGlzLl9maWx0ZXJNYW5hZ2VyLmdldEZpbHRlclN0YWNrKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGdpdmVuIHJlbmRlcmVyIHN0YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gc2F2ZVxuICAgKi9cbiAgcmVzdG9yZSAoc2F2ZSkge1xuICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KHNhdmUucmVuZGVyVGFyZ2V0KVxuICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIuc2V0RmlsdGVyU3RhY2soc2F2ZS5maWx0ZXJTdGFjaylcbiAgICB0aGlzLl9jdXJyZW50T2JqZWN0UmVuZGVyZXIgPSBzYXZlLm9iamVjdFJlbmRlcmVyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbmQvb3IgY3JlYXRlcyBhIFdlYkdMVGV4dHVyZSBmb3IgdGhlIGdpdmVuIEJhc2VUZXh0dXJlIG9iamVjdFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVRleHR1cmV9IHRleHR1cmVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMVGV4dHVyZX1cbiAgICovXG4gIGdldE9yQ3JlYXRlR0xUZXh0dXJlICh0ZXh0dXJlKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9jb250ZXh0XG5cbiAgICBsZXQgZ2xUZXh0dXJlID0gdGV4dHVyZS5nZXRHTFRleHR1cmVGb3JSZW5kZXJlcih0aGlzKVxuICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICBnbFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICAgIHRleHR1cmUuc2V0R0xUZXh0dXJlRm9yUmVuZGVyZXIoZ2xUZXh0dXJlLCB0aGlzKVxuXG4gICAgICAvLyBIb2xkIHJlZmVyZW5jZSB0byB0ZXh0dXJlIGZvciBlYXNpZXIgZGlzcG9zYWxcbiAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godGV4dHVyZSlcbiAgICB9XG5cbiAgICByZXR1cm4gZ2xUZXh0dXJlXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gdGV4dHVyZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVRleHR1cmV9IHRleHR1cmVcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3VwbG9hZCA9IHRydWVdXG4gICAqL1xuICB1cGRhdGVUZXh0dXJlICh0ZXh0dXJlLCB1cGxvYWQgPSB0cnVlKSB7XG4gICAgbGV0IHNvdXJjZSA9IHRleHR1cmUuZ2V0U291cmNlKClcbiAgICBjb25zdCBoYXNTb3VyY2UgPSAhIXNvdXJjZVxuXG4gICAgY29uc3QgZ2wgPSB0aGlzLl9jb250ZXh0XG4gICAgY29uc3QgZ2xVbml0ID0gdGV4dHVyZS5nZXRHTFVuaXQoKVxuICAgIGNvbnN0IGdsVGV4dHVyZSA9IHRoaXMuZ2V0T3JDcmVhdGVHTFRleHR1cmUodGV4dHVyZSlcblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBnbFVuaXQpXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKVxuXG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKVxuXG5cbiAgICBpZiAodXBsb2FkICYmIGhhc1NvdXJjZSkge1xuICAgICAgaWYgKCh0eXBlb2YgSW1hZ2UgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSBpbnN0YW5jZW9mIEltYWdlKSB8fFxuICAgICAgICAgICh0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkgfHxcbiAgICAgICAgICBzb3VyY2UuY29uc3RydWN0b3IubmFtZSA9PT0gJ0NhbnZhcycgfHxcbiAgICAgICAgICAoc291cmNlLnRhZ05hbWUgJiYgc291cmNlLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUycpIHx8XG4gICAgICAgICAgKHNvdXJjZS50YWdOYW1lICYmIHNvdXJjZS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdJTUcnKSkge1xuICAgICAgICAvLyBEZWZhdWx0IGNsaWVudC1zaWRlIGJlaGF2aW9yOiBVcGxvYWQgdGhlIGBzb3VyY2VgIGltYWdlXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgc291cmNlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gY2FzZSB3ZSdyZSBvbiB0aGUgc2VydmVyIHNpZGUsIGNvbnZlcnQgYSBgbm9kZS1jYW52YXNgIEltYWdlIG9iamVjdFxuICAgICAgICAvLyBpbnRvIGEgUGl4ZWxBcnJheUltYWdlXG4gICAgICAgIGlmICh0eXBlb2YgTm9kZUNhbnZhc0ltYWdlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBOb2RlQ2FudmFzSW1hZ2UpIHtcbiAgICAgICAgICBzb3VyY2UgPSBQaXhlbEFycmF5SW1hZ2UuZnJvbU5vZGVDYW52YXNJbWFnZShzb3VyY2UpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGxvYWQgdGhlIFBpeGVsQXJyYXlJbWFnZSdzIGRhdGEgKGEgVWludDhBcnJheSlcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHNvdXJjZS5kYXRhKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXh0dXJlLmlzTWlwTWFwcGluZ0VuYWJsZWQoKSkge1xuICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRClcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgdGV4dHVyZS5nZXRHTFJlcGVhdChnbCwgJ3gnKSlcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRleHR1cmUuZ2V0R0xSZXBlYXQoZ2wsICd5JykpXG4gICAgfVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLmdldEdMRmlsdGVyKGdsLCAnbWluJykpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRleHR1cmUuZ2V0R0xGaWx0ZXIoZ2wsICdtYWcnKSlcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRNYXhEaW1lbnNpb25zICgpIHtcbiAgICAvLyBub2RlLWdsIHN1cHBvcnRcbiAgICAgIGNvbnN0IGNhbnZhcyA9IFV0aWxzLmNyZWF0ZUNhbnZhcygpXG4gICAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKVxuICAgICAgaWYgKCFnbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSlcbiAgICAgICAgY29uc3QgbG9zZUNvbnRleHRFeHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpXG4gICAgICAgIGlmIChsb3NlQ29udGV4dEV4dGVuc2lvbikge1xuICAgICAgICAgIGxvc2VDb250ZXh0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4VGV4dHVyZVNpemVcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlbmRlciB0YXJnZXRcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRhcmdldH1cbiAgICovXG4gIGdldEN1cnJlbnRSZW5kZXJUYXJnZXQgKCkgeyByZXR1cm4gdGhpcy5fY3VycmVudFJlbmRlclRhcmdldCB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgb2JqZWN0IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5PYmplY3RSZW5kZXJlcn1cbiAgICovXG4gIGdldEN1cnJlbnRPYmplY3RSZW5kZXJlciAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50T2JqZWN0UmVuZGVyZXIgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyByZW5kZXJlciBpcyBzdXBwb3J0ZWQgb24gdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCBicm93c2VyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQgKCkge1xuICAgICAgbGV0IGNhbnZhcyA9IFV0aWxzLmNyZWF0ZUNhbnZhcygpXG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcicsIHRoaXMuX29uQ29udGV4dENyZWF0aW9uRXJyb3IpXG4gICAgICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJylcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yJywgdGhpcy5fb25Db250ZXh0Q3JlYXRpb25FcnJvcilcbiAgICAgIHJldHVybiAhIWdsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBmbG9hdCBwcmVjaXNpb24gZm9yIHRoaXMgZGV2aWNlIChsb3dwL21lZGl1bXAvaGlnaHApXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1heEZsb2F0UHJlY2lzaW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4RmxvYXRQcmVjaXNpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGludCBwcmVjaXNpb24gZm9yIHRoaXMgZGV2aWNlIChsb3dwL21lZGl1bXAvaGlnaHApXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1heEludFByZWNpc2lvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heEludFByZWNpc2lvblxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgUmVuZGVyZXJcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIuZGlzcG9zZSgpXG4gICAgdGhpcy5fY3VycmVudE9iamVjdFJlbmRlcmVyLmRpc3Bvc2UoKVxuICAgIHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQuZGlzcG9zZSgpXG4gICAgdGhpcy5fdGV4dHVyZXMuZm9yRWFjaCgodGV4dHVyZSkgPT4ge1xuICAgICAgdGV4dHVyZS5kaXNwb3NlR0xUZXh0dXJlc0ZvclJlbmRlcmVyKHRoaXMpXG4gICAgfSlcbiAgICBmb3IgKGxldCBzaGFkZXIgaW4gdGhpcy5zaGFkZXJzKSB7XG4gICAgICB0aGlzLnNoYWRlcnNbc2hhZGVyXS5kaXNwb3NlKClcbiAgICAgIGRlbGV0ZSB0aGlzLnNoYWRlcnNbc2hhZGVyXVxuICAgIH1cbiAgfVxufVxuXG5XZWJHTFJlbmRlcmVyLmNvbnRleHRJZCA9IDBcbldlYkdMUmVuZGVyZXIudHlwZSA9ICdXZWJHTCdcblxuZXhwb3J0IGRlZmF1bHQgV2ViR0xSZW5kZXJlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL3JlbmRlcmVycy93ZWJnbC93ZWJnbC1yZW5kZXJlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFRleHR1cmVTaGFkZXIgZnJvbSAnLi90ZXh0dXJlLXNoYWRlcidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBUZXh0dXJlU2hhZGVyXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvc2hhZGVycy9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uL2Rpc3BsYXkvY29udGFpbmVyJ1xuaW1wb3J0IFBPVFJlbmRlcmVyIGZyb20gJy4uLy4uL2xpYi9wb3QtcmVuZGVyZXInXG5cbi8qKlxuICogQSBkcmF3YWJsZSByZWN0YW5nbGUgd2l0aCBhIHRleHR1cmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRW5naW5lLkNvbnRhaW5lclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG5jbGFzcyBTcHJpdGUgZXh0ZW5kcyBDb250YWluZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gdGV4dHVyZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRleHR1cmUpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUgPSB0aGlzLl9vblRleHR1cmVVcGRhdGUuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmVcbiAgICB0aGlzLl9zaGFkZXIgPSBudWxsXG5cbiAgICAvLyBDYWNoZWQgZGltZW5zaW9uc1xuICAgIHRoaXMuX3dpZHRoID0gMFxuICAgIHRoaXMuX2hlaWdodCA9IDBcblxuICAgIHRoaXMuX2FuY2hvciA9IG5ldyBWZWN0b3IyKDAsIDApXG5cbiAgICB0aGlzLnNldFRleHR1cmUodGV4dHVyZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgc3ByaXRlJ3MgdGV4dHVyZSBoYXMgYmVlbiB1cGRhdGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25UZXh0dXJlVXBkYXRlICgpIHtcbiAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIHRoaXMuX2xvY2FsQm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250ZW50cyBvZiB0aGlzIGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBfcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgY29uc3Qgc2F2ZSA9IHJlbmRlcmVyLnNhdmUoKVxuICAgIGlmICh0aGlzLl9zbW9vdGhEb3duc2NhbGluZykge1xuICAgICAgaWYgKCF0aGlzLl9wb3RSZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9wb3RSZW5kZXJlciA9IG5ldyBQT1RSZW5kZXJlcigpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BvdFJlbmRlcmVyLnJlbmRlcihyZW5kZXJlciwgdGhpcywgdGhpcy5fdGV4dHVyZSlcbiAgICB9XG4gICAgcmVuZGVyZXIucmVzdG9yZShzYXZlKVxuXG4gICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucmVuZGVyZXJzLnNwcml0ZSlcbiAgICByZW5kZXJlci5yZW5kZXJlcnMuc3ByaXRlLnJlbmRlcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRlbnRzIG9mIHRoaXMgY29udGFpbmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICAvLyBAVE9ETyBNb3ZlIHRoaXMgdG8gU3ByaXRlUmVuZGVyZXJcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLl93b3JsZFRyYW5zZm9ybVxuICAgIGNvbnN0IHRleHR1cmVGcmFtZSA9IHRoaXMuX3RleHR1cmUuZ2V0RnJhbWUoKVxuXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0ZXh0dXJlRnJhbWVcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gcmVuZGVyZXIuZ2V0Q3VycmVudFJlbmRlclRhcmdldCgpLmdldFBpeGVsUmF0aW8oKVxuXG4gICAgLy8gQXBwbHkgdHJhbnNmb3JtXG4gICAgY29uc3QgZHggPSAodGhpcy5fYW5jaG9yLnggKiAtd2lkdGgpIHwgMFxuICAgIGNvbnN0IGR5ID0gKHRoaXMuX2FuY2hvci55ICogLWhlaWdodCkgfCAwXG4gICAgY29uc3QgY3R4ID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgY3R4LnNldFRyYW5zZm9ybShcbiAgICAgIHRyYW5zZm9ybS5hLFxuICAgICAgdHJhbnNmb3JtLmIsXG4gICAgICB0cmFuc2Zvcm0uYyxcbiAgICAgIHRyYW5zZm9ybS5kLFxuICAgICAgdHJhbnNmb3JtLnR4ICogcGl4ZWxSYXRpbyxcbiAgICAgIHRyYW5zZm9ybS50eSAqIHBpeGVsUmF0aW9cbiAgICApXG5cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmdldFdvcmxkQWxwaGEoKVxuXG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSB0aGlzLl90ZXh0dXJlLmdldEJhc2VUZXh0dXJlKClcbiAgICBjb25zdCB0ZXh0dXJlUGl4ZWxSYXRpbyA9IGJhc2VUZXh0dXJlLmdldFBpeGVsUmF0aW8oKVxuICAgIGNvbnN0IHNvdXJjZSA9IGJhc2VUZXh0dXJlLmdldFNvdXJjZSgpXG4gICAgY3R4LmRyYXdJbWFnZShcbiAgICAgIHRoaXMuX3RleHR1cmUuZ2V0QmFzZVRleHR1cmUoKS5nZXRTb3VyY2UoKSxcblxuICAgICAgLy8gU291cmNlIHgsIHksIHdpZHRoLCBoZWlnaHRcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgKHNvdXJjZS5uYXR1cmFsV2lkdGggfHwgd2lkdGgpICogdGV4dHVyZVBpeGVsUmF0aW8sXG4gICAgICAoc291cmNlLm5hdHVyYWxIZWlnaHQgfHwgaGVpZ2h0KSAqIHRleHR1cmVQaXhlbFJhdGlvLFxuXG4gICAgICAvLyBEZXN0aW5hdGlvbiB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICBkeCAqIHBpeGVsUmF0aW8sXG4gICAgICBkeSAqIHBpeGVsUmF0aW8sXG4gICAgICB3aWR0aCAqIHBpeGVsUmF0aW8sXG4gICAgICBoZWlnaHQgKiBwaXhlbFJhdGlvXG4gICAgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFVCTElDIEFQSVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBzcHJpdGUgaXMgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSAgcG9zaXRpb25cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQXRQb3NpdGlvbiAocG9zaXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFBvc2l0aW9uID0gdGhpcy5fd29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlVG9WZWN0b3IocG9zaXRpb24pXG4gICAgY29uc3QgdGV4dHVyZUZyYW1lID0gdGhpcy5fdGV4dHVyZS5nZXRGcmFtZSgpXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0ZXh0dXJlRnJhbWVcblxuICAgIGNvbnN0IHVwcGVyTGVmdCA9IG5ldyBWZWN0b3IyKC13aWR0aCwgLWhlaWdodClcbiAgICB1cHBlckxlZnQubXVsdGlwbHkodGhpcy5fYW5jaG9yKVxuICAgIGNvbnN0IGxvd2VyUmlnaHQgPSB1cHBlckxlZnQuY2xvbmUoKVxuICAgICAgLmFkZCh3aWR0aCwgaGVpZ2h0KVxuXG4gICAgaWYgKGxvY2FsUG9zaXRpb24ueCA8IHVwcGVyTGVmdC54IHx8IGxvY2FsUG9zaXRpb24ueCA+IGxvd2VyUmlnaHQueCB8fFxuICAgICAgICBsb2NhbFBvc2l0aW9uLnkgPCB1cHBlckxlZnQueSB8fCBsb2NhbFBvc2l0aW9uLnkgPiBsb3dlclJpZ2h0LnkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9uLWdsb2JhbCBib3VuZHMgb2YgdGhpcyBEaXNwbGF5T2JqZWN0XG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfVxuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMgKCkge1xuICAgIGlmICh0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUpIHtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2xvY2FsQm91bmRzXG4gICAgICBjb25zdCB0ZXh0dXJlRnJhbWUgPSB0aGlzLl90ZXh0dXJlLmdldEZyYW1lKClcblxuICAgICAgYm91bmRzLnggPSAtdGV4dHVyZUZyYW1lLndpZHRoICogdGhpcy5fYW5jaG9yLnhcbiAgICAgIGJvdW5kcy55ID0gLXRleHR1cmVGcmFtZS5oZWlnaHQgKiB0aGlzLl9hbmNob3IueVxuICAgICAgYm91bmRzLndpZHRoID0gdGV4dHVyZUZyYW1lLndpZHRoXG4gICAgICBib3VuZHMuaGVpZ2h0ID0gdGV4dHVyZUZyYW1lLmhlaWdodFxuXG4gICAgICB0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbG9jYWxCb3VuZHMuY2xvbmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kcyBmb3IgdGhpcyBEaXNwbGF5T2JqZWN0XG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfVxuICAgKi9cbiAgZ2V0Qm91bmRzICgpIHtcbiAgICBpZiAodGhpcy5fYm91bmRzTmVlZFVwZGF0ZSkge1xuICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5fYm91bmRzXG4gICAgICBjb25zdCB0ZXh0dXJlRnJhbWUgPSB0aGlzLl90ZXh0dXJlLmdldEZyYW1lKClcblxuICAgICAgLy8gQFRPRE8gT3B0aW1pemUgdGhpcyAoaWYgbmVjZXNzYXJ5KS4gV2UgY291bGQgc2tpcCBtYXRyaXggYXBwbGljYXRpb25cbiAgICAgIC8vICAgICAgIHdoZW4gdGhlcmUncyBubyByb3RhdGlvblxuICAgICAgY29uc3Qgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLl93b3JsZFRyYW5zZm9ybVxuICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5fYW5jaG9yXG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSB3b3JsZFRyYW5zZm9ybS5yZWN0YW5nbGVUb0Nvb3JkaW5hdGVzKHRleHR1cmVGcmFtZSwgYW5jaG9yKVxuXG4gICAgICBsZXQgbWluWCA9IHBvc2l0aW9uc1swXS54XG4gICAgICBsZXQgbWluWSA9IHBvc2l0aW9uc1swXS55XG4gICAgICBsZXQgbWF4WCA9IG1pblhcbiAgICAgIGxldCBtYXhZID0gbWluWVxuXG4gICAgICBwb3NpdGlvbnMuZm9yRWFjaCgoe3gsIHl9KSA9PiB7XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KVxuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSlcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpXG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KVxuICAgICAgfSlcblxuICAgICAgYm91bmRzLnggPSBtaW5YXG4gICAgICBib3VuZHMud2lkdGggPSBNYXRoLmFicyhtYXhYIC0gbWluWClcbiAgICAgIGJvdW5kcy55ID0gbWluWVxuICAgICAgYm91bmRzLmhlaWdodCA9IE1hdGguYWJzKG1heFkgLSBtaW5ZKVxuXG4gICAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5jbG9uZSgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBHRVRURVJTIC8gU0VUVEVSU1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlRleHR1cmV9IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGdldFRleHR1cmUgKCkgeyByZXR1cm4gdGhpcy5fdGV4dHVyZSB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gdGV4dHVyZVxuICAgKi9cbiAgc2V0VGV4dHVyZSAodGV4dHVyZSkge1xuICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgIHRoaXMuX3RleHR1cmUub2ZmKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUpXG4gICAgfVxuXG4gICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmVcbiAgICBpZiAodGV4dHVyZS5nZXRCYXNlVGV4dHVyZSgpLmlzTG9hZGVkKCkpIHtcbiAgICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpXG4gICAgfVxuICAgIHRleHR1cmUub24oJ3VwZGF0ZScsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaGFkZXJcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlNoYWRlcn1cbiAgICovXG4gIGdldFNoYWRlciAoKSB7IHJldHVybiB0aGlzLl9zaGFkZXIgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaGFkZXJcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU2hhZGVyfSBzaGFkZXJcbiAgICovXG4gIHNldFNoYWRlciAoc2hhZGVyKSB7IHRoaXMuX3NoYWRlciA9IHNoYWRlciB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFdpZHRoICgpIHsgcmV0dXJuIHRoaXMuX3dpZHRoIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgd2lkdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAqL1xuICBzZXRXaWR0aCAod2lkdGgpIHtcbiAgICB0aGlzLl9zY2FsZS54ID0gd2lkdGggLyB0aGlzLl90ZXh0dXJlLmdldEZyYW1lKCkud2lkdGhcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgICB0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldEhlaWdodCAoKSB7IHJldHVybiB0aGlzLl9oZWlnaHQgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoZWlnaHRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgc2V0SGVpZ2h0IChoZWlnaHQpIHtcbiAgICB0aGlzLl9zY2FsZS55ID0gaGVpZ2h0IC8gdGhpcy5fdGV4dHVyZS5nZXRGcmFtZSgpLmhlaWdodFxuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodFxuICAgIHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgdGhpcy5fbG9jYWxCb3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgd2lkdGggYW5kIGhlaWdodCBvZiB0aGlzIHNwcml0ZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvci5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXREaW1lbnNpb25zICgpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhbmNob3JcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0QW5jaG9yICgpIHsgcmV0dXJuIHRoaXMuX2FuY2hvciB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFuY2hvclxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gYW5jaG9yXG4gICAqL1xuICBzZXRBbmNob3IgKGFuY2hvciwgeSkge1xuICAgIGlmIChhbmNob3IgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XG4gICAgICB0aGlzLl9hbmNob3IuY29weShhbmNob3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FuY2hvci5zZXQoYW5jaG9yLCB5KVxuICAgIH1cbiAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIHRoaXMuX2xvY2FsQm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgc21vb3RoIGRvd25zY2FsaW5nIGlzIGVuYWJsZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzU21vb3RoRG93bnNjYWxpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9zbW9vdGhEb3duc2NhbGluZ1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNtb290aCBkb3duc2NhbGluZyBmbGFnXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc21vb3RoRG93bnNjYWxpbmdcbiAgICovXG4gIHNldFNtb290aERvd25zY2FsaW5nIChzbW9vdGhEb3duc2NhbGluZykge1xuICAgIHRoaXMuX3Ntb290aERvd25zY2FsaW5nID0gc21vb3RoRG93bnNjYWxpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIFNwcml0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRleHR1cmUgPSBmYWxzZSAtIFNob3VsZCB0aGUgdGV4dHVyZSBiZSBkaXNwb3NlZD9cbiAgICogQHBhcmFtIHtCb29sZWFufSBiYXNlVGV4dHVyZSA9IGZhbHNlIC0gU2hvdWxkIHRoZSBiYXNlIHRleHR1cmUgYmUgZGlzcG9zZWQ/XG4gICAqL1xuICBkaXNwb3NlICh0ZXh0dXJlID0gZmFsc2UsIGJhc2VUZXh0dXJlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgdGhpcy5fdGV4dHVyZS5vZmYoJ3VwZGF0ZScsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSlcbiAgICB9XG4gICAgKHRleHR1cmUgfHwgYmFzZVRleHR1cmUpICYmIHRoaXMuX3RleHR1cmUuZGlzcG9zZShiYXNlVGV4dHVyZSlcbiAgICBpZiAodGhpcy5fcG90UmVuZGVyZXIpIHtcbiAgICAgIHRoaXMuX3BvdFJlbmRlcmVyLmRpc3Bvc2UoKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTcHJpdGVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS9zcHJpdGVzL3Nwcml0ZS5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVmVjdG9yMiwgUmVjdGFuZ2xlLCBDb25zdGFudHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuY29uc3QgeyBSZW5kZXJlclR5cGUgfSA9IENvbnN0YW50c1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi90ZXh0dXJlJ1xuaW1wb3J0IEJhc2VUZXh0dXJlIGZyb20gJy4vYmFzZS10ZXh0dXJlJ1xuaW1wb3J0IFdlYkdMUmVuZGVyVGFyZ2V0IGZyb20gJy4uL3V0aWxzL3dlYmdsLXJlbmRlci10YXJnZXQnXG5pbXBvcnQgQ2FudmFzUmVuZGVyVGFyZ2V0IGZyb20gJy4uL3V0aWxzL2NhbnZhcy1yZW5kZXItdGFyZ2V0J1xuaW1wb3J0IFdlYkdMRmlsdGVyTWFuYWdlciBmcm9tICcuLi9tYW5hZ2Vycy93ZWJnbC1maWx0ZXItbWFuYWdlcidcbmltcG9ydCBDYW52YXNGaWx0ZXJNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXJzL2NhbnZhcy1maWx0ZXItbWFuYWdlcidcblxuLyoqXG4gKiBBIHRleHR1cmUgdGhhdCB5b3UgY2FuIHJlbmRlciB0b1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG5jbGFzcyBSZW5kZXJUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVuZGVyVGV4dHVyZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt3aWR0aCA9IDEwMF1cbiAgICogQHBhcmFtICB7TnVtYmVyfSBbaGVpZ2h0ID0gMTAwXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtwaXhlbFJhdGlvID0gMV1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChyZW5kZXJlciwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCwgcGl4ZWxSYXRpbyA9IDEpIHtcbiAgICBzdXBlcihuZXcgQmFzZVRleHR1cmUoKSwgbmV3IFJlY3RhbmdsZSgwLCAwLCB3aWR0aCwgaGVpZ2h0KSlcblxuICAgIC8vIFJlbmRlclRleHR1cmUgaXMgYWx3YXlzIGxvYWRlZCFcbiAgICB0aGlzLl9sb2FkZWQgPSB0cnVlXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aFxuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodFxuICAgIHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvXG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlclxuXG4gICAgdGhpcy5fc2V0dXBGaWx0ZXJNYW5hZ2VyKClcbiAgICB0aGlzLl9zZXR1cEJ1ZmZlcigpXG5cbiAgICB0aGlzLnNldEJhc2VUZXh0dXJlKHRoaXMuX3JlbmRlclRhcmdldC5nZXRCYXNlVGV4dHVyZSgpKVxuXG4gICAgdGhpcy5fdXBkYXRlVVZzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBmaWx0ZXIgbWFuYWdlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwRmlsdGVyTWFuYWdlciAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5XRUJHTCkpIHtcbiAgICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIgPSBuZXcgV2ViR0xGaWx0ZXJNYW5hZ2VyKHRoaXMuX3JlbmRlcmVyKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fcmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLkNBTlZBUykpIHtcbiAgICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIgPSBuZXcgQ2FudmFzRmlsdGVyTWFuYWdlcih0aGlzLl9yZW5kZXJlcilcbiAgICB9XG5cbiAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyLnJlc2l6ZVRvKG5ldyBWZWN0b3IyKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGJ1ZmZlciB0aGF0IHdlJ3JlIHJlbmRlcmluZyB0b1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwQnVmZmVyICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5fcmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKSkge1xuICAgICAgdGhpcy5fc2V0dXBXZWJHTFJlbmRlclRhcmdldCgpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9yZW5kZXJlci5pc09mVHlwZShSZW5kZXJlclR5cGUuQ0FOVkFTKSkge1xuICAgICAgdGhpcy5fc2V0dXBDYW52YXNSZW5kZXJUYXJnZXQoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBXZWJHTFJlbmRlclRhcmdldCBmb3IgdGhpcyBSZW5kZXJUZXh0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBfc2V0dXBXZWJHTFJlbmRlclRhcmdldCAoKSB7XG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMuX3JlbmRlcmVyLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCB0aGlzLl9waXhlbFJhdGlvKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIENhbnZhc1JlbmRlclRhcmdldCBmb3IgdGhpcyBSZW5kZXJUZXh0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBDYW52YXNSZW5kZXJUYXJnZXQgKCkge1xuICAgIHRoaXMuX3JlbmRlclRhcmdldCA9IG5ldyBDYW52YXNSZW5kZXJUYXJnZXQoXG4gICAgICB0aGlzLl93aWR0aCxcbiAgICAgIHRoaXMuX2hlaWdodCxcbiAgICAgIHRoaXMuX3BpeGVsUmF0aW8pXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoaXMgdGV4dHVyZSdzIHJlbmRlciBidWZmZXJcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5Db2xvcn0gY29sb3JcbiAgICovXG4gIGNsZWFyIChjb2xvcikge1xuICAgIHRoaXMuX3JlbmRlclRhcmdldC5jbGVhcihjb2xvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoaXMgUmVuZGVyVGV4dHVyZSB0byB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICovXG4gIHJlc2l6ZVRvIChkaW1lbnNpb25zKSB7XG4gICAgaWYgKHRoaXMuX3dpZHRoID09PSBkaW1lbnNpb25zLnggJiYgdGhpcy5faGVpZ2h0ID09PSBkaW1lbnNpb25zLnkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3dpZHRoID0gZGltZW5zaW9ucy54XG4gICAgdGhpcy5faGVpZ2h0ID0gZGltZW5zaW9ucy55XG4gICAgdGhpcy5fZnJhbWUud2lkdGggPSBkaW1lbnNpb25zLnhcbiAgICB0aGlzLl9mcmFtZS5oZWlnaHQgPSBkaW1lbnNpb25zLnlcblxuICAgIHRoaXMuX3JlbmRlclRhcmdldC5yZXNpemVUbyhkaW1lbnNpb25zKVxuICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIucmVzaXplVG8oZGltZW5zaW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBEaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0XG4gICAqL1xuICByZW5kZXIgKGRpc3BsYXlPYmplY3QpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5fcmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKSkge1xuICAgICAgdGhpcy5fcmVuZGVyV2ViR0woZGlzcGxheU9iamVjdClcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3JlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5DQU5WQVMpKSB7XG4gICAgICB0aGlzLl9yZW5kZXJDYW52YXMoZGlzcGxheU9iamVjdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZW5kZXJUZXh0dXJlIGRvZXMgbm90IHN1cHBvcnQgcmVuZGVyaW5nIHZpYSAke3RoaXMuX3JlbmRlcmVyLmNvbnN0cnVjdG9yLm5hbWV9YClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gRGlzcGxheU9iamVjdCB1c2luZyBXZWJHTFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgX3JlbmRlcldlYkdMIChkaXNwbGF5T2JqZWN0KSB7XG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0LmFjdGl2YXRlKClcblxuICAgIGRpc3BsYXlPYmplY3QuZ2V0V29ybGRUcmFuc2Zvcm0oKS5yZXNldCgpXG4gICAgZGlzcGxheU9iamVjdC5nZXRDaGlsZHJlbigpLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC51cGRhdGVUcmFuc2Zvcm0oKVxuICAgIH0pXG5cbiAgICBjb25zdCB0ZW1wRmlsdGVyTWFuYWdlciA9IHRoaXMuX3JlbmRlcmVyLmdldEZpbHRlck1hbmFnZXIoKVxuICAgIHRoaXMuX3JlbmRlcmVyLnNldEZpbHRlck1hbmFnZXIodGhpcy5fZmlsdGVyTWFuYWdlcilcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJEaXNwbGF5T2JqZWN0KGRpc3BsYXlPYmplY3QsIHRoaXMuX3JlbmRlclRhcmdldClcbiAgICAvLyB0aGlzLl9yZW5kZXJUYXJnZXQudXBkYXRlTWlwTWFwKClcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRGaWx0ZXJNYW5hZ2VyKHRlbXBGaWx0ZXJNYW5hZ2VyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIERpc3BsYXlPYmplY3QgdXNpbmcgQ2FudmFzMkRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKGRpc3BsYXlPYmplY3QpIHtcbiAgICBkaXNwbGF5T2JqZWN0LmdldFdvcmxkVHJhbnNmb3JtKCkucmVzZXQoKVxuICAgIGRpc3BsYXlPYmplY3QuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgY2hpbGQudXBkYXRlVHJhbnNmb3JtKClcbiAgICB9KVxuXG4gICAgY29uc3QgdGVtcEZpbHRlck1hbmFnZXIgPSB0aGlzLl9yZW5kZXJlci5nZXRGaWx0ZXJNYW5hZ2VyKClcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRGaWx0ZXJNYW5hZ2VyKHRoaXMuX2ZpbHRlck1hbmFnZXIpXG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCB0aGlzLl9yZW5kZXJUYXJnZXQpXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0RmlsdGVyTWFuYWdlcih0ZW1wRmlsdGVyTWFuYWdlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZW5kZXIgdGFyZ2V0XG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlclRhcmdldH1cbiAgICovXG4gIGdldFJlbmRlclRhcmdldCAoKSB7IHJldHVybiB0aGlzLl9yZW5kZXJUYXJnZXQgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIFJlbmRlclRleHR1cmVcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHRoaXMuX3JlbmRlclRhcmdldC5kaXNwb3NlKClcbiAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyLmRpc3Bvc2UoKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlclRleHR1cmVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS90ZXh0dXJlcy9yZW5kZXItdGV4dHVyZS5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ2xlIHRoYXQgaXMgcmVuZGVyZWQgdXNpbmcgV2ViR0xcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICogQGlnbm9yZVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY2xhc3MgUXVhZCB7XG4gIGNvbnN0cnVjdG9yIChyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXJcbiAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG5cbiAgICB0aGlzLl92ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCwgMCxcbiAgICAgIDEwMCwgMCxcbiAgICAgIDEwMCwgMTAwLFxuICAgICAgMCwgMTAwXG4gICAgXSlcblxuICAgIHRoaXMuX3V2cyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCwgMCxcbiAgICAgIDEsIDAsXG4gICAgICAxLCAxLFxuICAgICAgMCwgMVxuICAgIF0pXG5cbiAgICB0aGlzLl9pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAgIDAsIDEsIDIsIDAsIDMsIDJcbiAgICBdKVxuXG4gICAgdGhpcy5fY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAxLCAxLCAxLCAxLFxuICAgICAgMSwgMSwgMSwgMSxcbiAgICAgIDEsIDEsIDEsIDEsXG4gICAgICAxLCAxLCAxLCAxXG4gICAgXSlcblxuICAgIHRoaXMuX2luaXRCdWZmZXJzKClcbiAgICB0aGlzLl91cGxvYWRCdWZmZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBzIHRoZSBnaXZlbiByZWN0YW5nbGVzIHRvIHRoZSBxdWFkXG4gICAqIEBwYXJhbSAge1JlY3RhbmdsZX0gcmVjdDFcbiAgICogQHBhcmFtICB7UmVjdGFuZ2xlfSByZWN0MlxuICAgKi9cbiAgbWFwIChyZWN0MSwgcmVjdDIpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHJlY3QyXG5cbiAgICAvLyBVcGRhdGUgdGhlIFVWc1xuICAgIC8vIFdlIGRvbid0IGhhdmUgYW55IHRyYW5zbGF0aW9uLCBzbyB0aGVzZSBmb3VyXG4gICAgLy8gdmFsdWVzIGFyZSBhbGwgd2UgbmVlZFxuICAgIHRoaXMuX3V2c1syXSA9IHJlY3QyLndpZHRoIC8gcmVjdDEud2lkdGhcbiAgICB0aGlzLl91dnNbNF0gPSB0aGlzLl91dnNbMl1cbiAgICB0aGlzLl91dnNbNV0gPSByZWN0Mi5oZWlnaHQgLyByZWN0MS5oZWlnaHRcbiAgICB0aGlzLl91dnNbN10gPSB0aGlzLl91dnNbNV1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmVydGljZXNcbiAgICB0aGlzLl92ZXJ0aWNlc1swXSA9IHhcbiAgICB0aGlzLl92ZXJ0aWNlc1sxXSA9IHlcblxuICAgIHRoaXMuX3ZlcnRpY2VzWzJdID0geCArIHJlY3QyLndpZHRoXG4gICAgdGhpcy5fdmVydGljZXNbM10gPSB5XG5cbiAgICB0aGlzLl92ZXJ0aWNlc1s0XSA9IHRoaXMuX3ZlcnRpY2VzWzJdXG4gICAgdGhpcy5fdmVydGljZXNbNV0gPSB5ICsgcmVjdDIuaGVpZ2h0XG5cbiAgICB0aGlzLl92ZXJ0aWNlc1s2XSA9IHhcbiAgICB0aGlzLl92ZXJ0aWNlc1s3XSA9IHRoaXMuX3ZlcnRpY2VzWzVdXG5cbiAgICB0aGlzLl91cGxvYWRCdWZmZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgYnVmZmVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRCdWZmZXJzICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2NvbnRleHRcblxuICAgIC8vIEluaXQgdmVydGV4IGJ1ZmZlclxuICAgIHRoaXMuX3ZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX3ZlcnRleEJ1ZmZlcilcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgKDggKyA4ICsgMTYpICogNCwgZ2wuRFlOQU1JQ19EUkFXKVxuXG4gICAgdGhpcy5faW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2luZGV4QnVmZmVyKVxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2luZGljZXMsIGdsLlNUQVRJQ19EUkFXKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIGJ1ZmZlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGxvYWRCdWZmZXJzICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2NvbnRleHRcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLl92ZXJ0ZXhCdWZmZXIpXG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMuX3ZlcnRpY2VzKVxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCA4ICogNCwgdGhpcy5fdXZzKVxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAoOCArIDgpICogNCwgdGhpcy5fY29sb3JzKVxuICB9XG5cbiAgZ2V0VmVydGV4QnVmZmVyICgpIHsgcmV0dXJuIHRoaXMuX3ZlcnRleEJ1ZmZlciB9XG4gIGdldEluZGV4QnVmZmVyICgpIHsgcmV0dXJuIHRoaXMuX2luZGV4QnVmZmVyIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHRoaXMgUXVhZCdzIGJ1ZmZlcnNcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fY29udGV4dFxuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIpXG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX2luZGV4QnVmZmVyKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS91dGlscy9xdWFkLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vZ2xvYmFscydcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBVViBjb29yZGluYXRlcyBvZiBhIHRleHR1cmVcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG5jbGFzcyBUZXh0dXJlVVZzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBUZXh0dXJlVVZzIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fdXZzID0gW1xuICAgICAgbmV3IFZlY3RvcjIoMCwgMCksXG4gICAgICBuZXcgVmVjdG9yMigxLCAwKSxcbiAgICAgIG5ldyBWZWN0b3IyKDEsIDEpLFxuICAgICAgbmV3IFZlY3RvcjIoMCwgMSlcbiAgICBdXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgVVZzIGJhc2VkIG9uIHRoZSBnaXZlbiBiYXNlZnJhbWVcbiAgICogQHBhcmFtICB7UmVjdGFuZ2xlfSBmcmFtZVxuICAgKiBAcGFyYW0gIHtSZWN0YW5nbGV9IGJhc2VGcmFtZVxuICAgKi9cbiAgdXBkYXRlIChmcmFtZSwgYmFzZUZyYW1lKSB7XG4gICAgLy8gVXBwZXIgbGVmdFxuICAgIGxldCB1diA9IHRoaXMuX3V2c1swXVxuICAgIHV2LnggPSBmcmFtZS54IC8gYmFzZUZyYW1lLndpZHRoXG4gICAgdXYueSA9IGZyYW1lLnkgLyBiYXNlRnJhbWUuaGVpZ2h0XG5cbiAgICAvLyBVcHBlciByaWdodFxuICAgIHV2ID0gdGhpcy5fdXZzWzFdXG4gICAgdXYueCA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gYmFzZUZyYW1lLndpZHRoXG4gICAgdXYueSA9IGZyYW1lLnkgLyBiYXNlRnJhbWUuaGVpZ2h0XG5cbiAgICAvLyBMb3dlciByaWdodFxuICAgIHV2ID0gdGhpcy5fdXZzWzJdXG4gICAgdXYueCA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gYmFzZUZyYW1lLndpZHRoXG4gICAgdXYueSA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIGJhc2VGcmFtZS5oZWlnaHRcblxuICAgIC8vIExvd2VyIGxlZnRcbiAgICB1diA9IHRoaXMuX3V2c1szXVxuICAgIHV2LnggPSBmcmFtZS54IC8gYmFzZUZyYW1lLndpZHRoXG4gICAgdXYueSA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIGJhc2VGcmFtZS5oZWlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVViBjb29yZGluYXRlcyBmb3IgdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0VVZzQXQgKGluZGV4KSB7IHJldHVybiB0aGlzLl91dnNbaW5kZXhdIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVVYgY29vcmRpbmF0ZXNcbiAgICogQHJldHVybiB7QXJyYXkuPFBob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMj59XG4gICAqL1xuICBnZXRVVnMgKCkgeyByZXR1cm4gdGhpcy5fdXZzIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dHVyZVVWc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL3V0aWxzL3RleHR1cmUtdXZzLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4vKipcbiAqIEEgY291cGxlIG9mIHV0aWxpdHkgZnVuY3Rpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBVdGlscyA9IHtcbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byB1bmRlZmluZWQuIE9uY2UgYVxuICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IC4uLnNvdXJjZXNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZGVmYXVsdHM6IChvYmplY3QsIC4uLnNvdXJjZXMpID0+IHtcbiAgICAvLyBTaGFsbG93IGNsb25lXG4gICAgbGV0IG5ld09iamVjdCA9IHt9XG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSBvYmplY3Rba2V5XVxuICAgIH1cblxuICAgIC8vIENsb25lIHNvdXJjZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaV1cbiAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPYmplY3Rba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBuZXdPYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqZWN0XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICogc291cmNlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gLi4uc291cmNlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBleHRlbmQ6IChvYmplY3QsIC4uLnNvdXJjZXMpID0+IHtcbiAgICAvLyBTaGFsbG93IGNsb25lXG4gICAgbGV0IG5ld09iamVjdCA9IHt9XG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSBvYmplY3Rba2V5XVxuICAgIH1cblxuICAgIC8vIEV4dGVuZCBzb3VyY2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2ldXG4gICAgICBmb3IgKGxldCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIG5ld09iamVjdFtrZXldID0gc291cmNlW2tleV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqZWN0XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVXRpbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS91dGlscy91dGlscy5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cbmltcG9ydCBTdGF0cyBmcm9tICdzdGF0cy5qcydcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGhvb2tzIGludG8gV2ViR0wgY2FsbHMgYW5kIHRyYWNrcyB0aGUgY3JlYXRpb24gYW5kXG4gKiBkaXNwb3NhbCBvZiBXZWJHTCB0ZXh0dXJlcywgc2hhZGVycyBldGMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMTWVtb3J5TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yIChjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHRcbiAgICB0aGlzLl9ob29rSW50b0NvbnRleHQoKVxuICAgIHRoaXMuX3RleHR1cmVzID0ge31cbiAgICB0aGlzLl9mcmFtZWJ1ZmZlcnMgPSB7fVxuICAgIHRoaXMuX3Byb2dyYW1zID0ge31cbiAgICB0aGlzLl9zaGFkZXJzID0ge31cbiAgICB0aGlzLl9idWZmZXJzID0ge31cbiAgICB0aGlzLl9ib3VuZFRleHR1cmUgPSBudWxsXG4gICAgdGhpcy5faWQgPSAwXG5cbiAgICB0aGlzLl9zZXR1cFN0YXRzKClcblxuICAgIHRoaXMuX3VwZGF0ZU1lbW9yeVN0YXRzID0gdGhpcy5fdXBkYXRlTWVtb3J5U3RhdHMuYmluZCh0aGlzKVxuICAgIHRoaXMuX3VwZGF0ZU1lbW9yeVN0YXRzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHN0YXRzLmpzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBTdGF0cyAoKSB7XG4gICAgdGhpcy5fc3RhdHMgPSBuZXcgU3RhdHMoKVxuICAgIHRoaXMuX3N0YXRzLnNob3dQYW5lbCgzKVxuICAgIHRoaXMuX21lbVBhbmVsID0gdGhpcy5fc3RhdHMuYWRkUGFuZWwobmV3IFN0YXRzLlBhbmVsKCdNQiBbV2ViR0xdJywgJyM0M0FERUInLCAnIzI4MjgyOCcpKVxuICAgIHRoaXMuX3RleFBhbmVsID0gdGhpcy5fc3RhdHMuYWRkUGFuZWwobmV3IFN0YXRzLlBhbmVsKCdUZXh0dXJlcycsICcjNDNBREVCJywgJyMyODI4MjgnKSlcbiAgICB0aGlzLl9idWZQYW5lbCA9IHRoaXMuX3N0YXRzLmFkZFBhbmVsKG5ldyBTdGF0cy5QYW5lbCgnQnVmZmVycycsICcjNDNBREVCJywgJyMyODI4MjgnKSlcbiAgICB0aGlzLl9mYm9QYW5lbCA9IHRoaXMuX3N0YXRzLmFkZFBhbmVsKG5ldyBTdGF0cy5QYW5lbCgnRkJPcycsICcjNDNBREVCJywgJyMyODI4MjgnKSlcbiAgICB0aGlzLl9wcmdQYW5lbCA9IHRoaXMuX3N0YXRzLmFkZFBhbmVsKG5ldyBTdGF0cy5QYW5lbCgnUHJvZ3JhbXMnLCAnIzQzQURFQicsICcjMjgyODI4JykpXG4gICAgdGhpcy5fc2hkUGFuZWwgPSB0aGlzLl9zdGF0cy5hZGRQYW5lbChuZXcgU3RhdHMuUGFuZWwoJ1NoYWRlcnMnLCAnIzQzQURFQicsICcjMjgyODI4JykpXG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3N0YXRzLmRvbSlcbiAgICB0aGlzLl9zdGF0cy5kb20uc3R5bGUudG9wID0gJzgwcHgnXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gcGFuZWxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYW5lbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVBhbmVsIChwYW5lbCkge1xuICAgIHRoaXMuX3N0YXRzLmJlZ2luKClcbiAgICBzd2l0Y2ggKHBhbmVsKSB7XG4gICAgICBjYXNlICd0ZXgnOlxuICAgICAgICB0aGlzLl90ZXhQYW5lbC51cGRhdGUodGhpcy5nZXRUZXh0dXJlc0NvdW50KCksIDUwKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnYnVmJzpcbiAgICAgICAgdGhpcy5fYnVmUGFuZWwudXBkYXRlKHRoaXMuZ2V0QnVmZmVyc0NvdW50KCksIDUwKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZmJvJzpcbiAgICAgICAgdGhpcy5fZmJvUGFuZWwudXBkYXRlKHRoaXMuZ2V0RkJPQ291bnQoKSwgNTApXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmcnOlxuICAgICAgICB0aGlzLl9wcmdQYW5lbC51cGRhdGUodGhpcy5nZXRQcm9ncmFtQ291bnQoKSwgNTApXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzaGQnOlxuICAgICAgICB0aGlzLl9zaGRQYW5lbC51cGRhdGUodGhpcy5nZXRTaGFkZXJDb3VudCgpLCA1MClcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHMuZW5kKClcbiAgfVxuXG4gIGdldFRleHR1cmVzQ291bnQgKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fdGV4dHVyZXMpLmxlbmd0aCB9XG4gIGdldEJ1ZmZlcnNDb3VudCAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9idWZmZXJzKS5sZW5ndGggfVxuICBnZXRGQk9Db3VudCAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9mcmFtZWJ1ZmZlcnMpLmxlbmd0aCB9XG4gIGdldFByb2dyYW1Db3VudCAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9wcm9ncmFtcykubGVuZ3RoIH1cbiAgZ2V0U2hhZGVyQ291bnQgKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc2hhZGVycykubGVuZ3RoIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbWVtb3J5IGNoYXJ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlTWVtb3J5U3RhdHMgKCkge1xuICAgIGNvbnN0IG1lbW9yeSA9IHRoaXMuX2dldE1lbW9yeVVzYWdlKCkgLyAxMDAwIC8gMTAwMFxuICAgIHRoaXMuX21lbVBhbmVsLnVwZGF0ZShtZW1vcnksIDQwMClcblxuICAgIHNldFRpbWVvdXQodGhpcy5fdXBkYXRlTWVtb3J5U3RhdHMsIDEwMDApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXN0aW1hdGVkIG1lbW9yeSB1c2FnZSBpbiBieXRlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TWVtb3J5VXNhZ2UgKCkge1xuICAgIGxldCBieXRlcyA9IDBcbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX3RleHR1cmVzKSB7XG4gICAgICBieXRlcyArPSB0aGlzLl90ZXh0dXJlc1tuYW1lXS5tZW1vcnlcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLl9idWZmZXJzKSB7XG4gICAgICBieXRlcyArPSB0aGlzLl9idWZmZXJzW25hbWVdLm1lbW9yeVxuICAgIH1cbiAgICByZXR1cm4gYnl0ZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgV2ViR0wgZnVuY3Rpb25zIHdpdGggc3B5IGZ1bmN0aW9ucyBpbiBvcmRlciB0byB0cmFjayB0ZXh0dXJlXG4gICAqIGNyZWF0aW9uIGFuZCBkaXNwb3NhbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hvb2tJbnRvQ29udGV4dCAoKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbnRleHQpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXMuX2NvbnRleHRba2V5XVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgIGNvbnN0IGZuID0gdGhpcy5fY29udGV4dFtrZXldXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrR0xDYWxsKGZuLCBrZXksIGFyZ3MpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX21ha2VQcm9wZXJ0eVdyYXBwZXIoa2V5KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBnZXR0ZXIgYW5kIHNldHRlciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5XG4gICAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlUHJvcGVydHlXcmFwcGVyIChwcm9wZXJ0eSkge1xuICAgIGNvbnN0IGluc2VjdXJlUHJvcGVydGllcyA9IFtcbiAgICAgICdfY29udGV4dCdcbiAgICBdXG4gICAgaWYgKGluc2VjdXJlUHJvcGVydGllcy5pbmRleE9mKHByb3BlcnR5KSAhPT0gLTEpIHJldHVyblxuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHRcblxuICAgIHRoaXMuX19kZWZpbmVHZXR0ZXJfXyhwcm9wZXJ0eSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNvbnRleHRbcHJvcGVydHldXG4gICAgfSlcblxuICAgIHRoaXMuX19kZWZpbmVTZXR0ZXJfXyhwcm9wZXJ0eSwgKHZhbHVlKSA9PiB7XG4gICAgICBjb250ZXh0W3Byb3BlcnR5XSA9IHZhbHVlXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgV2ViR0wgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZ1bmN0aW9uTmFtZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gYXJnc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyYWNrR0xDYWxsIChmbiwgZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVGdW5jdGlvbnMgPSBbXG4gICAgICAndGV4SW1hZ2UyRCcsXG4gICAgICAnYmluZFRleHR1cmUnLFxuICAgICAgJ2NyZWF0ZVRleHR1cmUnLFxuICAgICAgJ2RlbGV0ZVRleHR1cmUnLFxuICAgICAgJ2NyZWF0ZUJ1ZmZlcicsXG4gICAgICAnYmluZEJ1ZmZlcicsXG4gICAgICAnYnVmZmVyRGF0YScsXG4gICAgICAnZGVsZXRlQnVmZmVyJyxcbiAgICAgICdjcmVhdGVGcmFtZWJ1ZmZlcicsXG4gICAgICAnZGVsZXRlRnJhbWVidWZmZXInLFxuICAgICAgJ2NyZWF0ZVByb2dyYW0nLFxuICAgICAgJ2RlbGV0ZVByb2dyYW0nLFxuICAgICAgJ2NyZWF0ZVNoYWRlcicsXG4gICAgICAnZGVsZXRlU2hhZGVyJ1xuICAgIF1cblxuICAgIGlmIChvdmVycmlkZUZ1bmN0aW9ucy5pbmRleE9mKGZ1bmN0aW9uTmFtZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1tgXyR7ZnVuY3Rpb25OYW1lfWBdKGFyZ3MpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMuX2NvbnRleHQsIGFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBgY3JlYXRlUHJvZ3JhbWAgaXMgY2FsbGVkIG9uIHRoZSBXZWJHTCBjb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlUHJvZ3JhbSAoKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlUHJvZ3JhbSgpXG4gICAgcHJvZ3JhbS5fd21tSWQgPSB0aGlzLl9pZCsrXG5cbiAgICB0aGlzLl9wcm9ncmFtc1twcm9ncmFtLl93bW1JZF0gPSBwcm9ncmFtXG5cbiAgICB0aGlzLl91cGRhdGVQYW5lbCgncHJnJylcblxuICAgIHJldHVybiBwcm9ncmFtXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgZ2l2ZW4gcHJvZ3JhbVxuICAgKiBAcGFyYW0gIHtXZWJHTFByb2dyYW19IHByb2dyYW1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWxldGVQcm9ncmFtIChbcHJvZ3JhbV0pIHtcbiAgICBpZiAoIXByb2dyYW0gfHwgIXRoaXMuX3Byb2dyYW1zW3Byb2dyYW0uX3dtbUlkXSkgcmV0dXJuXG5cbiAgICBkZWxldGUgdGhpcy5fcHJvZ3JhbXNbcHJvZ3JhbS5fd21tSWRdXG4gICAgdGhpcy5fY29udGV4dC5kZWxldGVQcm9ncmFtKHByb2dyYW0pXG5cbiAgICB0aGlzLl91cGRhdGVQYW5lbCgncHJnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGBjcmVhdGVTaGFkZXJgIGlzIGNhbGxlZCBvbiB0aGUgV2ViR0wgY29udGV4dFxuICAgKiBAcGFyYW0ge0dMZW51bX0gdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVNoYWRlciAoW3R5cGVdKSB7XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVTaGFkZXIodHlwZSlcbiAgICBzaGFkZXIuX3dtbUlkID0gdGhpcy5faWQrK1xuXG4gICAgdGhpcy5fc2hhZGVyc1tzaGFkZXIuX3dtbUlkXSA9IHNoYWRlclxuXG4gICAgdGhpcy5fdXBkYXRlUGFuZWwoJ3NoZCcpXG5cbiAgICByZXR1cm4gc2hhZGVyXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgZ2l2ZW4gc2hhZGVyXG4gICAqIEBwYXJhbSAge1dlYkdMU2hhZGVyfSBzaGFkZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWxldGVTaGFkZXIgKFtzaGFkZXJdKSB7XG4gICAgaWYgKCFzaGFkZXIgfHwgIXRoaXMuX3NoYWRlcnNbc2hhZGVyLl93bW1JZF0pIHJldHVyblxuXG4gICAgZGVsZXRlIHRoaXMuX3NoYWRlcnNbc2hhZGVyLl93bW1JZF1cbiAgICB0aGlzLl9jb250ZXh0LmRlbGV0ZVNoYWRlcihzaGFkZXIpXG5cbiAgICB0aGlzLl91cGRhdGVQYW5lbCgnc2hkJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGBjcmVhdGVGcmFtZWJ1ZmZlcmAgaXMgY2FsbGVkIG9uIHRoZSBXZWJHTCBjb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlRnJhbWVidWZmZXIgKCkge1xuICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcigpXG4gICAgZnJhbWVidWZmZXIuX3dtbUlkID0gdGhpcy5faWQrK1xuXG4gICAgdGhpcy5fZnJhbWVidWZmZXJzW2ZyYW1lYnVmZmVyLl93bW1JZF0gPSBmcmFtZWJ1ZmZlclxuXG4gICAgdGhpcy5fdXBkYXRlUGFuZWwoJ2ZibycpXG5cbiAgICByZXR1cm4gZnJhbWVidWZmZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBnaXZlbiBmcmFtZWJ1ZmZlclxuICAgKiBAcGFyYW0gIHtXZWJHTEZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlbGV0ZUZyYW1lYnVmZmVyIChbZnJhbWVidWZmZXJdKSB7XG4gICAgaWYgKCFmcmFtZWJ1ZmZlciB8fCAhdGhpcy5fZnJhbWVidWZmZXJzW2ZyYW1lYnVmZmVyLl93bW1JZF0pIHJldHVyblxuXG4gICAgZGVsZXRlIHRoaXMuX2ZyYW1lYnVmZmVyc1tmcmFtZWJ1ZmZlci5fd21tSWRdXG4gICAgdGhpcy5fY29udGV4dC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcilcblxuICAgIHRoaXMuX3VwZGF0ZVBhbmVsKCdmYm8nKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYGNyZWF0ZUJ1ZmZlcmAgaXMgY2FsbGVkIG9uIHRoZSBXZWJHTCBjb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQnVmZmVyICgpIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUJ1ZmZlcigpXG4gICAgYnVmZmVyLl93bW1JZCA9IHRoaXMuX2lkKytcblxuICAgIHRoaXMuX2J1ZmZlcnNbYnVmZmVyLl93bW1JZF0gPSB7XG4gICAgICBidWZmZXIsXG4gICAgICBtZW1vcnk6IDBcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVQYW5lbCgnYnVmJylcblxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgZ2l2ZW4gYnVmZmVyXG4gICAqIEBwYXJhbSAge0dMZW51bX0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge1dlYkdMQnVmZmVyfSBidWZmZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9iaW5kQnVmZmVyIChbdGFyZ2V0LCBidWZmZXJdKSB7XG4gICAgdGhpcy5fY29udGV4dC5iaW5kQnVmZmVyKHRhcmdldCwgYnVmZmVyKVxuXG4gICAgdGhpcy5fYm91bmRCdWZmZXIgPSBidWZmZXIuX3dtbUlkXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGJ1ZmZlcidzIGRhdGEgc3RvcmVcbiAgICogQHBhcmFtICB7R0xlbnVtfSB0YXJnZXRcbiAgICogQHBhcmFtICB7R0xzaXplaXB0cnxBcnJheUJ1ZmZlcn0gc2l6ZU9yRGF0YVxuICAgKiBAcGFyYW0gIHtHTGVudW19IHVzYWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnVmZmVyRGF0YSAoW3RhcmdldCwgc2l6ZU9yRGF0YSwgdXNhZ2VdKSB7XG4gICAgdGhpcy5fY29udGV4dC5idWZmZXJEYXRhKHRhcmdldCwgc2l6ZU9yRGF0YSwgdXNhZ2UpXG5cbiAgICBsZXQgc2l6ZVxuICAgIGlmICh0eXBlb2Ygc2l6ZU9yRGF0YSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNpemUgPSBzaXplT3JEYXRhIC8vIHNpemVcbiAgICB9IGVsc2UgaWYgKCdieXRlTGVuZ3RoJyBpbiBzaXplT3JEYXRhKSB7XG4gICAgICBzaXplID0gc2l6ZU9yRGF0YS5ieXRlTGVuZ3RoIC8vIGRhdGFcbiAgICB9IGVsc2UgaWYgKCdsZW5ndGgnIGluIHNpemVPckRhdGEpIHtcbiAgICAgIHNpemUgPSBzaXplT3JEYXRhLmxlbmd0aCAvLyBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5fYnVmZmVyc1t0aGlzLl9ib3VuZEJ1ZmZlcl0ubWVtb3J5ID0gc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIGdpdmVuIGJ1ZmZlclxuICAgKiBAcGFyYW0gIHtXZWJHTEJ1ZmZlcn0gYnVmZmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVsZXRlQnVmZmVyIChbYnVmZmVyXSkge1xuICAgIGlmICghYnVmZmVyIHx8ICF0aGlzLl9idWZmZXJzW2J1ZmZlci5fd21tSWRdKSByZXR1cm5cblxuICAgIGRlbGV0ZSB0aGlzLl9idWZmZXJzW2J1ZmZlci5fd21tSWRdXG4gICAgdGhpcy5fY29udGV4dC5kZWxldGVCdWZmZXIoYnVmZmVyKVxuXG4gICAgdGhpcy5fdXBkYXRlUGFuZWwoJ2J1ZicpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBgY3JlYXRlVGV4dHVyZWAgaXMgY2FsbGVkIG9uIHRoZSBXZWJHTCBjb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlVGV4dHVyZSAoKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlVGV4dHVyZSgpXG4gICAgdGV4dHVyZS5fd21tSWQgPSB0aGlzLl9pZCsrXG5cbiAgICBjb25zb2xlLmxvZygnY3JlYXRlZCcsIHRleHR1cmUuX3dtbUlkKVxuXG4gICAgdGhpcy5fdGV4dHVyZXNbdGV4dHVyZS5fd21tSWRdID0ge1xuICAgICAgdGV4dHVyZSxcbiAgICAgIG1lbW9yeTogMFxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVBhbmVsKCd0ZXgnKVxuXG4gICAgcmV0dXJuIHRleHR1cmVcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBnaXZlbiB0ZXh0dXJlXG4gICAqIEBwYXJhbSAge1dlYkdMVGV4dHVyZX0gdGV4dHVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlbGV0ZVRleHR1cmUgKFt0ZXh0dXJlXSkge1xuICAgIGlmICghdGV4dHVyZSB8fCAhdGhpcy5fdGV4dHVyZXNbdGV4dHVyZS5fd21tSWRdKSByZXR1cm5cblxuICAgIGRlbGV0ZSB0aGlzLl90ZXh0dXJlc1t0ZXh0dXJlLl93bW1JZF1cbiAgICB0aGlzLl9jb250ZXh0LmRlbGV0ZVRleHR1cmUodGV4dHVyZSlcblxuICAgIHRoaXMuX3VwZGF0ZVBhbmVsKCd0ZXgnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYGJpbmRUZXh0dXJlYCBpcyBjYWxsZWQgb24gdGhlIFdlYkdMIGNvbnRleHRcbiAgICogQHBhcmFtICB7R0xlbnVtfSB0YXJnZXRcbiAgICogQHBhcmFtICB7V2ViR0xUZXh0dXJlfSB0ZXh0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYmluZFRleHR1cmUgKFt0YXJnZXQsIHRleHR1cmVdKSB7XG4gICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleHR1cmUpXG5cbiAgICB0aGlzLl9ib3VuZFRleHR1cmUgPSB0ZXh0dXJlLl93bW1JZFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYHRleEltYWdlMkRgIGlzIGNhbGxlZCBvbiB0aGUgV2ViR0wgY29udGV4dFxuICAgKiBAcGFyYW0gIHtHTEVudW19IHRhcmdldFxuICAgKiBAcGFyYW0gIHtHTGludH0gbGV2ZWxcbiAgICogQHBhcmFtICB7R0xpbnR9IGludGVybmFsZm9ybWF0XG4gICAqIEBwYXJhbSAge0dMc2l6ZWl9IHdpZHRoXG4gICAqIEBwYXJhbSAge0dsc2l6ZWl9IGhlaWdodFxuICAgKiBAcGFyYW0gIHtHTGludH0gYm9yZGVyXG4gICAqIEBwYXJhbSAge0dMZW51bX0gZm9ybWF0XG4gICAqIEBwYXJhbSAge0dMZW51bX0gdHlwZVxuICAgKiBAcGFyYW0gIHsqfSBwaXhlbHNcbiAgICovXG4gIF90ZXhJbWFnZTJEIChhcmdzKSB7XG4gICAgbGV0IFssICwgaW50ZXJuYWxmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGJvcmRlciwgLCAsIHBpeGVsc10gPSBhcmdzXG4gICAgaWYgKHR5cGVvZiBwaXhlbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwaXhlbHMgPSBib3JkZXJcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGV4dHVyZVxuICAgIHRoaXMuX2NvbnRleHQudGV4SW1hZ2UyRC5hcHBseSh0aGlzLl9jb250ZXh0LCBhcmdzKVxuXG4gICAgY29uc3QgYnl0ZUNvdW50ID0gdGhpcy5fY2FsY3VsYXRlQnl0ZUNvdW50Rm9yVGV4dHVyZShpbnRlcm5hbGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgcGl4ZWxzKVxuICAgIHRoaXMuX3RleHR1cmVzW3RoaXMuX2JvdW5kVGV4dHVyZV0ubWVtb3J5ID0gYnl0ZUNvdW50XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBjb3VudCBmb3IgdGhlIGdpdmVuIHRleHR1cmUgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtICB7R0xpbnR9IGZvcm1hdFxuICAgKiBAcGFyYW0gIHtHTHNpemVpfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtHTHNpemVpfSBoZWlnaHRcbiAgICogQHBhcmFtICB7Kn0gcGl4ZWxzXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWxjdWxhdGVCeXRlQ291bnRGb3JUZXh0dXJlIChmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIHBpeGVscykge1xuICAgIGlmIChwaXhlbHMgIT09IG51bGwpIHtcbiAgICAgIGlmICgnd2lkdGgnIGluIHBpeGVscykge1xuICAgICAgICB3aWR0aCA9IHBpeGVscy53aWR0aFxuICAgICAgICBoZWlnaHQgPSBwaXhlbHMuaGVpZ2h0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGl4ZWxzLmxlbmd0aFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBieXRlc1BlclBpeGVsID0gMVxuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlIHRoaXMuX2NvbnRleHQuQUxQSEE6XG4gICAgICAgIGJ5dGVzUGVyUGl4ZWwgPSAxXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIHRoaXMuX2NvbnRleHQuUkdCOlxuICAgICAgICBieXRlc1BlclBpeGVsID0gM1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSB0aGlzLl9jb250ZXh0LlJHQkE6XG4gICAgICAgIGJ5dGVzUGVyUGl4ZWwgPSA0XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoICogaGVpZ2h0ICogYnl0ZXNQZXJQaXhlbFxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvdXRpbHMvd2ViZ2wvd2ViZ2wtbWVtb3J5LW1hbmFnZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogQW4gQXJyYXlTdHJlYW0gcHJvdmlkZXMgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIGEgYnl0ZSBhcnJheVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqIEBpZ25vcmVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIEFycmF5U3RyZWFtIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQXJyYXlTdHJlYW1cbiAgICogQHBhcmFtICB7QXJyYXl9IGJ1ZlxuICAgKi9cbiAgY29uc3RydWN0b3IgKGJ1Zikge1xuICAgIHRoaXMuX2hlYWQgPSAwXG4gICAgdGhpcy5fYnVmID0gYnVmXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZvbGxvd2luZyA4IGJpdCBpbnRlZ2VyXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHBlZWtJbnQ4ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVmW3RoaXMuX2hlYWRdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZvbGxvd2luZyAxNiBiaXQgaW50ZWdlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbbGl0dGxlRW5kaWFuID0gZmFsc2VdXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHBlZWtJbnQxNiAobGl0dGxlRW5kaWFuID0gZmFsc2UpIHtcbiAgICBjb25zdCBhID0gdGhpcy5fYnVmW3RoaXMuX2hlYWRdXG4gICAgY29uc3QgYiA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMV1cbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgcmV0dXJuIChhIDw8IDgpICsgYlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGIgPDwgOCkgKyBhXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmb2xsb3dpbmcgMjQgYml0IGludGVnZXJcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2xpdHRsZUVuZGlhbiA9IGZhbHNlXVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBwZWVrSW50MjQgKGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkXVxuICAgIGNvbnN0IGIgPSB0aGlzLl9idWZbdGhpcy5faGVhZCArIDFdXG4gICAgY29uc3QgYyA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMl1cbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgcmV0dXJuIChhIDw8IDE2KSArIChiIDw8IDgpICsgY1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGMgPDwgMTYpICsgKGIgPDwgOCkgKyBhXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmb2xsb3dpbmcgMzIgYml0IGludGVnZXJcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2xpdHRsZUVuZGlhbiA9IGZhbHNlXVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBwZWVrSW50MzIgKGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkXVxuICAgIGNvbnN0IGIgPSB0aGlzLl9idWZbdGhpcy5faGVhZCArIDFdXG4gICAgY29uc3QgYyA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMl1cbiAgICBjb25zdCBkID0gdGhpcy5fYnVmW3RoaXMuX2hlYWQgKyAzXVxuICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG4gICAgICByZXR1cm4gKGEgPDwgMzIpICsgKGIgPDwgMTYpICsgKGMgPDwgOCkgKyBkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZCA8PCAzMikgKyAoYyA8PCAxNikgKyAoYiA8PCA4KSArIGFcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBnaXZlbiAxNiBiaXQgaW50ZWdlciBhdCB0aGUgY3VycmVudCBoZWFkIHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge051bWJlcn0gbnVtXG4gICAqL1xuICB3cml0ZUludDE2IChudW0pIHtcbiAgICB0aGlzLl9idWZbdGhpcy5faGVhZF0gPSBudW0gPj4gOCAvLyB1cHBlclxuICAgIHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMV0gPSBudW0gJiAweGZmIC8vIGxvd2VyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZvbGxvd2luZyA4IGJpdCBpbnRlZ2VyIGFuZCBtb3ZlcyB0aGUgaGVhZCBieSAxIGJ5dGVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgcmVhZEludDggKCkge1xuICAgIGNvbnN0IG51bSA9IHRoaXMucGVla0ludDgoKVxuICAgIHRoaXMuX2hlYWQgKz0gMVxuICAgIHJldHVybiBudW1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZm9sbG93aW5nIDE2IGJpdCBpbnRlZ2VyIGFuZCBtb3ZlcyB0aGUgaGVhZCBieSAyIGJ5dGVzXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtsaXR0bGVFbmRpYW4gPSBmYWxzZV1cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgcmVhZEludDE2IChsaXR0bGVFbmRpYW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IG51bSA9IHRoaXMucGVla0ludDE2KGxpdHRsZUVuZGlhbilcbiAgICB0aGlzLl9oZWFkICs9IDJcbiAgICByZXR1cm4gbnVtXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZvbGxvd2luZyAyNCBiaXQgaW50ZWdlciBhbmQgbW92ZXMgdGhlIGhlYWQgYnkgMyBieXRlc1xuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbbGl0dGxlRW5kaWFuID0gZmFsc2VdXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHJlYWRJbnQyNCAobGl0dGxlRW5kaWFuID0gZmFsc2UpIHtcbiAgICBjb25zdCBudW0gPSB0aGlzLnBlZWtJbnQyNChsaXR0bGVFbmRpYW4pXG4gICAgdGhpcy5faGVhZCArPSAzXG4gICAgcmV0dXJuIG51bVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmb2xsb3dpbmcgMzIgYml0IGludGVnZXIgYW5kIG1vdmVzIHRoZSBoZWFkIGJ5IDQgYnl0ZXNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2xpdHRsZUVuZGlhbiA9IGZhbHNlXVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICByZWFkSW50MzIgKGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgbnVtID0gdGhpcy5wZWVrSW50MzIobGl0dGxlRW5kaWFuKVxuICAgIHRoaXMuX2hlYWQgKz0gNFxuICAgIHJldHVybiBudW1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBsZW5ndGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgcmVhZFN0cmluZyAobGVuZ3RoKSB7XG4gICAgbGV0IHN0ciA9ICcnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gdGhpcy5yZWFkSW50OCgpXG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyYWN0ZXIpXG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGhlYWQgcG9zaXRpb25cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0SGVhZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoZWFkIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWFkXG4gICAqL1xuICBzZXRIZWFkIChoZWFkKSB7XG4gICAgdGhpcy5faGVhZCA9IGhlYWRcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBcnJheVN0cmVhbVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL2FycmF5LXN0cmVhbS5qcyIsIi8qIGdsb2JhbCBJbWFnZSwgV0VCUEFDSyAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZW5kZXJUeXBlLCBJbWFnZUZvcm1hdCwgUmVuZGVyZXJUeXBlLCBPcHRpb25UeXBlIH0gZnJvbSAnLi4vY29uc3RhbnRzJ1xuaW1wb3J0IEVuZ2luZSBmcm9tICcuLi9lbmdpbmUnXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscydcbmltcG9ydCBFeGlmIGZyb20gJy4vZXhpZidcbmltcG9ydCBOb2RlR0xFeHBvcnRlciBmcm9tICcuL25vZGUtZ2wtZXhwb3J0ZXInXG5pbXBvcnQgQ29uZmlndXJhYmxlIGZyb20gJy4vY29uZmlndXJhYmxlJ1xuXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgUGhvdG9FZGl0b3JTREsuSW1hZ2VFeHBvcnRlclxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgSW1hZ2VFeHBvcnRlciBleHRlbmRzIENvbmZpZ3VyYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChzZGssIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgdGhpcy5fc2RrID0gc2RrXG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0cyB0aGUgaW1hZ2UgZnJvbSB0aGUgZ2l2ZW4gY2FudmFzIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGV4cG9ydCAoKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9zZGsuZ2V0UmVuZGVyZXIoKVxuICAgIGNvbnN0IHsgcmVuZGVyVHlwZSwgaW1hZ2VGb3JtYXQsIHF1YWxpdHkgfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2V0dGluZ3MoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlcGFyZVNESygpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKHRleHR1cmUpID0+IHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpXG4gICAgICAgIGlmIChyZW5kZXJlci5pc09mVHlwZShSZW5kZXJlclR5cGUuV0VCR0wpKSB7XG4gICAgICAgICAgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzRnJvbVRleHR1cmUodGV4dHVyZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHRcbiAgICAgICAgaWYgKHJlbmRlclR5cGUgPT09IFJlbmRlclR5cGUuSU1BR0UgfHxcbiAgICAgICAgICAgIHJlbmRlclR5cGUgPT09IFJlbmRlclR5cGUuREFUQVVSTCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gUXVhbGl0eSBub3Qgc3VwcG9ydGVkIGluIG5vZGUgZW52aXJvbm1lbnQgLyBub2RlLWNhbnZhc1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FudmFzLnRvRGF0YVVSTChpbWFnZUZvcm1hdClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FudmFzLnRvRGF0YVVSTChpbWFnZUZvcm1hdCwgcXVhbGl0eSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXaGVuIGltYWdlJ3MgYHNyY2AgYXR0cmlidXRlIGlzIGEganBlZyBkYXRhIHVybCwgd2UgY2FuIHJlc3RvcmVcbiAgICAgICAgICAvLyB0aGUgZXhpZiBpbmZvcm1hdGlvblxuICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5fc2RrLmdldEltYWdlKClcbiAgICAgICAgICBpZiAoRXhpZi5pc0pQRUcoaW1hZ2Uuc3JjKSAmJiBFeGlmLmlzSlBFRyhyZXN1bHQpKSB7XG4gICAgICAgICAgICBjb25zdCBleGlmID0gdGhpcy5fc2RrLmdldEV4aWYoKVxuICAgICAgICAgICAgaWYgKGV4aWYpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZXhpZi5yZXN0b3JlRXhpZlRhZ3MocmVzdWx0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJlci5pc09mVHlwZShSZW5kZXJlclR5cGUuV0VCR0wpICYmXG4gICAgICAgICAgKHR5cGVvZiBDYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIENhbnZhcykpIHtcbiAgICAgICAgICBOb2RlR0xFeHBvcnRlci5yZW5kZXJDb250ZXh0VG9DYW52YXMocmVuZGVyZXIuZ2V0Q29udGV4dCgpLCBjYW52YXMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyVHlwZSA9PT0gUmVuZGVyVHlwZS5JTUFHRSkge1xuICAgICAgICAgIGxldCBvdXRwdXRJbWFnZVxuXG5cbiAgICAgICAgICBpZiAodHlwZW9mIFdFQlBBQ0sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvdXRwdXRJbWFnZSA9IG5ldyBJbWFnZSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3V0cHV0SW1hZ2Uuc3JjID0gcmVzdWx0XG4gICAgICAgICAgcmV0dXJuIG91dHB1dEltYWdlXG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVyVHlwZSA9PT0gUmVuZGVyVHlwZS5EQVRBVVJMKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlclR5cGUgPT09IFJlbmRlclR5cGUuQlVGRkVSKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbnZhcy50b0J1ZmZlcigpXG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVyVHlwZSA9PT0gUmVuZGVyVHlwZS5NU0JMT0IpIHtcbiAgICAgICAgICByZXR1cm4gY2FudmFzLm1zVG9CbG9iKClcbiAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJUeXBlID09PSBSZW5kZXJUeXBlLkJMT0IpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKGJsb2IpXG4gICAgICAgICAgICB9LCBpbWFnZUZvcm1hdCwgcXVhbGl0eSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzdG9yZVNESygpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gcmVzdWx0KVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgU0RLIGZvciBleHBvcnRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcmVwYXJlU0RLICgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3Nkay5nZXRSZW5kZXJlcigpXG5cbiAgICB0aGlzLl9zZGtTZXR0aW5ncyA9IHtcbiAgICAgIGRpbWVuc2lvbnM6IHJlbmRlcmVyLmdldERpbWVuc2lvbnMoKS5jbG9uZSgpLFxuICAgICAgdGV4dHVyZVF1YWxpdHk6IHRoaXMuX3Nkay5nZXRUZXh0dXJlUXVhbGl0eSgpLFxuICAgICAgcGl4ZWxSYXRpbzogdGhpcy5fc2RrLmdldFBpeGVsUmF0aW8oKSxcbiAgICAgIHJlbmRlck1vZGU6IHRoaXMuX3Nkay5nZXRSZW5kZXJNb2RlKClcbiAgICB9XG5cbiAgICB0aGlzLl9zZGsuc2V0UmVuZGVyTW9kZSgnZXhwb3J0JylcbiAgICB0aGlzLl9zZGsuc2V0VGV4dHVyZVF1YWxpdHkoMSlcblxuICAgIGNvbnN0IHJlc2l6ZUNhbnZhcyA9IHJlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5DQU5WQVMpXG4gICAgcmVuZGVyZXIuc2V0UGl4ZWxSYXRpbygxKVxuICAgIHJlbmRlcmVyLnJlc2l6ZVRvKHRoaXMuX3Nkay5nZXRGaW5hbERpbWVuc2lvbnMoKSwgcmVzaXplQ2FudmFzKVxuXG4gICAgdGhpcy5fc2RrLnNldEFsbE9wZXJhdGlvbnNUb0RpcnR5KHRydWUpXG5cbiAgICBjb25zdCBzdGFjayA9IHRoaXMuX3Nkay5nZXRPcGVyYXRpb25zU3RhY2soKVxuICAgIHN0YWNrXG4gICAgICAuZm9yRWFjaCgob3BlcmF0aW9uKSA9PiB7XG4gICAgICAgIG9wZXJhdGlvbi5kaXNwb3NlUmVuZGVyVGV4dHVyZXMoKVxuICAgICAgfSlcbiAgICBzdGFjay5kaXNhYmxlQ2FjaGUoKVxuXG4gICAgcmV0dXJuIHRoaXMuX3Nkay5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmVzIHRoZSBwcmV2aW91cyBTREsgb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc3RvcmVTREsgKCkge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5fc2RrLmdldE9wZXJhdGlvbnNTdGFjaygpXG4gICAgc3RhY2suZW5hYmxlQ2FjaGUoKVxuXG4gICAgdGhpcy5fc2RrLnNldFJlbmRlck1vZGUodGhpcy5fc2RrU2V0dGluZ3MucmVuZGVyTW9kZSlcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3Nkay5nZXRSZW5kZXJlcigpXG5cbiAgICBjb25zdCByZXNpemVDYW52YXMgPSByZW5kZXJlci5pc09mVHlwZShSZW5kZXJlclR5cGUuQ0FOVkFTKVxuICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8odGhpcy5fc2RrU2V0dGluZ3MucGl4ZWxSYXRpbylcbiAgICByZW5kZXJlci5yZXNpemVUbyh0aGlzLl9zZGtTZXR0aW5ncy5kaW1lbnNpb25zLCByZXNpemVDYW52YXMpXG5cbiAgICB0aGlzLl9zZGsuc2V0VGV4dHVyZVF1YWxpdHkodGhpcy5fc2RrU2V0dGluZ3MucGl4ZWxSYXRpbylcbiAgICB0aGlzLl9zZGsuc2V0QWxsT3BlcmF0aW9uc1RvRGlydHkodHJ1ZSlcbiAgICByZXR1cm4gdGhpcy5fc2RrLnJlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhbnZhcyBmcm9tIHRoZSBnaXZlbiBUZXh0dXJlIGJ5IGF0dGFjaGluZyBpdCB0byBhbiBGQk8gYW5kIHVzaW5nXG4gICAqIGdsLnJlYWRQaXhlbHMoKSB0byByZWFkIHRoZSBwaXhlbHMuIEl0IHRoZW4gd3JpdGVzIHRoZSBwaXhlbCBkYXRhIHRvIGEgbmV3XG4gICAqIDJEIChub3QgaGFyZHdhcmUtYWNjZWxlcmF0ZWQpIGNhbnZhcyBhbmQgY2FsbHMgLnRvRGF0YVVSTCgpIG9uIGl0LlxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gdGV4dHVyZVxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVDYW52YXNGcm9tVGV4dHVyZSAodGV4dHVyZSkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fc2RrLmdldFJlbmRlcmVyKClcbiAgICBjb25zdCBmaW5hbERpbWVuc2lvbnMgPSB0aGlzLl9zZGsuZ2V0RmluYWxEaW1lbnNpb25zKClcblxuICAgIGNvbnN0IGdsID0gdGhpcy5fc2RrLmdldFJlbmRlcmVyKCkuZ2V0Q29udGV4dCgpXG5cbiAgICAvLyBDcmVhdGUgdGVtcG9yYXJ5IGZyYW1lYnVmZmVyXG4gICAgY29uc3QgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKVxuXG4gICAgLy8gQXR0YWNoIG91dHB1dCB0ZXh0dXJlIHRvIEZCT1xuICAgIGNvbnN0IGdsVGV4dHVyZSA9IHRleHR1cmUuZ2V0QmFzZVRleHR1cmUoKS5nZXRHTFRleHR1cmVGb3JSZW5kZXJlcihyZW5kZXJlcilcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSwgMClcblxuICAgIC8vIFJlYWQgcGl4ZWxzIGZyb20gRkJPXG4gICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoZmluYWxEaW1lbnNpb25zLnggKiBmaW5hbERpbWVuc2lvbnMueSAqIDQpXG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCBmaW5hbERpbWVuc2lvbnMueCwgZmluYWxEaW1lbnNpb25zLnksIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscylcblxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYW55IHNlbWktdHJhbnNwYXJlbnQgcGl4ZWxzXG4gICAgY29uc3QgaGFzVHJhbnNwYXJlbmN5ID0gdGhpcy5fY2hlY2tQaXhlbHNGb3JUcmFuc3BhcmVuY3kocGl4ZWxzKVxuXG4gICAgbGV0IHJlbmRlclRleHR1cmVcbiAgICBpZiAoaGFzVHJhbnNwYXJlbmN5KSB7XG4gICAgICAvLyBTaW5jZSBvdXIgdGV4dHVyZXMgaGF2ZSBwcmVtdWx0aXBsaWVkIFJHQiB2YWx1ZXMsIHdlIG5lZWQgdG8gdW4tcHJlbXVsdGlwbHkgdGhlXG4gICAgICAvLyB2YWx1ZXMgYmVmb3JlIHJlYWRpbmcgdGhlbSBmcm9tIHRoZSB0ZXh0dXJlIGFuZCBwYXNzaW5nIHRoZW0gdG8gYSBjYW52YXNcbiAgICAgIGNvbnN0IHNwcml0ZSA9IG5ldyBFbmdpbmUuU3ByaXRlKHRleHR1cmUpXG4gICAgICBzcHJpdGUuc2V0RmlsdGVycyhbbmV3IEVuZ2luZS5GaWx0ZXJzLlVucHJlbXVsdGlwbHlGaWx0ZXIoKV0pXG4gICAgICBjb25zdCBjb250YWluZXIgPSBuZXcgRW5naW5lLkNvbnRhaW5lcigpXG4gICAgICBjb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKVxuICAgICAgcmVuZGVyVGV4dHVyZSA9IG5ldyBFbmdpbmUuUmVuZGVyVGV4dHVyZShyZW5kZXJlciwgZmluYWxEaW1lbnNpb25zLngsIGZpbmFsRGltZW5zaW9ucy55KVxuICAgICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIoY29udGFpbmVyKVxuXG4gICAgICAvLyBBdHRhY2ggdGhlIG5ldyB0ZXh0dXJlXG4gICAgICBjb25zdCBnbFRleHR1cmUgPSByZW5kZXJUZXh0dXJlLmdldEJhc2VUZXh0dXJlKCkuZ2V0R0xUZXh0dXJlRm9yUmVuZGVyZXIocmVuZGVyZXIpXG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSwgMClcblxuICAgICAgLy8gUmVhZCBwaXhlbHMgZnJvbSBGQk9cbiAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgZmluYWxEaW1lbnNpb25zLngsIGZpbmFsRGltZW5zaW9ucy55LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpXG5cbiAgICAgIC8vIFN3aXRjaCBiYWNrIHRvIGRlZmF1bHQgcmVuZGVyIHRhcmdldCwgZGlzcG9zZSB0aGUgdGV4dHVyZVxuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KClcbiAgICAgIHJlbmRlclRleHR1cmUuZGlzcG9zZSgpXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGNhbnZhcyB3aXRoIGRpbWVuc2lvbnMgb2Ygb3V0cHV0IHRleHR1cmVcbiAgICBjb25zdCBjYW52YXMgPSBVdGlscy5jcmVhdGVDYW52YXMoKVxuICAgIGNhbnZhcy53aWR0aCA9IGZpbmFsRGltZW5zaW9ucy54XG4gICAgY2FudmFzLmhlaWdodCA9IGZpbmFsRGltZW5zaW9ucy55XG5cbiAgICAvLyBDb3B5IHBpeGVsIGRhdGEgb3ZlclxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKGZpbmFsRGltZW5zaW9ucy54LCBmaW5hbERpbWVuc2lvbnMueSlcblxuICAgIGltYWdlRGF0YS5kYXRhLnNldChwaXhlbHMpXG5cbiAgICAvLyBSZW5kZXIgdG8gY2FudmFzXG4gICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuXG4gICAgLy8gRGVsZXRlIEZCT1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZibylcblxuICAgIHJldHVybiBjYW52YXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW55IG9mIHRoZSBnaXZlbiBSR0JBIHBpeGVscyBoYXMgdHJhbnNwYXJlbmN5XG4gICAqIEBwYXJhbSAge1VpbnQ4QXJyYXl9IHBpeGVsc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2NoZWNrUGl4ZWxzRm9yVHJhbnNwYXJlbmN5IChwaXhlbHMpIHtcbiAgICBjb25zdCBmaW5hbERpbWVuc2lvbnMgPSB0aGlzLl9zZGsuZ2V0RmluYWxEaW1lbnNpb25zKClcbiAgICBjb25zdCBtYXhJbmRleCA9IGZpbmFsRGltZW5zaW9ucy54ICogZmluYWxEaW1lbnNpb25zLnkgKiA0XG4gICAgbGV0IHZhbHVlXG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCBtYXhJbmRleDsgaSArPSA0KSB7XG4gICAgICB2YWx1ZSA9IHBpeGVsc1tpXVxuICAgICAgaWYgKHZhbHVlICE9PSAyNTUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuSW1hZ2VFeHBvcnRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgcmVuZGVyVHlwZTogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORywgYXZhaWxhYmxlOiBVdGlscy52YWx1ZXMoUmVuZGVyVHlwZSksIGRlZmF1bHQ6IFJlbmRlclR5cGUuSU1BR0UgfSxcbiAgaW1hZ2VGb3JtYXQ6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIGF2YWlsYWJsZTogVXRpbHMudmFsdWVzKEltYWdlRm9ybWF0KSwgZGVmYXVsdDogSW1hZ2VGb3JtYXQuUE5HIH0sXG4gIHF1YWxpdHk6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDAuOCB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlRXhwb3J0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9pbWFnZS1leHBvcnRlci5qcyIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XHJcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcclxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXHJcbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XHJcbiAqXHJcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxyXG4gKi9cclxuXHJcbmltcG9ydCBCYXNlNjQgZnJvbSAnLi9iYXNlNjQnXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzJ1xyXG5jb25zdCBiZCA9IChzdHIpID0+IFV0aWxzLmJ5dGVBcnJheVRvU3RyaW5nKEJhc2U2NC5kZWNvZGUoc3RyKSlcclxuXHJcbmNvbnN0IEhPU1QgPSB7XHJcbiAgLy8gaHR0cHM6Ly9zdGFnaW5nLmFwaS5waG90b2VkaXRvcnNkay5jb21cclxuICBkZXZlbG9wbWVudDogJ2FIUjBjSE02THk5emRHRm5hVzVuTG1Gd2FTNXdhRzkwYjJWa2FYUnZjbk5rYXk1amIyMD0nLFxyXG4gIC8vIGh0dHBzOi8vYXBpLnBob3RvZWRpdG9yc2RrLmNvbVxyXG4gIHByb2R1Y3Rpb246ICdhSFIwY0hNNkx5OWhjR2t1Y0dodmRHOWxaR2wwYjNKelpHc3VZMjl0JyxcclxuICAvLyBodHRwczovL3N0YWdpbmcuYXBpLnBob3RvZWRpdG9yc2RrLmNvbVxyXG4gIHRlc3Q6ICdhSFIwY0hNNkx5OXpkR0ZuYVc1bkxtRndhUzV3YUc5MGIyVmthWFJ2Y25Oa2F5NWpiMjA9J1xyXG59XHJcbi8vIC9hdXRoP2FwaUtleT0gKGhhc2hlZCB0d2ljZSlcclxuY29uc3QgQVVUSF9QQVRIID0gJ1RESkdNV1JIWnk5WldFSndVekpXTlZCUlBUMD0nXHJcbi8vICZjYWxsYmFjaz0gKGhhc2hlZCB0d2ljZSlcclxuY29uc3QgQ0JfU1VGRklYID0gJ1NtMU9hR0pIZUdsWlYwNXlVRkU5UFE9PSdcclxuLy8gL3RyYWNrP2FwaUtleT0gKGhhc2hlZCB0d2ljZSlcclxuY29uc3QgVFJBQ0tfUEFUSCA9ICdURE5TZVZsWFRuSlFNa1ozWVZWMGJHVlVNRDA9J1xyXG4vLyBhdXRob3JpemVkXHJcbmNvbnN0IEFVVEhPUklaRUQgPSAnWVhWMGFHOXlhWHBsWkE9PSdcclxuLy8gZXJyb3JcclxuY29uc3QgRVJST1IgPSAnWlhKeWIzST0nXHJcblxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTCB7XHJcbiAgY29uc3RydWN0b3IgKGFwaUtleSkge1xyXG4gICAgdGhpcy5fWVhCcFMyVjUgPSBhcGlLZXlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWRzIHRoZSBnaXZlbiBVUkwgdXNpbmcgYHJlcXVlc3RgIG1vZHVsZSBvbiBub2RlIGFuZCBKU09OUCBpbiBicm93c2Vyc1xyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdXJsXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9sb2FkSlNPTiAodXJsKSB7XHJcbiAgICBpZiAodHlwZW9mIFdFQlBBQ0sgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkSlNPTkJyb3dzZXIodXJsKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRKU09OTm9kZSh1cmwpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyB0aGUgZ2l2ZW4gSlNPTiB1cmwgdXNpbmcgSlNPTlBcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfbG9hZEpTT05Ccm93c2VyICh1cmwpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxyXG4gICAgICBsZXQgZm4gPSAncGVzZGsnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5OTk5KVxyXG4gICAgICB3aW5kb3dbZm5dID0gKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxyXG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UpXHJcbiAgICAgICAgZGVsZXRlIHdpbmRvd1tmbl1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2NyaXB0LnNyYyA9IHVybCArIGJkKGJkKENCX1NVRkZJWCkpICsgZm5cclxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZVxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdClcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyB0aGUgZ2l2ZW4gSlNPTiB1cmwgdXNpbmcgdGhlIGByZXF1ZXN0YCBtb2R1bGVcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfbG9hZEpTT05Ob2RlICh1cmwpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGVzIHRoZSBhcGlLZXkgYWdhaW5zdCBvdXIgYmFja2VuZFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICogQGlnbm9yZVxyXG4gICAqL1xyXG4gIGMgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xvYWRKU09OKGJkKEhPU1RbcHJvY2Vzcy5lbnYuRU5WXSkgKyBiZChiZChBVVRIX1BBVEgpKSArIHRoaXMuX1lYQnBTMlY1KVxyXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICBpZiAoIXJlc3BvbnNlW2JkKEFVVEhPUklaRUQpXSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlW2JkKEVSUk9SKV0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhY2tzIGFuIGVkaXRcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAqIEBpZ25vcmVcclxuICAgKi9cclxuICB0ICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9sb2FkSlNPTihiZChIT1NUW3Byb2Nlc3MuZW52LkVOVl0pICsgYmQoYmQoVFJBQ0tfUEFUSCkpICsgdGhpcy5fWVhCcFMyVjUpXHJcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgIGlmICghcmVzcG9uc2VbYmQoQVVUSE9SSVpFRCldKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2VbYmQoRVJST1IpXSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9saWNlbnNpbmcuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vZGVHTEV4cG9ydGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYG5vZGUtY2FudmFzYCBDYW52YXMgYW5kIHJlbmRlcnMgdGhlIGltYWdlIGZyb20gdGhlIGBnbGAgY29udGV4dCBvbnRvIGl0XG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyaW5nQ29udGV4dDJEfSBnbFxuICAgKiBAcGFyYW0gIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgc3RhdGljIHJlbmRlckNvbnRleHRUb0NhbnZhcyAoZ2wsIGNhbnZhcykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzXG4gICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KVxuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKVxuXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IENhbnZhcy5JbWFnZURhdGEod2lkdGgsIGhlaWdodClcblxuICAgIGxldCBpID0gMFxuICAgIHBpeGVscy5mb3JFYWNoKCgpID0+IHtcbiAgICAgIGltYWdlRGF0YS5kYXRhW2ldID0gcGl4ZWxzW2ldXG4gICAgICBpKytcbiAgICB9KVxuXG4gICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvbm9kZS1nbC1leHBvcnRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgRW5naW5lLCBVdGlscywgVmVjdG9yMiwgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vZ2xvYmFscydcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBPVFJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IG5ldyBFbmdpbmUuQ29udGFpbmVyKClcbiAgICB0aGlzLl9zcHJpdGUgPSBuZXcgRW5naW5lLlNwcml0ZSgpXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZENoaWxkKHRoaXMuX3Nwcml0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBpbnB1dCB0ZXh0dXJlIHRvIGEgUE9UIHRleHR1cmVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlNwcml0ZX0gaW5wdXRTcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlRleHR1cmV9IGlucHV0VGV4dHVyZVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlciwgaW5wdXRTcHJpdGUsIGlucHV0VGV4dHVyZSkge1xuICAgIGNvbnN0IHRleHR1cmVEaW1lbnNpb25zID0gaW5wdXRUZXh0dXJlLmdldERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IG5leHRQT1QgPSB0aGlzLl9nZXROZXh0SGlnaGVzdFBPVCh0ZXh0dXJlRGltZW5zaW9ucylcblxuICAgIGlmICghdGhpcy5fcmVuZGVyVGV4dHVyZSkge1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZSA9IG5ldyBFbmdpbmUuUmVuZGVyVGV4dHVyZShyZW5kZXJlciwgbmV4dFBPVC54LCBuZXh0UE9ULnkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUucmVzaXplVG8obmV4dFBPVClcbiAgICB9XG5cbiAgICBjb25zdCBuZXdEaW1lbnNpb25zID0gdGhpcy5fcmVuZGVyVGV4dHVyZS5nZXREaW1lbnNpb25zKClcbiAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZShpbnB1dFRleHR1cmUpXG4gICAgdGhpcy5fc3ByaXRlLnVwZGF0ZVRyYW5zZm9ybSgpXG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxuXG4gICAgdGhpcy5fdXBkYXRlU3ByaXRlKHJlbmRlcmVyLCBpbnB1dFNwcml0ZSwgdGV4dHVyZURpbWVuc2lvbnMsIG5ld0RpbWVuc2lvbnMpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgc3ByaXRlJ3MgdGV4dHVyZSBhbmQgbWFrZXMgc3VyZSBvbmx5IHRoZSByZWxldmFudCBwYXJ0IG9mIHRoZVxuICAgKiByZW5kZXIgdGV4dHVyZSBpcyByZW5kZXJlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU3ByaXRlfSBpbnB1dFNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGluaXRpYWxEaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gbmV3RGltZW5zaW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVNwcml0ZSAocmVuZGVyZXIsIGlucHV0U3ByaXRlLCBpbml0aWFsRGltZW5zaW9ucywgbmV3RGltZW5zaW9ucykge1xuICAgIGlucHV0U3ByaXRlLnNldFRleHR1cmUodGhpcy5fcmVuZGVyVGV4dHVyZSlcblxuICAgIHRoaXMuX3JlbmRlclRleHR1cmUuc2V0RnJhbWUobmV3IFJlY3RhbmdsZShcbiAgICAgIDAsIDAsXG4gICAgICBpbml0aWFsRGltZW5zaW9ucy54LCBpbml0aWFsRGltZW5zaW9ucy55XG4gICAgKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IGhpZ2hlc3QgUE9UIGRpbWVuc2lvbnMgZm9yIHRoZSBnaXZlbiBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5leHRIaWdoZXN0UE9UIChkaW1lbnNpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKFxuICAgICAgVXRpbHMubmV4dEhpZ2hlc3RQT1QoZGltZW5zaW9ucy54KSxcbiAgICAgIFV0aWxzLm5leHRIaWdoZXN0UE9UKGRpbWVuc2lvbnMueSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBQT1QgcmVuZGVyZXJzXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9yZW5kZXJUZXh0dXJlLmRpc3Bvc2UoKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvcG90LXJlbmRlcmVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBMb2cgfSBmcm9tICcuLi9nbG9iYWxzJ1xuXG5jb25zdCBWRVJTSU9OX0NIRUNLX0ZOID0gJ2ltZ2x5U0RLVmVyc2lvbkNhbGxiYWNrJ1xuY29uc3QgVkVSU0lPTl9DSEVDS19VUkwgPSBgaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL3ZlcnNpb24uanNvbj9zZGs9aHRtbDUmanNvbmNhbGxiYWNrPSR7VkVSU0lPTl9DSEVDS19GTn1gXG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlcmUgaXMgYSBuZXcgdmVyc2lvbiBvZiB0aGUgU0RLIGF2YWlsYWJsZVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqIEBpZ25vcmVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIFZlcnNpb25DaGVja2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbkNoZWNrZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSB2ZXJzaW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbikge1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uXG4gICAgdGhpcy5fY2hlY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHZlcnNpb24gb2YgdGhlIFNESyBpcyBvdXRkYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrICgpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIExvZy5pbmZvKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ05vdCBpbiBicm93c2VyIGVudmlyb25tZW50LiBWZXJzaW9uIGNoZWNrIHNraXBwZWQuJylcbiAgICB9XG5cbiAgICBsZXQgc2VsZiA9IHRoaXNcbiAgICB3aW5kb3dbVkVSU0lPTl9DSEVDS19GTl0gPSAocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5vdXRkYXRlZCkge1xuICAgICAgICBMb2cud2Fybih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIGBZb3VyIFZlcnNpb24gJHtzZWxmLl92ZXJzaW9ufSBpcyBvdXRkYXRlZC4gQ3VycmVudCB2ZXJzaW9uIGlzICR7cmVzcG9uc2UudmVyc2lvbn0uYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICBzY3JpcHQuc3JjID0gVkVSU0lPTl9DSEVDS19VUkwgKyAnJnZlcnNpb249JyArIHRoaXMuX3ZlcnNpb25cbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzY3JpcHQpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVyc2lvbkNoZWNrZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi92ZXJzaW9uLWNoZWNrZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBQcm9taXNlIGZyb20gJy4uL3ZlbmRvci9wcm9taXNlJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcbmltcG9ydCBBZGp1c3RtZW50c0ZpbHRlciBmcm9tICcuL2FkanVzdG1lbnRzL2FkanVzdG1lbnRzLWZpbHRlcidcbmltcG9ydCBDbGFyaXR5RmlsdGVyIGZyb20gJy4vYWRqdXN0bWVudHMvY2xhcml0eS1maWx0ZXInXG5pbXBvcnQgeyBPcHRpb25UeXBlIH0gZnJvbSAnLi4vY29uc3RhbnRzJ1xuXG4vKipcbiAqIEFwcGxpZXMgYWRqdXN0bWVudHMgKGJyaWdodG5lc3MsIHNhdHVyYXRpb24sIGNvbnRyYXN0KSB0byB0aGUgaW1hZ2VcbiAqIEBjbGFzc1xuICogQGFsaWFzIE9wZXJhdGlvbnMuQWRqdXN0bWVudHNPcGVyYXRpb25cbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvblxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gKi9cbmNsYXNzIEFkanVzdG1lbnRzT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQWRqdXN0bWVudHNPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmJyaWdodG5lc3MgPSAwXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNhdHVyYXRpb24gPSAxXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmV4cG9zdXJlID0gMF1cbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5jb250cmFzdCA9IDFdXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2hhZG93cyA9IDBdXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuaGlnaGxpZ2h0cyA9IDFdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9jbGFyaXR5RmlsdGVyID0gbmV3IENsYXJpdHlGaWx0ZXIoKVxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBBZGp1c3RtZW50c0ZpbHRlcigpXG4gICAgdGhpcy5fc3ByaXRlLnNldEZpbHRlcnMoW3RoaXMuX2NsYXJpdHlGaWx0ZXIsIHRoaXMuX2ZpbHRlcl0pXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHJlbmRlcmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyIChzZGspIHtcbiAgICBsZXQgZGltZW5zaW9ucyA9IHNkay5nZXREaW1lbnNpb25zKClcbiAgICBkaW1lbnNpb25zLnggPSAxLjAgLyBkaW1lbnNpb25zLnhcbiAgICBkaW1lbnNpb25zLnkgPSAxLjAgLyBkaW1lbnNpb25zLnlcbiAgICB0aGlzLl9jbGFyaXR5RmlsdGVyLnNldCh7XG4gICAgICBjbGFyaXR5OiB0aGlzLl9vcHRpb25zLmNsYXJpdHksXG4gICAgICB0ZXhTaXplOiBkaW1lbnNpb25zXG4gICAgfSlcblxuICAgIHRoaXMuX2ZpbHRlci5zZXQoe1xuICAgICAgYnJpZ2h0bmVzczogdGhpcy5fb3B0aW9ucy5icmlnaHRuZXNzLFxuICAgICAgc2F0dXJhdGlvbjogdGhpcy5fb3B0aW9ucy5zYXR1cmF0aW9uLFxuICAgICAgY29udHJhc3Q6IHRoaXMuX29wdGlvbnMuY29udHJhc3QsXG4gICAgICBnYW1tYTogdGhpcy5fb3B0aW9ucy5nYW1tYSxcbiAgICAgIGV4cG9zdXJlOiB0aGlzLl9vcHRpb25zLmV4cG9zdXJlLFxuICAgICAgc2hhZG93czogdGhpcy5fb3B0aW9ucy5zaGFkb3dzLFxuICAgICAgaGlnaGxpZ2h0czogdGhpcy5fb3B0aW9ucy5oaWdobGlnaHRzXG4gICAgfSlcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsYXJpdHkgIT09IDApIHtcbiAgICAgIHRoaXMuX3Nwcml0ZS5zZXRGaWx0ZXJzKFt0aGlzLl9jbGFyaXR5RmlsdGVyLCB0aGlzLl9maWx0ZXJdKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zcHJpdGUuc2V0RmlsdGVycyhbdGhpcy5fZmlsdGVyXSlcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIG9wZXJhdGlvblxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpXG4gICAgdGhpcy5fZmlsdGVyLmRpc3Bvc2UoKVxuICAgIHRoaXMuX2NsYXJpdHlGaWx0ZXIuZGlzcG9zZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAqIG9wZXJhdGlvbnMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuQWRqdXN0bWVudHNPcGVyYXRpb24uaWRlbnRpZmllciA9ICdhZGp1c3RtZW50cydcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuQWRqdXN0bWVudHNPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGJyaWdodG5lc3M6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDAgfSxcbiAgc2F0dXJhdGlvbjogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMS4wIH0sXG4gIGNvbnRyYXN0OiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAxLjAgfSxcbiAgZ2FtbWE6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDEuMCB9LFxuICBleHBvc3VyZTogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMC4wIH0sXG4gIHNoYWRvd3M6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDAuMCB9LFxuICBoaWdobGlnaHRzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAxLjAgfSxcbiAgY2xhcml0eTogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMC4wIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWRqdXN0bWVudHNPcGVyYXRpb25cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvYWRqdXN0bWVudHMtb3BlcmF0aW9uLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBFbmdpbmUsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5jb25zdCB7IE9wdGlvblR5cGUsIFVuaWZvcm1UeXBlIH0gPSBDb25zdGFudHNcbmltcG9ydCBTdGFja0JsdXIgZnJvbSAnLi4vLi4vdmVuZG9yL3N0YWNrLWJsdXInXG5cbmNsYXNzIENsYXJpdHlGaWx0ZXIgZXh0ZW5kcyBFbmdpbmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuLi8uLi9zaGFkZXJzL2dlbmVyaWMvY2xhcml0eS5mcmFnJylcblxuICAgIHRoaXMuX2xhc3RDbGFyaXR5ID0gbnVsbFxuXG4gICAgdGhpcy5fYmx1cnJlZFJlbmRlclRhcmdldCA9IG5ldyBFbmdpbmUuQ2FudmFzUmVuZGVyVGFyZ2V0KFxuICAgICAgMTAwLFxuICAgICAgMTAwLFxuICAgICAgMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlci5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGFyZ2V0LmdldERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IGRpbWVuc2lvbnNDaGFuZ2VkID0gIXRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQuZ2V0RGltZW5zaW9ucygpLmVxdWFscyhpbnB1dERpbWVuc2lvbnMpXG5cbiAgICB0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LnNldFBpeGVsUmF0aW8oaW5wdXRUYXJnZXQuZ2V0UGl4ZWxSYXRpbygpKVxuICAgIHRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQucmVzaXplVG8oaW5wdXRUYXJnZXQuZ2V0RGltZW5zaW9ucygpKVxuXG4gICAgaWYgKCF0aGlzLl9vdXRwdXRSZW5kZXJUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9vdXRwdXRSZW5kZXJUZXh0dXJlID0gbmV3IEVuZ2luZS5SZW5kZXJUZXh0dXJlKHJlbmRlcmVyLFxuICAgICAgICBpbnB1dFRhcmdldC5nZXRXaWR0aCgpLFxuICAgICAgICBpbnB1dFRhcmdldC5nZXRIZWlnaHQoKSxcbiAgICAgICAgaW5wdXRUYXJnZXQuZ2V0UGl4ZWxSYXRpbygpKVxuICAgIH1cblxuICAgIGlmIChkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYmx1ckltYWdlKGlucHV0VGFyZ2V0KVxuICAgIH1cblxuICAgIHRoaXMuX2FwcGx5Q2xhcml0eShpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBibHVycmVkIGNvcHkgb2YgdGhlIGltYWdlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ibHVySW1hZ2UgKGlucHV0VGFyZ2V0KSB7XG4gICAgY29uc3QgaW5wdXRDYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgYmx1cnJ5SW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KVxuICAgIFN0YWNrQmx1ci5zdGFja0JsdXJDYW52YXNSR0JBKGJsdXJyeUltYWdlRGF0YSwgMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCwgMSlcblxuICAgIGNvbnN0IGJsdXJyeUNvbnRleHQgPSB0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGJsdXJyeUNvbnRleHQucHV0SW1hZ2VEYXRhKGJsdXJyeUltYWdlRGF0YSwgMCwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBmaW5hbCBjbGFyaXR5IGZpbHRlciB0byB0aGUgaW5wdXQgY2FudmFzXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDbGFyaXR5IChpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0KSB7XG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBpbnB1dENhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3QgYmx1cnJlZENvbnRleHQgPSB0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IGNsYXJpdHkgPSB0aGlzLl9vcHRpb25zLmNsYXJpdHlcbiAgICBjb25zdCBpbnB1dEltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodClcbiAgICBjb25zdCBwaXhlbHMgPSBpbnB1dEltYWdlRGF0YS5kYXRhXG4gICAgY29uc3QgYmx1cnJlZFBpeGVscyA9IGJsdXJyZWRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KS5kYXRhXG4gICAgLy8gRHVlIHRvIHNwZWVkIHdlIHByZWNhbGN1bGF0ZSBhbG90XG4gICAgY29uc3Qgc2F0dXJhdGlvbiA9IE1hdGgubWF4KDAuMiAqIHRoaXMuX29wdGlvbnMuY2xhcml0eSwgMC4wKVxuICAgIGNvbnN0IGludmVyc2VTYXR1cmF0aW9uID0gMSAtIHNhdHVyYXRpb25cbiAgICBjb25zdCBmYWN0b3IgPSAxLjAgKyBjbGFyaXR5XG4gICAgY29uc3QgaW52ZXJzZUZhY3RvciA9IDEgLSAoMS4wICsgY2xhcml0eSlcbiAgICAvLyBIZXJlIHdlIGNhbGN1bGF0ZSB0aGUgdW5zaGFycCBtYXNrIGJ5IHN1YnN0cmFjdGluZyB0aGUgYmx1cmVkIGltYWdlIGZyb20gdGhlXG4gICAgLy8gdW5ibHVycmVkLCBhbmQgdGhlIHN0cm9uZ2VyIHRoZSBlZmZlY3QgaXMgdGhlIGxlc3Mgc2F0dXJhdGVkIHRoZSBjb2xvcnMgd2lsbCBiZS5cbiAgICAvLyBUaGF0IGVuaGFuY2VzIHRoZSB2aXN1YWwgZWZmZWN0LlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDYW52YXMud2lkdGggKiBpbnB1dENhbnZhcy5oZWlnaHQgKiA0OyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IHIgPSAoYmx1cnJlZFBpeGVsc1tpXSAqIGludmVyc2VGYWN0b3IgKyBwaXhlbHNbaV0gKiBmYWN0b3IpXG4gICAgICBjb25zdCBnID0gKGJsdXJyZWRQaXhlbHNbaSArIDFdICogaW52ZXJzZUZhY3RvciArIHBpeGVsc1tpICsgMV0gKiBmYWN0b3IpXG4gICAgICBjb25zdCBiID0gKGJsdXJyZWRQaXhlbHNbaSArIDJdICogaW52ZXJzZUZhY3RvciArIHBpeGVsc1tpICsgMl0gKiBmYWN0b3IpXG4gICAgICBjb25zdCBsdW1pbmFuY2UgPSByICogMC4yMTI1ICsgZyAqIDAuNzE1NCArIGIgKiAwLjA3MjFcbiAgICAgIGNvbnN0IGx1bWluYW5jZVNhdHVyYXRpb24gPSBsdW1pbmFuY2UgKiBzYXR1cmF0aW9uXG4gICAgICBwaXhlbHNbaV0gPSByICogaW52ZXJzZVNhdHVyYXRpb24gKyBsdW1pbmFuY2VTYXR1cmF0aW9uXG4gICAgICBwaXhlbHNbaSArIDFdID0gZyAqIGludmVyc2VTYXR1cmF0aW9uICsgbHVtaW5hbmNlU2F0dXJhdGlvblxuICAgICAgcGl4ZWxzW2kgKyAyXSA9IGIgKiBpbnZlcnNlU2F0dXJhdGlvbiArIGx1bWluYW5jZVNhdHVyYXRpb25cbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbnB1dEltYWdlRGF0YSwgMCwgMClcbiAgfVxufVxuXG5DbGFyaXR5RmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBjbGFyaXR5OiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQgfSxcbiAgdGV4U2l6ZTogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDEwMCwgMTAwKSwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUMiB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENsYXJpdHlGaWx0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvYWRqdXN0bWVudHMvY2xhcml0eS1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cywgVmVjdG9yMiB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uJ1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vdmVuZG9yL3Byb21pc2UnXG5jb25zdCB7IE9wdGlvblR5cGUgfSA9IENvbnN0YW50c1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBjcm9wIG91dCBhIHBhcnQgb2YgdGhlIGltYWdlXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvblxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgQ3JvcE9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBDcm9wcyB0aGUgaW1hZ2VcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXIgKGlucHV0VGV4dHVyZSkge1xuICAgIHRoaXMuX3Nwcml0ZS5zZXRSb3RhdGlvbigwKVxuXG4gICAgbGV0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGV4dHVyZS5nZXREaW1lbnNpb25zKClcbiAgICBjb25zdCB7IHN0YXJ0LCByb3RhdGlvbiwgc2NhbGUsIHRleHR1cmVTY2FsZSB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIGNvbnN0IGZpbmFsU2NhbGUgPSBzY2FsZSAqIHRleHR1cmVTY2FsZVxuICAgIGNvbnN0IHNjYWxlZElucHV0RGltZW5zaW9ucyA9IGlucHV0RGltZW5zaW9ucy5jbG9uZSgpXG4gICAgICAubXVsdGlwbHkodGV4dHVyZVNjYWxlKVxuXG4gICAgdGhpcy5fc3ByaXRlLnNldEFuY2hvcigwLjUsIDAuNSlcbiAgICB0aGlzLl9zcHJpdGUuc2V0Um90YXRpb24ocm90YXRpb24pXG4gICAgdGhpcy5fc3ByaXRlLnNldFNjYWxlKGZpbmFsU2NhbGUsIGZpbmFsU2NhbGUpXG4gICAgdGhpcy5fc3ByaXRlLnNldFBvc2l0aW9uKFxuICAgICAgc2NhbGVkSW5wdXREaW1lbnNpb25zLmNsb25lKClcbiAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAuc3VidHJhY3QoXG4gICAgICAgICAgc3RhcnRcbiAgICAgICAgICAgIC5jbG9uZSgpXG4gICAgICAgICAgICAubXVsdGlwbHkoc2NhbGVkSW5wdXREaW1lbnNpb25zKVxuICAgICAgICApXG4gICAgKVxuXG4gICAgLy8gUmVuZGVyIHRoZSBjb250YWluZXIgdG8gdGhpcyBPcGVyYXRpb24ncyBSZW5kZXJUZXh0dXJlXG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyB0aGUgZ2l2ZW4gZGltZW5zaW9ucyB3aWxsIGhhdmUgYWZ0ZXIgdGhpcyBvcGVyYXRpb25cbiAgICogaGFzIGJlZW4gYXBwbGllZFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gaW5wdXREaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXROZXdEaW1lbnNpb25zIChpbnB1dERpbWVuc2lvbnMpIHtcbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHRleHR1cmVTY2FsZSB9ID0gdGhpcy5fb3B0aW9uc1xuXG4gICAgcmV0dXJuIGlucHV0RGltZW5zaW9ucy5jbG9uZSgpXG4gICAgICAubXVsdGlwbHkodGV4dHVyZVNjYWxlKVxuICAgICAgLm11bHRpcGx5KFxuICAgICAgICBlbmQuY2xvbmUoKS5zdWJ0cmFjdChzdGFydClcbiAgICAgIClcbiAgICAgIC5jZWlsKClcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGlwcyB0aGlzIG9wZXJhdGlvbiBpbnRvIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICovXG4gIGZsaXAgKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIGNvbnN0IHRtcFN0YXJ0ID0gc3RhcnQuY2xvbmUoKVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICBzdGFydC5zZXQoMS4wIC0gZW5kLngsIHN0YXJ0LnkpXG4gICAgICBlbmQuc2V0KDEuMCAtIHRtcFN0YXJ0LngsIGVuZC55KVxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICBzdGFydC5zZXQoc3RhcnQueCwgMS4wIC0gZW5kLnkpXG4gICAgICBlbmQuc2V0KGVuZC54LCAxLjAgLSB0bXBTdGFydC55KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGVzIHRoaXMgb3BlcmF0aW9uIHdpdGggdGhlIGdpdmVuIGRlZ3JlZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlZ3JlZXNcbiAgICovXG4gIHJvdGF0ZSAoZGVncmVlcykge1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIGNvbnN0IGRlZ3JlZXNEaWZmZXJlbmNlID0gKGRlZ3JlZXMgKyAzNjApICUgMzYwXG5cbiAgICBjb25zdCB0ZW1wU3RhcnQgPSBzdGFydC5jbG9uZSgpXG4gICAgaWYgKGRlZ3JlZXNEaWZmZXJlbmNlID09PSA5MCkge1xuICAgICAgc3RhcnQuc2V0KDEuMCAtIGVuZC55LCB0ZW1wU3RhcnQueClcbiAgICAgIGVuZC5zZXQoMS4wIC0gdGVtcFN0YXJ0LnksIGVuZC54KVxuICAgIH0gZWxzZSBpZiAoZGVncmVlc0RpZmZlcmVuY2UgPT09IDI3MCkge1xuICAgICAgc3RhcnQuc2V0KHRlbXBTdGFydC55LCAxLjAgLSBlbmQueClcbiAgICAgIGVuZC5zZXQoZW5kLnksIDEuMCAtIHRlbXBTdGFydC54KVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICogb3BlcmF0aW9ucy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Dcm9wT3BlcmF0aW9uLmlkZW50aWZpZXIgPSAnY3JvcCdcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuQ3JvcE9wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgc3RhcnQ6IHsgdHlwZTogT3B0aW9uVHlwZS5WRUNUT1IyLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigwLCAwKSB9LFxuICBlbmQ6IHsgdHlwZTogT3B0aW9uVHlwZS5WRUNUT1IyLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigxLCAxKSB9LFxuICBzY2FsZTogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMSB9LFxuICB0ZXh0dXJlU2NhbGU6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDEgfSxcbiAgcm90YXRpb246IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDcm9wT3BlcmF0aW9uXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2Nyb3Atb3BlcmF0aW9uLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vdmVuZG9yL3Byb21pc2UnXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi9saWIvbWF0aC92ZWN0b3IyJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcbmNvbnN0IHsgT3B0aW9uVHlwZSB9ID0gQ29uc3RhbnRzXG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIHJvdGF0ZSBhbmQgZmxpcCBhbiBpbWFnZSBkZXBlbmRpbmcgb24gdGhlIGdpdmVuIEVYSUYgaW5mb3JtYXRpb25cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uc1xuICovXG5jbGFzcyBFeGlmT3JpZW50YXRpb25PcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm90YXRpb25cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJvdGF0aW9uICgpIHtcbiAgICBsZXQgZGVncmVlcyA9IDBcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0VGFncygpLk9yaWVudGF0aW9uKSB7XG4gICAgICBjYXNlIDc6XG4gICAgICBjYXNlIDg6XG4gICAgICAgIGRlZ3JlZXMgPSAtOTBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgZGVncmVlcyA9IC0xODBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNTpcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgZGVncmVlcyA9IDkwXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHJldHVybiBkZWdyZWVzXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBpbWFnZSBuZWVkcyB0byBiZSBmbGlwcGVkIHZlcnRpY2FsbHlcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGbGlwVmVydGljYWxseSAoKSB7XG4gICAgY29uc3QgeyBPcmllbnRhdGlvbiB9ID0gdGhpcy5nZXRUYWdzKClcbiAgICByZXR1cm4gWzUsIDddLmluZGV4T2YoT3JpZW50YXRpb24pICE9PSAtMVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgaW1hZ2UgbmVlZHMgdG8gYmUgZmxpcHBlZCBob3Jpem9udGFsbHlcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGbGlwSG9yaXpvbnRhbGx5ICgpIHtcbiAgICBjb25zdCB7IE9yaWVudGF0aW9uIH0gPSB0aGlzLmdldFRhZ3MoKVxuICAgIHJldHVybiBbMiwgNF0uaW5kZXhPZihPcmllbnRhdGlvbikgIT09IC0xXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBiYXNlZCBvbiB0aGUgRVhJRiBvcmllbnRhdGlvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0RmluYWxPcHRpb25zICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IHRoaXMuX2dldFJvdGF0aW9uKCksXG4gICAgICBmbGlwVmVydGljYWxseTogdGhpcy5fZ2V0RmxpcFZlcnRpY2FsbHkoKSxcbiAgICAgIGZsaXBIb3Jpem9udGFsbHk6IHRoaXMuX2dldEZsaXBIb3Jpem9udGFsbHkoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGVzIGFuZC9vciBmbGlwcyB0aGUgaW1hZ2VcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQG92ZXJyaWRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyIChzZGspIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZ2V0RmluYWxPcHRpb25zKClcbiAgICBjb25zdCBhY3R1YWxEZWdyZWVzID0gb3B0aW9ucy5yb3RhdGlvbiAlIDM2MFxuICAgIGNvbnN0IHJhZGlhbnMgPSBhY3R1YWxEZWdyZWVzICogKE1hdGguUEkgLyAxODApXG5cbiAgICB0aGlzLl9zcHJpdGUuc2V0U2NhbGUoXG4gICAgICBvcHRpb25zLmZsaXBIb3Jpem9udGFsbHkgPyAtMSA6IDEsXG4gICAgICBvcHRpb25zLmZsaXBWZXJ0aWNhbGx5ID8gLTEgOiAxXG4gICAgKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRSb3RhdGlvbihyYWRpYW5zKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRBbmNob3IoMC41LCAwLjUpXG4gICAgdGhpcy5fc3ByaXRlLnVwZGF0ZVRyYW5zZm9ybSgpXG5cbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9zcHJpdGUuZ2V0Qm91bmRzKClcbiAgICB0aGlzLl9yZW5kZXJUZXh0dXJlLnJlc2l6ZVRvKG5ldyBWZWN0b3IyKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCkpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgcmVuZGVyaW5nIHRvIHRvcCBsZWZ0IGNvcm5lclxuICAgIHRoaXMuX3Nwcml0ZS5zZXRQb3NpdGlvbih0aGlzLl9yZW5kZXJUZXh0dXJlLmdldERpbWVuc2lvbnMoKS5kaXZpZGUoMikpXG5cbiAgICAvLyBEcmF3XG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyB0aGUgZ2l2ZW4gZGltZW5zaW9ucyB3aWxsIGhhdmUgYWZ0ZXIgdGhpcyBvcGVyYXRpb25cbiAgICogaGFzIGJlZW4gYXBwbGllZFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0TmV3RGltZW5zaW9ucyAoZGltZW5zaW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9nZXRGaW5hbE9wdGlvbnMoKVxuICAgIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zLmNsb25lKClcbiAgICBpZiAob3B0aW9ucy5yb3RhdGlvbiAlIDE4MCkge1xuICAgICAgZGltZW5zaW9ucy5mbGlwKClcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbnNcbiAgfVxufVxuXG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICogb3BlcmF0aW9ucy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5FeGlmT3JpZW50YXRpb25PcGVyYXRpb24uaWRlbnRpZmllciA9ICdleGlmLW9yaWVudGF0aW9uJ1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5FeGlmT3JpZW50YXRpb25PcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHRhZ3M6IHsgdHlwZTogT3B0aW9uVHlwZS5PQkpFQ1QsIGRlZmF1bHQ6IHt9IH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhpZk9yaWVudGF0aW9uT3BlcmF0aW9uXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2V4aWYtb3JpZW50YXRpb24tb3BlcmF0aW9uLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBQcm9taXNlLCBDb25zdGFudHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcbmltcG9ydCBJZGVudGl0eUZpbHRlciBmcm9tICcuL2ZpbHRlcnMvaWRlbnRpdHktZmlsdGVyJ1xuY29uc3QgeyBPcHRpb25UeXBlIH0gPSBDb25zdGFudHNcblxuLyoqXG4gKiBBbiBvcGVyYXRpb24gdGhhdCBjYW4gYXBwbHkgYSBzZWxlY3RlZCBmaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uc1xuICovXG5jbGFzcyBGaWx0ZXJPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogUmVuZGVycyB0aGlzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfSBpbnB1dFRleHR1cmVcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXIgKGlucHV0VGV4dHVyZSkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZEZpbHRlci5yZW5kZXIodGhpcy5fc2RrLCBpbnB1dFRleHR1cmUsIHRoaXMuX3JlbmRlclRleHR1cmUpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyIChpbnB1dFRleHR1cmUpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0ZWRGaWx0ZXIuZ2V0RGlydHkoKSkge1xuICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRFbmFibGVkKCkgfHwgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIuY29uc3RydWN0b3IuaXNJZGVudGl0eSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbnB1dFRleHR1cmUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnJlbmRlcihpbnB1dFRleHR1cmUpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGlydGluZXNzIGZvciB0aGUgZ2l2ZW4gcmVuZGVyZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBkaXJ0eVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0RGlydHlGb3JSZW5kZXJlciAoZGlydHksIHJlbmRlcmVyKSB7XG4gICAgc3VwZXIuc2V0RGlydHlGb3JSZW5kZXJlcihkaXJ0eSwgcmVuZGVyZXIpXG4gICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIuc2V0RGlydHlGb3JSZW5kZXJlcihkaXJ0eSwgcmVuZGVyZXIpXG4gIH1cblxuICAvKipcbiAgICogRnJlZXMgdGhlIG1lbW9yeVxuICAgKi9cbiAgZGlzcG9zZVJlbmRlclRleHR1cmVzICgpIHtcbiAgICBzdXBlci5kaXNwb3NlUmVuZGVyVGV4dHVyZXMoKVxuICAgIGlmICh0aGlzLl9zZWxlY3RlZEZpbHRlcikge1xuICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIuZGlzcG9zZVJlbmRlclRleHR1cmVzKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBvcGVyYXRpb25cbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICAgIGlmICh0aGlzLl9zZWxlY3RlZEZpbHRlcikge1xuICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIuZGlzcG9zZSgpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gKiBvcGVyYXRpb25zLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkZpbHRlck9wZXJhdGlvbi5pZGVudGlmaWVyID0gJ2ZpbHRlcidcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuRmlsdGVyT3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBpbnRlbnNpdHk6IHtcbiAgICB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUixcbiAgICBkZWZhdWx0OiAxLFxuICAgIHNldHRlcjogZnVuY3Rpb24gKGludGVuc2l0eSkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIgJiZcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIuc2V0SW50ZW5zaXR5KGludGVuc2l0eSlcbiAgICAgIHJldHVybiBpbnRlbnNpdHlcbiAgICB9XG4gIH0sXG4gIGZpbHRlcjoge1xuICAgIHR5cGU6IE9wdGlvblR5cGUuT0JKRUNULFxuICAgIGRlZmF1bHQ6IG5ldyBJZGVudGl0eUZpbHRlcigpLFxuICAgIHNldHRlcjogZnVuY3Rpb24gKEZpbHRlcikge1xuICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkRmlsdGVyKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkRmlsdGVyLmRpc3Bvc2UoKVxuICAgICAgICB0aGlzLl9zZWxlY3RlZEZpbHRlciA9IG51bGxcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIgPSBGaWx0ZXJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5pbnRlbnNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkRmlsdGVyLnNldCh7XG4gICAgICAgICAgaW50ZW5zaXR5OiB0aGlzLl9vcHRpb25zLmludGVuc2l0eVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIEZpbHRlclxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaWx0ZXJPcGVyYXRpb25cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVyLW9wZXJhdGlvbi5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEExNSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBBMTVGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICBjb250cmFzdDogMC42M1xuICAgIH0pKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5CcmlnaHRuZXNzKHtcbiAgICAgIGJyaWdodG5lc3M6IDAuMTJcbiAgICB9KSlcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDM4XSxcbiAgICAgICAgICBbOTQsIDk0XSxcbiAgICAgICAgICBbMTQ4LCAxNDJdLFxuICAgICAgICAgIFsxNzUsIDE4N10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbNzcsIDUzXSxcbiAgICAgICAgICBbMTcxLCAxOTBdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAxMF0sXG4gICAgICAgICAgWzQ4LCA4NV0sXG4gICAgICAgICAgWzE3NCwgMjI4XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkExNUZpbHRlci5pZGVudGlmaWVyID0gJ2ExNSdcblxuQTE1RmlsdGVyLmRpc3BsYXlOYW1lID0gJzE1J1xuXG5leHBvcnQgZGVmYXVsdCBBMTVGaWx0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9hMTUtZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogQnJlZXplIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEJyZWV6ZUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIC8vIERlc2F0dXJhdGlvblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuRGVzYXR1cmF0aW9uKHtcbiAgICAgIGRlc2F0dXJhdGlvbjogMC41XG4gICAgfSkpXG5cbiAgICAvLyBUb25lIGN1cnZlXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzE3MCwgMTcwXSxcbiAgICAgICAgICBbMjEyLCAyMTldLFxuICAgICAgICAgIFsyMzQsIDI0Ml0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTcwLCAxNjhdLFxuICAgICAgICAgIFsyMzQsIDIzMV0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxNzAsIDE3MF0sXG4gICAgICAgICAgWzIxMiwgMjA4XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkJyZWV6ZUZpbHRlci5pZGVudGlmaWVyID0gJ2JyZWV6ZSdcblxuQnJlZXplRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0JyZWV6ZSdcblxuZXhwb3J0IGRlZmF1bHQgQnJlZXplRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvYnJlZXplLWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEJXIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEJXRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5HcmF5c2NhbGUoKSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkJXRmlsdGVyLmlkZW50aWZpZXIgPSAnYncnXG5cbkJXRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0ImVydcblxuZXhwb3J0IGRlZmF1bHQgQldGaWx0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9idy1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBCV0hhcmQgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgQldIYXJkRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5HcmF5c2NhbGUoKSlcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLkNvbnRyYXN0KHtcbiAgICAgIGNvbnRyYXN0OiAxLjVcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkJXSGFyZEZpbHRlci5pZGVudGlmaWVyID0gJ2J3aGFyZCdcblxuQldIYXJkRmlsdGVyLmRpc3BsYXlOYW1lID0gJzE5MjAnXG5cbmV4cG9ydCBkZWZhdWx0IEJXSGFyZEZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2J3aGFyZC1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBDZWxzaXVzIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIENlbHNpdXNGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgNjldLFxuICAgICAgICAgIFs1NSwgMTEwXSxcbiAgICAgICAgICBbMjAyLCAyMzBdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgNDRdLFxuICAgICAgICAgIFs4OSwgOTNdLFxuICAgICAgICAgIFsxODUsIDE0MV0sXG4gICAgICAgICAgWzI1NSwgMTg5XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDc2XSxcbiAgICAgICAgICBbMzksIDgyXSxcbiAgICAgICAgICBbMjE4LCAxMzhdLFxuICAgICAgICAgIFsyNTUsIDE3MV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuQ2Vsc2l1c0ZpbHRlci5pZGVudGlmaWVyID0gJ2NlbHNpdXMnXG5cbkNlbHNpdXNGaWx0ZXIuZGlzcGxheU5hbWUgPSAnQ2Vsc2l1cydcblxuZXhwb3J0IGRlZmF1bHQgQ2Vsc2l1c0ZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2NlbHNpdXMtZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogQ2hlc3QgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgQ2hlc3RGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs0NCwgNDRdLFxuICAgICAgICAgIFsxMjQsIDE0M10sXG4gICAgICAgICAgWzIyMSwgMjA0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxMzAsIDEyN10sXG4gICAgICAgICAgWzIxMywgMTk5XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzUxLCA1Ml0sXG4gICAgICAgICAgWzIxOSwgMjA0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkNoZXN0RmlsdGVyLmlkZW50aWZpZXIgPSAnY2hlc3QnXG5cbkNoZXN0RmlsdGVyLmRpc3BsYXlOYW1lID0gJ0NoZXN0J1xuXG5leHBvcnQgZGVmYXVsdCBDaGVzdEZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2NoZXN0LWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEZpeGllIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEZpeGllRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs0NCwgMjhdLFxuICAgICAgICAgIFs2MywgNDhdLFxuICAgICAgICAgIFsxMjgsIDEzMl0sXG4gICAgICAgICAgWzIzNSwgMjQ4XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsyMCwgMTBdLFxuICAgICAgICAgIFs2MCwgNDVdLFxuICAgICAgICAgIFsxOTAsIDIwOV0sXG4gICAgICAgICAgWzIxMSwgMjMxXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMzFdLFxuICAgICAgICAgIFs0MSwgNjJdLFxuICAgICAgICAgIFsxNTAsIDE0Ml0sXG4gICAgICAgICAgWzIzNCwgMjEyXSxcbiAgICAgICAgICBbMjU1LCAyMjRdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkZpeGllRmlsdGVyLmlkZW50aWZpZXIgPSAnZml4aWUnXG5cbkZpeGllRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0ZpeGllJ1xuXG5leHBvcnQgZGVmYXVsdCBGaXhpZUZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpeGllLWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEZvb2QgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgRm9vZEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlNhdHVyYXRpb24oe1xuICAgICAgc2F0dXJhdGlvbjogMS4zNVxuICAgIH0pKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICBjb250cmFzdDogMS4xXG4gICAgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Gb29kRmlsdGVyLmlkZW50aWZpZXIgPSAnZm9vZCdcblxuRm9vZEZpbHRlci5kaXNwbGF5TmFtZSA9ICdGb29kJ1xuXG5leHBvcnQgZGVmYXVsdCBGb29kRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvZm9vZC1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBGcmlkZ2UgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgRnJpZGdlRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDldLFxuICAgICAgICAgIFsyMSwgMTFdLFxuICAgICAgICAgIFs0NSwgMjRdLFxuICAgICAgICAgIFsyNTUsIDIyMF1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgMTJdLFxuICAgICAgICAgIFsyMSwgMjFdLFxuICAgICAgICAgIFs0MiwgNDJdLFxuICAgICAgICAgIFsxNTAsIDE1MF0sXG4gICAgICAgICAgWzE3MCwgMTczXSxcbiAgICAgICAgICBbMjU1LCAyMTBdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMjhdLFxuICAgICAgICAgIFs0MywgNzJdLFxuICAgICAgICAgIFsxMjgsIDE4NV0sXG4gICAgICAgICAgWzI1NSwgMjIwXVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5GcmlkZ2VGaWx0ZXIuaWRlbnRpZmllciA9ICdmcmlkZ2UnXG5cbkZyaWRnZUZpbHRlci5kaXNwbGF5TmFtZSA9ICdGcmlkZ2UnXG5cbmV4cG9ydCBkZWZhdWx0IEZyaWRnZUZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZyaWRnZS1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBGcm9udCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBGcm9udEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCA2NV0sXG4gICAgICAgICAgWzI4LCA2N10sXG4gICAgICAgICAgWzY3LCAxMTNdLFxuICAgICAgICAgIFsxMjUsIDE4M10sXG4gICAgICAgICAgWzE4NywgMjE3XSxcbiAgICAgICAgICBbMjU1LCAyMjldXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDUyXSxcbiAgICAgICAgICBbNDIsIDU5XSxcbiAgICAgICAgICBbMTA0LCAxMzRdLFxuICAgICAgICAgIFsxNjksIDIwOV0sXG4gICAgICAgICAgWzI1NSwgMjQwXVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDUyXSxcbiAgICAgICAgICBbNjUsIDY4XSxcbiAgICAgICAgICBbOTMsIDEwNF0sXG4gICAgICAgICAgWzE1MCwgMTUzXSxcbiAgICAgICAgICBbMjU1LCAxOThdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkZyb250RmlsdGVyLmlkZW50aWZpZXIgPSAnZnJvbnQnXG5cbkZyb250RmlsdGVyLmRpc3BsYXlOYW1lID0gJ0Zyb250J1xuXG5leHBvcnQgZGVmYXVsdCBGcm9udEZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2Zyb250LWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEdsYW0gRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgR2xhbUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuQ29udHJhc3Qoe1xuICAgICAgY29udHJhc3Q6IDEuMVxuICAgIH0pKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzk0LCA3NF0sXG4gICAgICAgICAgWzE4MSwgMjA1XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxMjcsIDEyN10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxMDIsIDczXSxcbiAgICAgICAgICBbMjI3LCAyMTNdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuR2xhbUZpbHRlci5pZGVudGlmaWVyID0gJ2dsYW0nXG5cbkdsYW1GaWx0ZXIuZGlzcGxheU5hbWUgPSAnR2xhbSdcblxuZXhwb3J0IGRlZmF1bHQgR2xhbUZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2dsYW0tZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogR29iYmxpbiBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBHb2JibGluRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Hb2JibGluKCkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Hb2JibGluRmlsdGVyLmlkZW50aWZpZXIgPSAnZ29iYmxpbidcblxuR29iYmxpbkZpbHRlci5kaXNwbGF5TmFtZSA9ICdHb2JibGluJ1xuXG5leHBvcnQgZGVmYXVsdCBHb2JibGluRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvZ29iYmxpbi1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBLMSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBLMUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICBjb250cm9sUG9pbnRzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzUzLCAzMl0sXG4gICAgICAgIFs5MSwgODBdLFxuICAgICAgICBbMTc2LCAyMDVdLFxuICAgICAgICBbMjU1LCAyNTVdXG4gICAgICBdXG4gICAgfSkpXG5cbiAgICAvLyBTYXR1cmF0aW9uXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5TYXR1cmF0aW9uKHtcbiAgICAgIHNhdHVyYXRpb246IDAuOVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuSzFGaWx0ZXIuaWRlbnRpZmllciA9ICdrMSdcblxuSzFGaWx0ZXIuZGlzcGxheU5hbWUgPSAnSzEnXG5cbmV4cG9ydCBkZWZhdWx0IEsxRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvazEtZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi4vLi4vbGliL2NvbG9yJ1xuXG4vKipcbiAqIEsyIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEsyRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIGNvbnRyb2xQb2ludHM6IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbNTQsIDMzXSxcbiAgICAgICAgWzc3LCA4Ml0sXG4gICAgICAgIFs5NCwgMTAzXSxcbiAgICAgICAgWzEyMiwgMTI2XSxcbiAgICAgICAgWzE3NywgMTkzXSxcbiAgICAgICAgWzIyOSwgMjMyXSxcbiAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgXVxuICAgIH0pKVxuXG4gICAgLy8gU29mdCBjb2xvciBvdmVybGF5XG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Tb2Z0Q29sb3JPdmVybGF5KHtcbiAgICAgIGNvbG9yOiBuZXcgQ29sb3IoNDAgLyAyNTUsIDQwIC8gMjU1LCA0MCAvIDI1NSlcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbksyRmlsdGVyLmlkZW50aWZpZXIgPSAnazInXG5cbksyRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0syJ1xuXG5leHBvcnQgZGVmYXVsdCBLMkZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2syLWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEs2IEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEs2RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gU2F0dXJhdGlvblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjVcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbks2RmlsdGVyLmlkZW50aWZpZXIgPSAnazYnXG5cbks2RmlsdGVyLmRpc3BsYXlOYW1lID0gJ0s2J1xuXG5leHBvcnQgZGVmYXVsdCBLNkZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2s2LWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEtEeW5hbWljIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEtEeW5hbWljRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIGNvbnRyb2xQb2ludHM6IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMTcsIDI3XSxcbiAgICAgICAgWzQ2LCA2OV0sXG4gICAgICAgIFs5MCwgMTEyXSxcbiAgICAgICAgWzE1NiwgMjAwXSxcbiAgICAgICAgWzIwMywgMjQzXSxcbiAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgXVxuICAgIH0pKVxuXG4gICAgLy8gU2F0dXJhdGlvblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjdcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbktEeW5hbWljRmlsdGVyLmlkZW50aWZpZXIgPSAna2R5bmFtaWMnXG5cbktEeW5hbWljRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0tEeW5hbWljJ1xuXG5leHBvcnQgZGVmYXVsdCBLRHluYW1pY0ZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2tkeW5hbWljLWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIExlbmluIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIExlbmluRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gRGVzYXR1cmF0aW9uXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5EZXNhdHVyYXRpb24oe1xuICAgICAgZGVzYXR1cmF0aW9uOiAwLjRcbiAgICB9KSlcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCAyMF0sXG4gICAgICAgICAgWzQwLCAyMF0sXG4gICAgICAgICAgWzEwNiwgMTExXSxcbiAgICAgICAgICBbMTI5LCAxNTNdLFxuICAgICAgICAgIFsxOTAsIDIyM10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAyMF0sXG4gICAgICAgICAgWzQwLCAyMF0sXG4gICAgICAgICAgWzYyLCA0MV0sXG4gICAgICAgICAgWzEwNiwgMTA4XSxcbiAgICAgICAgICBbMTMyLCAxNTldLFxuICAgICAgICAgIFsyMDMsIDIzN10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDQwXSxcbiAgICAgICAgICBbNDAsIDQwXSxcbiAgICAgICAgICBbNzMsIDYwXSxcbiAgICAgICAgICBbMTMzLCAxNjBdLFxuICAgICAgICAgIFsxOTEsIDI5N10sXG4gICAgICAgICAgWzIwMywgMjM3XSxcbiAgICAgICAgICBbMjM3LCAyMzldLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuTGVuaW5GaWx0ZXIuaWRlbnRpZmllciA9ICdsZW5pbidcblxuTGVuaW5GaWx0ZXIuZGlzcGxheU5hbWUgPSAnTGVuaW4nXG5cbmV4cG9ydCBkZWZhdWx0IExlbmluRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvbGVuaW4tZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogTG9tbyBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBMb21vRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgY29udHJvbFBvaW50czogW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFs4NywgMjBdLFxuICAgICAgICBbMTMxLCAxNTZdLFxuICAgICAgICBbMTgzLCAyMDVdLFxuICAgICAgICBbMjU1LCAyMDBdXG4gICAgICBdXG4gICAgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Mb21vRmlsdGVyLmlkZW50aWZpZXIgPSAnbG9tbydcblxuTG9tb0ZpbHRlci5kaXNwbGF5TmFtZSA9ICdMb21vJ1xuXG5leHBvcnQgZGVmYXVsdCBMb21vRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvbG9tby1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5jb25zdCB7IE9wdGlvblR5cGUgfSA9IENvbnN0YW50c1xuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIExvbW8gRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgTFVURmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fbHV0UHJpbWl0aXZlID0gbmV3IEZpbHRlclByaW1pdGl2ZXMuTG9va3VwVGFibGVJbWFnZSh7XG4gICAgICBpbWFnZTogdGhpcy5fb3B0aW9ucy5pbWFnZVxuICAgIH0pXG4gICAgdGhpcy5fc3RhY2sucHVzaCh0aGlzLl9sdXRQcmltaXRpdmUpXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuTFVURmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBpbWFnZToge1xuICAgIHR5cGU6IE9wdGlvblR5cGUuSU1BR0UsXG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgc2V0dGVyOiBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIGlmICh0aGlzLl9sdXRQcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5fbHV0UHJpbWl0aXZlLnNldEltYWdlKGltYWdlKVxuICAgICAgfVxuICAgICAgdGhpcy5zZXREaXJ0eSh0cnVlKVxuICAgICAgcmV0dXJuIGltYWdlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuTFVURmlsdGVyLmlkZW50aWZpZXIgPSAnbHV0J1xuXG5MVVRGaWx0ZXIuZGlzcGxheU5hbWUgPSAnTG9va3VwIFRhYmxlJ1xuXG5leHBvcnQgZGVmYXVsdCBMVVRGaWx0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9sdXQtZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogTWVsbG93IEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIE1lbGxvd0ZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs0MSwgODRdLFxuICAgICAgICAgIFs4NywgMTM0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsyNTUsIDIxNl1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMjU1LCAxMzFdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbk1lbGxvd0ZpbHRlci5pZGVudGlmaWVyID0gJ21lbGxvdydcblxuTWVsbG93RmlsdGVyLmRpc3BsYXlOYW1lID0gJ01lbGxvdydcblxuZXhwb3J0IGRlZmF1bHQgTWVsbG93RmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvbWVsbG93LWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuaW1wb3J0IENvbG9yTWF0cml4IGZyb20gJy4uLy4uL2xpYi9tYXRoL2NvbG9yLW1hdHJpeCdcbmltcG9ydCBDb2xvciBmcm9tICcuLi8uLi9saWIvY29sb3InXG5cbi8qKlxuICogTWV0YWwgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgTWV0YWxGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgbGV0IG1hdHJpeDEgPSBuZXcgQ29sb3JNYXRyaXgoMC44MTU4MjE4MjkxNjMwNzE2LCAwLCAwLCAwLCAtMC4wMTc3OTgxMDE4MTE5MDY0NyxcbiAgICAgIDAsIDAuODA5ODM2MDY1NTczNzcwNCwgMCwgMCwgMC4wOTE2MzkzNDQyNjIyOTUzLFxuICAgICAgMCwgMCwgMC40NTk2MzM2NzczOTMyNDAyLCAwLCAwLjEyNzYwNTc0NzgyNDMyNzA3LFxuICAgICAgMCwgMCwgMCwgMSwgMClcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLkNvbG9yTWF0cml4UHJpbWl0aXZlKHtcbiAgICAgIGNvbG9ybWF0cml4OiBtYXRyaXgxXG4gICAgfSkpXG4gICAgbGV0IGdhbW1hQ29sb3IgPSBuZXcgQ29sb3IoMC44LCAwLjYsIDAuOSlcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLkdhbW1hKHtcbiAgICAgIGdhbW1hOiBnYW1tYUNvbG9yXG4gICAgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5NZXRhbEZpbHRlci5pZGVudGlmaWVyID0gJ21ldGFsJ1xuXG5NZXRhbEZpbHRlci5kaXNwbGF5TmFtZSA9ICdNZXRhbCdcblxuZXhwb3J0IGRlZmF1bHQgTWV0YWxGaWx0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9tZXRhbC1maWx0ZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBNb3JuaW5nIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIE1vcm5pbmdGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCA0MF0sXG4gICAgICAgICAgWzI1NSwgMjMwXVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAxMF0sXG4gICAgICAgICAgWzI1NSwgMjI1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDIwXSxcbiAgICAgICAgICBbMjU1LCAxODFdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuR2xvdygpKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuTW9ybmluZ0ZpbHRlci5pZGVudGlmaWVyID0gJ21vcm5pbmcnXG5cbk1vcm5pbmdGaWx0ZXIuZGlzcGxheU5hbWUgPSAnTW9ybmluZydcblxuZXhwb3J0IGRlZmF1bHQgTW9ybmluZ0ZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL21vcm5pbmctZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogT3JjaGlkIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIE9yY2hpZEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTE1LCAxMzBdLFxuICAgICAgICAgIFsxOTUsIDIxNV0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTQ4LCAxNTNdLFxuICAgICAgICAgIFsxNzIsIDIxNV0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDQ2XSxcbiAgICAgICAgICBbNTgsIDc1XSxcbiAgICAgICAgICBbMTc4LCAyMDVdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIGNvbnRyb2xQb2ludHM6IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMTE3LCAxNTFdLFxuICAgICAgICBbMTg5LCAyMTddLFxuICAgICAgICBbMjU1LCAyNTVdXG4gICAgICBdXG4gICAgfSkpXG5cbiAgICAvLyBEZXNhdHVyYXRpb25cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLkRlc2F0dXJhdGlvbih7XG4gICAgICBkZXNhdHVyYXRpb246IDAuNjVcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbk9yY2hpZEZpbHRlci5pZGVudGlmaWVyID0gJ29yY2hpZCdcblxuT3JjaGlkRmlsdGVyLmRpc3BsYXlOYW1lID0gJ09yY2hpZCdcblxuZXhwb3J0IGRlZmF1bHQgT3JjaGlkRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvb3JjaGlkLWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFBvbGEgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgUG9sYUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs5NCwgNzRdLFxuICAgICAgICAgIFsxODEsIDIwNV0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMzQsIDM0XSxcbiAgICAgICAgICBbOTksIDc2XSxcbiAgICAgICAgICBbMTc2LCAxOTBdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTAyLCA3M10sXG4gICAgICAgICAgWzIyNywgMjEzXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjhcbiAgICB9KSlcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuQ29udHJhc3Qoe1xuICAgICAgY29udHJhc3Q6IDEuNVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuUG9sYUZpbHRlci5pZGVudGlmaWVyID0gJ3BvbGEnXG5cblBvbGFGaWx0ZXIuZGlzcGxheU5hbWUgPSAnUG9sYSBTWCdcblxuZXhwb3J0IGRlZmF1bHQgUG9sYUZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3BvbGEtZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogUG9sYTY2OSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBQb2xhNjY5RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzU2LCAxOF0sXG4gICAgICAgICAgWzE5NiwgMjA5XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDM4XSxcbiAgICAgICAgICBbNzEsIDg0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzEzMSwgMTMzXSxcbiAgICAgICAgICBbMjA0LCAyMTFdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5TYXR1cmF0aW9uKHtcbiAgICAgIHNhdHVyYXRpb246IDAuOFxuICAgIH0pKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICBjb250cmFzdDogMS41XG4gICAgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Qb2xhNjY5RmlsdGVyLmlkZW50aWZpZXIgPSAncG9sYTY2OSdcblxuUG9sYTY2OUZpbHRlci5kaXNwbGF5TmFtZSA9ICdQb2xhIDY2OSdcblxuZXhwb3J0IGRlZmF1bHQgUG9sYTY2OUZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3BvbGE2NjktZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb2xvciwgRW5naW5lLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuY29uc3QgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSwgUmVuZGVyZXJUeXBlIH0gPSBDb25zdGFudHNcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3ZlbmRvci9wcm9taXNlJ1xuXG5jbGFzcyBCbGVuZEZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uL3NoYWRlcnMvZ2VuZXJpYy9ibGVuZC5mcmFnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDYW52YXMgKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhciA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgeyBmaWx0ZXJlZENhbnZhcyB9ID0gdGhpcy5fb3B0aW9uc1xuXG4gICAgb3V0cHV0Q29udGV4dC5zYXZlKClcbiAgICBvdXRwdXRDb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIDAsIDApXG4gICAgb3V0cHV0Q29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMuX29wdGlvbnMuaW50ZW5zaXR5XG4gICAgb3V0cHV0Q29udGV4dC5kcmF3SW1hZ2UoZmlsdGVyZWRDYW52YXMsIDAsIDApXG4gICAgb3V0cHV0Q29udGV4dC5yZXN0b3JlKClcbiAgfVxufVxuXG5CbGVuZEZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgZmlsdGVyZWRJbWFnZTogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMSwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLklOVCB9LFxuICBmaWx0ZXJlZENhbnZhczogeyB0eXBlOiBPcHRpb25UeXBlLk9CSkVDVCwgZGVmYXVsdDogbnVsbCB9LFxuICBpbnRlbnNpdHk6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDEsIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5GTE9BVCB9XG59XG5cbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgdGhhdCBjYW4gY29sbGVjdCB7QGxpbmsgUHJpbWl0aXZlfSBpbnN0YW5jZXMgYW5kIHJlbmRlclxuICogdGhlIHN0YWNrXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqL1xuY2xhc3MgUHJpbWl0aXZlc1N0YWNrIHtcbiAgY29uc3RydWN0b3IgKGludGVuc2l0eSA9IDEpIHtcbiAgICB0aGlzLl9pbnRlbnNpdHkgPSBpbnRlbnNpdHlcblxuICAgIHRoaXMuX3N0YWNrID0gW11cbiAgICB0aGlzLl9kaXJ0aW5lc3MgPSB7fVxuICAgIHRoaXMuX3JlbmRlclRleHR1cmVzID0ge31cbiAgICB0aGlzLl9jb250YWluZXIgPSBuZXcgRW5naW5lLkNvbnRhaW5lcigpXG4gICAgdGhpcy5fc3ByaXRlID0gbmV3IEVuZ2luZS5TcHJpdGUoKVxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRDaGlsZCh0aGlzLl9zcHJpdGUpXG5cbiAgICB0aGlzLl9ibGVuZEZpbHRlciA9IG5ldyBCbGVuZEZpbHRlcigpXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gcHJpbWl0aXZlIHRvIHRoZSBzdGFja1xuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkZpbHRlci5QcmltaXRpdmV9IHByaW1pdGl2ZVxuICAgKi9cbiAgcHVzaCAocHJpbWl0aXZlKSB7XG4gICAgdGhpcy5fc3RhY2sucHVzaChwcmltaXRpdmUpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBzdGFja1xuICAgKi9cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuX3N0YWNrID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgc3RhY2tcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUZXh0dXJlfSBvdXRwdXRUZXh0dXJlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIHRha2VzIHRoZSBvdXRwdXQgc3ByaXRlJ3MgY3VycmVudCB0ZXh0dXJlIGFuZCByZW5kZXJzXG4gICAqICAgICAgICAgICAgICBpdCB0byB0aGlzIHN0YWNrJ3MgaW50ZXJuYWwgcmVuZGVyIHRleHR1cmUuIEl0IHRoZW4gdXNlcyB0aGVcbiAgICogICAgICAgICAgICAgIGludGVybmFsIHRleHR1cmUgYXMgYSB1bmlmb3JtIGZvciBhIGJsZW5kIHNoYWRlciBhbmQgcmVuZGVyc1xuICAgKiAgICAgICAgICAgICAgdGhlIHNwcml0ZSB3aXRoIHRoZSBvcmlnaW5hbCB0ZXh0dXJlIGFuZCB0aGUgYmxlbmQgc2hhZGVyIHRvXG4gICAqICAgICAgICAgICAgICB0aGUgb3V0cHV0VGV4dHVyZVxuICAgKi9cbiAgcmVuZGVyIChzZGssIGlucHV0VGV4dHVyZSwgb3V0cHV0VGV4dHVyZSkge1xuICAgIGlmICh0aGlzLl9zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cbiAgICBjb25zdCByZW5kZXJlciA9IHNkay5nZXRSZW5kZXJlcigpXG5cbiAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZShpbnB1dFRleHR1cmUpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIFJlbmRlclRleHR1cmUgd2UgY2FuIHJlbmRlciB0aGUgZmlsdGVyZWQgaW1hZ2UgdG9cbiAgICBsZXQgZmlsdGVyZWRSZW5kZXJUZXh0dXJlID0gdGhpcy5fcmVuZGVyVGV4dHVyZXNbcmVuZGVyZXIuaWRdXG4gICAgaWYgKCFmaWx0ZXJlZFJlbmRlclRleHR1cmUpIHtcbiAgICAgIGNvbnN0IGZyYW1lID0gc2RrLmdldFNwcml0ZSgpLmdldFRleHR1cmUoKS5nZXRGcmFtZSgpXG4gICAgICBmaWx0ZXJlZFJlbmRlclRleHR1cmUgPSBuZXcgRW5naW5lLlJlbmRlclRleHR1cmUoc2RrLmdldFJlbmRlcmVyKCksIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpXG4gICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlc1tyZW5kZXJlci5pZF0gPSBmaWx0ZXJlZFJlbmRlclRleHR1cmVcbiAgICB9XG5cbiAgICAvLyBSZXNpemUgZmlsdGVyZWQgcmVuZGVyIHRleHR1cmUgdG8gb3V0cHV0IHRleHR1cmUgZGltZW5zaW9uc1xuICAgIGNvbnN0IHRleHR1cmVEaW1lbnNpb25zID0gb3V0cHV0VGV4dHVyZS5nZXREaW1lbnNpb25zKClcbiAgICBmaWx0ZXJlZFJlbmRlclRleHR1cmUucmVzaXplVG8odGV4dHVyZURpbWVuc2lvbnMpXG5cbiAgICBjb25zdCBzaG91bGRSZW5kZXIgPSB0aGlzLmlzRGlydHlGb3JSZW5kZXJlcihyZW5kZXJlcilcbiAgICBpZiAoc2hvdWxkUmVuZGVyKSB7XG4gICAgICAvLyBVcGRhdGUgcHJpbWl0aXZlc1xuICAgICAgdGhpcy5fc3RhY2suZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBwLnVwZGF0ZShzZGspXG4gICAgICB9KVxuXG4gICAgICAvLyBTZXQgZmlsdGVyc1xuICAgICAgY29uc3QgZmlsdGVycyA9IHRoaXMuX3N0YWNrLm1hcCgocCkgPT4gcC5nZXRGaWx0ZXIoKSlcbiAgICAgIHRoaXMuX3Nwcml0ZS5zZXRGaWx0ZXJzKGZpbHRlcnMpXG5cbiAgICAgIC8vIFJlbmRlciB0byBSZW5kZXJUZXh0dXJlXG4gICAgICBmaWx0ZXJlZFJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMuX2NvbnRhaW5lcilcbiAgICAgIHRoaXMuc2V0RGlydHlGb3JSZW5kZXJlcihmYWxzZSwgcmVuZGVyZXIpXG4gICAgfVxuXG4gICAgLy8gVXNlIGZpbHRlcmVkUmVuZGVyVGV4dHVyZSBhcyB1bmlmb3JtIGZvciBibGVuZCBzaGFkZXIsIGJsZW5kIHRoZSB0d29cbiAgICAvLyB0byBhY2hpZXZlIGludGVuc2l0eVxuICAgIHRoaXMuX2JsZW5kRmlsdGVyLnNldEludGVuc2l0eSh0aGlzLl9pbnRlbnNpdHkpXG4gICAgaWYgKHJlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5DQU5WQVMpKSB7XG4gICAgICB0aGlzLl9ibGVuZEZpbHRlci5zZXRGaWx0ZXJlZENhbnZhcyhmaWx0ZXJlZFJlbmRlclRleHR1cmUuZ2V0UmVuZGVyVGFyZ2V0KCkuZ2V0Q2FudmFzKCkpXG4gICAgfSBlbHNlIGlmIChyZW5kZXJlci5pc09mVHlwZShSZW5kZXJlclR5cGUuV0VCR0wpKSB7XG4gICAgICBjb25zdCBiYXNlVGV4dHVyZSA9IGZpbHRlcmVkUmVuZGVyVGV4dHVyZS5nZXRCYXNlVGV4dHVyZSgpXG4gICAgICBiYXNlVGV4dHVyZS5zZXRHTFVuaXQodGhpcy5fYmxlbmRGaWx0ZXIuZ2V0RmlsdGVyZWRJbWFnZSgpKVxuICAgICAgcmVuZGVyZXIudXBkYXRlVGV4dHVyZShiYXNlVGV4dHVyZSwgZmFsc2UpXG4gICAgfVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRGaWx0ZXJzKFtcbiAgICAgIHRoaXMuX2JsZW5kRmlsdGVyXG4gICAgXSlcblxuICAgIG91dHB1dFRleHR1cmUuY2xlYXIoQ29sb3IuVFJBTlNQQVJFTlQpXG4gICAgb3V0cHV0VGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxuXG4gICAgaWYgKHNob3VsZFJlbmRlcikge1xuICAgICAgdGhpcy5kaXNwb3NlUmVuZGVyVGV4dHVyZXMoKVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3V0cHV0VGV4dHVyZSlcbiAgfVxuXG4gIHNldEludGVuc2l0eSAoaW50ZW5zaXR5KSB7IHRoaXMuX2ludGVuc2l0eSA9IGludGVuc2l0eSB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIG9wZXJhdGlvbiBpcyBkaXJ0eSBmb3IgdGhlIGdpdmVuIHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9ICByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNEaXJ0eUZvclJlbmRlcmVyIChyZW5kZXJlcikge1xuICAgIGlmICghKHJlbmRlcmVyLmlkIGluIHRoaXMuX2RpcnRpbmVzcykpIHtcbiAgICAgIHRoaXMuX2RpcnRpbmVzc1tyZW5kZXJlci5pZF0gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kaXJ0aW5lc3NbcmVuZGVyZXIuaWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGlydGluZXNzIGZvciB0aGUgZ2l2ZW4gcmVuZGVyZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBkaXJ0eVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICBzZXREaXJ0eUZvclJlbmRlcmVyIChkaXJ0eSwgcmVuZGVyZXIpIHtcbiAgICB0aGlzLl9kaXJ0aW5lc3NbcmVuZGVyZXIuaWRdID0gZGlydHlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkaXJ0aW5lc3MgZm9yIGFsbCByZW5kZXJlcnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBkaXJ0eVxuICAgKi9cbiAgc2V0RGlydHkgKGRpcnR5KSB7XG4gICAgZm9yIChsZXQgcmVuZGVyZXJJZCBpbiB0aGlzLl9kaXJ0aW5lc3MpIHtcbiAgICAgIHRoaXMuX2RpcnRpbmVzc1tyZW5kZXJlcklkXSA9IGRpcnR5XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoZSByZW5kZXIgdGV4dHVyZXMsIGZyZWVzIHNvbWUgbWVtb3J5XG4gICAqL1xuICBkaXNwb3NlUmVuZGVyVGV4dHVyZXMgKCkge1xuICAgIGZvciAobGV0IHJlbmRlcmVySWQgaW4gdGhpcy5fcmVuZGVyVGV4dHVyZXMpIHtcbiAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVzW3JlbmRlcmVySWRdLmRpc3Bvc2UoKVxuICAgICAgZGVsZXRlIHRoaXMuX3JlbmRlclRleHR1cmVzW3JlbmRlcmVySWRdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGlzIGluc3RhbmNlXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSZW5kZXJUZXh0dXJlcygpXG4gICAgdGhpcy5fc3RhY2suZm9yRWFjaCgocHJpbWl0aXZlKSA9PiBwcmltaXRpdmUuZGlzcG9zZSgpKVxuICAgIHRoaXMuX3N0YWNrID0gW11cbiAgICB0aGlzLl9ibGVuZEZpbHRlci5kaXNwb3NlKClcblxuICAgIHRoaXMuX3Nwcml0ZS5kaXNwb3NlKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcmltaXRpdmVzU3RhY2tcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzLXN0YWNrLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBFbmdpbmUgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL3ByaW1pdGl2ZSdcbmltcG9ydCB7IE9wdGlvblR5cGUsIFVuaWZvcm1UeXBlIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzJ1xuXG5jbGFzcyBCcmlnaHRuZXNzRmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vLi4vc2hhZGVycy9wcmltaXRpdmVzL2JyaWdodG5lc3MuZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgbGV0IHsgYnJpZ2h0bmVzcyB9ID0gdGhpcy5fb3B0aW9uc1xuXG4gICAgaWYgKGJyaWdodG5lc3MgPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBicmlnaHRuZXNzID0gYnJpZ2h0bmVzcyAqIDI1NVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYW52YXMud2lkdGggKiBjYW52YXMuaGVpZ2h0OyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDRcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSArPSBicmlnaHRuZXNzXG4gICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdICs9IGJyaWdodG5lc3NcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gKz0gYnJpZ2h0bmVzc1xuICAgIH1cblxuICAgIG91dHB1dENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMClcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgZmlsdGVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5CcmlnaHRuZXNzRmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBicmlnaHRuZXNzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQgfVxufVxuXG4vKipcbiAqIEJyaWdodG5lc3MgcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlcnMuUHJpbWl0aXZlXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5jbGFzcyBCcmlnaHRuZXNzIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBCcmlnaHRuZXNzRmlsdGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBmaWx0ZXIncyB1bmlmb3Jtc1xuICAgKi9cbiAgdXBkYXRlICgpIHtcbiAgICB0aGlzLl9maWx0ZXIuc2V0QnJpZ2h0bmVzcyh0aGlzLl9vcHRpb25zLmJyaWdodG5lc3MpXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIHByaW1pdGl2ZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuQnJpZ2h0bmVzcy5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IEJyaWdodG5lc3NGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQgQnJpZ2h0bmVzc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvYnJpZ2h0bmVzcy5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgRW5naW5lLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL3ByaW1pdGl2ZSdcbmltcG9ydCBDb2xvciBmcm9tICcuLi8uLi8uLi9saWIvY29sb3InXG5pbXBvcnQgQ29sb3JNYXRyaXggZnJvbSAnLi4vLi4vLi4vbGliL21hdGgvY29sb3ItbWF0cml4J1xuY29uc3QgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSB9ID0gQ29uc3RhbnRzXG5cbmNsYXNzIENvbG9yTWF0cml4RmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vLi4vc2hhZGVycy9wcmltaXRpdmVzL2NvbG9yLW1hdHJpeC5mcmFnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDYW52YXMgKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhciA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBpbnB1dENvbnRleHQgPSBpbnB1dFRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgICBsZXQgeyBjb2xvcm1hdHJpeCB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIGxldCBjb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAwKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYW52YXMud2lkdGggKiBjYW52YXMuaGVpZ2h0OyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDRcbiAgICAgIGNvbG9yLnIgPSBpbWFnZURhdGEuZGF0YVtpbmRleF1cbiAgICAgIGNvbG9yLmcgPSBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdXG4gICAgICBjb2xvci5iID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXVxuICAgICAgY29sb3IuYSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgM11cbiAgICAgIGNvbG9yID0gY29sb3JtYXRyaXguYXBwbHkoY29sb3IpXG4gICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSBjb2xvci5yXG4gICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdID0gY29sb3IuZ1xuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGNvbG9yLmJcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgM10gPSBjb2xvci5hXG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBjb2xvcm1hdHJpeDogeyB0eXBlOiBPcHRpb25UeXBlLkNPTE9SX01BVFJJWCwgZGVmYXVsdDogbmV3IENvbG9yTWF0cml4KCksIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5NQVQ0IH1cbn1cblxuLyoqXG4gKiBDb2xvck1hdHJpeCBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJQcmltaXRpdmVzXG4gKi9cbmNsYXNzIENvbG9yTWF0cml4UHJpbWl0aXZlIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBDb2xvck1hdHJpeEZpbHRlcigpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZmlsdGVyJ3MgdW5pZm9ybXNcbiAgICovXG4gIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fZmlsdGVyLnNldENvbG9ybWF0cml4KHRoaXMuX29wdGlvbnMuY29sb3JtYXRyaXgpXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIHByaW1pdGl2ZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuQ29sb3JNYXRyaXhQcmltaXRpdmUucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSBDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9uc1xuXG5leHBvcnQgZGVmYXVsdCBDb2xvck1hdHJpeFByaW1pdGl2ZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvY29sb3ItbWF0cml4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMsIEVuZ2luZSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlJ1xuY29uc3QgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSB9ID0gQ29uc3RhbnRzXG5cbmNsYXNzIENvbnRyYXN0RmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vLi4vc2hhZGVycy9wcmltaXRpdmVzL2NvbnRyYXN0LmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGxldCB7IGNvbnRyYXN0IH0gPSB0aGlzLl9vcHRpb25zXG4gICAgaWYgKGNvbnRyYXN0ID09PSAxKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQ7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBpICogNFxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gKGltYWdlRGF0YS5kYXRhW2luZGV4XSAtIDEyNykgKiBjb250cmFzdCArIDEyN1xuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IChpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdIC0gMTI3KSAqIGNvbnRyYXN0ICsgMTI3XG4gICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gKGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gLSAxMjcpICogY29udHJhc3QgKyAxMjdcbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuQ29udHJhc3RGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGNvbnRyYXN0OiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAxLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQgfVxufVxuXG4vKipcbiAqIENvbnRyYXN0IHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJzLlByaW1pdGl2ZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuY2xhc3MgQ29udHJhc3QgZXh0ZW5kcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9maWx0ZXIgPSBuZXcgQ29udHJhc3RGaWx0ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGZpbHRlcidzIHVuaWZvcm1zXG4gICAqL1xuICB1cGRhdGUgKCkge1xuICAgIHRoaXMuX2ZpbHRlci5zZXRDb250cmFzdCh0aGlzLl9vcHRpb25zLmNvbnRyYXN0KVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBwcmltaXRpdmVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbkNvbnRyYXN0LnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0gQ29udHJhc3RGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQgQ29udHJhc3RcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2NvbnRyYXN0LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRW5naW5lIGZyb20gJy4uLy4uLy4uL2VuZ2luZS8nXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlJ1xuaW1wb3J0IHsgT3B0aW9uVHlwZSwgVW5pZm9ybVR5cGUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMnXG5cbmNsYXNzIERlc2F0dXJhdGlvbkZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uLy4uL3NoYWRlcnMvcHJpbWl0aXZlcy9kZXNhdHVyYXRpb24uZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgY29uc3QgeyBkZXNhdHVyYXRpb24gfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0XG4gICAgICB2YXIgbHVtaW5hbmNlID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogMC4zICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIDAuNTkgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogMC4xMVxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gbHVtaW5hbmNlICogKDEgLSBkZXNhdHVyYXRpb24pICsgKGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIGRlc2F0dXJhdGlvbilcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBsdW1pbmFuY2UgKiAoMSAtIGRlc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIGRlc2F0dXJhdGlvbilcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBsdW1pbmFuY2UgKiAoMSAtIGRlc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAqIGRlc2F0dXJhdGlvbilcbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuRGVzYXR1cmF0aW9uRmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBkZXNhdHVyYXRpb246IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDEsIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5GTE9BVCB9XG59XG5cbi8qKlxuICogRGVzYXR1cmF0aW9uIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJzLlByaW1pdGl2ZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuY2xhc3MgRGVzYXR1cmF0aW9uIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fZmlsdGVyID0gbmV3IERlc2F0dXJhdGlvbkZpbHRlcigpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZmlsdGVyJ3MgdW5pZm9ybXNcbiAgICovXG4gIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fZmlsdGVyLnNldERlc2F0dXJhdGlvbih0aGlzLl9vcHRpb25zLmRlc2F0dXJhdGlvbilcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgcHJpbWl0aXZlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5EZXNhdHVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSBEZXNhdHVyYXRpb25GaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQgRGVzYXR1cmF0aW9uXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9kZXNhdHVyYXRpb24uanMiLCIvKlxuKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbipcbiogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4qIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuKlxuKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiovXG5cbmltcG9ydCB7IEVuZ2luZSwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBQcmltaXRpdmUgZnJvbSAnLi9wcmltaXRpdmUnXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi4vLi4vLi4vbGliL2NvbG9yJ1xuY29uc3QgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSB9ID0gQ29uc3RhbnRzXG5cbmNsYXNzIEdhbW1hRmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vLi4vc2hhZGVycy9wcmltaXRpdmVzL2dhbW1hLmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxuICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBfYXBwbHlDYW52YXMgKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhciA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBpbnB1dENvbnRleHQgPSBpbnB1dFRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgICBsZXQgeyBnYW1tYSB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIC8vIHByZSBjYWxjdWxhdGUgbG9va3VwIHRhYmxlcyBmb3IgZWFjaCBjaGFubmVsXG4gICAgbGV0IGdhbW1hQXJyYXlSZWQgPSBuZXcgRmxvYXQzMkFycmF5KDI1NilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBnYW1tYUFycmF5UmVkW2ldID0gMjU1LjAgKiBNYXRoLnBvdygoaSAvIDI1NS4wKSwgZ2FtbWEucilcbiAgICB9XG5cbiAgICBsZXQgZ2FtbWFBcnJheUdyZWVuID0gbmV3IEZsb2F0MzJBcnJheSgyNTYpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgZ2FtbWFBcnJheUdyZWVuW2ldID0gMjU1LjAgKiBNYXRoLnBvdygoaSAvIDI1NS4wKSwgZ2FtbWEuZylcbiAgICB9XG5cbiAgICBsZXQgZ2FtbWFBcnJheUJsdWUgPSBuZXcgRmxvYXQzMkFycmF5KDI1NilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBnYW1tYUFycmF5Qmx1ZVtpXSA9IDI1NS4wICogTWF0aC5wb3coKGkgLyAyNTUuMCksIGdhbW1hLmIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYW52YXMud2lkdGggKiBjYW52YXMuaGVpZ2h0OyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDRcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGdhbW1hQXJyYXlSZWRbaW1hZ2VEYXRhLmRhdGFbaW5kZXhdXVxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGdhbW1hQXJyYXlHcmVlbltpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdXVxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGdhbW1hQXJyYXlCbHVlW2ltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl1dXG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbi8qKlxuKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAaWdub3JlXG4qL1xuR2FtbWFGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGdhbW1hOiB7IHR5cGU6IE9wdGlvblR5cGUuQ09MT1IsIGRlZmF1bHQ6IENvbG9yLldISVRFLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQzIH1cbn1cblxuLyoqXG4qIEdhbW1hIHByaW1pdGl2ZVxuKiBAY2xhc3NcbiogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVcbiogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiovXG5jbGFzcyBHYW1tYSBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl9maWx0ZXIgPSBuZXcgR2FtbWFGaWx0ZXIoKVxuICB9XG5cbiAgLyoqXG4gICogVXBkYXRlcyB0aGUgZmlsdGVyJ3MgdW5pZm9ybXNcbiAgKi9cbiAgdXBkYXRlICgpIHtcbiAgICB0aGlzLl9maWx0ZXIuc2V0R2FtbWEodGhpcy5fb3B0aW9ucy5nYW1tYSlcbiAgfVxufVxuXG4vKipcbiogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBwcmltaXRpdmVcbiogQHR5cGUge09iamVjdH1cbiogQGlnbm9yZVxuKi9cbkdhbW1hLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0gR2FtbWFGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQgR2FtbWFcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2dhbW1hLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlJ1xuaW1wb3J0IENvbG9yIGZyb20gJy4uLy4uLy4uL2xpYi9jb2xvcidcbmltcG9ydCB7IEVuZ2luZSwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmNvbnN0IHsgT3B0aW9uVHlwZSwgVW5pZm9ybVR5cGUgfSA9IENvbnN0YW50c1xuXG5jbGFzcyBHbG93RmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vLi4vc2hhZGVycy9wcmltaXRpdmVzL2dsb3cuZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgY29uc3QgeyBjb2xvciB9ID0gdGhpcy5fb3B0aW9uc1xuXG4gICAgdmFyIGRcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNFxuXG4gICAgICAgIHZhciB4MDEgPSB4IC8gY2FudmFzLndpZHRoXG4gICAgICAgIHZhciB5MDEgPSB5IC8gY2FudmFzLmhlaWdodFxuXG4gICAgICAgIHZhciBueCA9ICh4MDEgLSAwLjUpIC8gMC43NVxuICAgICAgICB2YXIgbnkgPSAoeTAxIC0gMC41KSAvIDAuNzVcblxuICAgICAgICB2YXIgc2NhbGFyWCA9IG54ICogbnhcbiAgICAgICAgdmFyIHNjYWxhclkgPSBueSAqIG55XG4gICAgICAgIGQgPSAxIC0gKHNjYWxhclggKyBzY2FsYXJZKVxuICAgICAgICBkID0gTWF0aC5taW4oTWF0aC5tYXgoZCwgMC4xKSwgMS4wKVxuXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIChkICogY29sb3IucilcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAoZCAqIGNvbG9yLmcpXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogKGQgKiBjb2xvci5iKVxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDNdID0gMjU1XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbkdsb3dGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGNvbG9yOiB7IHR5cGU6IE9wdGlvblR5cGUuQ09MT1IsIGRlZmF1bHQ6IENvbG9yLldISVRFLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQzIH1cbn1cblxuLyoqXG4gKiBHbG93IHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJzLlByaW1pdGl2ZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuY2xhc3MgR2xvdyBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBHbG93RmlsdGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBmaWx0ZXIncyB1bmlmb3Jtc1xuICAgKi9cbiAgdXBkYXRlICgpIHtcbiAgICB0aGlzLl9maWx0ZXIuc2V0Q29sb3IodGhpcy5fb3B0aW9ucy5jb2xvcilcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgcHJpbWl0aXZlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5HbG93LnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0gR2xvd0ZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9uc1xuXG5leHBvcnQgZGVmYXVsdCBHbG93XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9nbG93LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRW5naW5lIGZyb20gJy4uLy4uLy4uL2VuZ2luZS8nXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlJ1xuXG5jbGFzcyBHb2JibGluRmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vLi4vc2hhZGVycy9wcmltaXRpdmVzL2dvYmJsaW4uZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDRcblxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIDAuMzNcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogMC42XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gKz0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogMC4zM1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIDAuN1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDNdID0gMjU1XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbi8qKlxuICogR29iYmxpbiBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJQcmltaXRpdmVzXG4gKi9cbmNsYXNzIEdvYmJsaW4gZXh0ZW5kcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fZmlsdGVyID0gbmV3IEdvYmJsaW5GaWx0ZXIoKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdvYmJsaW5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2dvYmJsaW4uanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBFbmdpbmUgZnJvbSAnLi4vLi4vLi4vZW5naW5lLydcbmltcG9ydCBQcmltaXRpdmUgZnJvbSAnLi9wcmltaXRpdmUnXG5cbmNsYXNzIEdyYXlzY2FsZUZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uLy4uL3NoYWRlcnMvcHJpbWl0aXZlcy9ncmF5c2NhbGUuZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDRcblxuICAgICAgICB2YXIgbHVtaW5hbmNlID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogMC4yMTI1ICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIDAuNzE1NCArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gKiAwLjA3MjFcblxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSBsdW1pbmFuY2VcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGx1bWluYW5jZVxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gbHVtaW5hbmNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbi8qKlxuICogR3JheXNjYWxlIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJzLlByaW1pdGl2ZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuY2xhc3MgR3JheXNjYWxlIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBHcmF5c2NhbGVGaWx0ZXIoKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdyYXlzY2FsZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZ3JheXNjYWxlLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5jb25zdCBURVhUVVJFX0dMX1VOSVQgPSAzXG5cbmltcG9ydCB7IFV0aWxzLCBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBFbmdpbmUgZnJvbSAnLi4vLi4vLi4vZW5naW5lLydcbmltcG9ydCBQcmltaXRpdmUgZnJvbSAnLi9wcmltaXRpdmUnXG5pbXBvcnQgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSwgUmVuZGVyZXJUeXBlIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzJ1xuXG5jbGFzcyBMb29rdXBUYWJsZUltYWdlRmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fcHJlY29tcHV0ZVF1YWRzKClcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuLi8uLi8uLi9zaGFkZXJzL3ByaW1pdGl2ZXMvbG9va3VwLXRhYmxlLWltYWdlLmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcHJlLWNhbGN1bGF0ZXMgYW4gYXJyYXkgdGhhdCBob2xkcyBxdWFkcyBmb3IgZWFjaFxuICAgKiBvZiB0aGUgMjU2IHBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgYmx1ZSBjaGFubmVsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJlY29tcHV0ZVF1YWRzICgpIHtcbiAgICB0aGlzLl9xdWFkcyA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgY29uc3QgYmx1ZUNvbG9yID0gaSAvIDI1NSAqIDYzXG4gICAgICBsZXQgcXVhZCA9IG5ldyBWZWN0b3IyKClcblxuICAgICAgcXVhZC55ID0gKChibHVlQ29sb3IgfCAwKSAqIDAuMTI1KSB8IDBcbiAgICAgIHF1YWQueCA9IChibHVlQ29sb3IgfCAwKSAtIChxdWFkLnkgKiA4KVxuICAgICAgdGhpcy5fcXVhZHMucHVzaChxdWFkKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDYW52YXMgKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhciA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBpbnB1dENvbnRleHQgPSBpbnB1dFRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgbHV0SW1hZ2UgPSB0aGlzLl9vcHRpb25zLmxvb2t1cFRhYmxlSW1hZ2VcbiAgICBjb25zdCBsdXRDYW52YXMgPSB0aGlzLl9jcmVhdGVJbWFnZUNhbnZhcyhsdXRJbWFnZSlcbiAgICBjb25zdCBsdXRDb250ZXh0ID0gbHV0Q2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGNvbnN0IGlucHV0SW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gICAgY29uc3QgZmlsdGVySW1hZ2VEYXRhID0gbHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgbHV0SW1hZ2Uud2lkdGgsIGx1dEltYWdlLmhlaWdodClcblxuICAgIGxldCB0ZXhDb29yZCA9IG5ldyBWZWN0b3IyKClcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodCAqIDQ7IGluZGV4ICs9IDQpIHtcbiAgICAgIGNvbnN0IHIgPSBpbnB1dEltYWdlRGF0YS5kYXRhW2luZGV4XVxuICAgICAgY29uc3QgZyA9IGlucHV0SW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXVxuICAgICAgY29uc3QgYiA9IGlucHV0SW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXVxuICAgICAgY29uc3QgYSA9IGlucHV0SW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAzXSAvIDI1NVxuICAgICAgY29uc3QgcXVhZCA9IHRoaXMuX3F1YWRzW2JdXG5cbiAgICAgIC8vIDY0IHNpbmNlIHdlIGhhdmUgOHg4IHRpbGVzIG9uIGEgNTEyeDUxMiB0ZXh0dXJlLlxuICAgICAgY29uc3QgdGlsZVNpZGVMZW5ndGggPSA2NFxuXG4gICAgICAvLyBjYWxjdWxhdGUgcGl4ZWwgcG9zaXRpb24gb2YgdGhlIGNvb3JkaW5hdGUgb3JpZ2luLlxuICAgICAgdGV4Q29vcmQueCA9IHF1YWQueCAqIHRpbGVTaWRlTGVuZ3RoXG4gICAgICB0ZXhDb29yZC55ID0gcXVhZC55ICogdGlsZVNpZGVMZW5ndGhcblxuICAgICAgLy8gbm93IGxvb2t1cCB0aGUgY29ycmVjdCBjb2xvciB3aXRoaW4gdGhlIHRpbGUuXG4gICAgICAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIHBpeGVsIGlzIGluZGljYXRlZCBieSB0aGUgdmVjdG9yLFxuICAgICAgLy8gaW5kdWNlZCBieSB0aGUgY29tYmluYXRpb24gb2YgdGhlIHJlZCBhbmQgZ3JlZW4gdmVjdG9yLlxuICAgICAgdGV4Q29vcmQueCArPSBNYXRoLmZsb29yKHIgLyA0KSAvLyByIC8gMjU2ICogNjQgPSByIC8gNFxuICAgICAgdGV4Q29vcmQueSArPSBNYXRoLmZsb29yKGcgLyA0KSAvLyBnIC8gMjU2ICogNjQgPSByIC8gNFxuXG4gICAgICBjb25zdCB0ZXhDb29yZEluZGV4ID0gKCgobHV0SW1hZ2Uud2lkdGggKiB0ZXhDb29yZC55KSArIHRleENvb3JkLngpICogNCkgfCAwXG4gICAgICBsZXQgbmV3UiA9IGZpbHRlckltYWdlRGF0YS5kYXRhW3RleENvb3JkSW5kZXhdXG4gICAgICBuZXdSID0gciAqICgxIC0gYSkgKyBuZXdSICogYVxuICAgICAgbGV0IG5ld0cgPSBmaWx0ZXJJbWFnZURhdGEuZGF0YVt0ZXhDb29yZEluZGV4ICsgMV1cbiAgICAgIG5ld0cgPSBnICogKDEgLSBhKSArIG5ld0cgKiBhXG4gICAgICBsZXQgbmV3QiA9IGZpbHRlckltYWdlRGF0YS5kYXRhW3RleENvb3JkSW5kZXggKyAyXVxuICAgICAgbmV3QiA9IGIgKiAoMSAtIGEpICsgbmV3QiAqIGFcbiAgICAgIGlucHV0SW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gbmV3UlxuICAgICAgaW5wdXRJbWFnZURhdGEuZGF0YVtpbmRleCArIDFdID0gbmV3R1xuICAgICAgaW5wdXRJbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gbmV3QlxuICAgIH1cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbnB1dEltYWdlRGF0YSwgMCwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FudmFzIHdpdGggdGhlIGdpdmVuIGltYWdlXG4gICAqIEBwYXJhbSAge0ltYWdlfSBpbWFnZVxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVJbWFnZUNhbnZhcyAoaW1hZ2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBVdGlscy5jcmVhdGVDYW52YXMoKVxuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodFxuXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApXG5cbiAgICByZXR1cm4gY2FudmFzXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuTG9va3VwVGFibGVJbWFnZUZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgbG9va3VwVGFibGU6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IFRFWFRVUkVfR0xfVU5JVCwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLklOVCB9LFxuICBsb29rdXBUYWJsZUltYWdlOiB7IHR5cGU6IE9wdGlvblR5cGUuSU1BR0UsIHVuaWZvcm1UeXBlOiBudWxsIH1cbn1cblxuLyoqXG4gKiBTdG9yZXMgYSAyNTYgYnl0ZSBsb25nIGxvb2t1cCB0YWJsZSBpbiBhIDJkIHRleHR1cmUgd2hpY2ggd2lsbCBiZVxuICogdXNlZCB0byBsb29rIHVwIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciBlYWNoIGNoYW5uZWwuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlcnMuUHJpbWl0aXZlXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5jbGFzcyBMb29rdXBUYWJsZUltYWdlIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fZmlsdGVyID0gbmV3IExvb2t1cFRhYmxlSW1hZ2VGaWx0ZXIoKVxuICAgIHRoaXMuX3RleHR1cmVzID0ge31cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBiZWZvcmUgdGhpcyBwcmltaXRpdmUncyBmaWx0ZXIgaXMgYmVpbmcgYXBwbGllZFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICovXG4gIHVwZGF0ZSAoc2RrKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChyZW5kZXJlci5pc09mVHlwZShSZW5kZXJlclR5cGUuV0VCR0wpKSB7XG4gICAgICB0aGlzLl91cGRhdGVXZWJHTFRleHR1cmUoc2RrKVxuICAgIH0gZWxzZSBpZiAocmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLkNBTlZBUykpIHtcbiAgICAgIHRoaXMuX2ZpbHRlci5zZXRMb29rdXBUYWJsZUltYWdlKHRoaXMuX29wdGlvbnMuaW1hZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGxvb2t1cCB0YWJsZSB0ZXh0dXJlIChXZWJHTCBvbmx5KVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF91cGRhdGVXZWJHTFRleHR1cmUgKHNkaykge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gc2RrLmdldFJlbmRlcmVyKClcbiAgICBjb25zdCB7IGlkIH0gPSByZW5kZXJlclxuICAgIGlmICghdGhpcy5fdGV4dHVyZXNbaWRdKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlc1tpZF0gPSBuZXcgRW5naW5lLkJhc2VUZXh0dXJlKClcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZXNbaWRdXG4gICAgdGV4dHVyZS5zZXRTb3VyY2UodGhpcy5fb3B0aW9ucy5pbWFnZSlcbiAgICB0ZXh0dXJlLnNldEdMVW5pdChURVhUVVJFX0dMX1VOSVQpXG5cbiAgICByZW5kZXJlci51cGRhdGVUZXh0dXJlKHRleHR1cmUpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHRoaXMgcHJpbWl0aXZlXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICBzdXBlci5kaXNwb3NlKClcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLl90ZXh0dXJlcykge1xuICAgICAgZGVsZXRlIHRoaXMuX3RleHR1cmVzW2lkXVxuICAgIH1cbiAgfVxufVxuXG5Mb29rdXBUYWJsZUltYWdlLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBpbWFnZTogeyB0eXBlOiBPcHRpb25UeXBlLklNQUdFIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTG9va3VwVGFibGVJbWFnZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvbG9va3VwLXRhYmxlLWltYWdlLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlJ1xuaW1wb3J0IHsgQ29uc3RhbnRzLCBFbmdpbmUgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuY29uc3QgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSB9ID0gQ29uc3RhbnRzXG5cbmNsYXNzIFNhdHVyYXRpb25GaWx0ZXIgZXh0ZW5kcyBFbmdpbmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuLi8uLi8uLi9zaGFkZXJzL3ByaW1pdGl2ZXMvc2F0dXJhdGlvbi5mcmFnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDYW52YXMgKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhciA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBpbnB1dENvbnRleHQgPSBpbnB1dFRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gICAgY29uc3QgeyBzYXR1cmF0aW9uIH0gPSB0aGlzLl9vcHRpb25zXG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNFxuXG4gICAgICAgIHZhciBsdW1pbmFuY2UgPSBpbWFnZURhdGEuZGF0YVtpbmRleF0gKiAwLjIxMjUgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdICogMC43MTU0ICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAqIDAuMDcyMVxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSBsdW1pbmFuY2UgKiAoMSAtIHNhdHVyYXRpb24pICsgKGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIHNhdHVyYXRpb24pXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBsdW1pbmFuY2UgKiAoMSAtIHNhdHVyYXRpb24pICsgKGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiBzYXR1cmF0aW9uKVxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gbHVtaW5hbmNlICogKDEgLSBzYXR1cmF0aW9uKSArIChpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogc2F0dXJhdGlvbilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuU2F0dXJhdGlvbkZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgc2F0dXJhdGlvbjogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMCwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUIH1cbn1cblxuLyoqXG4gKiBTYXR1cmF0aW9uIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJzLlByaW1pdGl2ZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuY2xhc3MgU2F0dXJhdGlvbiBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBTYXR1cmF0aW9uRmlsdGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBmaWx0ZXIncyB1bmlmb3Jtc1xuICAgKi9cbiAgdXBkYXRlICgpIHtcbiAgICB0aGlzLl9maWx0ZXIuc2V0U2F0dXJhdGlvbih0aGlzLl9vcHRpb25zLnNhdHVyYXRpb24pXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIHByaW1pdGl2ZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuU2F0dXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IFNhdHVyYXRpb25GaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQgU2F0dXJhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvc2F0dXJhdGlvbi5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL3ByaW1pdGl2ZSdcbmltcG9ydCBDb2xvciBmcm9tICcuLi8uLi8uLi9saWIvY29sb3InXG5pbXBvcnQgeyBFbmdpbmUsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5jb25zdCB7IE9wdGlvblR5cGUsIFVuaWZvcm1UeXBlIH0gPSBDb25zdGFudHNcblxuY2xhc3MgU29mdENvbG9yT3ZlcmxheUZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uLy4uL3NoYWRlcnMvcHJpbWl0aXZlcy9zb2Z0LWNvbG9yLW92ZXJsYXkuZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDRcblxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSBNYXRoLm1heCh0aGlzLl9vcHRpb25zLmNvbG9yLnIgKiAyNTUsIGltYWdlRGF0YS5kYXRhW2luZGV4XSlcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IE1hdGgubWF4KHRoaXMuX29wdGlvbnMuY29sb3IuZyAqIDI1NSwgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSlcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IE1hdGgubWF4KHRoaXMuX29wdGlvbnMuY29sb3IuYiAqIDI1NSwgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuU29mdENvbG9yT3ZlcmxheUZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgY29sb3I6IHsgdHlwZTogT3B0aW9uVHlwZS5DT0xPUiwgZGVmYXVsdDogQ29sb3IuV0hJVEUsIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5GTE9BVDMgfVxufVxuXG4vKipcbiAqIFNvZnRDb2xvck92ZXJsYXkgcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlcnMuUHJpbWl0aXZlXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5jbGFzcyBTb2Z0Q29sb3JPdmVybGF5IGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fZmlsdGVyID0gbmV3IFNvZnRDb2xvck92ZXJsYXlGaWx0ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGZpbHRlcidzIHVuaWZvcm1zXG4gICAqL1xuICB1cGRhdGUgKCkge1xuICAgIHRoaXMuX2ZpbHRlci5zZXRDb2xvcih0aGlzLl9vcHRpb25zLmNvbG9yKVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBwcmltaXRpdmVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cblNvZnRDb2xvck92ZXJsYXkucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSBTb2Z0Q29sb3JPdmVybGF5RmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zXG5cbmV4cG9ydCBkZWZhdWx0IFNvZnRDb2xvck92ZXJsYXlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL3NvZnQtY29sb3Itb3ZlcmxheS5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IExvb2t1cFRhYmxlIGZyb20gJy4vbG9va3VwLXRhYmxlJ1xuaW1wb3J0IHsgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmNvbnN0IHsgT3B0aW9uVHlwZSB9ID0gQ29uc3RhbnRzXG5cbi8qKlxuICogVG9uZSBjdXJ2ZSBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVzLkxvb2t1cFRhYmxlXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5jbGFzcyBUb25lQ3VydmUgZXh0ZW5kcyBMb29rdXBUYWJsZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIGlmICghdGhpcy5fb3B0aW9ucy5yZ2JDb250cm9sUG9pbnRzKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLnJnYkNvbnRyb2xQb2ludHMgPSB7XG4gICAgICAgIHJlZDogdGhpcy5fb3B0aW9ucy5jb250cm9sUG9pbnRzLFxuICAgICAgICBncmVlbjogdGhpcy5fb3B0aW9ucy5jb250cm9sUG9pbnRzLFxuICAgICAgICBibHVlOiB0aGlzLl9vcHRpb25zLmNvbnRyb2xQb2ludHNcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVMb29rdXBUYWJsZSgpXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbG9va3VwIHRhYmxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlTG9va3VwVGFibGUgKCkge1xuICAgIHZhciByID0gdGhpcy5fY2FsY3VsYXRlU3BsaW5lQ3VydmUodGhpcy5fb3B0aW9ucy5yZ2JDb250cm9sUG9pbnRzLnJlZClcbiAgICB2YXIgZyA9IHRoaXMuX2NhbGN1bGF0ZVNwbGluZUN1cnZlKHRoaXMuX29wdGlvbnMucmdiQ29udHJvbFBvaW50cy5ncmVlbilcbiAgICB2YXIgYiA9IHRoaXMuX2NhbGN1bGF0ZVNwbGluZUN1cnZlKHRoaXMuX29wdGlvbnMucmdiQ29udHJvbFBvaW50cy5ibHVlKVxuXG4gICAgdGhpcy5fb3B0aW9ucy5kYXRhID0gdGhpcy5fYnVpbGRMb29rdXBUYWJsZShyLCBnLCBiKVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgbG9va3VwIHRhYmxlXG4gICAqIEBwYXJhbSAge0FycmF5fSByXG4gICAqIEBwYXJhbSAge0FycmF5fSBnXG4gICAqIEBwYXJhbSAge0FycmF5fSBiXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkTG9va3VwVGFibGUgKHIsIGcsIGIpIHtcbiAgICB2YXIgZGF0YSA9IFtdXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBkYXRhLnB1c2goTWF0aC5taW4oTWF0aC5tYXgoaSArIHJbaV0sIDApLCAyNTUpKVxuICAgICAgZGF0YS5wdXNoKE1hdGgubWluKE1hdGgubWF4KGkgKyBnW2ldLCAwKSwgMjU1KSlcbiAgICAgIGRhdGEucHVzaChNYXRoLm1pbihNYXRoLm1heChpICsgYltpXSwgMCksIDI1NSkpXG4gICAgICBkYXRhLnB1c2goMjU1KVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgc3BsaW5lIGN1cnZlIGRhdGEgZm9yIHRoZSBnaXZlbiBwb2ludHNcbiAgICogQHBhcmFtICB7QXJyYXkuPEFycmF5LjxOdW1iZXI+Pn0gcG9pbnRzXG4gICAqIEByZXR1cm4ge0FycmF5LjxOdW1iZXI+fVxuICAgKi9cbiAgX2NhbGN1bGF0ZVNwbGluZUN1cnZlIChwb2ludHMpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0gPiBiWzBdXG4gICAgfSlcblxuICAgIHZhciBzcGxpbmVQb2ludHMgPSB0aGlzLl9nZXRTcGxpbmVDdXJ2ZShwb2ludHMpXG4gICAgdmFyIGZpcnN0U3BsaW5lUG9pbnQgPSBzcGxpbmVQb2ludHNbMF1cbiAgICB2YXIgaVxuXG4gICAgaWYgKGZpcnN0U3BsaW5lUG9pbnRbMF0gPiAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZmlyc3RTcGxpbmVQb2ludFswXTsgaSsrKSB7XG4gICAgICAgIHNwbGluZVBvaW50cy51bnNoaWZ0KFswLCAwXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJlcGFyZWRQb2ludHMgPSBbXVxuICAgIGZvciAoaSA9IDA7IGkgPCBzcGxpbmVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXdQb2ludCA9IHNwbGluZVBvaW50c1tpXVxuICAgICAgdmFyIG9yaWdQb2ludCA9IFtuZXdQb2ludFswXSwgbmV3UG9pbnRbMF1dXG5cbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3cob3JpZ1BvaW50WzBdIC0gbmV3UG9pbnRbMF0sIDIpICtcbiAgICAgICAgTWF0aC5wb3cob3JpZ1BvaW50WzFdIC0gbmV3UG9pbnRbMV0sIDIpXG4gICAgICApXG5cbiAgICAgIGlmIChvcmlnUG9pbnRbMV0gPiBuZXdQb2ludFsxXSkge1xuICAgICAgICBkaXN0YW5jZSA9IC1kaXN0YW5jZVxuICAgICAgfVxuXG4gICAgICBwcmVwYXJlZFBvaW50cy5wdXNoKGRpc3RhbmNlKVxuICAgIH1cblxuICAgIHJldHVybiBwcmVwYXJlZFBvaW50c1xuICB9XG5cbiAgX2dldFNwbGluZUN1cnZlIChwb2ludHMpIHtcbiAgICB2YXIgc2RBID0gdGhpcy5fc2Vjb25kRGVyaXZhdGl2ZShwb2ludHMpXG5cbiAgICB2YXIgbiA9IHNkQS5sZW5ndGhcbiAgICB2YXIgc2QgPSBbXVxuICAgIHZhciBpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzZFtpXSA9IHNkQVtpXVxuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBbXVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSBwb2ludHNbaV1cbiAgICAgIHZhciBuZXh0ID0gcG9pbnRzW2kgKyAxXVxuXG4gICAgICBmb3IgKHZhciB4ID0gY3VyWzBdOyB4IDwgbmV4dFswXTsgeCsrKSB7XG4gICAgICAgIHZhciB0ID0gKHggLSBjdXJbMF0pIC8gKG5leHRbMF0gLSBjdXJbMF0pXG5cbiAgICAgICAgdmFyIGEgPSAxIC0gdFxuICAgICAgICB2YXIgYiA9IHRcbiAgICAgICAgdmFyIGggPSBuZXh0WzBdIC0gY3VyWzBdXG5cbiAgICAgICAgdmFyIHkgPSBhICogY3VyWzFdICsgYiAqIG5leHRbMV0gKyAoaCAqIGggLyA2KSAqXG4gICAgICAgICAgKChhICogYSAqIGEgLSBhKSAqIHNkW2ldICsgKGIgKiBiICogYiAtIGIpICogc2RbaSArIDFdKVxuXG4gICAgICAgIGlmICh5ID4gMjU1KSB7XG4gICAgICAgICAgeSA9IDI1NVxuICAgICAgICB9IGVsc2UgaWYgKHkgPCAwKSB7XG4gICAgICAgICAgeSA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKFt4LCB5XSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMjU1KSB7XG4gICAgICBvdXRwdXQucHVzaChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIF9zZWNvbmREZXJpdmF0aXZlIChwb2ludHMpIHtcbiAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGhcbiAgICBpZiAobiA8PSAwIHx8IG4gPT09IDEpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIG1hdHJpeCA9IFtdXG4gICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgdmFyIGksIGtcblxuICAgIG1hdHJpeFswXSA9IFswLCAxLCAwXVxuXG4gICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIHZhciBQMSA9IHBvaW50c1tpIC0gMV1cbiAgICAgIHZhciBQMiA9IHBvaW50c1tpXVxuICAgICAgdmFyIFAzID0gcG9pbnRzW2kgKyAxXVxuXG4gICAgICBtYXRyaXhbaV0gPSBtYXRyaXhbaV0gfHwgW11cbiAgICAgIG1hdHJpeFtpXVswXSA9IChQMlswXSAtIFAxWzBdKSAvIDZcbiAgICAgIG1hdHJpeFtpXVsxXSA9IChQM1swXSAtIFAxWzBdKSAvIDNcbiAgICAgIG1hdHJpeFtpXVsyXSA9IChQM1swXSAtIFAyWzBdKSAvIDZcbiAgICAgIHJlc3VsdFtpXSA9IChQM1sxXSAtIFAyWzFdKSAvIChQM1swXSAtIFAyWzBdKSAtIChQMlsxXSAtIFAxWzFdKSAvIChQMlswXSAtIFAxWzBdKVxuICAgIH1cblxuICAgIHJlc3VsdFswXSA9IDBcbiAgICByZXN1bHRbbiAtIDFdID0gMFxuXG4gICAgbWF0cml4W24gLSAxXSA9IFswLCAxLCAwXVxuXG4gICAgLy8gUGFzcyAxXG4gICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgayA9IG1hdHJpeFsxXVswXSAvIG1hdHJpeFtpIC0gMV1bMV1cbiAgICAgIG1hdHJpeFtpXVsxXSAtPSBrICogbWF0cml4W2kgLSAxXVsyXVxuICAgICAgbWF0cml4W2ldWzBdID0gMFxuICAgICAgcmVzdWx0W2ldIC09IGsgKiByZXN1bHRbaSAtIDFdXG4gICAgfVxuXG4gICAgLy8gUGFzcyAyXG4gICAgZm9yIChpID0gbiAtIDI7IGkgPiAwOyBpLS0pIHtcbiAgICAgIGsgPSBtYXRyaXhbaV1bMl0gLyBtYXRyaXhbaSArIDFdWzFdXG4gICAgICBtYXRyaXhbaV1bMV0gLT0gayAqIG1hdHJpeFtpICsgMV1bMF1cbiAgICAgIG1hdHJpeFtpXVsyXSA9IDBcbiAgICAgIHJlc3VsdFtpXSAtPSBrICogcmVzdWx0W2kgKyAxXVxuICAgIH1cblxuICAgIHZhciB5MiA9IFtdXG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgeTJbaV0gPSByZXN1bHRbaV0gLyBtYXRyaXhbaV1bMV1cbiAgICB9XG5cbiAgICByZXR1cm4geTJcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgcHJpbWl0aXZlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5Ub25lQ3VydmUucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHJnYkNvbnRyb2xQb2ludHM6IHsgdHlwZTogT3B0aW9uVHlwZS5PQkpFQ1QgfSxcbiAgY29udHJvbFBvaW50czogeyB0eXBlOiBPcHRpb25UeXBlLkFSUkFZLCBkZWZhdWx0OiBbXSB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvbmVDdXJ2ZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvdG9uZS1jdXJ2ZS5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEVuZ2luZSBmcm9tICcuLi8uLi8uLi9lbmdpbmUnXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlJ1xuXG5jbGFzcyBYNDAwRmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vLi4vc2hhZGVycy9wcmltaXRpdmVzL3g0MDAuZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDRcblxuICAgICAgICB2YXIgZ3JheSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAvIDI1NSAqIDAuMyArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gLyAyNTUgKiAwLjMgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdIC8gMjU1ICogMC4zXG4gICAgICAgIGdyYXkgLT0gMC4yXG4gICAgICAgIGdyYXkgPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKDEuMCwgZ3JheSkpXG4gICAgICAgIGdyYXkgKz0gMC4xNVxuICAgICAgICBncmF5ICo9IDEuNFxuXG4gICAgICAgIGdyYXkgKj0gMjU1XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGdyYXlcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGdyYXlcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGdyYXlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBYNDAwIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJzLlByaW1pdGl2ZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuY2xhc3MgWDQwMCBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl9maWx0ZXIgPSBuZXcgWDQwMEZpbHRlcigpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWDQwMFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMveDQwMC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFF1b3ppIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIFF1b3ppRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gRGVzYXR1cmF0aW9uXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5EZXNhdHVyYXRpb24oe1xuICAgICAgZGVzYXR1cmF0aW9uOiAwLjY1XG4gICAgfSkpXG5cbiAgICAvLyBUb25lIGN1cnZlXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgNTBdLFxuICAgICAgICAgIFs0MCwgNzhdLFxuICAgICAgICAgIFsxMTgsIDE3MF0sXG4gICAgICAgICAgWzE4MSwgMjExXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDI3XSxcbiAgICAgICAgICBbMjgsIDQ1XSxcbiAgICAgICAgICBbMTA5LCAxNTddLFxuICAgICAgICAgIFsxNTcsIDE5NV0sXG4gICAgICAgICAgWzE3OSwgMjA4XSxcbiAgICAgICAgICBbMjA2LCAyMTJdLFxuICAgICAgICAgIFsyNTUsIDI0MF1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCA1MF0sXG4gICAgICAgICAgWzEyLCA1NV0sXG4gICAgICAgICAgWzQ2LCAxMDNdLFxuICAgICAgICAgIFsxMDMsIDE2Ml0sXG4gICAgICAgICAgWzE5NCwgMTgyXSxcbiAgICAgICAgICBbMjQxLCAyMDFdLFxuICAgICAgICAgIFsyNTUsIDIxOV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuUXVvemlGaWx0ZXIuaWRlbnRpZmllciA9ICdxdW96aSdcblxuUXVvemlGaWx0ZXIuZGlzcGxheU5hbWUgPSAnUXVvemknXG5cbmV4cG9ydCBkZWZhdWx0IFF1b3ppRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZpbHRlcnMvcXVvemktZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogU2VtaXJlZCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBTZW1pcmVkRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMTI5XSxcbiAgICAgICAgICBbNzUsIDE1M10sXG4gICAgICAgICAgWzE4MSwgMjI3XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDhdLFxuICAgICAgICAgIFsxMTEsIDg1XSxcbiAgICAgICAgICBbMjEyLCAxNThdLFxuICAgICAgICAgIFsyNTUsIDIyNl1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCA1XSxcbiAgICAgICAgICBbNzUsIDIyXSxcbiAgICAgICAgICBbMTkzLCA5MF0sXG4gICAgICAgICAgWzI1NSwgMjI5XVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLkdsb3coKSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblNlbWlyZWRGaWx0ZXIuaWRlbnRpZmllciA9ICdzZW1pcmVkJ1xuXG5TZW1pcmVkRmlsdGVyLmRpc3BsYXlOYW1lID0gJ1NlbWlyZWQnXG5cbmV4cG9ydCBkZWZhdWx0IFNlbWlyZWRGaWx0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZmlsdGVycy9zZW1pcmVkLWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFN1bm55IEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIFN1bm55RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzYyLCA4Ml0sXG4gICAgICAgICAgWzE0MSwgMTU0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDM5XSxcbiAgICAgICAgICBbNTYsIDk2XSxcbiAgICAgICAgICBbMTkyLCAxNzZdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTc0LCA5OV0sXG4gICAgICAgICAgWzI1NSwgMjM1XVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICBjb250cm9sUG9pbnRzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzU1LCAyMF0sXG4gICAgICAgIFsxNTgsIDE5MV0sXG4gICAgICAgIFsyNTUsIDI1NV1cbiAgICAgIF1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblN1bm55RmlsdGVyLmlkZW50aWZpZXIgPSAnc3VubnknXG5cblN1bm55RmlsdGVyLmRpc3BsYXlOYW1lID0gJ1N1bm55J1xuXG5leHBvcnQgZGVmYXVsdCBTdW5ueUZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3N1bm55LWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFRleGFzIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIFRleGFzRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgNzJdLFxuICAgICAgICAgIFs4OSwgOTldLFxuICAgICAgICAgIFsxNzYsIDIxMl0sXG4gICAgICAgICAgWzI1NSwgMjM3XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCA0OV0sXG4gICAgICAgICAgWzI1NSwgMTkyXVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDcyXSxcbiAgICAgICAgICBbMjU1LCAxNTFdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblRleGFzRmlsdGVyLmlkZW50aWZpZXIgPSAndGV4YXMnXG5cblRleGFzRmlsdGVyLmRpc3BsYXlOYW1lID0gJ1RleGFzJ1xuXG5leHBvcnQgZGVmYXVsdCBUZXhhc0ZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3RleGFzLWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFg0MDAgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgWDQwMEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuWDQwMCgpKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuWDQwMEZpbHRlci5pZGVudGlmaWVyID0gJ3g0MDAnXG5cblg0MDBGaWx0ZXIuZGlzcGxheU5hbWUgPSAnWDQwMCdcblxuZXhwb3J0IGRlZmF1bHQgWDQwMEZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3g0MDAtZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBFbmdpbmUsIENvbnN0YW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5jb25zdCB7IE9wdGlvblR5cGUsIFVuaWZvcm1UeXBlIH0gPSBDb25zdGFudHNcbmltcG9ydCBTdGFja0JsdXIgZnJvbSAnLi4vLi4vdmVuZG9yL3N0YWNrLWJsdXInXG5cbmNsYXNzIExpbmVhckZvY3VzRmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuLi8uLi9zaGFkZXJzL2ZvY3VzL2xpbmVhci1mb2N1cy5mcmFnJylcblxuICAgIHRoaXMuX2xhc3RCbHVyUmFkaXVzID0gbnVsbFxuICAgIHRoaXMuX2xhc3RHcmFkaWVudFJhZGl1cyA9IG51bGxcbiAgICB0aGlzLl9sYXN0U3RhcnQgPSBuZXcgVmVjdG9yMigpXG4gICAgdGhpcy5fbGFzdEVuZCA9IG5ldyBWZWN0b3IyKClcblxuICAgIHRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQgPSBuZXcgRW5naW5lLkNhbnZhc1JlbmRlclRhcmdldChcbiAgICAgIDEwMCxcbiAgICAgIDEwMCxcbiAgICAgIDEpXG5cbiAgICB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0ID0gbmV3IEVuZ2luZS5DYW52YXNSZW5kZXJUYXJnZXQoXG4gICAgICAxMDAsXG4gICAgICAxMDAsXG4gICAgICAxKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSBpbnB1dFRhcmdldC5nZXREaW1lbnNpb25zKClcbiAgICBjb25zdCBkaW1lbnNpb25zQ2hhbmdlZCA9ICF0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LmdldERpbWVuc2lvbnMoKS5lcXVhbHMoaW5wdXREaW1lbnNpb25zKVxuXG4gICAgdGhpcy5fYmx1cnJlZFJlbmRlclRhcmdldC5zZXRQaXhlbFJhdGlvKGlucHV0VGFyZ2V0LmdldFBpeGVsUmF0aW8oKSlcbiAgICB0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LnJlc2l6ZVRvKGlucHV0VGFyZ2V0LmdldERpbWVuc2lvbnMoKSlcblxuICAgIHRoaXMuX21hc2tSZW5kZXJUYXJnZXQuc2V0UGl4ZWxSYXRpbyhpbnB1dFRhcmdldC5nZXRQaXhlbFJhdGlvKCkpXG4gICAgdGhpcy5fbWFza1JlbmRlclRhcmdldC5yZXNpemVUbyhpbnB1dFRhcmdldC5nZXREaW1lbnNpb25zKCkpXG5cbiAgICBpZiAoIXRoaXMuX291dHB1dFJlbmRlclRleHR1cmUpIHtcbiAgICAgIHRoaXMuX291dHB1dFJlbmRlclRleHR1cmUgPSBuZXcgRW5naW5lLlJlbmRlclRleHR1cmUocmVuZGVyZXIsXG4gICAgICAgIGlucHV0VGFyZ2V0LmdldFdpZHRoKCksXG4gICAgICAgIGlucHV0VGFyZ2V0LmdldEhlaWdodCgpLFxuICAgICAgICBpbnB1dFRhcmdldC5nZXRQaXhlbFJhdGlvKCkpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9sYXN0U3RhcnQuZXF1YWxzKHRoaXMuX29wdGlvbnMuc3RhcnQpIHx8XG4gICAgICAgICF0aGlzLl9sYXN0RW5kLmVxdWFscyh0aGlzLl9vcHRpb25zLmVuZCkgfHxcbiAgICAgICAgdGhpcy5fbGFzdEdyYWRpZW50UmFkaXVzICE9PSB0aGlzLl9vcHRpb25zLnNpemUgfHxcbiAgICAgICAgZGltZW5zaW9uc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3JlbmRlck1hc2soKVxuXG4gICAgICB0aGlzLl9sYXN0U3RhcnQgPSB0aGlzLl9vcHRpb25zLnN0YXJ0LmNsb25lKClcbiAgICAgIHRoaXMuX2xhc3RFbmQgPSB0aGlzLl9vcHRpb25zLmVuZC5jbG9uZSgpXG4gICAgICB0aGlzLl9sYXN0R3JhZGllbnRSYWRpdXMgPSB0aGlzLl9vcHRpb25zLnNpemVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGFzdEJsdXJSYWRpdXMgIT09IHRoaXMuX29wdGlvbnMuYmx1clJhZGl1cyB8fFxuICAgICAgZGltZW5zaW9uc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2JsdXJJbWFnZShpbnB1dFRhcmdldClcbiAgICAgIHRoaXMuX2xhc3RCbHVyUmFkaXVzID0gdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzXG4gICAgfVxuXG4gICAgdGhpcy5fYXBwbHlNYXNrKGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJsdXJyZWQgY29weSBvZiB0aGUgaW1hZ2VcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYmx1ckltYWdlIChpbnB1dFRhcmdldCkge1xuICAgIGNvbnN0IGlucHV0Q2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBpbnB1dENvbnRleHQgPSBpbnB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpXG4gICAgY29uc3QgYmx1cnJ5SW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KVxuICAgIFN0YWNrQmx1ci5zdGFja0JsdXJDYW52YXNSR0JBKGJsdXJyeUltYWdlRGF0YSwgMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCwgdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzICogaW5wdXREaW1lbnNpb25zLm1pbigpKVxuXG4gICAgY29uc3QgYmx1cnJ5Q29udGV4dCA9IHRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgYmx1cnJ5Q29udGV4dC5wdXRJbWFnZURhdGEoYmx1cnJ5SW1hZ2VEYXRhLCAwLCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG1hc2sgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyTWFzayAoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fbWFza1JlbmRlclRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0LmdldFBpeGVsUmF0aW8oKVxuXG4gICAgY29uc3QgY2FudmFzRGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9vcHRpb25zLnNpemUgKiBjYW52YXNEaW1lbnNpb25zLm1pbigpICogcGl4ZWxSYXRpb1xuICAgIGNvbnN0IGdyYWRpZW50U2l6ZSA9IHRoaXMuX29wdGlvbnMuZ3JhZGllbnRTaXplICogY2FudmFzRGltZW5zaW9ucy5taW4oKSAqIHBpeGVsUmF0aW9cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX29wdGlvbnMuc3RhcnQuY2xvbmUoKS5tdWx0aXBseShjYW52YXNEaW1lbnNpb25zKVxuICAgIGNvbnN0IGVuZCA9IHRoaXMuX29wdGlvbnMuZW5kLmNsb25lKCkubXVsdGlwbHkoY2FudmFzRGltZW5zaW9ucylcbiAgICBjb25zdCBkaXN0ID0gZW5kLmNsb25lKCkuc3VidHJhY3Qoc3RhcnQpXG4gICAgY29uc3QgbWlkZGxlID0gc3RhcnQuY2xvbmUoKS5hZGQoZGlzdC5jbG9uZSgpLmRpdmlkZSgyKSlcblxuICAgIGNvbnN0IHRvdGFsRGlzdCA9IGRpc3QubGVuKClcbiAgICBjb25zdCBmYWN0b3IgPSBkaXN0LmNsb25lKCkuZGl2aWRlKHRvdGFsRGlzdClcblxuICAgIGNvbnN0IGdyYWRpZW50U3RhcnQgPSBtaWRkbGUuY2xvbmUoKVxuICAgICAgLmFkZChcbiAgICAgICAgKHNpemUgKyBncmFkaWVudFNpemUpICogZmFjdG9yLnksXG4gICAgICAgIC0oc2l6ZSArIGdyYWRpZW50U2l6ZSkgKiBmYWN0b3IueFxuICAgICAgKVxuICAgIGNvbnN0IGdyYWRpZW50RW5kID0gbWlkZGxlLmNsb25lKClcbiAgICAgIC5hZGQoXG4gICAgICAgIC0oc2l6ZSArIGdyYWRpZW50U2l6ZSkgKiBmYWN0b3IueSxcbiAgICAgICAgKHNpemUgKyBncmFkaWVudFNpemUpICogZmFjdG9yLnhcbiAgICAgIClcblxuICAgIC8vIEJ1aWxkIGdyYWRpZW50XG4gICAgY29uc3QgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgZ3JhZGllbnRTdGFydC54LCBncmFkaWVudFN0YXJ0LnksXG4gICAgICBncmFkaWVudEVuZC54LCBncmFkaWVudEVuZC55XG4gICAgKVxuICAgIGNvbnN0IGZ1bGxHcmFkaWVudFNpemUgPSBncmFkaWVudEVuZC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QoZ3JhZGllbnRTdGFydClcbiAgICAgIC5sZW4oKVxuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnIzAwMDAwMCcpXG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKChncmFkaWVudFNpemUgLyAyKSAvIGZ1bGxHcmFkaWVudFNpemUsICcjRkZGRkZGJylcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMS4wIC0gKChncmFkaWVudFNpemUgLyAyKSAvIGZ1bGxHcmFkaWVudFNpemUpLCAnI0ZGRkZGRicpXG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjMDAwMDAwJylcblxuICAgIC8vIERyYXcgZ3JhZGllbnRcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgYmx1ciBhbmQgbWFzayB0byB0aGUgaW5wdXQgY2FudmFzXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlNYXNrIChpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0KSB7XG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBpbnB1dENhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3QgYmx1cnJlZENvbnRleHQgPSB0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG1hc2tDb250ZXh0ID0gdGhpcy5fbWFza1JlbmRlclRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGlucHV0SW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KVxuICAgIGNvbnN0IHBpeGVscyA9IGlucHV0SW1hZ2VEYXRhLmRhdGFcbiAgICBjb25zdCBibHVycmVkUGl4ZWxzID0gYmx1cnJlZENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpLmRhdGFcbiAgICBjb25zdCBtYXNrUGl4ZWxzID0gbWFza0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpLmRhdGFcblxuICAgIGxldCBhbHBoYVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDYW52YXMud2lkdGggKiBpbnB1dENhbnZhcy5oZWlnaHQgKiA0OyBpICs9IDQpIHtcbiAgICAgIGFscGhhID0gbWFza1BpeGVsc1tpXSAvIDI1NVxuXG4gICAgICBwaXhlbHNbaV0gPSBhbHBoYSAqIHBpeGVsc1tpXSArICgxIC0gYWxwaGEpICogYmx1cnJlZFBpeGVsc1tpXVxuICAgICAgcGl4ZWxzW2kgKyAxXSA9IGFscGhhICogcGl4ZWxzW2kgKyAxXSArICgxIC0gYWxwaGEpICogYmx1cnJlZFBpeGVsc1tpICsgMV1cbiAgICAgIHBpeGVsc1tpICsgMl0gPSBhbHBoYSAqIHBpeGVsc1tpICsgMl0gKyAoMSAtIGFscGhhKSAqIGJsdXJyZWRQaXhlbHNbaSArIDJdXG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW5wdXRJbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuTGluZWFyRm9jdXNGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGJsdXJSYWRpdXM6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDMwLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQgfSxcbiAgc2l6ZTogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogNTAsIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5GTE9BVCB9LFxuICBncmFkaWVudFNpemU6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDUwLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQgfSxcbiAgc3RhcnQ6IHsgdHlwZTogT3B0aW9uVHlwZS5WRUNUT1IyLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigwLCAwLjUpLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQyIH0sXG4gIGVuZDogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDEsIDAuNSksIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5GTE9BVDIgfSxcbiAgZGVsdGE6IHsgdHlwZTogT3B0aW9uVHlwZS5WRUNUT1IyLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigxLCAxKSwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUMiB9LFxuICB0ZXhTaXplOiB7IHR5cGU6IE9wdGlvblR5cGUuVkVDVE9SMiwgZGVmYXVsdDogbmV3IFZlY3RvcjIoMTAwLCAxMDApLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQyIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGluZWFyRm9jdXNGaWx0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvZm9jdXMvbGluZWFyLWZvY3VzLWZpbHRlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVmVjdG9yMiwgRW5naW5lLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuY29uc3QgeyBVbmlmb3JtVHlwZSwgT3B0aW9uVHlwZSB9ID0gQ29uc3RhbnRzXG5pbXBvcnQgU3RhY2tCbHVyIGZyb20gJy4uLy4uL3ZlbmRvci9zdGFjay1ibHVyJ1xuXG5jbGFzcyBSYWRpYWxGb2N1c0ZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vc2hhZGVycy9mb2N1cy9yYWRpYWwtZm9jdXMuZnJhZycpXG5cbiAgICB0aGlzLl9sYXN0Qmx1clJhZGl1cyA9IG51bGxcbiAgICB0aGlzLl9sYXN0R3JhZGllbnRSYWRpdXMgPSBudWxsXG4gICAgdGhpcy5fbGFzdFBvc2l0aW9uID0gbmV3IFZlY3RvcjIoKVxuXG4gICAgdGhpcy5fYmx1cnJlZFJlbmRlclRhcmdldCA9IG5ldyBFbmdpbmUuQ2FudmFzUmVuZGVyVGFyZ2V0KFxuICAgICAgMTAwLFxuICAgICAgMTAwLFxuICAgICAgMSlcblxuICAgIHRoaXMuX21hc2tSZW5kZXJUYXJnZXQgPSBuZXcgRW5naW5lLkNhbnZhc1JlbmRlclRhcmdldChcbiAgICAgIDEwMCxcbiAgICAgIDEwMCxcbiAgICAgIDEpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGFyZ2V0LmdldERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IGRpbWVuc2lvbnNDaGFuZ2VkID0gIXRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQuZ2V0RGltZW5zaW9ucygpLmVxdWFscyhpbnB1dERpbWVuc2lvbnMpXG5cbiAgICB0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LnNldFBpeGVsUmF0aW8oaW5wdXRUYXJnZXQuZ2V0UGl4ZWxSYXRpbygpKVxuICAgIHRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQucmVzaXplVG8oaW5wdXRUYXJnZXQuZ2V0RGltZW5zaW9ucygpKVxuXG4gICAgdGhpcy5fbWFza1JlbmRlclRhcmdldC5zZXRQaXhlbFJhdGlvKGlucHV0VGFyZ2V0LmdldFBpeGVsUmF0aW8oKSlcbiAgICB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0LnJlc2l6ZVRvKGlucHV0VGFyZ2V0LmdldERpbWVuc2lvbnMoKSlcblxuICAgIGlmICghdGhpcy5fb3V0cHV0UmVuZGVyVGV4dHVyZSkge1xuICAgICAgdGhpcy5fb3V0cHV0UmVuZGVyVGV4dHVyZSA9IG5ldyBFbmdpbmUuUmVuZGVyVGV4dHVyZShyZW5kZXJlcixcbiAgICAgICAgaW5wdXRUYXJnZXQuZ2V0V2lkdGgoKSxcbiAgICAgICAgaW5wdXRUYXJnZXQuZ2V0SGVpZ2h0KCksXG4gICAgICAgIGlucHV0VGFyZ2V0LmdldFBpeGVsUmF0aW8oKSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2xhc3RQb3NpdGlvbi5lcXVhbHModGhpcy5fb3B0aW9ucy5wb3NpdGlvbikgfHxcbiAgICAgICAgdGhpcy5fbGFzdEdyYWRpZW50UmFkaXVzICE9PSB0aGlzLl9vcHRpb25zLmdyYWRpZW50UmFkaXVzIHx8XG4gICAgICAgIGRpbWVuc2lvbnNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9yZW5kZXJNYXNrKClcblxuICAgICAgdGhpcy5fbGFzdFBvc2l0aW9uID0gdGhpcy5fb3B0aW9ucy5wb3NpdGlvbi5jbG9uZSgpXG4gICAgICB0aGlzLl9sYXN0R3JhZGllbnRSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmdyYWRpZW50UmFkaXVzXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xhc3RCbHVyUmFkaXVzICE9PSB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXMgfHwgZGltZW5zaW9uc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2JsdXJJbWFnZShpbnB1dFRhcmdldClcbiAgICAgIHRoaXMuX2xhc3RCbHVyUmFkaXVzID0gdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzXG4gICAgfVxuXG4gICAgdGhpcy5fYXBwbHlNYXNrKGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJsdXJyZWQgY29weSBvZiB0aGUgaW1hZ2VcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYmx1ckltYWdlIChpbnB1dFRhcmdldCkge1xuICAgIGNvbnN0IGlucHV0Q2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBpbnB1dENvbnRleHQgPSBpbnB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpXG4gICAgY29uc3QgYmx1cnJ5SW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KVxuICAgIFN0YWNrQmx1ci5zdGFja0JsdXJDYW52YXNSR0JBKGJsdXJyeUltYWdlRGF0YSwgMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCwgdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzICogaW5wdXREaW1lbnNpb25zLm1pbigpKVxuXG4gICAgY29uc3QgYmx1cnJ5Q29udGV4dCA9IHRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgYmx1cnJ5Q29udGV4dC5wdXRJbWFnZURhdGEoYmx1cnJ5SW1hZ2VEYXRhLCAwLCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG1hc2sgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyTWFzayAoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fbWFza1JlbmRlclRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgY2FudmFzRGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5fbWFza1JlbmRlclRhcmdldC5nZXRQaXhlbFJhdGlvKClcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb24uY2xvbmUoKS5tdWx0aXBseShjYW52YXNEaW1lbnNpb25zKVxuXG4gICAgbGV0IHsgcmFkaXVzLCBncmFkaWVudFJhZGl1cyB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIHJhZGl1cyAqPSBjYW52YXMuaGVpZ2h0XG4gICAgZ3JhZGllbnRSYWRpdXMgKj0gY2FudmFzLmhlaWdodFxuXG4gICAgLy8gQnVpbGQgZ3JhZGllbnRcbiAgICBjb25zdCBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCAwLFxuICAgICAgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgKHJhZGl1cyArIGdyYWRpZW50UmFkaXVzKSAqIHBpeGVsUmF0aW9cbiAgICApXG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjRkZGRkZGJylcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AocmFkaXVzIC8gKHJhZGl1cyArIGdyYWRpZW50UmFkaXVzKSwgJyNGRkZGRkYnKVxuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzAwMDAwMCcpXG5cbiAgICAvLyBEcmF3IGdyYWRpZW50XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudFxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgY2FudmFzRGltZW5zaW9ucy54LCBjYW52YXNEaW1lbnNpb25zLnkpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgYmx1ciBhbmQgbWFzayB0byB0aGUgaW5wdXQgY2FudmFzXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlNYXNrIChpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0KSB7XG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBpbnB1dENhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3QgYmx1cnJlZENvbnRleHQgPSB0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG1hc2tDb250ZXh0ID0gdGhpcy5fbWFza1JlbmRlclRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGlucHV0SW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KVxuICAgIGNvbnN0IHBpeGVscyA9IGlucHV0SW1hZ2VEYXRhLmRhdGFcbiAgICBjb25zdCBibHVycmVkUGl4ZWxzID0gYmx1cnJlZENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpLmRhdGFcbiAgICBjb25zdCBtYXNrUGl4ZWxzID0gbWFza0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpLmRhdGFcblxuICAgIGxldCBhbHBoYVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDYW52YXMud2lkdGggKiBpbnB1dENhbnZhcy5oZWlnaHQgKiA0OyBpICs9IDQpIHtcbiAgICAgIGFscGhhID0gbWFza1BpeGVsc1tpXSAvIDI1NVxuXG4gICAgICBwaXhlbHNbaV0gPSBhbHBoYSAqIHBpeGVsc1tpXSArICgxIC0gYWxwaGEpICogYmx1cnJlZFBpeGVsc1tpXVxuICAgICAgcGl4ZWxzW2kgKyAxXSA9IGFscGhhICogcGl4ZWxzW2kgKyAxXSArICgxIC0gYWxwaGEpICogYmx1cnJlZFBpeGVsc1tpICsgMV1cbiAgICAgIHBpeGVsc1tpICsgMl0gPSBhbHBoYSAqIHBpeGVsc1tpICsgMl0gKyAoMSAtIGFscGhhKSAqIGJsdXJyZWRQaXhlbHNbaSArIDJdXG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW5wdXRJbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuUmFkaWFsRm9jdXNGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGJsdXJSYWRpdXM6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDMwLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQgfSxcbiAgcmFkaXVzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiA1MCwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUIH0sXG4gIGdyYWRpZW50UmFkaXVzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAyNSwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUIH0sXG4gIHBvc2l0aW9uOiB7IHR5cGU6IE9wdGlvblR5cGUuVkVDVE9SMiwgZGVmYXVsdDogbmV3IFZlY3RvcjIoMC41LCAwLjUpLCB1bmlmb3JtVHlwZTogVW5pZm9ybVR5cGUuRkxPQVQyIH0sXG4gIGRlbHRhOiB7IHR5cGU6IE9wdGlvblR5cGUuVkVDVE9SMiwgZGVmYXVsdDogbmV3IFZlY3RvcjIoMSwgMSksIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5GTE9BVDIgfSxcbiAgdGV4U2l6ZTogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDEwMCwgMTAwKSwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUMiB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhZGlhbEZvY3VzRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL2ZvY3VzL3JhZGlhbC1mb2N1cy1maWx0ZXIuanMiLCIvKiBnbG9iYWwgSFRNTEltYWdlRWxlbWVudCAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgQ29uc3RhbnRzLCBQcm9taXNlLCBFbmdpbmUsIFZlY3RvcjIsIENvbG9yIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBPcGVyYXRpb24gZnJvbSAnLi9vcGVyYXRpb24nXG5jb25zdCB7IE9wdGlvblR5cGUsIFJlbmRlcmVyVHlwZSB9ID0gQ29uc3RhbnRzXG5cbmxldCBJbWFnZVxuaWYgKHR5cGVvZiBXRUJQQUNLICE9PSAndW5kZWZpbmVkJykge1xuICBJbWFnZSA9IHdpbmRvdy5JbWFnZVxufVxuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBkcmF3IGEgZnJhbWUgYXJvdW5kIHRoZSBpbWFnZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5PcGVyYXRpb25cbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zXG4gKi9cbmNsYXNzIEZyYW1lT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRnJhbWVPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fY29sb3JPdmVybGF5RmlsdGVyID0gbmV3IEVuZ2luZS5GaWx0ZXJzLkNvbG9yT3ZlcmxheUZpbHRlcih7XG4gICAgICBjb2xvcjogdGhpcy5nZXRUaW50Q29sb3IoKVxuICAgIH0pXG5cbiAgICB0aGlzLl9mcmFtZUNvbnRhaW5lciA9IG5ldyBFbmdpbmUuQ29udGFpbmVyKClcblxuICAgIHRoaXMuX3Jlc2V0U3ByaXRlcygpXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZnJhbWUpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVNwcml0ZXNGb3JGcmFtZSh0aGlzLl9vcHRpb25zLmZyYW1lKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHNwcml0ZUdyb3VwcyBhbmQgc3ByaXRlcyBhdHRyaWJ1dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRTcHJpdGVzICgpIHtcbiAgICB0aGlzLl9zcHJpdGVHcm91cHMgPSB7XG4gICAgICB0b3A6IHt9LFxuICAgICAgbGVmdDoge30sXG4gICAgICByaWdodDoge30sXG4gICAgICBib3R0b206IHt9XG4gICAgfVxuICAgIHRoaXMuX3Nwcml0ZXMgPSBbXVxuICAgIHRoaXMuX3JlcGVhdFNwcml0ZXMgPSB7XG4gICAgICB0b3A6IFtdLFxuICAgICAgbGVmdDogW10sXG4gICAgICByaWdodDogW10sXG4gICAgICBib3R0b206IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHNwcml0ZXMgYW5kIGltYWdlIGdyb3VwcyBmb3IgdGhlIGdpdmVuIGZyYW1lIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGZyYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlU3ByaXRlc0ZvckZyYW1lIChmcmFtZSkge1xuICAgIGlmICghZnJhbWUpIHJldHVybiB0aGlzLl9kaXNwb3NlU3ByaXRlcygpXG5cbiAgICBjb25zdCB7IGltYWdlR3JvdXBzLCBsYXlvdXRNb2RlIH0gPSBmcmFtZVxuICAgIHRoaXMuX2xheW91dE1vZGUgPSBsYXlvdXRNb2RlIHx8ICdob3Jpem9udGFsLWluc2lkZSdcblxuICAgIHRoaXMuX2Rpc3Bvc2VTcHJpdGVzKCk7XG5cbiAgICBbJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbSddLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGltYWdlR3JvdXBzW2dyb3VwXSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuXG4gICAgICBbJ3N0YXJ0JywgJ21pZCcsICdlbmQnXS5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW1hZ2VHcm91cHNbZ3JvdXBdW3BhcnRdID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cbiAgICAgICAgLy8gSW4gY2FzZSBvYmplY3QgaXMgcGFzc2VkLCBwaWNrIGF0dHJpYnV0ZXNcbiAgICAgICAgbGV0IGltYWdlID0gaW1hZ2VHcm91cHNbZ3JvdXBdW3BhcnRdXG4gICAgICAgIGlmICgnaW1hZ2UnIGluIGltYWdlKSB7XG4gICAgICAgICAgaW1hZ2UgPSBpbWFnZS5pbWFnZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRleHR1cmUgYW5kIHNwcml0ZXNcbiAgICAgICAgbGV0IHRleHR1cmUgPSBFbmdpbmUuVGV4dHVyZS5mcm9tSW1hZ2UoaW1hZ2UpXG4gICAgICAgIGNvbnN0IHNwcml0ZSA9IG5ldyBFbmdpbmUuU3ByaXRlKHRleHR1cmUpXG4gICAgICAgIHRoaXMuX3Nwcml0ZUdyb3Vwc1tncm91cF1bcGFydF0gPSBzcHJpdGVcbiAgICAgICAgdGhpcy5fc3ByaXRlcy5wdXNoKHNwcml0ZSlcbiAgICAgICAgdGhpcy5fZnJhbWVDb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZyYW1lIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyIChpbnB1dFRleHR1cmUpIHtcbiAgICBjb25zdCBkaW1lbnNpb25zID0gdGhpcy5fcmVuZGVyVGV4dHVyZS5nZXREaW1lbnNpb25zKClcblxuICAgIC8vIENyZWF0ZSBhbmQgcG9zaXRpb24gc3ByaXRlc1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmZyYW1lKSB7XG4gICAgICB0aGlzLl9jb2xvck92ZXJsYXlGaWx0ZXIuc2V0Q29sb3IodGhpcy5nZXRUaW50Q29sb3IoKSlcbiAgICAgIHRoaXMuX3VwZGF0ZVNwcml0ZXMoaW5wdXRUZXh0dXJlKVxuICAgIH1cblxuICAgIC8vIFByZXBhcmUgcmVuZGVyIHRleHR1cmUgZm9yIGZyYW1lXG4gICAgaWYgKCF0aGlzLl9mcmFtZVJlbmRlclRleHR1cmUpIHtcbiAgICAgIHRoaXMuX2ZyYW1lUmVuZGVyVGV4dHVyZSA9IG5ldyBFbmdpbmUuUmVuZGVyVGV4dHVyZSh0aGlzLl9zZGsuZ2V0UmVuZGVyZXIoKSwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLnkpXG4gICAgICB0aGlzLl9mcmFtZVNwcml0ZSA9IG5ldyBFbmdpbmUuU3ByaXRlKHRoaXMuX2ZyYW1lUmVuZGVyVGV4dHVyZSlcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRDaGlsZCh0aGlzLl9mcmFtZVNwcml0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZnJhbWVSZW5kZXJUZXh0dXJlLnJlc2l6ZVRvKGRpbWVuc2lvbnMpXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRpbnRpbmdcbiAgICBjb25zdCBpc1dlYkdMID0gdGhpcy5fc2RrLmdldFJlbmRlcmVyKCkuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKVxuICAgIGlmIChpc1dlYkdMKSB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5mcmFtZSAmJiB0aGlzLl9vcHRpb25zLmZyYW1lLnRpbnRhYmxlKSB7XG4gICAgICAgIHRoaXMuX2ZyYW1lU3ByaXRlLnNldEZpbHRlcnMoW3RoaXMuX2NvbG9yT3ZlcmxheUZpbHRlcl0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mcmFtZVNwcml0ZS5zZXRGaWx0ZXJzKFtdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbmRlciBmcmFtZVxuICAgIHRoaXMuX2ZyYW1lUmVuZGVyVGV4dHVyZS5jbGVhcigpXG4gICAgdGhpcy5fZnJhbWVSZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9mcmFtZUNvbnRhaW5lcilcblxuICAgIC8vIFJlbmRlciBldmVyeXRoaW5nXG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcmVuZGVyVGV4dHVyZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzcHJpdGUgcG9zaXRpb25zIGFuZCBzY2FsaW5nc1xuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfSBpbnB1dFRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTcHJpdGVzIChpbnB1dFRleHR1cmUpIHtcbiAgICBjb25zdCBkaW1lbnNpb25zID0gaW5wdXRUZXh0dXJlLmdldERpbWVuc2lvbnMoKVxuICAgIHRoaXMuX2ZyYW1lV2lkdGggPSBNYXRoLmNlaWwoaW5wdXRUZXh0dXJlLmdldERpbWVuc2lvbnMoKS5taW4oKSAqIHRoaXMuX29wdGlvbnMuc2NhbGUpXG5cbiAgICB0aGlzLl91cGRhdGVIb3Jpem9udGFsU3ByaXRlR3JvdXAoaW5wdXRUZXh0dXJlLCAndG9wJywgMClcbiAgICB0aGlzLl91cGRhdGVIb3Jpem9udGFsU3ByaXRlR3JvdXAoaW5wdXRUZXh0dXJlLCAnYm90dG9tJywgZGltZW5zaW9ucy55IC0gdGhpcy5fZnJhbWVXaWR0aClcbiAgICB0aGlzLl91cGRhdGVWZXJ0aWNhbFNwcml0ZUdyb3VwKGlucHV0VGV4dHVyZSwgJ2xlZnQnLCAwKVxuICAgIHRoaXMuX3VwZGF0ZVZlcnRpY2FsU3ByaXRlR3JvdXAoaW5wdXRUZXh0dXJlLCAncmlnaHQnLCBkaW1lbnNpb25zLnggLSB0aGlzLl9mcmFtZVdpZHRoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNwcml0ZSBwb3NpdGlvbnMgYW5kIHNjYWxlIGZvciB0aGUgZ2l2ZW4gaG9yaXpvbnRhbCBzcHJpdGUgZ3JvdXBcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0ID0gMFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUhvcml6b250YWxTcHJpdGVHcm91cCAoaW5wdXRUZXh0dXJlLCBncm91cCwgb2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBpbnB1dFRleHR1cmUuZ2V0RGltZW5zaW9ucygpXG4gICAgY29uc3QgaG9yaXpvbnRhbEluc2lkZSA9IHRoaXMuX2xheW91dE1vZGUgPT09ICdob3Jpem9udGFsLWluc2lkZSdcblxuICAgIGNvbnN0IHN0YXJ0U3ByaXRlID0gdGhpcy5fc3ByaXRlR3JvdXBzW2dyb3VwXS5zdGFydFxuICAgIGNvbnN0IG1pZFNwcml0ZSA9IHRoaXMuX3Nwcml0ZUdyb3Vwc1tncm91cF0ubWlkXG4gICAgY29uc3QgZW5kU3ByaXRlID0gdGhpcy5fc3ByaXRlR3JvdXBzW2dyb3VwXS5lbmRcblxuICAgIGxldCBzdGFydFdpZHRoID0gMFxuICAgIGxldCBlbmRXaWR0aCA9IDBcblxuICAgIGxldCB0ZXh0dXJlRGltZW5zaW9ucywgdGV4dHVyZVJhdGlvXG4gICAgaWYgKHN0YXJ0U3ByaXRlKSB7XG4gICAgICB0ZXh0dXJlRGltZW5zaW9ucyA9IHN0YXJ0U3ByaXRlLmdldFRleHR1cmUoKS5nZXREaW1lbnNpb25zKClcbiAgICAgIHRleHR1cmVSYXRpbyA9IHRleHR1cmVEaW1lbnNpb25zLnkgLyB0ZXh0dXJlRGltZW5zaW9ucy54XG5cbiAgICAgIHN0YXJ0V2lkdGggPSBNYXRoLmZsb29yKHRoaXMuX2ZyYW1lV2lkdGggLyB0ZXh0dXJlUmF0aW8pXG5cbiAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBuZXcgVmVjdG9yMigwLCBvZmZzZXQpXG4gICAgICBzdGFydFBvc2l0aW9uLnggPSBob3Jpem9udGFsSW5zaWRlID8gdGhpcy5fZnJhbWVXaWR0aCA6IDBcblxuICAgICAgc3RhcnRTcHJpdGUuc2V0UG9zaXRpb24oc3RhcnRQb3NpdGlvbilcbiAgICAgIHN0YXJ0U3ByaXRlLnNldEhlaWdodCh0aGlzLl9mcmFtZVdpZHRoKVxuICAgICAgc3RhcnRTcHJpdGUuc2V0V2lkdGgoc3RhcnRXaWR0aClcbiAgICB9XG5cbiAgICBpZiAoZW5kU3ByaXRlKSB7XG4gICAgICB0ZXh0dXJlRGltZW5zaW9ucyA9IGVuZFNwcml0ZS5nZXRUZXh0dXJlKCkuZ2V0RGltZW5zaW9ucygpXG4gICAgICB0ZXh0dXJlUmF0aW8gPSB0ZXh0dXJlRGltZW5zaW9ucy55IC8gdGV4dHVyZURpbWVuc2lvbnMueFxuXG4gICAgICBlbmRXaWR0aCA9IE1hdGguZmxvb3IodGhpcy5fZnJhbWVXaWR0aCAqIHRleHR1cmVSYXRpbylcblxuICAgICAgbGV0IGVuZFBvc2l0aW9uID0gbmV3IFZlY3RvcjIoZGltZW5zaW9ucy54IC0gZW5kV2lkdGgsIG9mZnNldClcbiAgICAgIGVuZFBvc2l0aW9uLnggLT0gaG9yaXpvbnRhbEluc2lkZSA/IHRoaXMuX2ZyYW1lV2lkdGggOiAwXG5cbiAgICAgIGVuZFNwcml0ZS5zZXRQb3NpdGlvbihlbmRQb3NpdGlvbilcbiAgICAgIGVuZFNwcml0ZS5zZXRIZWlnaHQodGhpcy5fZnJhbWVXaWR0aClcbiAgICAgIGVuZFNwcml0ZS5zZXRXaWR0aChlbmRXaWR0aClcbiAgICB9XG5cbiAgICBpZiAobWlkU3ByaXRlKSB7XG4gICAgICB0ZXh0dXJlRGltZW5zaW9ucyA9IG1pZFNwcml0ZS5nZXRUZXh0dXJlKCkuZ2V0RGltZW5zaW9ucygpXG4gICAgICB0ZXh0dXJlUmF0aW8gPSB0ZXh0dXJlRGltZW5zaW9ucy55IC8gdGV4dHVyZURpbWVuc2lvbnMueFxuXG4gICAgICBsZXQgbWlkUG9zaXRpb24gPSBuZXcgVmVjdG9yMihzdGFydFdpZHRoLCBvZmZzZXQpXG4gICAgICBsZXQgbWlkV2lkdGggPSBkaW1lbnNpb25zLnggLSBzdGFydFdpZHRoIC0gZW5kV2lkdGhcblxuICAgICAgaWYgKGhvcml6b250YWxJbnNpZGUpIHtcbiAgICAgICAgbWlkUG9zaXRpb24ueCArPSB0aGlzLl9mcmFtZVdpZHRoXG4gICAgICAgIG1pZFdpZHRoIC09IHRoaXMuX2ZyYW1lV2lkdGggKiAyXG4gICAgICB9XG5cbiAgICAgIG1pZFNwcml0ZS5zZXRQb3NpdGlvbihtaWRQb3NpdGlvbilcbiAgICAgIG1pZFNwcml0ZS5zZXRXaWR0aChtaWRXaWR0aClcbiAgICAgIG1pZFNwcml0ZS5zZXRIZWlnaHQodGhpcy5fZnJhbWVXaWR0aClcblxuICAgICAgLy8gSGFuZGxlIHJlcGVhdFxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZnJhbWUuaW1hZ2VHcm91cHNbZ3JvdXBdLm1pZC5tb2RlID09PSAncmVwZWF0Jykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBleGFjdGx5IHRoZSByaWdodCBhbW91bnQgb2Ygc3ByaXRlcyB3ZSBuZWVkXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTcHJpdGVXaWR0aCA9IHRoaXMuX2ZyYW1lV2lkdGggLyB0ZXh0dXJlUmF0aW9cbiAgICAgICAgY29uc3QgcmVxdWlyZWRSZXBlYXRTcHJpdGVzID0gTWF0aC5jZWlsKG1pZFdpZHRoIC8gZGVmYXVsdFNwcml0ZVdpZHRoKVxuICAgICAgICBsZXQgY29uc3VtZWRXaWR0aCA9IDBcblxuICAgICAgICBpZiAocmVxdWlyZWRSZXBlYXRTcHJpdGVzICE9PSAtMSkge1xuICAgICAgICAgIGxldCBzcHJpdGVXaWR0aCA9IE1hdGgucm91bmQobWlkV2lkdGggLyByZXF1aXJlZFJlcGVhdFNwcml0ZXMpXG4gICAgICAgICAgbWlkU3ByaXRlLnNldFdpZHRoKHNwcml0ZVdpZHRoKVxuICAgICAgICAgIGNvbnN1bWVkV2lkdGggKz0gc3ByaXRlV2lkdGhcblxuICAgICAgICAgIHRoaXMuX2Vuc3VyZVJlcGVhdFNwcml0ZXNFeGlzdChyZXF1aXJlZFJlcGVhdFNwcml0ZXMgLSAxLCBncm91cCwgbWlkU3ByaXRlKVxuXG4gICAgICAgICAgLy8gUmVwb3NpdGlvbiBhbGwgcmVwZWF0IHNwcml0ZXNcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVpcmVkUmVwZWF0U3ByaXRlcyAtIDE7IGkrKykge1xuICAgICAgICAgICAgLy8gRGl2aWRlIHRoZSByZW1haW5pbmcgaGVpZ2h0IGJ5IHRoZSByZW1haW5pbmcgYW1vdW50IG9mIHNwcml0ZXMgdG8gYmUgcGxhY2VkXG4gICAgICAgICAgICBzcHJpdGVXaWR0aCA9IE1hdGgucm91bmQoKG1pZFdpZHRoIC0gY29uc3VtZWRXaWR0aCkgLyAocmVxdWlyZWRSZXBlYXRTcHJpdGVzIC0gaSAtIDEpKVxuXG4gICAgICAgICAgICBjb25zdCBzcHJpdGUgPSB0aGlzLl9yZXBlYXRTcHJpdGVzW2dyb3VwXVtpXVxuICAgICAgICAgICAgY29uc3Qgc3ByaXRlUG9zaXRpb24gPSBtaWRQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAgICAgICAgIC5hZGQoY29uc3VtZWRXaWR0aCwgMClcbiAgICAgICAgICAgICAgLmZsb29yKClcbiAgICAgICAgICAgIHNwcml0ZS5zZXRQb3NpdGlvbihzcHJpdGVQb3NpdGlvbilcbiAgICAgICAgICAgIHNwcml0ZS5zZXRXaWR0aChzcHJpdGVXaWR0aClcbiAgICAgICAgICAgIHNwcml0ZS5zZXRIZWlnaHQodGhpcy5fZnJhbWVXaWR0aClcblxuICAgICAgICAgICAgY29uc3VtZWRXaWR0aCArPSBzcHJpdGVXaWR0aFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVSZXBlYXRTcHJpdGVzRXhpc3QgKHJlcXVpcmVkU3ByaXRlc0NvdW50LCBncm91cCwgc291cmNlU3ByaXRlKSB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IGdldCBhbiBFdmVudEVtaXR0ZXIgd2FybmluZ1xuICAgIHNvdXJjZVNwcml0ZS5nZXRUZXh0dXJlKCkuc2V0TWF4TGlzdGVuZXJzKHJlcXVpcmVkU3ByaXRlc0NvdW50ICsgMSlcblxuICAgIGNvbnN0IGV4aXN0aW5nU3ByaXRlc0NvdW50ID0gdGhpcy5fcmVwZWF0U3ByaXRlc1tncm91cF0ubGVuZ3RoXG4gICAgaWYgKHJlcXVpcmVkU3ByaXRlc0NvdW50ID4gZXhpc3RpbmdTcHJpdGVzQ291bnQpIHtcbiAgICAgIC8vIFdlIG5lZWQgbW9yZSBzcHJpdGVzXG4gICAgICBjb25zdCBtaXNzaW5nUmVwZWF0U3ByaXRlcyA9IHJlcXVpcmVkU3ByaXRlc0NvdW50IC0gZXhpc3RpbmdTcHJpdGVzQ291bnRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWlzc2luZ1JlcGVhdFNwcml0ZXM7IGkrKykge1xuICAgICAgICBjb25zdCBzcHJpdGUgPSBuZXcgRW5naW5lLlNwcml0ZShzb3VyY2VTcHJpdGUuZ2V0VGV4dHVyZSgpKVxuICAgICAgICB0aGlzLl9yZXBlYXRTcHJpdGVzW2dyb3VwXS5wdXNoKHNwcml0ZSlcbiAgICAgICAgdGhpcy5fZnJhbWVDb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKVxuICAgICAgICB0aGlzLl9zcHJpdGVzLnB1c2goc3ByaXRlKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVxdWlyZWRTcHJpdGVzQ291bnQgPCBleGlzdGluZ1Nwcml0ZXNDb3VudCkge1xuICAgICAgLy8gV2UgbmVlZCBsZXNzIHNwcml0ZXNcbiAgICAgIGNvbnN0IHNwYXJlUmVwZWF0U3ByaXRlcyA9IHRoaXMuX3JlcGVhdFNwcml0ZXNbZ3JvdXBdLnNwbGljZShyZXF1aXJlZFNwcml0ZXNDb3VudClcbiAgICAgIHNwYXJlUmVwZWF0U3ByaXRlcy5mb3JFYWNoKChzcHJpdGUpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9zcHJpdGVzLmluZGV4T2Yoc3ByaXRlKVxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm5cblxuICAgICAgICB0aGlzLl9zcHJpdGVzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgdGhpcy5fZnJhbWVDb250YWluZXIucmVtb3ZlQ2hpbGQoc3ByaXRlKVxuICAgICAgICBzcHJpdGUuZGlzcG9zZSgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzcHJpdGUgcG9zaXRpb25zIGFuZCBzY2FsZSBmb3IgZ2l2ZW4gdmVydGljYWwgY29sdW1uXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlRleHR1cmV9IGlucHV0VGV4dHVyZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCA9IDBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVWZXJ0aWNhbFNwcml0ZUdyb3VwIChpbnB1dFRleHR1cmUsIGdyb3VwLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IGlucHV0VGV4dHVyZS5nZXREaW1lbnNpb25zKClcbiAgICBjb25zdCB2ZXJ0aWNhbEluc2lkZSA9IHRoaXMuX2xheW91dE1vZGUgPT09ICd2ZXJ0aWNhbC1pbnNpZGUnXG5cbiAgICBjb25zdCBzdGFydFNwcml0ZSA9IHRoaXMuX3Nwcml0ZUdyb3Vwc1tncm91cF0uc3RhcnRcbiAgICBjb25zdCBtaWRTcHJpdGUgPSB0aGlzLl9zcHJpdGVHcm91cHNbZ3JvdXBdLm1pZFxuICAgIGNvbnN0IGVuZFNwcml0ZSA9IHRoaXMuX3Nwcml0ZUdyb3Vwc1tncm91cF0uZW5kXG5cbiAgICBsZXQgc3RhcnRIZWlnaHQgPSAwXG4gICAgbGV0IGVuZEhlaWdodCA9IDBcblxuICAgIGxldCB0ZXh0dXJlRGltZW5zaW9ucywgdGV4dHVyZVJhdGlvXG4gICAgaWYgKHN0YXJ0U3ByaXRlKSB7XG4gICAgICB0ZXh0dXJlRGltZW5zaW9ucyA9IHN0YXJ0U3ByaXRlLmdldFRleHR1cmUoKS5nZXREaW1lbnNpb25zKClcbiAgICAgIHRleHR1cmVSYXRpbyA9IHRleHR1cmVEaW1lbnNpb25zLnkgLyB0ZXh0dXJlRGltZW5zaW9ucy54XG5cbiAgICAgIHN0YXJ0SGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLl9mcmFtZVdpZHRoICogdGV4dHVyZVJhdGlvKVxuXG4gICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gbmV3IFZlY3RvcjIob2Zmc2V0LCAwKVxuICAgICAgc3RhcnRQb3NpdGlvbi55ID0gdmVydGljYWxJbnNpZGUgPyB0aGlzLl9mcmFtZVdpZHRoIDogMFxuXG4gICAgICBzdGFydFNwcml0ZS5zZXRQb3NpdGlvbihzdGFydFBvc2l0aW9uKVxuICAgICAgc3RhcnRTcHJpdGUuc2V0V2lkdGgodGhpcy5fZnJhbWVXaWR0aClcbiAgICAgIHN0YXJ0U3ByaXRlLnNldEhlaWdodChzdGFydEhlaWdodClcbiAgICB9XG5cbiAgICBpZiAoZW5kU3ByaXRlKSB7XG4gICAgICB0ZXh0dXJlRGltZW5zaW9ucyA9IGVuZFNwcml0ZS5nZXRUZXh0dXJlKCkuZ2V0RGltZW5zaW9ucygpXG4gICAgICB0ZXh0dXJlUmF0aW8gPSB0ZXh0dXJlRGltZW5zaW9ucy55IC8gdGV4dHVyZURpbWVuc2lvbnMueFxuXG4gICAgICBlbmRIZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuX2ZyYW1lV2lkdGggKiB0ZXh0dXJlUmF0aW8pXG5cbiAgICAgIGxldCBlbmRQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKG9mZnNldCwgZGltZW5zaW9ucy55IC0gZW5kSGVpZ2h0KVxuICAgICAgZW5kUG9zaXRpb24ueSAtPSB2ZXJ0aWNhbEluc2lkZSA/IHRoaXMuX2ZyYW1lV2lkdGggOiAwXG5cbiAgICAgIGVuZFNwcml0ZS5zZXRQb3NpdGlvbihlbmRQb3NpdGlvbilcbiAgICAgIGVuZFNwcml0ZS5zZXRXaWR0aCh0aGlzLl9mcmFtZVdpZHRoKVxuICAgICAgZW5kU3ByaXRlLnNldEhlaWdodChlbmRIZWlnaHQpXG4gICAgfVxuXG4gICAgaWYgKG1pZFNwcml0ZSkge1xuICAgICAgdGV4dHVyZURpbWVuc2lvbnMgPSBtaWRTcHJpdGUuZ2V0VGV4dHVyZSgpLmdldERpbWVuc2lvbnMoKVxuICAgICAgdGV4dHVyZVJhdGlvID0gdGV4dHVyZURpbWVuc2lvbnMueSAvIHRleHR1cmVEaW1lbnNpb25zLnhcblxuICAgICAgbGV0IG1pZFBvc2l0aW9uID0gbmV3IFZlY3RvcjIob2Zmc2V0LCBzdGFydEhlaWdodClcbiAgICAgIGxldCBtaWRIZWlnaHQgPSBkaW1lbnNpb25zLnkgLSBzdGFydEhlaWdodCAtIGVuZEhlaWdodFxuXG4gICAgICBpZiAodmVydGljYWxJbnNpZGUpIHtcbiAgICAgICAgbWlkUG9zaXRpb24ueSArPSB0aGlzLl9mcmFtZVdpZHRoXG4gICAgICAgIG1pZEhlaWdodCAtPSB0aGlzLl9mcmFtZVdpZHRoICogMlxuICAgICAgfVxuXG4gICAgICBtaWRTcHJpdGUuc2V0UG9zaXRpb24obWlkUG9zaXRpb24pXG4gICAgICBtaWRTcHJpdGUuc2V0SGVpZ2h0KG1pZEhlaWdodClcbiAgICAgIG1pZFNwcml0ZS5zZXRXaWR0aCh0aGlzLl9mcmFtZVdpZHRoKVxuXG4gICAgICAvLyBIYW5kbGUgcmVwZWF0XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5mcmFtZS5pbWFnZUdyb3Vwc1tncm91cF0ubWlkLm1vZGUgPT09ICdyZXBlYXQnKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGV4YWN0bHkgdGhlIHJpZ2h0IGFtb3VudCBvZiBzcHJpdGVzIHdlIG5lZWRcbiAgICAgICAgY29uc3QgZGVmYXVsdFNwcml0ZUhlaWdodCA9IHRoaXMuX2ZyYW1lV2lkdGggKiB0ZXh0dXJlUmF0aW9cbiAgICAgICAgY29uc3QgcmVxdWlyZWRSZXBlYXRTcHJpdGVzID0gTWF0aC5jZWlsKG1pZEhlaWdodCAvIGRlZmF1bHRTcHJpdGVIZWlnaHQpXG4gICAgICAgIGxldCBjb25zdW1lZEhlaWdodCA9IDBcblxuICAgICAgICBpZiAocmVxdWlyZWRSZXBlYXRTcHJpdGVzICE9PSAtMSkge1xuICAgICAgICAgIGxldCBzcHJpdGVIZWlnaHQgPSBNYXRoLnJvdW5kKG1pZEhlaWdodCAvIHJlcXVpcmVkUmVwZWF0U3ByaXRlcylcbiAgICAgICAgICBtaWRTcHJpdGUuc2V0SGVpZ2h0KHNwcml0ZUhlaWdodClcbiAgICAgICAgICBjb25zdW1lZEhlaWdodCArPSBzcHJpdGVIZWlnaHRcblxuICAgICAgICAgIHRoaXMuX2Vuc3VyZVJlcGVhdFNwcml0ZXNFeGlzdChyZXF1aXJlZFJlcGVhdFNwcml0ZXMgLSAxLCBncm91cCwgbWlkU3ByaXRlKVxuXG4gICAgICAgICAgLy8gUmVwb3NpdGlvbiBhbGwgcmVwZWF0IHNwcml0ZXNcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVpcmVkUmVwZWF0U3ByaXRlcyAtIDE7IGkrKykge1xuICAgICAgICAgICAgLy8gRGl2aWRlIHRoZSByZW1haW5pbmcgaGVpZ2h0IGJ5IHRoZSByZW1haW5pbmcgYW1vdW50IG9mIHNwcml0ZXMgdG8gYmUgcGxhY2VkXG4gICAgICAgICAgICBzcHJpdGVIZWlnaHQgPSBNYXRoLnJvdW5kKChtaWRIZWlnaHQgLSBjb25zdW1lZEhlaWdodCkgLyAocmVxdWlyZWRSZXBlYXRTcHJpdGVzIC0gaSAtIDEpKVxuXG4gICAgICAgICAgICBjb25zdCBzcHJpdGUgPSB0aGlzLl9yZXBlYXRTcHJpdGVzW2dyb3VwXVtpXVxuICAgICAgICAgICAgY29uc3Qgc3ByaXRlUG9zaXRpb24gPSBtaWRQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAgICAgICAgIC5hZGQoMCwgY29uc3VtZWRIZWlnaHQpXG4gICAgICAgICAgICAgIC5mbG9vcigpXG4gICAgICAgICAgICBzcHJpdGUuc2V0UG9zaXRpb24oc3ByaXRlUG9zaXRpb24pXG4gICAgICAgICAgICBzcHJpdGUuc2V0SGVpZ2h0KHNwcml0ZUhlaWdodClcbiAgICAgICAgICAgIHNwcml0ZS5zZXRXaWR0aCh0aGlzLl9mcmFtZVdpZHRoKVxuXG4gICAgICAgICAgICBjb25zdW1lZEhlaWdodCArPSBzcHJpdGVIZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgYWxsIHNwcml0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXNwb3NlU3ByaXRlcyAoKSB7XG4gICAgdGhpcy5fc3ByaXRlcy5mb3JFYWNoKChzcHJpdGUpID0+IHtcbiAgICAgIHRoaXMuX2ZyYW1lQ29udGFpbmVyLnJlbW92ZUNoaWxkKHNwcml0ZSlcbiAgICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gc3ByaXRlLmdldFRleHR1cmUoKS5nZXRCYXNlVGV4dHVyZSgpXG4gICAgICBiYXNlVGV4dHVyZS5kaXNwb3NlKClcblxuICAgICAgc3ByaXRlLmRpc3Bvc2UoKVxuICAgIH0pXG4gICAgdGhpcy5fcmVzZXRTcHJpdGVzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIG9wZXJhdGlvblxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpXG4gICAgdGhpcy5fZGlzcG9zZVNwcml0ZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gZnJhbWUgb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gZnJhbWVcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZUZyYW1lIChmcmFtZSkge1xuICAgIGlmICghZnJhbWUpIHJldHVyblxuICAgIGNvbnN0IHsgaW1hZ2VHcm91cHMsIGxheW91dE1vZGUgfSA9IGZyYW1lXG5cbiAgICBpZiAodHlwZW9mIGZyYW1lLm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lIG5lZWRzIGEgcHJvcGVydHkgYG5hbWVgIG9mIHR5cGUgU3RyaW5nLicpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmcmFtZS5sYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWUgbmVlZHMgYSBwcm9wZXJ0eSBgbGFiZWxgIG9mIHR5cGUgU3RyaW5nLicpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmcmFtZS5pbWFnZUdyb3VwcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWUgbmVlZHMgYSBwcm9wZXJ0eSBgaW1hZ2VHcm91cHNgIG9mIHR5cGUgT2JqZWN0LicpXG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWRhdGVJbWFnZUdyb3VwID0gKGdyb3VwKSA9PiB7XG4gICAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIG1pZCB9ID0gaW1hZ2VHcm91cHNbZ3JvdXBdXG5cbiAgICAgIGlmICh0eXBlb2YgaW1hZ2VHcm91cHNbZ3JvdXBdID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG4gICAgICBpZiAodHlwZW9mIGltYWdlR3JvdXBzW2dyb3VwXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcmFtZTogXFxgaW1hZ2VHcm91cHMuJHtncm91cH1cXGAgbmVlZHMgdG8gYmUgb2YgdHlwZSBPYmplY3QuYClcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAhKHN0YXJ0IGluc3RhbmNlb2YgSW1hZ2UgfHwgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBzdGFydCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZyYW1lOiBcXGBpbWFnZUdyb3Vwcy4ke2dyb3VwfS5zdGFydFxcYCBuZWVkcyB0byBiZSBvZiB0eXBlIEltYWdlLmApXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbWlkICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICEoc3RhcnQgaW5zdGFuY2VvZiBJbWFnZSB8fCAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHN0YXJ0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpICYmXG4gICAgICAgICAgdHlwZW9mIG1pZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcmFtZTogXFxgaW1hZ2VHcm91cHMuJHtncm91cH0ubWlkXFxgIG5lZWRzIHRvIGJlIG9mIHR5cGUgSW1hZ2Ugb3IgT2JqZWN0LmApXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICEoZW5kIGluc3RhbmNlb2YgSW1hZ2UgfHwgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBlbmQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcmFtZTogXFxgaW1hZ2VHcm91cHMuJHtncm91cH0uZW5kXFxgIG5lZWRzIHRvIGJlIG9mIHR5cGUgSW1hZ2UuYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxheW91dE1vZGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIFsndmVydGljYWwtaW5zaWRlJywgJ2hvcml6b250YWwtaW5zaWRlJ10uaW5kZXhPZihsYXlvdXRNb2RlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRnJhbWU6IFxcYGxheW91dE1vZGVcXGAgbXVzdCBiZSBvbmUgb2YgdmVydGljYWwtaW5zaWRlLCBob3Jpem9udGFsLWluc2lkZWApXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aW50YWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRpbnRhYmxlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRnJhbWU6IFxcYHRpbnRhYmxlXFxgIG5lZWRzIHRvIGJlIG9mIHR5cGUgQm9vbGVhbi5gKVxuICAgIH1cblxuICAgIHZhbGlkYXRlSW1hZ2VHcm91cCgndG9wJylcbiAgICB2YWxpZGF0ZUltYWdlR3JvdXAoJ2xlZnQnKVxuICAgIHZhbGlkYXRlSW1hZ2VHcm91cCgncmlnaHQnKVxuICAgIHZhbGlkYXRlSW1hZ2VHcm91cCgnYm90dG9tJylcbiAgfVxufVxuXG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICogb3BlcmF0aW9ucy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5GcmFtZU9wZXJhdGlvbi5pZGVudGlmaWVyID0gJ2ZyYW1lJ1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5GcmFtZU9wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgZnJhbWU6IHtcbiAgICB0eXBlOiBPcHRpb25UeXBlLk9CSkVDVCxcbiAgICB2YWxpZGF0aW9uOiBGcmFtZU9wZXJhdGlvbi52YWxpZGF0ZUZyYW1lLFxuICAgIHNldHRlcjogZnVuY3Rpb24gKGZyYW1lLCBpbml0aWFsKSB7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlU3ByaXRlc0ZvckZyYW1lKGZyYW1lKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYW1lXG4gICAgfVxuICB9LFxuICB0aW50Q29sb3I6IHsgdHlwZTogT3B0aW9uVHlwZS5DT0xPUiwgZGVmYXVsdDogbmV3IENvbG9yKDEsIDEsIDEsIDApIH0sXG4gIHNjYWxlOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLjEgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmFtZU9wZXJhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9mcmFtZS1vcGVyYXRpb24uanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbnN0YW50cywgVmVjdG9yMiB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uJ1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vdmVuZG9yL3Byb21pc2UnXG5pbXBvcnQgTGluZWFyRm9jdXNGaWx0ZXIgZnJvbSAnLi9mb2N1cy9saW5lYXItZm9jdXMtZmlsdGVyJ1xuY29uc3QgeyBPcHRpb25UeXBlIH0gPSBDb25zdGFudHNcblxuLyoqXG4gKiBBbiBvcGVyYXRpb24gdGhhdCBjYW4gZHJhdyBhIGxpbmVhciBmb2N1c1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5PcGVyYXRpb25cbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zXG4gKi9cbmNsYXNzIExpbmVhckZvY3VzT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTGluZWFyRm9jdXNPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fbGFzdEJsdXJSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXNcbiAgICB0aGlzLl9sYXN0U2l6ZSA9IHRoaXMuX29wdGlvbnMuc2l6ZVxuICAgIHRoaXMuX2xhc3RHcmFkaWVudFNpemUgPSB0aGlzLl9vcHRpb25zLmdyYWRpZW50U2l6ZVxuXG4gICAgdGhpcy5faG9yaXpvbnRhbEZpbHRlciA9IG5ldyBMaW5lYXJGb2N1c0ZpbHRlcigpXG4gICAgdGhpcy5fdmVydGljYWxGaWx0ZXIgPSBuZXcgTGluZWFyRm9jdXNGaWx0ZXIoKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRGaWx0ZXJzKFtcbiAgICAgIHRoaXMuX2hvcml6b250YWxGaWx0ZXIsXG4gICAgICB0aGlzLl92ZXJ0aWNhbEZpbHRlclxuICAgIF0pXG5cbiAgICB0aGlzLl9ob3Jpem9udGFsRmlsdGVyLnNldERlbHRhKG5ldyBWZWN0b3IyKDEsIDEpKVxuICAgIHRoaXMuX3ZlcnRpY2FsRmlsdGVyLnNldERlbHRhKG5ldyBWZWN0b3IyKC0xLCAxKSlcblxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBMaW5lYXJGb2N1c0ZpbHRlcigpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZ2l2ZW4gcm90YXRpb24gY2hhbmdlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuUm90YXRpb25PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZXNcbiAgICovXG4gIHJvdGF0ZSAoZGVncmVlcykge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fb3B0aW9ucy5zdGFydFxuICAgIGNvbnN0IGVuZCA9IHRoaXMuX29wdGlvbnMuZW5kXG5cbiAgICBpZiAoZGVncmVlcyA9PT0gOTApIHtcbiAgICAgIHN0YXJ0LmZsaXAoKVxuICAgICAgc3RhcnQueCA9IDEgLSBzdGFydC54XG4gICAgICBlbmQuZmxpcCgpXG4gICAgICBlbmQueCA9IDEgLSBlbmQueFxuICAgIH0gZWxzZSBpZiAoZGVncmVlcyA9PT0gLTkwKSB7XG4gICAgICBzdGFydC5mbGlwKClcbiAgICAgIHN0YXJ0LnkgPSAxIC0gc3RhcnQueVxuICAgICAgZW5kLmZsaXAoKVxuICAgICAgZW5kLnkgPSAxIC0gZW5kLnlcbiAgICB9XG5cbiAgICB0aGlzLnNldCh7IHN0YXJ0LCBlbmQgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgZmxpcCB3aXRoIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICovXG4gIGZsaXAgKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fb3B0aW9ucy5zdGFydFxuICAgIGNvbnN0IGVuZCA9IHRoaXMuX29wdGlvbnMuZW5kXG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgIHN0YXJ0LnggPSAxIC0gc3RhcnQueFxuICAgICAgICBlbmQueCA9IDEgLSBlbmQueFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICBzdGFydC55ID0gMSAtIHN0YXJ0LnlcbiAgICAgICAgZW5kLnkgPSAxIC0gZW5kLnlcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB0aGlzLnNldCh7IHN0YXJ0LCBlbmQgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcm9wcyB0aGlzIGltYWdlIHVzaW5nIFdlYkdMXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfSBpbnB1dFRleHR1cmVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBfcmVuZGVyV2ViR0wgKGlucHV0VGV4dHVyZSkge1xuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGV4dHVyZS5nZXREaW1lbnNpb25zKClcbiAgICBjb25zdCBzaG9ydGVzdFNpZGUgPSBpbnB1dERpbWVuc2lvbnMubWluKClcblxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fb3B0aW9ucy5zdGFydC5jbG9uZSgpXG4gICAgY29uc3QgZW5kID0gdGhpcy5fb3B0aW9ucy5lbmQuY2xvbmUoKVxuXG4gICAgY29uc3QgeyBibHVyUmFkaXVzLCBzaXplLCBncmFkaWVudFNpemUgfSA9IHRoaXMuX29wdGlvbnNcbiAgICBjb25zdCBjb21tb25PcHRpb25zID0ge1xuICAgICAgYmx1clJhZGl1czogYmx1clJhZGl1cyAqIHNob3J0ZXN0U2lkZSxcbiAgICAgIHNpemU6IHNpemUgKiBzaG9ydGVzdFNpZGUsXG4gICAgICBncmFkaWVudFNpemU6IGdyYWRpZW50U2l6ZSAqIHNob3J0ZXN0U2lkZSxcblxuICAgICAgc3RhcnQ6IHN0YXJ0LmNsb25lKCkubXVsdGlwbHkoaW5wdXREaW1lbnNpb25zKSxcbiAgICAgIGVuZDogZW5kLmNsb25lKCkubXVsdGlwbHkoaW5wdXREaW1lbnNpb25zKSxcbiAgICAgIHRleFNpemU6IGlucHV0RGltZW5zaW9uc1xuICAgIH1cblxuICAgIHRoaXMuX2hvcml6b250YWxGaWx0ZXIuc2V0KGNvbW1vbk9wdGlvbnMpXG4gICAgdGhpcy5fdmVydGljYWxGaWx0ZXIuc2V0KGNvbW1vbk9wdGlvbnMpXG5cbiAgICB0aGlzLl9yZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSByYWRpYWwgYmx1ciB1c2luZyBDYW52YXMyRFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAoaW5wdXRUZXh0dXJlKSB7XG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gaW5wdXRUZXh0dXJlLmdldERpbWVuc2lvbnMoKVxuXG4gICAgY29uc3QgeyBibHVyUmFkaXVzLCBzaXplLCBncmFkaWVudFNpemUsIHN0YXJ0LCBlbmQgfSA9IHRoaXMuX29wdGlvbnNcbiAgICB0aGlzLl9maWx0ZXIuc2V0KHtcbiAgICAgIGJsdXJSYWRpdXM6IGJsdXJSYWRpdXMsXG4gICAgICBncmFkaWVudFNpemU6IGdyYWRpZW50U2l6ZSxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBzdGFydDogc3RhcnQuY2xvbmUoKSxcbiAgICAgIGVuZDogZW5kLmNsb25lKCksXG4gICAgICB0ZXhTaXplOiBpbnB1dERpbWVuc2lvbnNcbiAgICB9KVxuXG4gICAgdGhpcy5fc3ByaXRlLnNldEZpbHRlcnMoW1xuICAgICAgdGhpcy5fZmlsdGVyXG4gICAgXSlcblxuICAgIHRoaXMuX3JlbmRlclRleHR1cmUucmVuZGVyKHRoaXMuX2NvbnRhaW5lcilcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICBzdXBlci5kaXNwb3NlKClcbiAgICB0aGlzLl9maWx0ZXIuZGlzcG9zZSgpXG4gICAgdGhpcy5fdmVydGljYWxGaWx0ZXIuZGlzcG9zZSgpXG4gICAgdGhpcy5faG9yaXpvbnRhbEZpbHRlci5kaXNwb3NlKClcbiAgfVxufVxuXG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICogb3BlcmF0aW9ucy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5MaW5lYXJGb2N1c09wZXJhdGlvbi5pZGVudGlmaWVyID0gJ2xpbmVhci1mb2N1cydcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuTGluZWFyRm9jdXNPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHN0YXJ0OiB7IHR5cGU6IE9wdGlvblR5cGUuVkVDVE9SMiwgZGVmYXVsdDogbmV3IFZlY3RvcjIoMC4wLCAwLjUpIH0sXG4gIGVuZDogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDEuMCwgMC41KSB9LFxuICBibHVyUmFkaXVzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLjAyNSB9LFxuICBzaXplOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLjEgfSxcbiAgZ3JhZGllbnRTaXplOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLjEgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5lYXJGb2N1c09wZXJhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9saW5lYXItZm9jdXMtb3BlcmF0aW9uLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vdmVuZG9yL3Byb21pc2UnXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi9saWIvbWF0aC92ZWN0b3IyJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcbmNvbnN0IHsgT3B0aW9uVHlwZSB9ID0gQ29uc3RhbnRzXG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIHJvdGF0ZSBhbmQgZmxpcCBhbiBpbWFnZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5PcGVyYXRpb25cbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zXG4gKi9cbmNsYXNzIE9yaWVudGF0aW9uT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIFJvdGF0ZXMgYW5kL29yIGZsaXBzIHRoZSBpbWFnZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXIgKHNkaykge1xuICAgIGNvbnN0IGFjdHVhbERlZ3JlZXMgPSB0aGlzLl9vcHRpb25zLnJvdGF0aW9uICUgMzYwXG4gICAgY29uc3QgcmFkaWFucyA9IGFjdHVhbERlZ3JlZXMgKiAoTWF0aC5QSSAvIDE4MClcblxuICAgIHRoaXMuX3Nwcml0ZS5zZXRTY2FsZShcbiAgICAgIHRoaXMuX29wdGlvbnMuZmxpcEhvcml6b250YWxseSA/IC0xIDogMSxcbiAgICAgIHRoaXMuX29wdGlvbnMuZmxpcFZlcnRpY2FsbHkgPyAtMSA6IDFcbiAgICApXG4gICAgdGhpcy5fc3ByaXRlLnNldFJvdGF0aW9uKHJhZGlhbnMpXG4gICAgdGhpcy5fc3ByaXRlLnNldEFuY2hvcigwLjUsIDAuNSlcbiAgICB0aGlzLl9zcHJpdGUudXBkYXRlVHJhbnNmb3JtKClcblxuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX3Nwcml0ZS5nZXRCb3VuZHMoKVxuICAgIHRoaXMuX3JlbmRlclRleHR1cmUucmVzaXplVG8obmV3IFZlY3RvcjIoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KSlcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSByZW5kZXJpbmcgdG8gdG9wIGxlZnQgY29ybmVyXG4gICAgdGhpcy5fc3ByaXRlLnNldFBvc2l0aW9uKHRoaXMuX3JlbmRlclRleHR1cmUuZ2V0RGltZW5zaW9ucygpLmRpdmlkZSgyKSlcblxuICAgIC8vIERyYXdcbiAgICB0aGlzLl9yZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIHRoZSBnaXZlbiBkaW1lbnNpb25zIHdpbGwgaGF2ZSBhZnRlciB0aGlzIG9wZXJhdGlvblxuICAgKiBoYXMgYmVlbiBhcHBsaWVkXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXROZXdEaW1lbnNpb25zIChkaW1lbnNpb25zKSB7XG4gICAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMuY2xvbmUoKVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnJvdGF0aW9uICUgMTgwKSB7XG4gICAgICBkaW1lbnNpb25zLmZsaXAoKVxuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIEZsaXBzIHRoZSBpbWFnZSB3aGlsZSBpbmNvcnBvcmF0aW5nIHRoZSBjdXJyZW50IHJvdGF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICovXG4gIGZsaXAgKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgcm90YXRpb24gfSA9IHRoaXMuX29wdGlvbnNcbiAgICBpZiAocm90YXRpb24gPT09IDkwIHx8IHJvdGF0aW9uID09PSAyNzApIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gJ2hvcml6b250YWwnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJlY3Rpb24gPSAndmVydGljYWwnXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgdGhpcy5zZXRGbGlwVmVydGljYWxseSghdGhpcy5nZXRGbGlwVmVydGljYWxseSgpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgIHRoaXMuc2V0RmxpcEhvcml6b250YWxseSghdGhpcy5nZXRGbGlwSG9yaXpvbnRhbGx5KCkpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gKiBvcGVyYXRpb25zLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbk9yaWVudGF0aW9uT3BlcmF0aW9uLmlkZW50aWZpZXIgPSAnb3JpZW50YXRpb24nXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBvcGVyYXRpb25cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbk9yaWVudGF0aW9uT3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICByb3RhdGlvbjoge1xuICAgIHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgdmFsaWRhdGlvbjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgJSA5MCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09yaWVudGF0aW9uT3BlcmF0aW9uOiBgcm90YXRpb25gIGhhcyB0byBiZSBhIG11bHRpcGxlIG9mIDkwLicpXG4gICAgICB9XG4gICAgfSxcbiAgICBzZXR0ZXI6ICh2YWx1ZSkgPT4gKHZhbHVlICsgMzYwKSAlIDM2MFxuICB9LFxuICBmbGlwVmVydGljYWxseTogeyB0eXBlOiBPcHRpb25UeXBlLkJPT0xFQU4sIGRlZmF1bHQ6IGZhbHNlIH0sXG4gIGZsaXBIb3Jpem9udGFsbHk6IHsgdHlwZTogT3B0aW9uVHlwZS5CT09MRUFOLCBkZWZhdWx0OiBmYWxzZSB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9yaWVudGF0aW9uT3BlcmF0aW9uXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL29yaWVudGF0aW9uLW9wZXJhdGlvbi5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgQ29uc3RhbnRzLCBWZWN0b3IyIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBPcGVyYXRpb24gZnJvbSAnLi9vcGVyYXRpb24nXG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuLi92ZW5kb3IvcHJvbWlzZSdcbmltcG9ydCBSYWRpYWxGb2N1c0ZpbHRlciBmcm9tICcuL2ZvY3VzL3JhZGlhbC1mb2N1cy1maWx0ZXInXG5jb25zdCB7IE9wdGlvblR5cGUgfSA9IENvbnN0YW50c1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBkcmF3IGEgcmFkaWFsIGZvY3VzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvblxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgUmFkaWFsRm9jdXNPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSYWRpYWxGb2N1c09wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9sYXN0Qmx1clJhZGl1cyA9IHRoaXMuX29wdGlvbnMuYmx1clJhZGl1c1xuICAgIHRoaXMuX2xhc3RHcmFkaWVudFJhZGl1cyA9IHRoaXMuX29wdGlvbnMuZ3JhZGllbnRSYWRpdXNcblxuICAgIHRoaXMuX2hvcml6b250YWxGaWx0ZXIgPSBuZXcgUmFkaWFsRm9jdXNGaWx0ZXIoKVxuICAgIHRoaXMuX3ZlcnRpY2FsRmlsdGVyID0gbmV3IFJhZGlhbEZvY3VzRmlsdGVyKClcbiAgICB0aGlzLl9zcHJpdGUuc2V0RmlsdGVycyhbXG4gICAgICB0aGlzLl9ob3Jpem9udGFsRmlsdGVyLFxuICAgICAgdGhpcy5fdmVydGljYWxGaWx0ZXJcbiAgICBdKVxuXG4gICAgdGhpcy5faG9yaXpvbnRhbEZpbHRlci5zZXREZWx0YShuZXcgVmVjdG9yMigxLCAxKSlcbiAgICB0aGlzLl92ZXJ0aWNhbEZpbHRlci5zZXREZWx0YShuZXcgVmVjdG9yMigtMSwgMSkpXG5cbiAgICB0aGlzLl9maWx0ZXIgPSBuZXcgUmFkaWFsRm9jdXNGaWx0ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIHJvdGF0aW9uIGNoYW5nZVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZXNcbiAgICovXG4gIHJvdGF0ZSAoZGVncmVlcykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fb3B0aW9ucy5wb3NpdGlvblxuXG4gICAgaWYgKGRlZ3JlZXMgPT09IDkwKSB7XG4gICAgICBwb3NpdGlvbi5mbGlwKClcbiAgICAgIHBvc2l0aW9uLnggPSAxIC0gcG9zaXRpb24ueFxuICAgIH0gZWxzZSBpZiAoZGVncmVlcyA9PT0gLTkwKSB7XG4gICAgICBwb3NpdGlvbi5mbGlwKClcbiAgICAgIHBvc2l0aW9uLnkgPSAxIC0gcG9zaXRpb24ueVxuICAgIH1cblxuICAgIHRoaXMuc2V0KHsgcG9zaXRpb24gfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgZmxpcCB3aXRoIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICovXG4gIGZsaXAgKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fb3B0aW9ucy5wb3NpdGlvblxuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICBwb3NpdGlvbi54ID0gMSAtIHBvc2l0aW9uLnhcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgcG9zaXRpb24ueSA9IDEgLSBwb3NpdGlvbi55XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgdGhpcy5zZXQoeyBwb3NpdGlvbiB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHJhZGlhbCBibHVyIHVzaW5nIFdlYkdMXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfSBpbnB1dFRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBfcmVuZGVyV2ViR0wgKGlucHV0VGV4dHVyZSkge1xuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGV4dHVyZS5nZXREaW1lbnNpb25zKClcbiAgICBjb25zdCBzaG9ydGVzdFNpZGUgPSBpbnB1dERpbWVuc2lvbnMubWluKClcblxuICAgIGNvbnN0IHsgcG9zaXRpb24sIGJsdXJSYWRpdXMsIHJhZGl1cywgZ3JhZGllbnRSYWRpdXMgfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIGNvbnN0IGNvbW1vbk9wdGlvbnMgPSB7XG4gICAgICBibHVyUmFkaXVzOiBibHVyUmFkaXVzICogc2hvcnRlc3RTaWRlLFxuICAgICAgcmFkaXVzOiByYWRpdXMgKiBzaG9ydGVzdFNpZGUsXG4gICAgICBncmFkaWVudFJhZGl1czogZ3JhZGllbnRSYWRpdXMgKiBzaG9ydGVzdFNpZGUsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24uY2xvbmUoKS5tdWx0aXBseShpbnB1dERpbWVuc2lvbnMpLFxuICAgICAgdGV4U2l6ZTogaW5wdXREaW1lbnNpb25zXG4gICAgfVxuXG4gICAgdGhpcy5faG9yaXpvbnRhbEZpbHRlci5zZXQoY29tbW9uT3B0aW9ucylcbiAgICB0aGlzLl92ZXJ0aWNhbEZpbHRlci5zZXQoY29tbW9uT3B0aW9ucylcblxuICAgIHRoaXMuX3JlbmRlclRleHR1cmUucmVuZGVyKHRoaXMuX2NvbnRhaW5lcilcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHJhZGlhbCBibHVyIHVzaW5nIENhbnZhczJEXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfSBpbnB1dFRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfcmVuZGVyQ2FudmFzIChpbnB1dFRleHR1cmUpIHtcbiAgICBjb25zdCB7IGJsdXJSYWRpdXMsIHJhZGl1cywgZ3JhZGllbnRSYWRpdXMsIHBvc2l0aW9uIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gaW5wdXRUZXh0dXJlLmdldERpbWVuc2lvbnMoKVxuXG4gICAgdGhpcy5fZmlsdGVyLnNldCh7XG4gICAgICBibHVyUmFkaXVzLFxuICAgICAgcmFkaXVzLFxuICAgICAgZ3JhZGllbnRSYWRpdXMsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIHRleFNpemU6IGlucHV0RGltZW5zaW9uc1xuICAgIH0pXG5cbiAgICB0aGlzLl9zcHJpdGUuc2V0RmlsdGVycyhbXG4gICAgICB0aGlzLl9maWx0ZXJcbiAgICBdKVxuXG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBvcGVyYXRpb25cbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICAgIHRoaXMuX2ZpbHRlci5kaXNwb3NlKClcbiAgICB0aGlzLl92ZXJ0aWNhbEZpbHRlci5kaXNwb3NlKClcbiAgICB0aGlzLl9ob3Jpem9udGFsRmlsdGVyLmRpc3Bvc2UoKVxuICB9XG59XG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gKiBvcGVyYXRpb25zLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblJhZGlhbEZvY3VzT3BlcmF0aW9uLmlkZW50aWZpZXIgPSAncmFkaWFsLWZvY3VzJ1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5SYWRpYWxGb2N1c09wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgcG9zaXRpb246IHsgdHlwZTogT3B0aW9uVHlwZS5WRUNUT1IyLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigwLjUsIDAuNSkgfSxcbiAgcmFkaXVzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLjI1IH0sXG4gIGdyYWRpZW50UmFkaXVzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLjEyNSB9LFxuICBibHVyUmFkaXVzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLjAyNSB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhZGlhbEZvY3VzT3BlcmF0aW9uXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL3JhZGlhbC1mb2N1cy1vcGVyYXRpb24uanMiLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cclxuICpcclxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxyXG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XHJcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxyXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxyXG4gKlxyXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcclxuICovXHJcblxyXG5pbXBvcnQgeyBFbmdpbmUsIENvbnN0YW50cywgVmVjdG9yMiwgQ29sb3IgfSBmcm9tICcuLi9nbG9iYWxzJ1xyXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uJ1xyXG5pbXBvcnQgQnJ1c2ggZnJvbSAnLi9zcHJpdGVzL2JydXNoJ1xyXG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuLi92ZW5kb3IvcHJvbWlzZSdcclxuaW1wb3J0IEJsdXJGaWx0ZXIgZnJvbSAnLi9zaGFyZWQvYmx1ci1maWx0ZXInXHJcbmltcG9ydCBNYXNrRmlsdGVyIGZyb20gJy4vc2hhcmVkL21hc2stZmlsdGVyJ1xyXG5jb25zdCB7IE9wdGlvblR5cGUsIFJlbmRlcmVyVHlwZSB9ID0gQ29uc3RhbnRzXHJcblxyXG4vKipcclxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGRyYXcgYSBzZWxlY3RpdmUgYmx1ciB1c2luZyBicnVzaGVzXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5PcGVyYXRpb25cclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNcclxuICovXHJcbmNsYXNzIFNlbGVjdGl2ZUJsdXJPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgU2VsZWN0aXZlQmx1ck9wZXJhdGlvblxyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XHJcbiAgICBzdXBlciguLi5hcmdzKVxyXG5cclxuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fc2RrLmdldFJlbmRlcmVyKClcclxuXHJcbiAgICB0aGlzLl9sYXN0Qmx1clJhZGl1cyA9IG51bGxcclxuICAgIHRoaXMuX2JsdXJyZWRSZW5kZXJUZXh0dXJlID0gbmV3IEVuZ2luZS5SZW5kZXJUZXh0dXJlKHJlbmRlcmVyLCAxMDAsIDEwMCwgMSlcclxuICAgIHRoaXMuX21hc2tSZW5kZXJUZXh0dXJlID0gbmV3IEVuZ2luZS5SZW5kZXJUZXh0dXJlKHJlbmRlcmVyLCAxMDAsIDEwMCwgMSlcclxuXHJcbiAgICB0aGlzLl9icnVzaCA9IG5ldyBCcnVzaCh0aGlzKVxyXG4gICAgdGhpcy5fYnJ1c2hDb250YWluZXIgPSBuZXcgRW5naW5lLkNvbnRhaW5lcigpXHJcbiAgICBjb25zdCBicnVzaFNwcml0ZSA9IHRoaXMuX2JydXNoLmdldERpc3BsYXlPYmplY3QoKVxyXG4gICAgdGhpcy5fYnJ1c2hDb250YWluZXIuYWRkQ2hpbGQoYnJ1c2hTcHJpdGUpXHJcblxyXG4gICAgdGhpcy5fb3V0cHV0U3ByaXRlID0gbmV3IEVuZ2luZS5TcHJpdGUoKVxyXG4gICAgdGhpcy5fb3V0cHV0Q29udGFpbmVyID0gbmV3IEVuZ2luZS5Db250YWluZXIoKVxyXG4gICAgdGhpcy5fb3V0cHV0Q29udGFpbmVyLmFkZENoaWxkKHRoaXMuX291dHB1dFNwcml0ZSlcclxuXHJcbiAgICB0aGlzLl9tYXNrRmlsdGVyID0gbmV3IE1hc2tGaWx0ZXIoKVxyXG4gICAgaWYgKHJlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5XRUJHTCkpIHtcclxuICAgICAgdGhpcy5faG9yaXpvbnRhbEZpbHRlciA9IG5ldyBCbHVyRmlsdGVyKClcclxuICAgICAgdGhpcy5fdmVydGljYWxGaWx0ZXIgPSBuZXcgQmx1ckZpbHRlcigpXHJcbiAgICAgIHRoaXMuX3Nwcml0ZS5zZXRGaWx0ZXJzKFtcclxuICAgICAgICB0aGlzLl9ob3Jpem9udGFsRmlsdGVyLFxyXG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsRmlsdGVyXHJcbiAgICAgIF0pXHJcblxyXG4gICAgICB0aGlzLl9ob3Jpem9udGFsRmlsdGVyLnNldERlbHRhKG5ldyBWZWN0b3IyKDEsIDEpKVxyXG4gICAgICB0aGlzLl92ZXJ0aWNhbEZpbHRlci5zZXREZWx0YShuZXcgVmVjdG9yMigtMSwgMSkpXHJcblxyXG4gICAgICBsZXQgYmFzZVRleHR1cmUgPSB0aGlzLl9tYXNrUmVuZGVyVGV4dHVyZS5nZXRCYXNlVGV4dHVyZSgpXHJcbiAgICAgIGJhc2VUZXh0dXJlLnNldEdMVW5pdCh0aGlzLl9tYXNrRmlsdGVyLmdldE1hc2tJbWFnZSgpKVxyXG4gICAgICByZW5kZXJlci51cGRhdGVUZXh0dXJlKGJhc2VUZXh0dXJlLCBmYWxzZSlcclxuXHJcbiAgICAgIGJhc2VUZXh0dXJlID0gdGhpcy5fYmx1cnJlZFJlbmRlclRleHR1cmUuZ2V0QmFzZVRleHR1cmUoKVxyXG4gICAgICBiYXNlVGV4dHVyZS5zZXRHTFVuaXQodGhpcy5fbWFza0ZpbHRlci5nZXRGaWx0ZXJJbWFnZSgpKVxyXG4gICAgICByZW5kZXJlci51cGRhdGVUZXh0dXJlKGJhc2VUZXh0dXJlLCBmYWxzZSlcclxuICAgIH0gZWxzZSBpZiAocmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLkNBTlZBUykpIHtcclxuICAgICAgdGhpcy5fYmx1ckZpbHRlciA9IG5ldyBCbHVyRmlsdGVyKClcclxuXHJcbiAgICAgIHRoaXMuX3Nwcml0ZS5zZXRGaWx0ZXJzKFt0aGlzLl9ibHVyRmlsdGVyXSlcclxuXHJcbiAgICAgIHRoaXMuX21hc2tGaWx0ZXIuc2V0TWFza0NhbnZhcyh0aGlzLl9tYXNrUmVuZGVyVGV4dHVyZS5nZXRSZW5kZXJUYXJnZXQoKS5nZXRDYW52YXMoKSlcclxuICAgICAgdGhpcy5fbWFza0ZpbHRlci5zZXRGaWx0ZXJDYW52YXModGhpcy5fYmx1cnJlZFJlbmRlclRleHR1cmUuZ2V0UmVuZGVyVGFyZ2V0KCkuZ2V0Q2FudmFzKCkpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fb3V0cHV0U3ByaXRlLnNldEZpbHRlcnMoW1xyXG4gICAgICB0aGlzLl9tYXNrRmlsdGVyXHJcbiAgICBdKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbGllcyBhIGZsaXAgdG8gdGhpcyBvcGVyYXRpb25cclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxyXG4gICAqL1xyXG4gIGZsaXAgKGRpcmVjdGlvbikge1xyXG4gICAgdGhpcy5fYnJ1c2guYXBwbHlGbGlwKGRpcmVjdGlvbilcclxuICAgIHRoaXMuc2V0RGlydHkodHJ1ZSwgdHJ1ZSlcclxuICAgIHRoaXMuX2xhc3RCbHVyUmFkaXVzID0gbnVsbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbGllcyBhIHJvdGF0aW9uIHRvIHRoaXMgb3BlcmF0aW9uXHJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBkZWdyZWVzXHJcbiAgICovXHJcbiAgcm90YXRlIChkZWdyZWVzKSB7XHJcbiAgICB0aGlzLl9icnVzaC5hcHBseVJvdGF0aW9uKGRlZ3JlZXMpXHJcbiAgICB0aGlzLnNldERpcnR5KHRydWUsIHRydWUpXHJcbiAgICB0aGlzLl9sYXN0Qmx1clJhZGl1cyA9IG51bGxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGxpZXMgYSBjcm9wIHRvIHRoaXMgb3BlcmF0aW9uXHJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBjcm9wT3BlcmF0aW9uXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICovXHJcbiAgY3JvcCAoY3JvcE9wZXJhdGlvbiwgb3B0aW9ucykge1xyXG4gICAgdGhpcy5fYnJ1c2guYXBwbHlDcm9wKGNyb3BPcGVyYXRpb24sIG9wdGlvbnMpXHJcbiAgICB0aGlzLnNldERpcnR5KHRydWUsIHRydWUpXHJcbiAgICB0aGlzLl9sYXN0Qmx1clJhZGl1cyA9IG51bGxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgdGhpcyBvcGVyYXRpb25cclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcmVuZGVyIChpbnB1dFRleHR1cmUpIHtcclxuICAgIHRoaXMuX3JlbmRlckJsdXIoaW5wdXRUZXh0dXJlKVxyXG4gICAgdGhpcy5fcmVuZGVyTWFzayhpbnB1dFRleHR1cmUpXHJcblxyXG4gICAgdGhpcy5fb3V0cHV0U3ByaXRlLnNldFRleHR1cmUoaW5wdXRUZXh0dXJlKVxyXG4gICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fb3V0cHV0Q29udGFpbmVyKVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyB0aGUgbWFza1xyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfSBpbnB1dFRleHR1cmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9yZW5kZXJNYXNrIChpbnB1dFRleHR1cmUpIHtcclxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGV4dHVyZS5nZXREaW1lbnNpb25zKClcclxuXHJcbiAgICBjb25zdCBtYXNrRGltZW5zaW9ucyA9IHRoaXMuX21hc2tSZW5kZXJUZXh0dXJlLmdldERpbWVuc2lvbnMoKVxyXG4gICAgaWYgKCFtYXNrRGltZW5zaW9ucy5lcXVhbHMoaW5wdXREaW1lbnNpb25zKSkge1xyXG4gICAgICB0aGlzLl9tYXNrUmVuZGVyVGV4dHVyZS5yZXNpemVUbyhpbnB1dERpbWVuc2lvbnMpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fYnJ1c2gudXBkYXRlKHRoaXMuX3NkaywgaW5wdXREaW1lbnNpb25zKVxyXG4gICAgdGhpcy5fbWFza1JlbmRlclRleHR1cmUuY2xlYXIoQ29sb3IuQkxBQ0spXHJcbiAgICB0aGlzLl9tYXNrUmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fYnJ1c2hDb250YWluZXIpXHJcblxyXG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9zZGsuZ2V0UmVuZGVyZXIoKVxyXG4gICAgaWYgKHJlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5XRUJHTCkpIHtcclxuICAgICAgcmVuZGVyZXIudXBkYXRlVGV4dHVyZSh0aGlzLl9tYXNrUmVuZGVyVGV4dHVyZS5nZXRCYXNlVGV4dHVyZSgpLCBmYWxzZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJsdXJzIHRoZSBpbnB1dCBpbWFnZVxyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfSBpbnB1dFRleHR1cmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9yZW5kZXJCbHVyIChpbnB1dFRleHR1cmUpIHtcclxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGV4dHVyZS5nZXREaW1lbnNpb25zKClcclxuXHJcbiAgICBjb25zdCBibHVycmVkRGltZW5zaW9ucyA9IHRoaXMuX2JsdXJyZWRSZW5kZXJUZXh0dXJlLmdldERpbWVuc2lvbnMoKVxyXG4gICAgaWYgKCFibHVycmVkRGltZW5zaW9ucy5lcXVhbHMoaW5wdXREaW1lbnNpb25zKSkge1xyXG4gICAgICB0aGlzLl9ibHVycmVkUmVuZGVyVGV4dHVyZS5yZXNpemVUbyhpbnB1dERpbWVuc2lvbnMpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBibHVyUmFkaXVzIH0gPSB0aGlzLl9vcHRpb25zXHJcbiAgICBpZiAodGhpcy5fbGFzdEJsdXJSYWRpdXMgIT09IGJsdXJSYWRpdXMgfHwgIWJsdXJyZWREaW1lbnNpb25zLmVxdWFscyhpbnB1dERpbWVuc2lvbnMpKSB7XHJcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fc2RrLmdldFJlbmRlcmVyKClcclxuXHJcbiAgICAgIGxldCBibHVyT3B0aW9uc1xyXG4gICAgICBpZiAocmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKSkge1xyXG4gICAgICAgIGNvbnN0IHNob3J0ZXN0U2lkZSA9IGlucHV0RGltZW5zaW9ucy5taW4oKVxyXG4gICAgICAgIGJsdXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgYmx1clJhZGl1czogYmx1clJhZGl1cyAqIHNob3J0ZXN0U2lkZSxcclxuICAgICAgICAgIHRleFNpemU6IGlucHV0RGltZW5zaW9uc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbEZpbHRlci5zZXQoYmx1ck9wdGlvbnMpXHJcbiAgICAgICAgdGhpcy5fdmVydGljYWxGaWx0ZXIuc2V0KGJsdXJPcHRpb25zKVxyXG4gICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5DQU5WQVMpKSB7XHJcbiAgICAgICAgYmx1ck9wdGlvbnMgPSB7IGJsdXJSYWRpdXMgfVxyXG4gICAgICAgIHRoaXMuX2JsdXJGaWx0ZXIuc2V0KGJsdXJPcHRpb25zKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9ibHVycmVkUmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxyXG4gICAgICB0aGlzLl9sYXN0Qmx1clJhZGl1cyA9IGJsdXJSYWRpdXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhpcyBvcGVyYXRpb24ncyBicnVzaFxyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLkJydXNofVxyXG4gICAqL1xyXG4gIGdldEJydXNoICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9icnVzaFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbmQgYWRkcyBhIG5ldyBwYXRoXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzc1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoYXJkbmVzcyA9IDFcclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJydXNoT3BlcmF0aW9uLlBhdGh9XHJcbiAgICovXHJcbiAgY3JlYXRlUGF0aCAodGhpY2tuZXNzLCBoYXJkbmVzcyA9IDEpIHtcclxuICAgIGNvbnN0IHBhdGggPSB0aGlzLl9icnVzaC5jcmVhdGVQYXRoKHRoaWNrbmVzcywgaGFyZG5lc3MsIENvbG9yLldISVRFKVxyXG4gICAgdGhpcy5fb3B0aW9ucy5wYXRocy5wdXNoKHBhdGgpXHJcbiAgICB0aGlzLnNldERpcnR5KHRydWUpXHJcbiAgICByZXR1cm4gcGF0aFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgZGlydGluZXNzIGZvciB0aGUgZ2l2ZW4gcmVuZGVyZXJcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5XHJcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGltZW5zaW9uc0NoYW5nZWQgPSBmYWxzZVxyXG4gICAqL1xyXG4gIHNldERpcnR5Rm9yUmVuZGVyZXIgKGRpcnR5LCByZW5kZXJlciwgZGltZW5zaW9uc0NoYW5nZWQpIHtcclxuICAgIHN1cGVyLnNldERpcnR5Rm9yUmVuZGVyZXIoZGlydHksIHJlbmRlcmVyLCBkaW1lbnNpb25zQ2hhbmdlZClcclxuICAgIHRoaXMuX2JydXNoLnNldERpcnR5Rm9yUmVuZGVyZXIoZGlydHksIHJlbmRlcmVyLCBkaW1lbnNpb25zQ2hhbmdlZClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3Bvc2VzIHRoaXMgb3BlcmF0aW9uXHJcbiAgICovXHJcbiAgZGlzcG9zZSAoKSB7XHJcbiAgICBzdXBlci5kaXNwb3NlKClcclxuXHJcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3Nkay5nZXRSZW5kZXJlcigpXHJcbiAgICBpZiAocmVuZGVyZXIuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKSkge1xyXG4gICAgICB0aGlzLl92ZXJ0aWNhbEZpbHRlci5kaXNwb3NlKClcclxuICAgICAgdGhpcy5faG9yaXpvbnRhbEZpbHRlci5kaXNwb3NlKClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2JsdXJGaWx0ZXIuZGlzcG9zZSgpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fYnJ1c2guZGlzcG9zZSgpXHJcbiAgICB0aGlzLl9tYXNrRmlsdGVyLmRpc3Bvc2UoKVxyXG4gICAgdGhpcy5fYmx1cnJlZFJlbmRlclRleHR1cmUuZGlzcG9zZSgpXHJcbiAgICB0aGlzLl9tYXNrUmVuZGVyVGV4dHVyZS5kaXNwb3NlKClcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcclxuICogb3BlcmF0aW9ucy5cclxuICogQHR5cGUge1N0cmluZ31cclxuICogQGRlZmF1bHRcclxuICovXHJcblNlbGVjdGl2ZUJsdXJPcGVyYXRpb24uaWRlbnRpZmllciA9ICdzZWxlY3RpdmUtYmx1cidcclxuXHJcbi8qKlxyXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5TZWxlY3RpdmVCbHVyT3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xyXG4gIGJsdXJSYWRpdXM6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDAuMDUgfSxcclxuICBwYXRoczoge1xyXG4gICAgdHlwZTogT3B0aW9uVHlwZS5BUlJBWSxcclxuICAgIGRlZmF1bHQ6IFtdLFxyXG4gICAgc2V0dGVyOiBmdW5jdGlvbiAocGF0aHMpIHtcclxuICAgICAgaWYgKHRoaXMuX2JydXNoKSB7XHJcbiAgICAgICAgdGhpcy5fYnJ1c2guc2V0UGF0aHMocGF0aHMpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhdGhzXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RpdmVCbHVyT3BlcmF0aW9uXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvc2VsZWN0aXZlLWJsdXItb3BlcmF0aW9uLmpzIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcclxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxyXG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cclxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcclxuICpcclxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgVmVjdG9yMiwgRW5naW5lLCBDb25zdGFudHMgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xyXG5jb25zdCB7IE9wdGlvblR5cGUsIFVuaWZvcm1UeXBlIH0gPSBDb25zdGFudHNcclxuaW1wb3J0IFN0YWNrQmx1ciBmcm9tICcuLi8uLi92ZW5kb3Ivc3RhY2stYmx1cidcclxuXHJcbmNsYXNzIEJsdXJGaWx0ZXIgZXh0ZW5kcyBFbmdpbmUuRmlsdGVyIHtcclxuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xyXG4gICAgc3VwZXIoLi4uYXJncylcclxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uL3NoYWRlcnMvZ2VuZXJpYy9ibHVyLmZyYWcnKVxyXG5cclxuICAgIHRoaXMuX2xhc3RCbHVyUmFkaXVzID0gbnVsbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cclxuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGFyZ2V0LmdldERpbWVuc2lvbnMoKVxyXG4gICAgY29uc3QgZGltZW5zaW9uc0NoYW5nZWQgPSAhb3V0cHV0VGFyZ2V0LmdldERpbWVuc2lvbnMoKS5lcXVhbHMoaW5wdXREaW1lbnNpb25zKVxyXG5cclxuICAgIG91dHB1dFRhcmdldC5zZXRQaXhlbFJhdGlvKGlucHV0VGFyZ2V0LmdldFBpeGVsUmF0aW8oKSlcclxuICAgIG91dHB1dFRhcmdldC5yZXNpemVUbyhpbnB1dFRhcmdldC5nZXREaW1lbnNpb25zKCkpXHJcblxyXG4gICAgaWYgKHRoaXMuX2xhc3RCbHVyUmFkaXVzICE9PSB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXMgfHxcclxuICAgICAgZGltZW5zaW9uc0NoYW5nZWQpIHtcclxuICAgICAgdGhpcy5fYmx1ckltYWdlKGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQpXHJcbiAgICAgIHRoaXMuX2xhc3RCbHVyUmFkaXVzID0gdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgYmx1cnJlZCBjb3B5IG9mIHRoZSBpbWFnZVxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxyXG4gICAqIEByZXR1cm4ge0NhbnZhc31cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9ibHVySW1hZ2UgKGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQpIHtcclxuICAgIGNvbnN0IGlucHV0Q2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcclxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxyXG5cclxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpXHJcbiAgICBjb25zdCBibHVycnlJbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpXHJcbiAgICBTdGFja0JsdXIuc3RhY2tCbHVyQ2FudmFzUkdCQShibHVycnlJbWFnZURhdGEsIDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQsIHRoaXMuX29wdGlvbnMuYmx1clJhZGl1cyAqIGlucHV0RGltZW5zaW9ucy5taW4oKSlcclxuXHJcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxyXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoYmx1cnJ5SW1hZ2VEYXRhLCAwLCAwKVxyXG4gIH1cclxufVxyXG5cclxuQmx1ckZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcclxuICBibHVyUmFkaXVzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAzMCwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUIH0sXHJcbiAgZGVsdGE6IHsgdHlwZTogT3B0aW9uVHlwZS5WRUNUT1IyLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigxLCAxKSwgdW5pZm9ybVR5cGU6IFVuaWZvcm1UeXBlLkZMT0FUMiB9LFxyXG4gIHRleFNpemU6IHsgdHlwZTogT3B0aW9uVHlwZS5WRUNUT1IyLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigxMDAsIDEwMCksIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5GTE9BVDIgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCbHVyRmlsdGVyXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvc2hhcmVkL2JsdXItZmlsdGVyLmpzIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR2JtSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XHJcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcclxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXHJcbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XHJcbiAqXHJcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEVuZ2luZSwgQ29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcclxuY29uc3QgeyBPcHRpb25UeXBlLCBVbmlmb3JtVHlwZSB9ID0gQ29uc3RhbnRzXHJcblxyXG5jbGFzcyBNYXNrRmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XHJcbiAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vc2hhZGVycy9nZW5lcmljL21hc2suZnJhZycpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xyXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXHJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XHJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XHJcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgaW5wdXRDYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxyXG5cclxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxyXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcclxuXHJcbiAgICBjb25zdCB7IG1hc2tDYW52YXMsIGZpbHRlckNhbnZhcyB9ID0gdGhpcy5fb3B0aW9uc1xyXG4gICAgY29uc3QgbWFza0NvbnRleHQgPSBtYXNrQ2FudmFzLmdldENvbnRleHQoJzJkJylcclxuICAgIGNvbnN0IGZpbHRlckNvbnRleHQgPSBmaWx0ZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxyXG5cclxuICAgIGNvbnN0IG1hc2tQaXhlbHMgPSBtYXNrQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCkuZGF0YVxyXG4gICAgY29uc3QgZXhpc3RpbmdJbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpXHJcbiAgICBjb25zdCBleGlzdGluZ1BpeGVscyA9IGV4aXN0aW5nSW1hZ2VEYXRhLmRhdGFcclxuICAgIGNvbnN0IG5ld1BpeGVscyA9IGZpbHRlckNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpLmRhdGFcclxuXHJcbiAgICBsZXQgYWxwaGFcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDYW52YXMud2lkdGggKiBpbnB1dENhbnZhcy5oZWlnaHQgKiA0OyBpICs9IDQpIHtcclxuICAgICAgYWxwaGEgPSBtYXNrUGl4ZWxzW2ldIC8gMjU1XHJcblxyXG4gICAgICBleGlzdGluZ1BpeGVsc1tpXSA9IGFscGhhICogbmV3UGl4ZWxzW2ldICsgKDEgLSBhbHBoYSkgKiBleGlzdGluZ1BpeGVsc1tpXVxyXG4gICAgICBleGlzdGluZ1BpeGVsc1tpICsgMV0gPSBhbHBoYSAqIG5ld1BpeGVsc1tpICsgMV0gKyAoMSAtIGFscGhhKSAqIGV4aXN0aW5nUGl4ZWxzW2kgKyAxXVxyXG4gICAgICBleGlzdGluZ1BpeGVsc1tpICsgMl0gPSBhbHBoYSAqIG5ld1BpeGVsc1tpICsgMl0gKyAoMSAtIGFscGhhKSAqIGV4aXN0aW5nUGl4ZWxzW2kgKyAyXVxyXG4gICAgfVxyXG5cclxuICAgIG91dHB1dENvbnRleHQucHV0SW1hZ2VEYXRhKGV4aXN0aW5nSW1hZ2VEYXRhLCAwLCAwKVxyXG4gIH1cclxufVxyXG5cclxuTWFza0ZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcclxuICBtYXNrSW1hZ2U6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDEsIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5JTlQgfSxcclxuICBtYXNrQ2FudmFzOiB7IHR5cGU6IE9wdGlvblR5cGUuT0JKRUNULCBkZWZhdWx0OiBudWxsIH0sXHJcbiAgZmlsdGVySW1hZ2U6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDIsIHVuaWZvcm1UeXBlOiBVbmlmb3JtVHlwZS5JTlQgfSxcclxuICBmaWx0ZXJDYW52YXM6IHsgdHlwZTogT3B0aW9uVHlwZS5PQkpFQ1QsIGRlZmF1bHQ6IG51bGwgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYXNrRmlsdGVyXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvc2hhcmVkL21hc2stZmlsdGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBVdGlscywgUHJvbWlzZSwgTG9nLCBDb25zdGFudHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcblxuaW1wb3J0IFNwcml0ZSBmcm9tICcuL3Nwcml0ZXMvc3ByaXRlJ1xuaW1wb3J0IFN0aWNrZXIgZnJvbSAnLi9zcHJpdGVzL3N0aWNrZXInXG5pbXBvcnQgVGV4dCBmcm9tICcuL3Nwcml0ZXMvdGV4dCdcbmltcG9ydCBCcnVzaCBmcm9tICcuL3Nwcml0ZXMvYnJ1c2gnXG5jb25zdCB7IE9wdGlvblR5cGUgfSA9IENvbnN0YW50c1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBkcmF3IHNwcml0ZXMgKHRleHQgYW5kIHN0aWNrZXJzKSBvbiB0aGUgY2FudmFzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvblxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgU3ByaXRlT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU3ByaXRlT3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX29uU3ByaXRlVXBkYXRlID0gdGhpcy5fb25TcHJpdGVVcGRhdGUuYmluZCh0aGlzKVxuXG4gICAgY29uc3Qgc3ByaXRlcyA9IHRoaXMuX29wdGlvbnMuc3ByaXRlcy5zbGljZSgpXG4gICAgc3ByaXRlcy5mb3JFYWNoKChzcHJpdGUpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlU3ByaXRlKHNwcml0ZSlcbiAgICAgIHRoaXMuYWRkU3ByaXRlKHNwcml0ZSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNwcml0ZXMgdGhhdCBhcmUgaW5zdGFuY2VzIG9mIHRoZSBnaXZlbiBjbGFzc1xuICAgKiBAcGFyYW0gIHtDbGFzc30gS2xhc3NcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuU3ByaXRlW119XG4gICAqL1xuICBnZXRTcHJpdGVzT2ZUeXBlIChLbGFzcykge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnNwcml0ZXMuZmlsdGVyKChzcHJpdGUpID0+XG4gICAgICBzcHJpdGUgaW5zdGFuY2VvZiBLbGFzc1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgcm90YXRpb24gd2l0aCB0aGUgZ2l2ZW4gZGVncmVlc1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJvdGF0ZSAoZGVncmVlcykge1xuICAgIHRoaXMuX29wdGlvbnMuc3ByaXRlcy5mb3JFYWNoKChzcHJpdGUpID0+IHtcbiAgICAgIHNwcml0ZS5hcHBseVJvdGF0aW9uKGRlZ3JlZXMpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgZmxpcCB3aXRoIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZsaXAgKGRpcmVjdGlvbikge1xuICAgIHRoaXMuX29wdGlvbnMuc3ByaXRlcy5mb3JFYWNoKChzcHJpdGUpID0+IHtcbiAgICAgIHNwcml0ZS5hcHBseUZsaXAoZGlyZWN0aW9uKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIHNwcml0ZSBpcyBmbGFnZ2VkIGFzIGRpcnR5IC8gaXRzIG9wdGlvbnMgY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5TcHJpdGV9IHNwcml0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNwcml0ZVVwZGF0ZSAoc3ByaXRlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zZXREaXJ0eSh0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIHJvdGF0aW9uIGNoYW5nZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlJvdGF0aW9uT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlSb3RhdGlvbiAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5zcHJpdGVzLmZvckVhY2goKHNwcml0ZSkgPT4gc3ByaXRlLmFwcGx5Um90YXRpb24ob3BlcmF0aW9uLCBvcHRpb25zKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBjcm9wIGNoYW5nZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkNyb3BPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNyb3AgKG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMuc3ByaXRlcy5mb3JFYWNoKChzcHJpdGUpID0+IHNwcml0ZS5hcHBseUNyb3Aob3BlcmF0aW9uLCBvcHRpb25zKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBvcHRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHJldHVybiB7Kn0gb3B0aW9uTmFtZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9zZXJpYWxpemVPcHRpb24gKG9wdGlvbk5hbWUpIHtcbiAgICAvLyBTaW5jZSBgc3ByaXRlc2AgaXMgYW4gYXJyYXkgb2YgY29uZmlndXJhYmxlcywgd2UgbmVlZFxuICAgIC8vIHRvIHNlcmlhbGl6ZSB0aGVtIGFzIHdlbGxcbiAgICBpZiAob3B0aW9uTmFtZSA9PT0gJ3Nwcml0ZXMnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5zcHJpdGVzLm1hcCgoc3ByaXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBzcHJpdGUuc2VyaWFsaXplT3B0aW9ucygpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX3NlcmlhbGl6ZU9wdGlvbihvcHRpb25OYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3RpY2tlciBvYmplY3QgYW5kIHJldHVybnMgaXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlN0aWNrZXJ9XG4gICAqL1xuICBjcmVhdGVTdGlja2VyIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdGlja2VyKHRoaXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdGlja2VyIG9iamVjdCBhbmQgcmV0dXJucyBpdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uVGV4dH1cbiAgICovXG4gIGNyZWF0ZVRleHQgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRleHQodGhpcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYnJ1c2ggb2JqZWN0IGFuZCByZXR1cm5zIGl0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbi5CcnVzaH1cbiAgICovXG4gIGNyZWF0ZUJydXNoIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBCcnVzaCh0aGlzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYSBzcHJpdGUgaGFzIGJlZW4gYWRkZWRcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5TcHJpdGV9IHNwcml0ZVxuICAgKi9cbiAgYWRkU3ByaXRlIChzcHJpdGUpIHtcbiAgICB0aGlzLl9vcHRpb25zLnNwcml0ZXMucHVzaChzcHJpdGUpXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZENoaWxkKHNwcml0ZS5nZXREaXNwbGF5T2JqZWN0KCkpXG5cbiAgICAvLyBUaGlzIG9wZXJhdGlvbiBuZWVkcyB0byBiZSByZXJlbmRlcmVkXG4gICAgdGhpcy5zZXREaXJ0eSh0cnVlKVxuXG4gICAgc3ByaXRlLm9uKCd1cGRhdGUnLCB0aGlzLl9vblNwcml0ZVVwZGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBzcHJpdGUgZnJvbSB0aGUgbGlzdCBvZiBzcHJpdGVzXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLlNwcml0ZX0gc3ByaXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICByZW1vdmVTcHJpdGUgKHNwcml0ZSkge1xuICAgIGNvbnN0IHNwcml0ZXMgPSB0aGlzLl9vcHRpb25zLnNwcml0ZXNcbiAgICBjb25zdCBpbmRleCA9IHNwcml0ZXMuaW5kZXhPZihzcHJpdGUpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3ByaXRlLm9mZigndXBkYXRlJywgdGhpcy5fb25TcHJpdGVVcGRhdGUpXG4gICAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoc3ByaXRlLmdldERpc3BsYXlPYmplY3QoKSlcbiAgICAgIHNwcml0ZXMuc3BsaWNlKGluZGV4LCAxKVxuXG4gICAgICAvLyBUaGlzIG9wZXJhdGlvbiBuZWVkcyB0byBiZSByZXJlbmRlcmVkXG4gICAgICB0aGlzLnNldERpcnR5KHRydWUpXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXIgKGlucHV0VGV4dHVyZSkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lclxuICAgIGNvbnN0IHNwcml0ZXMgPSB0aGlzLl9vcHRpb25zLnNwcml0ZXNcblxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGV4dHVyZS5nZXREaW1lbnNpb25zKCkuY2xvbmUoKS5mbG9vcigpXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNwcml0ZXMubWFwKChzKSA9PiBzLnZhbGlkYXRlU2V0dGluZ3MoKSkpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHNwcml0ZXMuZm9yRWFjaCgoc3ByaXRlKSA9PiB7XG4gICAgICAgICAgc3ByaXRlLnVwZGF0ZSh0aGlzLl9zZGssIGlucHV0RGltZW5zaW9ucylcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlLmNsZWFyKClcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZS5yZW5kZXIoY29udGFpbmVyKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgZ2l2ZW4gU3ByaXRlIHRvIGZyb250XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlNwcml0ZX0gc3ByaXRlXG4gICAqL1xuICB0YWtlU3ByaXRlVG9Gcm9udCAoc3ByaXRlKSB7XG4gICAgY29uc3QgeyBzcHJpdGVzIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgY29uc3Qgc3ByaXRlSW5kZXggPSBzcHJpdGVzLmluZGV4T2Yoc3ByaXRlKVxuICAgIGlmIChzcHJpdGVJbmRleCA9PT0gLTEpIHJldHVyblxuXG4gICAgVXRpbHMubW92ZUFycmF5SXRlbShzcHJpdGVzLCBzcHJpdGVJbmRleCwgc3ByaXRlcy5sZW5ndGggLSAxKVxuXG4gICAgY29uc3QgZGlzcGxheU9iamVjdCA9IHNwcml0ZS5nZXREaXNwbGF5T2JqZWN0KClcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoZGlzcGxheU9iamVjdClcbiAgICB0aGlzLl9jb250YWluZXIuYWRkQ2hpbGQoZGlzcGxheU9iamVjdClcblxuICAgIHRoaXMuc2V0RGlydHkodHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzcHJpdGVzIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBvbiB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBpbnB1dERpbWVuc2lvbnNcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuU3ByaXRlW119XG4gICAqL1xuICBnZXRTcHJpdGVzQXRQb3NpdGlvbiAocG9zaXRpb24sIGlucHV0RGltZW5zaW9ucykge1xuICAgIGxldCBpbnRlcnNlY3RpbmdTcHJpdGVzID0gW11cblxuICAgIHRoaXMuX29wdGlvbnMuc3ByaXRlcy5mb3JFYWNoKChzKSA9PiBzLnVwZGF0ZSh0aGlzLl9zZGssIGlucHV0RGltZW5zaW9ucykpXG5cbiAgICAvLyBUcmFuc2xhdGUgY2FudmFzIHBvc2l0aW9uIHRvIHJlbGF0aXZlIHBvc2l0aW9uIG9uIHNwcml0ZSBieVxuICAgIC8vIGFwcGx5aW5nIHRoZSBpbnZlcnNlIG9mIG91ciBvdXRwdXRTcHJpdGUncyB3b3JsZCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgY29uc3Qgb3V0cHV0U3ByaXRlID0gdGhpcy5fc2RrLmdldFNwcml0ZSgpXG4gICAgY29uc3QgYWN0dWFsUG9zaXRpb24gPSBvdXRwdXRTcHJpdGVcbiAgICAgIC5nZXRXb3JsZFRyYW5zZm9ybSgpXG4gICAgICAuYXBwbHlJbnZlcnNlVG9WZWN0b3IocG9zaXRpb24pXG5cbiAgICAvLyBBcHBseSBhbmNob3JcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG91dHB1dFNwcml0ZS5nZXRUZXh0dXJlKCkuZ2V0RnJhbWUoKVxuICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IG91dHB1dFNwcml0ZS5nZXRBbmNob3IoKS5jbG9uZSgpXG4gICAgICAubXVsdGlwbHkoLXdpZHRoLCAtaGVpZ2h0KVxuICAgIGFjdHVhbFBvc2l0aW9uLnN1YnRyYWN0KGFuY2hvck9mZnNldClcblxuICAgIC8vIE5vdGU6IGBhY3R1YWxQb3NpdGlvbmAgaXMgbm93IHRoZSBwaXhlbCBwb3NpdGlvbiBvbiB0aGUgb3V0cHV0IHNwcml0ZSwgTk9UXG4gICAgLy8gb24gdGhlIHN0aWNrZXIgLyB0ZXh0IC8gYnJ1c2hcblxuICAgIC8vIEZpbmQgaW50ZXJzZWN0aW5nIHNwcml0ZVxuICAgIGxldCBzcHJpdGVzID0gdGhpcy5fb3B0aW9ucy5zcHJpdGVzLnNsaWNlKDApLnJldmVyc2UoKVxuICAgIGZvciAobGV0IGkgPSAwLCBjID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBjOyBpKyspIHtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IHNwcml0ZXNbaV1cbiAgICAgIGlmIChzcHJpdGUuZ2V0RGlzcGxheU9iamVjdCgpLmlzQXRQb3NpdGlvbihhY3R1YWxQb3NpdGlvbikpIHtcbiAgICAgICAgaW50ZXJzZWN0aW5nU3ByaXRlcy5wdXNoKHNwcml0ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW5nU3ByaXRlc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcnRpbmVzcyBmb3IgdGhlIGdpdmVuIHJlbmRlcmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpbWVuc2lvbnNDaGFuZ2VkID0gZmFsc2VcbiAgICovXG4gIHNldERpcnR5Rm9yUmVuZGVyZXIgKGRpcnR5LCByZW5kZXJlciwgZGltZW5zaW9uc0NoYW5nZWQpIHtcbiAgICBzdXBlci5zZXREaXJ0eUZvclJlbmRlcmVyKGRpcnR5LCByZW5kZXJlciwgZGltZW5zaW9uc0NoYW5nZWQpXG4gICAgdGhpcy5fb3B0aW9ucy5zcHJpdGVzLmZvckVhY2goKHNwcml0ZSkgPT4ge1xuICAgICAgc3ByaXRlLnNldERpcnR5Rm9yUmVuZGVyZXIoZGlydHksIHJlbmRlcmVyLCBkaW1lbnNpb25zQ2hhbmdlZClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICBzdXBlci5kaXNwb3NlKClcbiAgICB0aGlzLl9vcHRpb25zLnNwcml0ZXMuZm9yRWFjaCgoc3ByaXRlKSA9PiB7XG4gICAgICBzcHJpdGUuZGlzcG9zZSgpXG4gICAgfSlcbiAgfVxufVxuXG5TcHJpdGVPcGVyYXRpb24uU3RpY2tlciA9IFN0aWNrZXJcblNwcml0ZU9wZXJhdGlvbi5UZXh0ID0gVGV4dFxuU3ByaXRlT3BlcmF0aW9uLkJydXNoID0gQnJ1c2hcblxuLyoqXG4gKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAqIG9wZXJhdGlvbnMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuU3ByaXRlT3BlcmF0aW9uLmlkZW50aWZpZXIgPSAnc3ByaXRlJ1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5TcHJpdGVPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHNwcml0ZXM6IHtcbiAgICB0eXBlOiBPcHRpb25UeXBlLkFSUkFZLFxuICAgIGRlZmF1bHQ6IFtdLFxuICAgIHNldHRlcjogZnVuY3Rpb24gKHNwcml0ZXMsIGluaXRpYWwpIHtcbiAgICAgIHNwcml0ZXMgPSBzcHJpdGVzLm1hcCgoc3ByaXRlLCBpKSA9PiB7XG4gICAgICAgIGlmIChzcHJpdGUgaW5zdGFuY2VvZiBTcHJpdGUpIHtcbiAgICAgICAgICByZXR1cm4gc3ByaXRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHNwcml0ZVxuICAgICAgICBkZWxldGUgc3ByaXRlLnR5cGVcblxuICAgICAgICAvLyBDcmVhdGUgc3ByaXRlIGZyb20gdGhlIGdpdmVuIG9wdGlvbnNcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHQodGhpcywgc3ByaXRlKVxuICAgICAgICAgIGNhc2UgJ3N0aWNrZXInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGlja2VyKHRoaXMsIHNwcml0ZSlcbiAgICAgICAgICBjYXNlICdicnVzaCc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJydXNoKHRoaXMsIHNwcml0ZSlcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgTG9nLmVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ0ludmFsaWQgc3ByaXRlIHR5cGU6ICcgKyBzcHJpdGUudHlwZSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gUmVtb3ZlIGFsbCBzcHJpdGVzXG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc3ByaXRlcykge1xuICAgICAgICAgIGNvbnN0IHNwcml0ZXNUb1JlbW92ZSA9IHRoaXMuX29wdGlvbnMuc3ByaXRlcy5zbGljZSgpXG4gICAgICAgICAgc3ByaXRlc1RvUmVtb3ZlLmZvckVhY2goKHNwcml0ZSkgPT4ge1xuICAgICAgICAgICAgc3ByaXRlLmRpc3Bvc2UoKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTcHJpdGUoc3ByaXRlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYWxsIHNwcml0ZXNcbiAgICAgICAgc3ByaXRlcy5mb3JFYWNoKChzcHJpdGUpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZFNwcml0ZShzcHJpdGUpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzcHJpdGVzXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwcml0ZU9wZXJhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9zcHJpdGUtb3BlcmF0aW9uLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcblxuLyoqXG4gKiBBIENvbnRyb2xQb2ludCBpcyBhIHBhcnQgb2YgYSB7QGxpbmsgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5CcnVzaE9wZXJhdGlvbi5QYXRofSwgc28gYSBQYXRoXG4gKiBjb25zaXN0cyBvZiBtdWx0aXBsZSBDb250cm9sUG9pbnRzLiBTaG91bGQgb25seSBiZSBjcmVhdGVkIHVzaW5nIHtAbGluayBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJydXNoT3BlcmF0aW9uLlBhdGgjYWRkQ29udHJvbFBvaW50fVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5CcnVzaE9wZXJhdGlvblxuICovXG5jbGFzcyBDb250cm9sUG9pbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIENvbnRyb2xQb2ludFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJydXNoT3BlcmF0aW9uLlBhdGh9IHBhdGhcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBwb3NpdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHBhdGgsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5fcGF0aCA9IHBhdGhcbiAgICB0aGlzLl9kcmF3bkNhbnZhc2VzID0gW11cbiAgICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIENvbnRyb2xQb2ludCB0byB0aGUgZ2l2ZW4gY2FudmFzXG4gICAqIEBwYXJhbSAge0hUTUxDYW52YXNFbGVtZW50fSBicnVzaFxuICAgKiBAcGFyYW0gIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuQnJ1c2hPcGVyYXRpb24uQ29udHJvbFBvaW50fSBsYXN0Q29udHJvbFBvaW50XG4gICAqL1xuICByZW5kZXJUb0NhbnZhcyAoYnJ1c2gsIGNhbnZhcywgbGFzdENvbnRyb2xQb2ludCkge1xuICAgIGlmICh0aGlzLl9kcmF3bkNhbnZhc2VzLmluZGV4T2YoY2FudmFzKSAhPT0gLTEpIHtcbiAgICAgIC8vIFRoaXMgY29udHJvbCBwb2ludCBoYXMgYWxyZWFkeSBiZWVuIGRyYXduIG9uIHRoaXMgY2FudmFzLiBJZ25vcmUuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjYW52YXNEaW1lbnNpb25zID0gbmV3IFZlY3RvcjIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbi5jbG9uZSgpLm11bHRpcGx5KGNhbnZhc0RpbWVuc2lvbnMpIC8vIHgyXG4gICAgY29uc3QgbGFzdFBvc2l0aW9uID0gbGFzdENvbnRyb2xQb2ludC5nZXRQb3NpdGlvbigpLmNsb25lKCkubXVsdGlwbHkoY2FudmFzRGltZW5zaW9ucykgLy8geDFcbiAgICBjb25zdCBkaXN0YW5jZSA9IHBvc2l0aW9uLmNsb25lKCkuc3VidHJhY3QobGFzdFBvc2l0aW9uKS5sZW4oKVxuICAgIGNvbnN0IHN0ZXAgPSBicnVzaC53aWR0aCAvIDEwXG5cbiAgICBsZXQgaSA9IDBcbiAgICB3aGlsZSAoaSA8PSBkaXN0YW5jZSkge1xuICAgICAgbGV0IHQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBpIC8gZGlzdGFuY2UpKVxuICAgICAgY29uc3QgeCA9IGxhc3RQb3NpdGlvbi54ICsgKHBvc2l0aW9uLnggLSBsYXN0UG9zaXRpb24ueCkgKiB0XG4gICAgICBjb25zdCB5ID0gbGFzdFBvc2l0aW9uLnkgKyAocG9zaXRpb24ueSAtIGxhc3RQb3NpdGlvbi55KSAqIHRcblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoYnJ1c2gsXG4gICAgICAgIHggLSBicnVzaC53aWR0aCAvIDIsXG4gICAgICAgIHkgLSBicnVzaC5oZWlnaHQgLyAyKVxuICAgICAgaSArPSBzdGVwXG4gICAgfVxuXG4gICAgdGhpcy5fZHJhd25DYW52YXNlcy5wdXNoKGNhbnZhcylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gcG9zaXRpb25cbiAgICovXG4gIHNldFBvc2l0aW9uIChwb3NpdGlvbikge1xuICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRQb3NpdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uLmNsb25lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgQ29udHJvbFBvaW50IHRvIGRpcnR5XG4gICAqL1xuICBzZXREaXJ0eSAoKSB7XG4gICAgdGhpcy5fZHJhd25DYW52YXNlcyA9IFtdXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbFBvaW50XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL3Nwcml0ZXMvYnJ1c2gvY29udHJvbC1wb2ludC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgQ29uc3RhbnRzLCBDb2xvciwgVXRpbHMsIENvbmZpZ3VyYWJsZSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbHMnXG5jb25zdCB7IE9wdGlvblR5cGUgfSA9IENvbnN0YW50c1xuaW1wb3J0IENvbnRyb2xQb2ludCBmcm9tICcuL2NvbnRyb2wtcG9pbnQnXG5cbi8qKlxuICogQSBwYXRoIHRoYXQgY2FuIGJlIGRyYXduIG9uIGEge0BsaW5rIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuQnJ1c2hPcGVyYXRpb259LiBTaG91bGQgb25seSBiZVxuICogY3JlYXRlZCB1c2luZyB7QGxpbmsgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5CcnVzaE9wZXJhdGlvbiNjcmVhdGVQYXRofVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5FdmVudEVtaXR0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJydXNoT3BlcmF0aW9uXG4gKi9cbmNsYXNzIFBhdGggZXh0ZW5kcyBDb25maWd1cmFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBhdGhcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5CcnVzaE9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3BlcmF0aW9uLCBvcHRpb25zLCBjYW52YXMpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuXG4gICAgdGhpcy5fb3BlcmF0aW9uID0gb3BlcmF0aW9uXG5cbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXMgfHwgVXRpbHMuY3JlYXRlQ2FudmFzKClcbiAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3cyB0aGlzIHBhdGggb250byBpdHMgY2FudmFzXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBpbnB1dERpbWVuc2lvbnNcbiAgICovXG4gIHJlbmRlciAoaW5wdXREaW1lbnNpb25zKSB7XG4gICAgY29uc3QgeyBjb250cm9sUG9pbnRzLCB0aGlja25lc3MgfSA9IHRoaXMuX29wdGlvbnNcbiAgICBpZiAoY29udHJvbFBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBVdGlscy5lbnN1cmVDYW52YXNEaW1lbnNpb25zKHRoaXMuX2NhbnZhcywgaW5wdXREaW1lbnNpb25zKVxuXG4gICAgaWYgKCF0aGlzLl9icnVzaCB8fCB0aGlzLl9sYXN0QnJ1c2hUaGlja25lc3MgIT09IHRoaWNrbmVzcyB8fCAhaW5wdXREaW1lbnNpb25zLmVxdWFscyh0aGlzLl9icnVzaElucHV0RGltZW5zaW9ucykpIHtcbiAgICAgIHRoaXMuX2JydXNoID0gdGhpcy5fY3JlYXRlQnJ1c2goaW5wdXREaW1lbnNpb25zKVxuICAgICAgdGhpcy5fYnJ1c2hJbnB1dERpbWVuc2lvbnMgPSBpbnB1dERpbWVuc2lvbnMuY2xvbmUoKVxuICAgICAgdGhpcy5fbGFzdEJydXNoVGhpY2tuZXNzID0gdGhpY2tuZXNzXG4gICAgfVxuXG4gICAgbGV0IGxhc3RDb250cm9sUG9pbnQgPSBjb250cm9sUG9pbnRzWzBdXG4gICAgbGV0IGNvbnRyb2xQb2ludCA9IGxhc3RDb250cm9sUG9pbnRcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbnRyb2xQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnRyb2xQb2ludCA9IGNvbnRyb2xQb2ludHNbaV1cbiAgICAgIGNvbnRyb2xQb2ludC5yZW5kZXJUb0NhbnZhcyh0aGlzLl9icnVzaCwgdGhpcy5fY2FudmFzLCBsYXN0Q29udHJvbFBvaW50KVxuICAgICAgbGFzdENvbnRyb2xQb2ludCA9IGNvbnRyb2xQb2ludFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYnJ1c2ggZnJvbSB0aGUgZ2l2ZW4gdGhpY2tuZXNzLCBoYXJkbmVzcyBhbmQgY29sb3JcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBpbnB1dERpbWVuc2lvbnNcbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQnJ1c2ggKGlucHV0RGltZW5zaW9ucykge1xuICAgIGxldCB7IHRoaWNrbmVzcywgaGFyZG5lc3MsIGNvbG9yIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgY29uc3QgY2FudmFzID0gVXRpbHMuY3JlYXRlQ2FudmFzKClcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaWNrbmVzcyAqIGlucHV0RGltZW5zaW9ucy5taW4oKSlcblxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgLy8gQnJ1c2ggYWx3YXlzIGhhcyAxMDAlIG9wYWNpdHlcbiAgICBjb2xvciA9IGNvbG9yLmNsb25lKClcbiAgICBjb2xvci5hID0gMVxuXG4gICAgaWYgKGNhbnZhcy53aWR0aCA9PT0gMSkge1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1JHQkEoKVxuICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCAxLCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgIGNhbnZhcy53aWR0aCAvIDIsXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyLFxuICAgICAgICBNYXRoLm1pbihcbiAgICAgICAgICBjYW52YXMud2lkdGggLyAyIC0gMSxcbiAgICAgICAgICBjYW52YXMud2lkdGggLyAyICogaGFyZG5lc3NcbiAgICAgICAgKSxcbiAgICAgICAgY2FudmFzLndpZHRoIC8gMixcbiAgICAgICAgY2FudmFzLmhlaWdodCAvIDIsXG4gICAgICAgIGNhbnZhcy53aWR0aCAvIDJcbiAgICAgIClcblxuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGNvbG9yLnRvUkdCQSgpKVxuICAgICAgY29uc3QgdHJhbnNwYXJlbnRDb2xvciA9IGNvbG9yLmNsb25lKClcbiAgICAgIHRyYW5zcGFyZW50Q29sb3IuYSA9IDBcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCB0cmFuc3BhcmVudENvbG9yLnRvUkdCQSgpKVxuXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNvbnRyb2wgcG9pbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHRvIHRoaXMgcGF0aFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gcG9zaXRpb25cbiAgICovXG4gIGFkZENvbnRyb2xQb2ludCAocG9zaXRpb24pIHtcbiAgICBjb25zdCBjb250cm9sUG9pbnQgPSBuZXcgQ29udHJvbFBvaW50KHRoaXMsIHBvc2l0aW9uKVxuICAgIHRoaXMuX29wdGlvbnMuY29udHJvbFBvaW50cy5wdXNoKGNvbnRyb2xQb2ludClcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIHBhdGgncyBjYW52YXNcbiAgICogQHJldHVybiB7Q2FudmFzfVxuICAgKi9cbiAgZ2V0Q2FudmFzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gY2FudmFzXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKi9cbiAgc2V0Q2FudmFzIChjYW52YXMpIHtcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXNcbiAgICB0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgcGF0aCB0byBkaXJ0eVxuICAgKi9cbiAgc2V0RGlydHkgKCkge1xuICAgIHRoaXMuX2NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodClcblxuICAgIHRoaXMuX29wdGlvbnMuY29udHJvbFBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgcG9pbnQuc2V0RGlydHkoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgYGl0ZXJhdG9yYCBmb3IgZWFjaCBjb250cm9sIHBvaW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKi9cbiAgZm9yRWFjaENvbnRyb2xQb2ludCAoaXRlcmF0b3IpIHtcbiAgICB0aGlzLl9vcHRpb25zLmNvbnRyb2xQb2ludHMuZm9yRWFjaChpdGVyYXRvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgcGF0aCB0byB0aGUgZ2l2ZW4gY2FudmFzIHdpdGggdGhlIHJpZ2h0IG9wYWNpdHlcbiAgICogQHBhcmFtICB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIHJlbmRlclRvQ2FudmFzIChjYW52YXMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb250ZXh0LnNhdmUoKVxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLl9vcHRpb25zLmNvbG9yLmFcbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLl9jYW52YXMsIDAsIDApXG4gICAgY29udGV4dC5yZXN0b3JlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjYW52YXMgZGltZW5zaW9uIGZvciB0aGlzIHBhdGhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0Q2FudmFzRGltZW5zaW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhc0RpbWVuc2lvbnNcbiAgfVxufVxuXG5QYXRoLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBpZDogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORywgZGVmYXVsdDogKCkgPT4gVXRpbHMuZ2V0VVVJRCgpIH0sXG4gIGNvbG9yOiB7IHR5cGU6IE9wdGlvblR5cGUuQ09MT1IsIGRlZmF1bHQ6IENvbG9yLlJFRCB9LFxuICBoYXJkbmVzczogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMSB9LFxuICB0aGlja25lc3M6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDAuMDUgfSxcbiAgY29udHJvbFBvaW50czogeyB0eXBlOiBPcHRpb25UeXBlLkFSUkFZLCBkZWZhdWx0OiBbXSB9LFxuICBjbG9zZWQ6IHsgdHlwZTogT3B0aW9uVHlwZS5CT09MRUFOLCBkZWZhdWx0OiBmYWxzZSB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhdGhcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvc3ByaXRlcy9icnVzaC9wYXRoLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBVdGlscywgQ29uc3RhbnRzLCBQcm9taXNlLCBFbmdpbmUsIFZlY3RvcjIgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuY29uc3QgeyBPcHRpb25UeXBlLCBSZW5kZXJlclR5cGUgfSA9IENvbnN0YW50c1xuaW1wb3J0IFNwcml0ZSBmcm9tICcuL3Nwcml0ZSdcbmltcG9ydCBBZGp1c3RtZW50c0ZpbHRlciBmcm9tICcuLi9hZGp1c3RtZW50cy9hZGp1c3RtZW50cy1maWx0ZXInXG5cbi8qKlxuICogQSBzdGlja2VyIHRoYXQgY2FuIGJlIGRyYXduIGJ5IFNwcml0ZU9wZXJhdGlvbi4gU2hvdWxkIG9ubHkgYmUgY3JlYXRlZCB2aWEge0BsaW5rIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uI2NyZWF0ZVN0aWNrZXJ9XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvblxuICovXG5jbGFzcyBTdGlja2VyIGV4dGVuZHMgU3ByaXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU3RpY2tlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5pbWFnZSkge1xuICAgICAgdGhpcy5fb25JbWFnZVVwZGF0ZSgpXG4gICAgfVxuXG4gICAgdGhpcy5fYWRqdXN0bWVudHNGaWx0ZXIgPSBuZXcgQWRqdXN0bWVudHNGaWx0ZXIoKVxuXG4gICAgdGhpcy5fb25PcHRpb25zQ2hhbmdlID0gdGhpcy5fb25PcHRpb25zQ2hhbmdlLmJpbmQodGhpcylcbiAgICB0aGlzLl9vcHRpb25zLmFkanVzdG1lbnRzLm9uKCd1cGRhdGVkJywgdGhpcy5fb25PcHRpb25zQ2hhbmdlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhpcyBjb25maWd1cmFibGVcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRvT2JqZWN0ID0gZmFsc2VcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc2VyaWFsaXplT3B0aW9ucyAoa2V5cywgdG9PYmplY3QgPSBmYWxzZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzdXBlci5zZXJpYWxpemVPcHRpb25zKGtleXMsIHRvT2JqZWN0KVxuICAgIGlmICgha2V5cykgb3B0aW9ucy50eXBlID0gJ3N0aWNrZXInXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBzcHJpdGUgc2hvdWxkIGJlIHJlbmRlcmVkIHRvIGEgcmVuZGVyIHRleHR1cmVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlcnNUb1JlbmRlclRleHR1cmUgKHNkaykge1xuICAgIGNvbnN0IHNtb290aERvd25zY2FsaW5nID0gdGhpcy5fb3B0aW9ucy5zbW9vdGhEb3duc2NhbGluZyAmJlxuICAgICAgc2RrLmdldFJlbmRlcmVyKCkuaXNPZlR5cGUoUmVuZGVyZXJUeXBlLldFQkdMKVxuICAgIHJldHVybiBzbW9vdGhEb3duc2NhbGluZyB8fCB0aGlzLl9oYXNBZGp1c3RtZW50cygpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dHVyZSBmb3IgdGhlIHNwcml0ZSB0aGF0IHNob3VsZCBiZSByZW5kZXJlZFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX1cbiAgICogQHByaXZhdGVcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBfZ2V0VGV4dHVyZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0VGV4dHVyZVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBzcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGlucHV0RGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgdXBkYXRlIChzZGssIGlucHV0RGltZW5zaW9ucykge1xuICAgIGNvbnN0IHsgZGltZW5zaW9ucywgaW1hZ2UgfSA9IHRoaXMuX29wdGlvbnNcbiAgICBpZiAoZGltZW5zaW9ucy5lcXVhbHMoVmVjdG9yMi5OVUxMKSkge1xuICAgICAgZGltZW5zaW9ucy5zZXQoXG4gICAgICAgIGltYWdlLndpZHRoLFxuICAgICAgICBpbWFnZS5oZWlnaHRcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyc1RvUmVuZGVyVGV4dHVyZShzZGspKSB7XG4gICAgICB0aGlzLl9wcmVwYXJlUmVuZGVyVGV4dHVyZShzZGspXG4gICAgfVxuXG4gICAgLy8gU3RpY2tlcnMgd2l0aCBhZGp1c3RtZW50cyBhcmUgcmVuZGVyZWQgdG8gYSByZW5kZXIgdGV4dHVyZSB0aGF0XG4gICAgLy8gY2FuIGJlIHJlLXVzZWRcbiAgICBpZiAodGhpcy5faGFzQWRqdXN0bWVudHMoKSkge1xuICAgICAgLy8gQXBwbHkgYWRqdXN0bWVudHNcbiAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVTcHJpdGUuc2V0RmlsdGVycyhbdGhpcy5fYWRqdXN0bWVudHNGaWx0ZXJdKVxuXG4gICAgICBjb25zdCBhZGp1c3RtZW50cyA9IHRoaXMuX29wdGlvbnMuYWRqdXN0bWVudHNcbiAgICAgIHRoaXMuX2FkanVzdG1lbnRzRmlsdGVyLnNldCh7XG4gICAgICAgIGJyaWdodG5lc3M6IGFkanVzdG1lbnRzLmdldEJyaWdodG5lc3MoKSxcbiAgICAgICAgc2F0dXJhdGlvbjogYWRqdXN0bWVudHMuZ2V0U2F0dXJhdGlvbigpLFxuICAgICAgICBjb250cmFzdDogYWRqdXN0bWVudHMuZ2V0Q29udHJhc3QoKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVTcHJpdGUoaW5wdXREaW1lbnNpb25zKVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlcnNUb1JlbmRlclRleHR1cmUoc2RrKSkge1xuICAgICAgdGhpcy5fcmVuZGVyVG9SZW5kZXJUZXh0dXJlKHNkaylcbiAgICB9XG4gICAgdGhpcy5fYXBwbHlGbGlwKClcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIGZsaXAgaXMgZW5hYmxlZCwgdGhpcyBmbGlwcyB0aGUgc3ByaXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlGbGlwICgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX3Nwcml0ZS5nZXRTY2FsZSgpXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZmxpcFZlcnRpY2FsbHkpIHtcbiAgICAgIHNjYWxlLnkgKj0gLTFcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZmxpcEhvcml6b250YWxseSkge1xuICAgICAgc2NhbGUueCAqPSAtMVxuICAgIH1cbiAgICB0aGlzLl9zcHJpdGUuc2V0U2NhbGUoc2NhbGUpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBhIGZsaXAgaW4gdGhlIGdpdmVuIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKi9cbiAgYXBwbHlGbGlwIChkaXJlY3Rpb24pIHtcbiAgICBzdXBlci5hcHBseUZsaXAoZGlyZWN0aW9uKVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvdGF0aW9uOiB0aGlzLl9vcHRpb25zLnJvdGF0aW9uXG4gICAgfVxuXG4gICAgY29uc3QgZGVncmVlcyA9IG9wdGlvbnMucm90YXRpb24gLyBNYXRoLlBJICogMTgwXG4gICAgY29uc3QgbmV3RGVncmVlcyA9IGRlZ3JlZXMgKiAtMVxuICAgIG9wdGlvbnMucm90YXRpb24gPSBuZXdEZWdyZWVzICogTWF0aC5QSSAvIDE4MFxuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICBvcHRpb25zLmZsaXBIb3Jpem9udGFsbHkgPSAhdGhpcy5fb3B0aW9ucy5mbGlwSG9yaXpvbnRhbGx5XG4gICAgICAgIHRoaXMuc2V0KG9wdGlvbnMpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIG9wdGlvbnMuZmxpcFZlcnRpY2FsbHkgPSAhdGhpcy5fb3B0aW9ucy5mbGlwVmVydGljYWxseVxuICAgICAgICB0aGlzLnNldChvcHRpb25zKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBzdGlja2VyIGhhcyBhbnkgYWRqdXN0bWVudHMgYW5kIGEgZmlsdGVyIGlzIG5lZWRlZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhc0FkanVzdG1lbnRzICgpIHtcbiAgICBjb25zdCBhZGp1c3RtZW50cyA9IHRoaXMuX29wdGlvbnMuYWRqdXN0bWVudHNcbiAgICByZXR1cm4gYWRqdXN0bWVudHMuZ2V0QnJpZ2h0bmVzcygpICE9PSAwIHx8XG4gICAgICBhZGp1c3RtZW50cy5nZXRTYXR1cmF0aW9uKCkgIT09IDEgfHxcbiAgICAgIGFkanVzdG1lbnRzLmdldENvbnRyYXN0KCkgIT09IDFcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgc3RpY2tlcidzIGltYWdlIGlzIHVwZGF0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkltYWdlVXBkYXRlICgpIHtcbiAgICB0aGlzLl9pbnB1dFRleHR1cmUgPSBFbmdpbmUuVGV4dHVyZS5mcm9tSW1hZ2UodGhpcy5fb3B0aW9ucy5pbWFnZSlcbiAgICB0aGlzLl9pZGVudGl0eVNwcml0ZS5zZXRUZXh0dXJlKHRoaXMuX2lucHV0VGV4dHVyZSlcbiAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZSh0aGlzLl9pbnB1dFRleHR1cmUpXG4gICAgdGhpcy5zZXREaXJ0eSh0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gb3B0aW9uLCB2YWxpZGF0ZXMgaXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZSA9IHRydWVcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRPcHRpb24gKG9wdGlvbk5hbWUsIHZhbHVlLCB1cGRhdGUgPSB0cnVlKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9uKG9wdGlvbk5hbWUsIHZhbHVlLCB1cGRhdGUpXG5cbiAgICBpZiAob3B0aW9uTmFtZSA9PT0gJ2ltYWdlJyAmJiB0aGlzLl9pZGVudGl0eVNwcml0ZSkge1xuICAgICAgdGhpcy5fb25JbWFnZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gb3B0aW9ucyBoYXZlIGJlZW4gY2hhbmdlZC4gU2V0cyB0aGlzIG9wZXJhdGlvbiB0byBkaXJ0eS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wdGlvbnNDaGFuZ2UgKCkge1xuICAgIGNvbnN0IGRpcnRpbmVzcyA9IHRoaXMuX2RpcnRpbmVzc1xuICAgIGZvciAobGV0IGlkIGluIGRpcnRpbmVzcykge1xuICAgICAgZGlydGluZXNzW2lkXSA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBzcHJpdGVcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICAgIHRoaXMuX2lucHV0VGV4dHVyZS5nZXRCYXNlVGV4dHVyZSgpLmRpc3Bvc2UoKVxuICAgIHRoaXMuX2lucHV0VGV4dHVyZSA9IG51bGxcbiAgICB0aGlzLl9vcHRpb25zLmFkanVzdG1lbnRzLm9mZigndXBkYXRlZCcsIHRoaXMuX29uT3B0aW9uc0NoYW5nZSlcbiAgfVxufVxuXG5TdGlja2VyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBpZDogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORywgZGVmYXVsdDogKCkgPT4gVXRpbHMuZ2V0VVVJRCgpIH0sXG4gIG5hbWU6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIGRlZmF1bHQ6ICcnIH0sXG4gIGltYWdlOiB7IHR5cGU6IE9wdGlvblR5cGUuT0JKRUNULCByZXF1aXJlZDogdHJ1ZSB9LFxuICBwb3NpdGlvbjogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IFZlY3RvcjIuTlVMTCB9LFxuICBkaW1lbnNpb25zOiB7IHR5cGU6IE9wdGlvblR5cGUuVkVDVE9SMiwgZGVmYXVsdDogVmVjdG9yMi5OVUxMIH0sXG4gIGFuY2hvcjogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDAuMCwgMC4wKSB9LFxuICBwaXZvdDogeyB0eXBlOiBPcHRpb25UeXBlLlZFQ1RPUjIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDAuNSwgMC41KSB9LFxuICByb3RhdGlvbjogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMCB9LFxuICBmbGlwSG9yaXpvbnRhbGx5OiB7IHR5cGU6IE9wdGlvblR5cGUuQk9PTEVBTiwgZGVmYXVsdDogZmFsc2UgfSxcbiAgZmxpcFZlcnRpY2FsbHk6IHsgdHlwZTogT3B0aW9uVHlwZS5CT09MRUFOLCBkZWZhdWx0OiBmYWxzZSB9LFxuICBzbW9vdGhEb3duc2NhbGluZzogeyB0eXBlOiBPcHRpb25UeXBlLkJPT0xFQU4sIGRlZmF1bHQ6IGZhbHNlIH0sXG4gIGFkanVzdG1lbnRzOiB7XG4gICAgdHlwZTogT3B0aW9uVHlwZS5DT05GSUdVUkFCTEUsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICBicmlnaHRuZXNzOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwIH0sXG4gICAgICBzYXR1cmF0aW9uOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAxIH0sXG4gICAgICBjb250cmFzdDogeyB0eXBlOiBPcHRpb25UeXBlLk5VTUJFUiwgZGVmYXVsdDogMSB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0aWNrZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvc3ByaXRlcy9zdGlja2VyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBVdGlscywgQ29uc3RhbnRzLCBDb2xvciwgVmVjdG9yMiB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5jb25zdCB7IE9wdGlvblR5cGUsIFJlbmRlcmVyVHlwZSB9ID0gQ29uc3RhbnRzXG5pbXBvcnQgU3ByaXRlIGZyb20gJy4vc3ByaXRlJ1xuaW1wb3J0IFRleHRSZW5kZXJlciBmcm9tICcuL3RleHQvdGV4dC1yZW5kZXJlcidcblxuLyoqXG4gKiBBIHRleHQgdGhhdCBjYW4gYmUgZHJhd24gYnkgU3ByaXRlT3BlcmF0aW9uLiBTaG91bGQgb25seSBiZSBjcmVhdGVkIHZpYSB7QGxpbmsgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24jY3JlYXRlVGV4dH1cbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uXG4gKi9cbmNsYXNzIFRleHQgZXh0ZW5kcyBTcHJpdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUZXh0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3RleHRSZW5kZXJlciA9IG5ldyBUZXh0UmVuZGVyZXIodGhpcywgdGhpcy5fb3BlcmF0aW9uKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKHRoaXMuX3RleHRSZW5kZXJlci5nZXRUZXh0dXJlKCkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGlzIGNvbmZpZ3VyYWJsZVxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdG9PYmplY3QgPSBmYWxzZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzZXJpYWxpemVPcHRpb25zIChrZXlzLCB0b09iamVjdCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHN1cGVyLnNlcmlhbGl6ZU9wdGlvbnMoa2V5cywgdG9PYmplY3QpXG4gICAgaWYgKCFrZXlzKSBvcHRpb25zLnR5cGUgPSAndGV4dCdcbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHlsZSBvYmplY3QgZm9yIHRoaXMgdGV4dFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLfSBTREtcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGlucHV0RGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXRET01TdHlsZSAoc2RrLCBpbnB1dERpbWVuc2lvbnMpIHtcbiAgICBjb25zdCBhY3R1YWxGb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKSAqIGlucHV0RGltZW5zaW9ucy55XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9udFdlaWdodDogdGhpcy5fb3B0aW9ucy5mb250V2VpZ2h0LFxuICAgICAgZm9udFNpemU6IE1hdGgucm91bmQoYWN0dWFsRm9udFNpemUpICsgJ3B4JyxcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5fb3B0aW9ucy5mb250U3R5bGUsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLl9vcHRpb25zLmZvbnRGYW1pbHksXG4gICAgICBsaW5lSGVpZ2h0OiBNYXRoLnJvdW5kKGFjdHVhbEZvbnRTaXplICogdGhpcy5nZXRMaW5lSGVpZ2h0KCkpICsgJ3B4JyxcbiAgICAgIGNvbG9yOiB0aGlzLl9vcHRpb25zLmNvbG9yLnRvUkdCQSgpLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9vcHRpb25zLmJhY2tncm91bmRDb2xvci50b1JHQkEoKSxcbiAgICAgIHRleHRBbGlnbjogdGhpcy5fb3B0aW9ucy5hbGlnbm1lbnRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciB0aGlzIHRleHRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGlucHV0RGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXRCb3VuZGluZ0JveCAoc2RrLCBpbnB1dERpbWVuc2lvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dFJlbmRlcmVyLmdldEJvdW5kaW5nQm94KHNkaywgaW5wdXREaW1lbnNpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBmbGlwIGluIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICovXG4gIGFwcGx5RmxpcCAoZGlyZWN0aW9uKSB7XG4gICAgc3VwZXIuYXBwbHlGbGlwKGRpcmVjdGlvbilcblxuICAgIGxldCByb3RhdGlvbiA9IHRoaXMuX29wdGlvbnMucm90YXRpb25cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgIHJvdGF0aW9uICs9IChNYXRoLlBJIC0gcm90YXRpb24pICogMlxuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICByb3RhdGlvbiArPSAoTWF0aC5QSSAvIDIgLSByb3RhdGlvbikgKiAyXG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBjcm9wIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5Dcm9wT3BlcmF0aW9ufSBjcm9wT3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgYXBwbHlDcm9wIChjcm9wT3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgc3VwZXIuYXBwbHlDcm9wKGNyb3BPcGVyYXRpb24sIG9wdGlvbnMpXG4gICAgY29uc3Qgb2xkU2l6ZSA9IGNyb3BPcGVyYXRpb24uZ2V0RW5kKCkuY2xvbmUoKS5zdWJ0cmFjdChjcm9wT3BlcmF0aW9uLmdldFN0YXJ0KCkpXG4gICAgY29uc3QgbmV3U2l6ZSA9IG9wdGlvbnMuZW5kLmNsb25lKCkuc3VidHJhY3Qob3B0aW9ucy5zdGFydClcblxuICAgIGNvbnN0IGZhY3RvciA9IG5ld1NpemUuY2xvbmUoKS5kaXZpZGUob2xkU2l6ZSlcbiAgICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuc2NhbGUgLyBjcm9wT3BlcmF0aW9uLmdldFNjYWxlKClcbiAgICB0aGlzLnNldEZvbnRTaXplKHRoaXMuZ2V0Rm9udFNpemUoKSAvIGZhY3Rvci55ICogc2NhbGUpXG4gICAgdGhpcy5zZXRNYXhXaWR0aCh0aGlzLmdldE1heFdpZHRoKCkgLyBmYWN0b3IueCAqIHNjYWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSByb3RhdGlvbiB3aXRoIHRoZSBnaXZlbiBkZWdyZWVzXG4gICAqIEBwYXJhbSAge051bWJlcn0gZGVncmVlc1xuICAgKi9cbiAgYXBwbHlSb3RhdGlvbiAoZGVncmVlcykge1xuICAgIHN1cGVyLmFwcGx5Um90YXRpb24oZGVncmVlcylcblxuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IHRoaXMuX29wZXJhdGlvbi5nZXRJbnB1dERpbWVuc2lvbnMoKVxuICAgIHRoaXMuc2V0TWF4V2lkdGgodGhpcy5nZXRNYXhXaWR0aCgpIC8gaW5wdXREaW1lbnNpb25zLnggKiBpbnB1dERpbWVuc2lvbnMueSlcbiAgICB0aGlzLnNldEZvbnRTaXplKHRoaXMuZ2V0Rm9udFNpemUoKSAvIGlucHV0RGltZW5zaW9ucy55ICogaW5wdXREaW1lbnNpb25zLngpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIHNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gaW5wdXREaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB1cGRhdGUgKHNkaywgaW5wdXREaW1lbnNpb25zKSB7XG4gICAgLy8gUmUtcmVuZGVyIHRleHRcbiAgICB0aGlzLl90ZXh0UmVuZGVyZXIudXBkYXRlKHNkaywgaW5wdXREaW1lbnNpb25zKVxuICAgIGNvbnN0IHRleHRUZXh0dXJlID0gdGhpcy5fdGV4dFJlbmRlcmVyLmdldFRleHR1cmUoKVxuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gdGV4dFRleHR1cmUuZ2V0QmFzZVRleHR1cmUoKVxuICAgIGJhc2VUZXh0dXJlLnVwZGF0ZSgpXG5cbiAgICAvLyBVcGxvYWQgdGV4dHVyZVxuICAgIGNvbnN0IHJlbmRlcmVyID0gc2RrLmdldFJlbmRlcmVyKClcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHJlbmRlcmVyLmlzT2ZUeXBlKFJlbmRlcmVyVHlwZS5XRUJHTCkpIHtcbiAgICAgIHJlbmRlcmVyLnVwZGF0ZVRleHR1cmUodGV4dFRleHR1cmUuZ2V0QmFzZVRleHR1cmUoKSlcbiAgICB9XG5cbiAgICBzdXBlci51cGRhdGUoc2RrLCBpbnB1dERpbWVuc2lvbnMpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0dXJlIGZvciB0aGUgc3ByaXRlIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIF9nZXRUZXh0dXJlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dFJlbmRlcmVyLmdldFRleHR1cmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGlzIFNwcml0ZVxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpXG4gICAgdGhpcy5fdGV4dFJlbmRlcmVyLmRpc3Bvc2UoKVxuICB9XG59XG5cblRleHQucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGlkOiB7IHR5cGU6IE9wdGlvblR5cGUuU1RSSU5HLCBkZWZhdWx0OiAoKSA9PiBVdGlscy5nZXRVVUlEKCkgfSxcbiAgZm9udFNpemU6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDAuMSB9LFxuICBsaW5lSGVpZ2h0OiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAxLjEgfSxcbiAgZm9udEZhbWlseTogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORywgZGVmYXVsdDogJ1RpbWVzIE5ldyBSb21hbicgfSxcbiAgZm9udFdlaWdodDogeyB0eXBlOiBPcHRpb25UeXBlLkFMTCwgZGVmYXVsdDogJ25vcm1hbCcgfSxcbiAgZm9udFN0eWxlOiB7IHR5cGU6IE9wdGlvblR5cGUuU1RSSU5HLCBkZWZhdWx0OiAnbm9ybWFsJyB9LFxuICBvdXRsaW5lV2lkdGg6IHsgdHlwZTogT3B0aW9uVHlwZS5OVU1CRVIsIGRlZmF1bHQ6IDAgfSxcbiAgb3V0bGluZUNvbG9yOiB7IHR5cGU6IE9wdGlvblR5cGUuQ09MT1IsIGRlZmF1bHQ6IENvbG9yLkJMQUNLIH0sXG4gIGFsaWdubWVudDogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORywgZGVmYXVsdDogJ2xlZnQnLCBhdmFpbGFibGU6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSB9LFxuICB2ZXJ0aWNhbEFsaWdubWVudDogeyB0eXBlOiBPcHRpb25UeXBlLlNUUklORywgZGVmYXVsdDogJ3RvcCcsIGF2YWlsYWJsZTogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddIH0sXG4gIGNvbG9yOiB7IHR5cGU6IE9wdGlvblR5cGUuQ09MT1IsIGRlZmF1bHQ6IG5ldyBDb2xvcigxLCAwLCAwLCAxKSB9LFxuICBiYWNrZ3JvdW5kQ29sb3I6IHsgdHlwZTogT3B0aW9uVHlwZS5DT0xPUiwgZGVmYXVsdDogQ29sb3IuVFJBTlNQQVJFTlQgfSxcbiAgcG9zaXRpb246IHsgdHlwZTogT3B0aW9uVHlwZS5WRUNUT1IyLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigwLjUsIDAuNSkgfSxcbiAgYW5jaG9yOiB7IHR5cGU6IE9wdGlvblR5cGUuVkVDVE9SMiwgZGVmYXVsdDogbmV3IFZlY3RvcjIoMCwgMCkgfSxcbiAgcGl2b3Q6IHsgdHlwZTogT3B0aW9uVHlwZS5WRUNUT1IyLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigwLjUsIDApIH0sXG4gIHJvdGF0aW9uOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwIH0sXG4gIHRleHQ6IHsgdHlwZTogT3B0aW9uVHlwZS5TVFJJTkcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gIG1heFdpZHRoOiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwLjUgfSxcbiAgbWF4SGVpZ2h0OiB7IHR5cGU6IE9wdGlvblR5cGUuTlVNQkVSLCBkZWZhdWx0OiAwIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy9zcHJpdGVzL3RleHQuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFByb21pc2UsIEVuZ2luZSwgVmVjdG9yMiwgVXRpbHMgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFRleHRTcGxpdHRlciBmcm9tICcuL3RleHQtc3BsaXR0ZXInXG5cbmNsYXNzIFRleHRSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yICh0ZXh0LCBvcGVyYXRpb24pIHtcbiAgICB0aGlzLl90ZXh0ID0gdGV4dFxuICAgIHRoaXMuX29wZXJhdGlvbiA9IG9wZXJhdGlvblxuICAgIHRoaXMuX3RleHRPcHRpb25zID0ge31cblxuICAgIHRoaXMuX2NyZWF0ZUNhbnZhcygpXG4gICAgdGhpcy5fY3JlYXRlTWVhc3VyZW1lbnRDYW52YXMoKVxuICAgIHRoaXMuX2NyZWF0ZVRleHR1cmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGNhbnZhcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIHRleHQgc3BsaXR0ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVDYW52YXMgKCkge1xuICAgIHRoaXMuX2NhbnZhcyA9IFV0aWxzLmNyZWF0ZUNhbnZhcygpXG4gICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgdGhpcy5fdGV4dFNwbGl0dGVyID0gbmV3IFRleHRTcGxpdHRlcih0aGlzLl9jb250ZXh0KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGNhbnZhcyB0aGF0IHdlIG5lZWQgZm9yIG1lYXN1cmluZyB0aGUgbWF4aW11bSB0ZXh0IGhlaWdodFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZU1lYXN1cmVtZW50Q2FudmFzICgpIHtcbiAgICB0aGlzLl9tZWFzdXJlbWVudENhbnZhcyA9IFV0aWxzLmNyZWF0ZUNhbnZhcygpXG4gICAgdGhpcy5fbWVhc3VyZW1lbnRDb250ZXh0ID0gdGhpcy5fbWVhc3VyZW1lbnRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVUZXh0dXJlICgpIHtcbiAgICB0aGlzLl90ZXh0dXJlID0gRW5naW5lLlRleHR1cmUuZnJvbUNhbnZhcyh0aGlzLl9jYW52YXMpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgdGV4dCBvcHRpb25zIG9uIHRoZSBnaXZlbiBjb250ZXh0XG4gICAqIEBwYXJhbSAge09iamVjdH0gdGV4dE9wdGlvbnNcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlUZXh0T3B0aW9ucyAodGV4dE9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmZvbnQgPSB0aGlzLl90ZXh0LmdldEZvbnRXZWlnaHQoKSArICcgJyArXG4gICAgICB0ZXh0T3B0aW9ucy5mb250U2l6ZSArICdweCAnICtcbiAgICAgIHRoaXMuX3RleHQuZ2V0Rm9udEZhbWlseSgpXG5cbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnXG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSB0aGlzLl90ZXh0LmdldEFsaWdubWVudCgpXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl90ZXh0LmdldENvbG9yKCkudG9SR0JBKClcblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLl90ZXh0LmdldE91dGxpbmVDb2xvcigpLnRvUkdCQSgpXG4gICAgY29uc3Qgb3V0bGluZVdpZHRoID0gdGhpcy5fdGV4dC5nZXRPdXRsaW5lV2lkdGgoKVxuICAgIGlmIChvdXRsaW5lV2lkdGggPiAwKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IG91dGxpbmVXaWR0aFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIGxpbmVzIGFuZCBzcGxpdCB0aGVtIGludG8gbXVsdGlwbGUgbGluZXMsIGRlcGVuZGluZ1xuICAgKiBvbiB0aGUgd2lkdGggdGhleSBuZWVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhXaWR0aFxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9idWlsZE91dHB1dExpbmVzIChtYXhXaWR0aCkge1xuICAgIHRoaXMuX3RleHRTcGxpdHRlci5zZXRUZXh0KHRoaXMuX3RleHQuZ2V0VGV4dCgpKVxuICAgIHRoaXMuX3RleHRTcGxpdHRlci5zZXRNYXhXaWR0aChtYXhXaWR0aClcbiAgICByZXR1cm4gdGhpcy5fdGV4dFNwbGl0dGVyLmdldExpbmVzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3cyB0aGUgZ2l2ZW4gbGluZSBvbnRvIGNvbnRleHQgYXQgdGhlIGdpdmVuIFkgcG9zaXRpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSAge051bWJlcn0geVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclRleHRMaW5lICh0ZXh0LCB5KSB7XG4gICAgY29uc3QgdGV4dEFsaWdubWVudCA9IHRoaXMuX3RleHQuZ2V0QWxpZ25tZW50KClcbiAgICBjb25zdCBkcmF3UG9zaXRpb24gPSBuZXcgVmVjdG9yMigwLCB5KSAvLyBMZWZ0IGFsaWdubWVudFxuXG4gICAgc3dpdGNoICh0ZXh0QWxpZ25tZW50KSB7XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBkcmF3UG9zaXRpb24ueCA9IHRoaXMuX2NhbnZhcy53aWR0aCAvIDJcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgZHJhd1Bvc2l0aW9uLnggPSB0aGlzLl9jYW52YXMud2lkdGhcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KHRleHQsIGRyYXdQb3NpdGlvbi54LCBkcmF3UG9zaXRpb24ueSlcbiAgICBjb25zdCBvdXRsaW5lV2lkdGggPSB0aGlzLl90ZXh0LmdldE91dGxpbmVXaWR0aCgpXG4gICAgaWYgKG91dGxpbmVXaWR0aCA+IDApIHtcbiAgICAgIHRoaXMuX2NvbnRleHQubWl0ZXJMaW1pdCA9IDJcbiAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCBkcmF3UG9zaXRpb24ueCwgZHJhd1Bvc2l0aW9uLnkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBzcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGlucHV0RGltZW5zaW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHVwZGF0ZSAoc2RrLCBpbnB1dERpbWVuc2lvbnMpIHtcbiAgICBjb25zdCB0ZXh0T3B0aW9ucyA9IHRoaXMuY2FsY3VsYXRlRm9udFN0eWxlcyhzZGssIGlucHV0RGltZW5zaW9ucylcbiAgICBjb25zdCB7IGJvdW5kaW5nQm94LCBsaW5lcyB9ID0gdGhpcy5fY2FsY3VsYXRlVGV4dChzZGssIHRleHRPcHRpb25zLCBpbnB1dERpbWVuc2lvbnMpXG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclRleHQoc2RrLCBib3VuZGluZ0JveCwgbGluZXMsIHRleHRPcHRpb25zLCBpbnB1dERpbWVuc2lvbnMpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgdGV4dFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IGJvdW5kaW5nQm94XG4gICAqIEBwYXJhbSAge0FycmF5LjxTdHJpbmc+fSBsaW5lc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHRPcHRpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gaW5wdXREaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVGV4dCAoc2RrLCBib3VuZGluZ0JveCwgbGluZXMsIHRleHRPcHRpb25zLCBpbnB1dERpbWVuc2lvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gUmVzaXplIHRoZSBjYW52YXNcbiAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IGJvdW5kaW5nQm94LnhcbiAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBib3VuZGluZ0JveC55XG5cbiAgICAgIGlmICh0aGlzLl90ZXh0LmdldE1heEhlaWdodCgpKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgICB0aGlzLl90ZXh0LmdldE1heEhlaWdodCgpICogaW5wdXREaW1lbnNpb25zLnksXG4gICAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGV4dFxuICAgICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICAgIC8vIFJlbmRlciBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX3RleHQuZ2V0QmFja2dyb3VuZENvbG9yKCkudG9SR0JBKClcbiAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoMCwgMCwgYm91bmRpbmdCb3gueCwgYm91bmRpbmdCb3gueSlcblxuICAgICAgLy8gQXBwbHkgdGV4dCBvcHRpb25zXG4gICAgICB0aGlzLl9hcHBseVRleHRPcHRpb25zKHRleHRPcHRpb25zLCB0aGlzLl9jb250ZXh0KVxuXG4gICAgICAvLyBEcmF3IGxpbmVzXG4gICAgICBmb3IgKHZhciBsaW5lTnVtID0gMDsgbGluZU51bSA8IGxpbmVzLmxlbmd0aDsgbGluZU51bSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tsaW5lTnVtXVxuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZShsaW5lLCB0ZXh0T3B0aW9ucy5saW5lSGVpZ2h0ICogbGluZU51bSlcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhY3R1YWwgZm9udCBzaXplIGFuZCBsaW5lIGhlaWdodFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gaW5wdXREaW1lbnNpb25zXG4gICAqL1xuICBjYWxjdWxhdGVGb250U3R5bGVzIChzZGssIGlucHV0RGltZW5zaW9ucykge1xuICAgIGNvbnN0IGZvbnRGYW1pbHkgPSB0aGlzLl90ZXh0LmdldEZvbnRGYW1pbHkoKVxuICAgIGNvbnN0IGZvbnRTaXplID0gTWF0aC5yb3VuZCh0aGlzLl90ZXh0LmdldEZvbnRTaXplKCkgKiBpbnB1dERpbWVuc2lvbnMueSlcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLl90ZXh0LmdldExpbmVIZWlnaHQoKSAqIGZvbnRTaXplKVxuXG4gICAgY29uc3QgdGV4dE9wdGlvbnMgPSB7IGZvbnRGYW1pbHksIGZvbnRTaXplLCBsaW5lSGVpZ2h0IH1cbiAgICBpZiAodGhpcy5fdGV4dE9wdGlvbnMuZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSB8fFxuICAgICAgICB0aGlzLl90ZXh0T3B0aW9ucy5mb250U2l6ZSAhPT0gZm9udFNpemUgfHxcbiAgICAgICAgdGhpcy5fdGV4dE9wdGlvbnMubGluZUhlaWdodCAhPT0gbGluZUhlaWdodCkge1xuICAgICAgdGhpcy5fbWF4VGV4dEhlaWdodCA9IG51bGxcbiAgICAgIHRoaXMuX3RleHRPcHRpb25zID0gdGV4dE9wdGlvbnNcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dE9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBib3VuZGluZyBib3ggYW5kIG5ldyBsaW5lcyBhY2NvcmRpbmcgdG8gbWF4IHdpZHRoXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHBhcmFtICB7T2JqZWN0fSB0ZXh0T3B0aW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGlucHV0RGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FsY3VsYXRlVGV4dCAoc2RrLCB0ZXh0T3B0aW9ucywgaW5wdXREaW1lbnNpb25zKSB7XG4gICAgLy8gQ2FsY3VsYXRlIG1heCB3aWR0aFxuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMuX3RleHQuZ2V0TWF4V2lkdGgoKSAqIGlucHV0RGltZW5zaW9ucy54XG5cbiAgICAvLyBBcHBseSB0ZXh0IG9wdGlvbnNcbiAgICB0aGlzLl9hcHBseVRleHRPcHRpb25zKHRleHRPcHRpb25zLCB0aGlzLl9jb250ZXh0KVxuXG4gICAgLy8gQ2FsY3VsYXRlIGJvdW5kaW5nIGJveFxuICAgIGxldCBib3VuZGluZ0JveCA9IG5ldyBWZWN0b3IyKClcbiAgICBsZXQgbGluZXMgPSB0aGlzLl90ZXh0LmdldFRleHQoKS5zcGxpdCgnXFxuJylcbiAgICBpZiAodHlwZW9mIG1heFdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3hcbiAgICAgIGJvdW5kaW5nQm94LnggPSBtYXhXaWR0aFxuICAgICAgbGluZXMgPSB0aGlzLl9idWlsZE91dHB1dExpbmVzKG1heFdpZHRoKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBsaW5lTnVtID0gMDsgbGluZU51bSA8IGxpbmVzLmxlbmd0aDsgbGluZU51bSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tsaW5lTnVtXVxuICAgICAgICBib3VuZGluZ0JveC54ID0gTWF0aC5tYXgoYm91bmRpbmdCb3gueCwgdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgYm91bmRpbmdib3ggaGVpZ2h0XG4gICAgY29uc3QgeyBsaW5lSGVpZ2h0IH0gPSB0ZXh0T3B0aW9uc1xuICAgIGNvbnN0IG1heFRleHRIZWlnaHQgPSB0aGlzLl9nZXRNYXhUZXh0SGVpZ2h0KHNkaywgdGV4dE9wdGlvbnMsIGlucHV0RGltZW5zaW9ucykgKiAxLjEgLy8gKyAxMCVcblxuICAgIGJvdW5kaW5nQm94LnkgKz0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodCArIChtYXhUZXh0SGVpZ2h0IC0gbGluZUhlaWdodClcblxuICAgIHJldHVybiB7IGJvdW5kaW5nQm94LCBsaW5lcyB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSB0ZXh0IGhlaWdodCBwZXIgbGluZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0T3B0aW9uc1xuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gaW5wdXREaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRNYXhUZXh0SGVpZ2h0IChzZGssIHRleHRPcHRpb25zLCBpbnB1dERpbWVuc2lvbnMpIHtcbiAgICBpZiAodGhpcy5fbWF4VGV4dEhlaWdodCkgcmV0dXJuIHRoaXMuX21heFRleHRIZWlnaHRcblxuICAgICAgdGhpcy5fbWF4VGV4dEhlaWdodCA9IHRoaXMuX2dldE1heFRleHRIZWlnaHRVc2luZ0RPTShzZGssIHRleHRPcHRpb25zLCBpbnB1dERpbWVuc2lvbnMpXG5cbiAgICByZXR1cm4gdGhpcy5fbWF4VGV4dEhlaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1heGltdW0gdGV4dCBoZWlnaHQgcGVyIGxpbmUgdXNpbmcgYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge09iamVjdH0gdGV4dE9wdGlvbnNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBpbnB1dERpbWVuc2lvbnNcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE1heFRleHRIZWlnaHRVc2luZ0RPTSAoc2RrLCB0ZXh0T3B0aW9ucywgaW5wdXREaW1lbnNpb25zKSB7XG4gICAgY29uc3QgbWVhc3VyZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3RleHQuZ2V0RE9NU3R5bGUoc2RrLCBpbnB1dERpbWVuc2lvbnMpXG4gICAgY29uc3QgYmxvY2tlZFByb3BzID0gWydsaW5lSGVpZ2h0J11cbiAgICBmb3IgKGxldCBwcm9wIGluIHN0eWxlKSB7XG4gICAgICBpZiAoYmxvY2tlZFByb3BzLmluZGV4T2YocHJvcCkgIT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlW3Byb3BdXG4gICAgfVxuXG4gICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUubGVmdCA9ICctOTk5OXB4J1xuICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLnRvcCA9ICctOTk5OXB4J1xuICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJ1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZWFzdXJlRWxlbWVudClcbiAgICBtZWFzdXJlRWxlbWVudC5pbm5lckhUTUwgPSAnIVwiIyQlJlxcJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXFxcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fidcbiAgICBjb25zdCBoZWlnaHQgPSBtZWFzdXJlRWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG1lYXN1cmVFbGVtZW50KVxuXG4gICAgcmV0dXJuIGhlaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1heGltdW0gdGV4dCBoZWlnaHQgcGVyIGxpbmUgdXNpbmcgY2FudmFzIGVzdGltYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHRPcHRpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gaW5wdXREaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRNYXhUZXh0SGVpZ2h0VXNpbmdDYW52YXMgKHNkaywgdGV4dE9wdGlvbnMsIGlucHV0RGltZW5zaW9ucykge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX21lYXN1cmVtZW50Q2FudmFzXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuX21lYXN1cmVtZW50Q29udGV4dFxuXG4gICAgY29uc3QgeyBmb250U2l6ZSB9ID0gdGV4dE9wdGlvbnNcbiAgICBjYW52YXMud2lkdGggPSBmb250U2l6ZSAqIDEwXG4gICAgY2FudmFzLmhlaWdodCA9IGZvbnRTaXplICogMlxuXG4gICAgdGhpcy5fYXBwbHlUZXh0T3B0aW9ucyh0ZXh0T3B0aW9ucywgdGhpcy5fbWVhc3VyZW1lbnRDb250ZXh0KVxuXG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJ1xuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcidcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjaydcblxuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICBjb25zdCBjaGFycyA9ICchXCIjJCUmXFwnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXFxdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+J1xuICAgIGNvbnN0IGNoYXJzQ291bnQgPSBjaGFycy5sZW5ndGhcbiAgICBsZXQgcG9pbnRlciA9IDBcbiAgICB3aGlsZSAocG9pbnRlciA8IGNoYXJzQ291bnQpIHtcbiAgICAgIGNvbnN0IHByaW50YWJsZVN0cmluZyA9IGNoYXJzLnN1YnN0cihwb2ludGVyLCA1KVxuICAgICAgcG9pbnRlciArPSA1XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHByaW50YWJsZVN0cmluZywgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpXG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhIH0gPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgICBsZXQgeVxuICAgIC8vIEZpbmQgc3RhcnQgWVxuICAgIGxldCBzdGFydFkgPSBudWxsXG4gICAgZm9yICh5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgbGV0IHBpeGVsRm91bmQgPSBmYWxzZVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9ICgoeSAqIGNhbnZhcy53aWR0aCkgKyB4KSAqIDRcbiAgICAgICAgY29uc3QgY29sb3IgPSBkYXRhW2luZGV4XSArIGRhdGFbaW5kZXggKyAxXSArIGRhdGFbaW5kZXggKyAyXSArIGRhdGFbaW5kZXggKyAzXVxuICAgICAgICBpZiAoY29sb3IgPiAwKSB7XG4gICAgICAgICAgcGl4ZWxGb3VuZCA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcGl4ZWxGb3VuZCkge1xuICAgICAgICBzdGFydFkrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGVuZCBZXG4gICAgbGV0IGVuZFkgPSBjYW52YXMuaGVpZ2h0XG4gICAgZm9yICh5ID0gY2FudmFzLmhlaWdodCAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgICBsZXQgcGl4ZWxGb3VuZCA9IGZhbHNlXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKCh5ICogY2FudmFzLndpZHRoKSArIHgpICogNFxuICAgICAgICBjb25zdCBjb2xvciA9IGRhdGFbaW5kZXhdICsgZGF0YVtpbmRleCArIDFdICsgZGF0YVtpbmRleCArIDJdICsgZGF0YVtpbmRleCArIDNdXG4gICAgICAgIGlmIChjb2xvciA+IDApIHtcbiAgICAgICAgICBwaXhlbEZvdW5kID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFwaXhlbEZvdW5kKSB7XG4gICAgICAgIGVuZFktLVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXhUZXh0SGVpZ2h0ID0gZW5kWSAtIHN0YXJ0WVxuICAgIHJldHVybiB0aGlzLl9tYXhUZXh0SGVpZ2h0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIHJlbmRlcmVyJ3MgdGV4dHVyZVxuICAgKiBAcmV0dXJuIHtFbmdpbmUuVGV4dHVyZX1cbiAgICovXG4gIGdldFRleHR1cmUgKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciB0aGlzIHRleHRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGlucHV0RGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdCb3ggKHNkaywgaW5wdXREaW1lbnNpb25zKSB7XG4gICAgY29uc3QgdGV4dE9wdGlvbnMgPSB0aGlzLmNhbGN1bGF0ZUZvbnRTdHlsZXMoc2RrLCBpbnB1dERpbWVuc2lvbnMpXG4gICAgY29uc3QgeyBib3VuZGluZ0JveCB9ID0gdGhpcy5fY2FsY3VsYXRlVGV4dChzZGssIHRleHRPcHRpb25zLCBpbnB1dERpbWVuc2lvbnMpXG4gICAgcmV0dXJuIGJvdW5kaW5nQm94XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyB0ZXh0IHJlbmRlcmVyXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl90ZXh0dXJlLmdldEJhc2VUZXh0dXJlKCkuZGlzcG9zZSgpXG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0UmVuZGVyZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL29wZXJhdGlvbnMvc3ByaXRlcy90ZXh0L3RleHQtcmVuZGVyZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2LTIwMTcgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmNsYXNzIFRleHRTcGxpdHRlciB7XG4gIGNvbnN0cnVjdG9yIChjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHRcbiAgICB0aGlzLl9sYXN0Rm9udFN0eWxlID0ge31cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaW5lcyB0aGF0IGZpdCB0aGUgbWF4V2lkdGhcbiAgICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59XG4gICAqL1xuICBnZXRMaW5lcyAoKSB7XG4gICAgbGV0IGxpbmVzID0gW11cbiAgICBsZXQgbmV3TGluZVdvcmRzID0gW11cblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBsaW5lc1xuICAgIGNvbnN0IGxpbmVzQ291bnQgPSB0aGlzLl9saW5lcy5sZW5ndGhcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGxpbmVzQ291bnQ7IGwrKykge1xuICAgICAgY29uc3QgbGluZSA9IHRoaXMuX2xpbmVzW2xdXG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciB3b3Jkc1xuICAgICAgY29uc3Qgd29yZHMgPSB0aGlzLl9idWlsZFdvcmRzKGxpbmUpXG4gICAgICBjb25zdCB3b3Jkc0NvdW50ID0gd29yZHMubGVuZ3RoXG4gICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHdvcmRzQ291bnQ7IHcrKykge1xuICAgICAgICBjb25zdCB3b3JkID0gd29yZHNbd11cblxuICAgICAgICAvLyBDaGVjayBpZiBsaW5lIGlzIHRvbyB3aWRlIGZvciB0aGUgbWF4d2lkdGhcbiAgICAgICAgbGV0IGN1cnJlbnRMaW5lID0gbmV3TGluZVdvcmRzLmNvbmNhdCh3b3JkKS5qb2luKCcnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHMrJC9pLCAnJylcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl9nZXRXaWR0aChjdXJyZW50TGluZSlcbiAgICAgICAgaWYgKHdpZHRoID4gdGhpcy5fbWF4V2lkdGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBoYXZlIGJlZW4gd29yZHMgYmVmb3JlIHRoaXMgb25lLCBzdGFydFxuICAgICAgICAgIC8vIGEgbmV3IGxpbmVcbiAgICAgICAgICBpZiAobmV3TGluZVdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIExpbmUgdG9vIGxvbmcgLT4gbGluZSBlbmRlZFxuICAgICAgICAgICAgbGluZXMucHVzaChuZXdMaW5lV29yZHMuam9pbignJykpXG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGxpbmUgd2l0aCB0aGUgd29yZFxuICAgICAgICAgICAgbmV3TGluZVdvcmRzID0gW3dvcmRdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIG5leHQgd29yZCBpcyB0b28gbG9uZyAod2l0aG91dCB0cmFpbGluZyBzcGFjZXMpLCBzcGxpdCBpdCB1cFxuICAgICAgICAgIGNvbnN0IF93b3JkID0gd29yZC5yZXBsYWNlKC9cXHMrJC9pLCAnJylcbiAgICAgICAgICBpZiAodGhpcy5fZ2V0V2lkdGgoX3dvcmQpID4gdGhpcy5fbWF4V2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0V29yZCA9IHRoaXMuX3NwbGl0V29yZCh3b3JkKVxuICAgICAgICAgICAgbGluZXMgPSBsaW5lcy5jb25jYXQoc3BsaXRXb3JkLmxpbmVzKVxuICAgICAgICAgICAgaWYgKHNwbGl0V29yZC5yZXN0KSB7XG4gICAgICAgICAgICAgIG5ld0xpbmVXb3JkcyA9IFtzcGxpdFdvcmQucmVzdF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGluZVdvcmRzLnB1c2god29yZClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lcy5wdXNoKG5ld0xpbmVXb3Jkcy5qb2luKCcnKSlcbiAgICAgIG5ld0xpbmVXb3JkcyA9IFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzXG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuIGFycmF5IG9mIHdvcmRzIGZyb20gdGhlIGdpdmVuIGxpbmVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBsaW5lXG4gICAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkV29yZHMgKGxpbmUpIHtcbiAgICBsZXQgd29yZHMgPSBbXVxuICAgIGxldCB3b3JkID0gJydcblxuICAgIGNvbnN0IGxlbiA9IGxpbmUubGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGxpbmVbaV1cbiAgICAgIHdvcmQgKz0gY2hhclxuICAgICAgaWYgKGNoYXIgPT09ICcgJyB8fCBjaGFyID09PSAnLScgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICB3b3Jkcy5wdXNoKHdvcmQpXG4gICAgICAgIHdvcmQgPSAnJ1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3b3Jkc1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyB1cCB0aGUgZ2l2ZW4gd29yZCB0byBmaXQgdGhlIG1heCB3aWR0aFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHdvcmRcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NwbGl0V29yZCAod29yZCkge1xuICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgIGxpbmVzOiBbXSxcbiAgICAgIHJlc3Q6IG51bGxcbiAgICB9XG5cbiAgICBjb25zdCB3b3JkTGVuZ3RoID0gd29yZC5sZW5ndGhcbiAgICBsZXQgY2hhcnMgPSBbXVxuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgd29yZExlbmd0aDsgYysrKSB7XG4gICAgICBjb25zdCBjaGFyID0gd29yZFtjXVxuICAgICAgaWYgKHRoaXMuX2dldFdpZHRoKGNoYXJzLmNvbmNhdChjaGFyKS5qb2luKCcnKSkgPiB0aGlzLl9tYXhXaWR0aCkge1xuICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3BvbnNlLmxpbmVzLnB1c2goY2hhcnMuam9pbignJykpXG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMgPSBbY2hhcl1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJzLnB1c2goY2hhcilcbiAgICAgIH1cblxuICAgICAgaWYgKGMgPT09IHdvcmRMZW5ndGggLSAxICYmIGNoYXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzcG9uc2UucmVzdCA9IGNoYXJzLmpvaW4oJycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBmb250IHN0eWxlIGNoYW5nZWQgZnJvbSB0aGUgbGFzdCBjYWxsXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9udFN0eWxlQ2hhbmdlZCAoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRleHQuZm9udCAhPT0gdGhpcy5fbGFzdEZvbnRTdHlsZSkge1xuICAgICAgdGhpcy5fbGFzdEZvbnRTdHlsZSA9IHRoaXMuX2NvbnRleHQuZm9udFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWVhc3VyZWQgd2lkdGggZm9yIHRoZSBnaXZlbiBzdHJpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFdpZHRoIChzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKi9cbiAgc2V0VGV4dCAodGV4dCkge1xuICAgIHRoaXMuX3RleHQgPSB0ZXh0XG4gICAgdGhpcy5fbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heCB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4V2lkdGhcbiAgICovXG4gIHNldE1heFdpZHRoIChtYXhXaWR0aCkgeyB0aGlzLl9tYXhXaWR0aCA9IG1heFdpZHRoIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dFNwbGl0dGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9vcGVyYXRpb25zL3Nwcml0ZXMvdGV4dC90ZXh0LXNwbGl0dGVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBQcm9taXNlLCBFbmdpbmUsIFV0aWxzLCBWZWN0b3IyLCBDb25zdGFudHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcbmNvbnN0IHsgT3B0aW9uVHlwZSB9ID0gQ29uc3RhbnRzXG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGRyYXcgYSB3YXRlcm1hcmsgb24gdG9wIG9mIHRoZSBpbWFnZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5PcGVyYXRpb25cbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zXG4gKi9cbmNsYXNzIFdhdGVybWFya09wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFdhdGVybWFya09wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl93YXRlcm1hcmtTcHJpdGUgPSBuZXcgRW5naW5lLlNwcml0ZSgpXG4gICAgdGhpcy5fd2F0ZXJtYXJrU3ByaXRlLnNldEFuY2hvcigwLjUsIDAuNSlcbiAgICB0aGlzLl9jb250YWluZXIuYWRkQ2hpbGQodGhpcy5fd2F0ZXJtYXJrU3ByaXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHdhdGVybWFya1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgX3JlbmRlciAoaW5wdXRUZXh0dXJlKSB7XG4gICAgaWYgKCF0aGlzLl93YXRlcm1hcmtUZXh0dXJlKSB7XG4gICAgICB0aGlzLl93YXRlcm1hcmtUZXh0dXJlID0gRW5naW5lLlRleHR1cmUuZnJvbUltYWdlKHRoaXMuX29wdGlvbnMuaW1hZ2UpXG4gICAgICB0aGlzLl93YXRlcm1hcmtTcHJpdGUuc2V0VGV4dHVyZSh0aGlzLl93YXRlcm1hcmtUZXh0dXJlKVxuICAgIH1cblxuICAgIGNvbnN0IHRleHR1cmVEaW1lbnNpb25zID0gaW5wdXRUZXh0dXJlLmdldERpbWVuc2lvbnMoKVxuXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLl9vcHRpb25zLmltYWdlXG4gICAgY29uc3QgZGltZW5zaW9ucyA9IFV0aWxzLnJlc2l6ZVZlY3RvclRvRml0KFxuICAgICAgbmV3IFZlY3RvcjIod2lkdGgsIGhlaWdodCksXG4gICAgICB0ZXh0dXJlRGltZW5zaW9uc1xuICAgIClcbiAgICB0aGlzLl93YXRlcm1hcmtTcHJpdGUuc2V0UG9zaXRpb24odGV4dHVyZURpbWVuc2lvbnMuY2xvbmUoKS5kaXZpZGUoMikpXG4gICAgdGhpcy5fd2F0ZXJtYXJrU3ByaXRlLnNldFdpZHRoKGRpbWVuc2lvbnMueClcbiAgICB0aGlzLl93YXRlcm1hcmtTcHJpdGUuc2V0SGVpZ2h0KGRpbWVuc2lvbnMueSlcblxuICAgIHRoaXMuX3JlbmRlclRleHR1cmUucmVuZGVyKHRoaXMuX2NvbnRhaW5lcilcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICBzdXBlci5kaXNwb3NlKClcbiAgICB0aGlzLl93YXRlcm1hcmtTcHJpdGUuZGlzcG9zZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAqIG9wZXJhdGlvbnMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuV2F0ZXJtYXJrT3BlcmF0aW9uLmlkZW50aWZpZXIgPSAnd2F0ZXJtYXJrJ1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5XYXRlcm1hcmtPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGltYWdlOiB7IHR5cGU6IE9wdGlvblR5cGUuT0JKRUNULCByZXF1aXJlZDogdHJ1ZSB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdhdGVybWFya09wZXJhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vb3BlcmF0aW9ucy93YXRlcm1hcmstb3BlcmF0aW9uLmpzIiwiLypcbiAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gKiBodHRwOi8vbXkub3BlcmEuY29tL2Vtb2xsZXIvYmxvZy8yMDExLzEyLzIwL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtZXItYW5pbWF0aW5nXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyLiBmaXhlcyBmcm9tIFBhdWwgSXJpc2ggYW5kIFRpbm8gWmlqZGVsXG4gKiBNSVQgbGljZW5zZVxuICogQGxpY2Vuc2VcbiAqL1xuY29uc3Qgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG5sZXQgckFGID0gcm9vdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbmxldCBjQUYgPSByb290LmNhbmNlbEFuaW1hdGlvbkZyYW1lXG5cbmxldCBsYXN0VGltZSA9IDBcbmNvbnN0IHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddXG5mb3IgKGxldCB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFyQUY7ICsreCkge1xuICByQUYgPSByb290W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ11cbiAgY0FGID0gcm9vdFt2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgcm9vdFt2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoIXJBRikge1xuICByQUYgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICBjb25zdCBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgY29uc3QgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKVxuICAgIGNvbnN0IGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCkgfSwgdGltZVRvQ2FsbClcbiAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbFxuICAgIHJldHVybiBpZFxuICB9XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoIWNBRikge1xuICBjQUYgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBjbGVhclRpbWVvdXQoaWQpXG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgckFGIGFzIHJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgY0FGIGFzIGNhbmNlbEFuaW1hdGlvbkZyYW1lXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vc2hhcmVkL2FuaW1hdGlvbi1mcmFtZS5qcyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pc0l0ZXJhYmxlMiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL2lzLWl0ZXJhYmxlXCIpO1xuXG52YXIgX2lzSXRlcmFibGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNJdGVyYWJsZTIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKGFyciksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pc0l0ZXJhYmxlMy5kZWZhdWx0KShPYmplY3QoYXJyKSkpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZScpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKXtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSBwSUUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2tleW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1FVEEgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKVxuICAsIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBoYXMgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgc2V0RGVzYyAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaWQgICAgICAgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24oaXQpe1xuICBzZXREZXNjKGl0LCBNRVRBLCB7dmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9fSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKXNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiAgICAgIE1FVEEsXG4gIE5FRUQ6ICAgICBmYWxzZSxcbiAgZmFzdEtleTogIGZhc3RLZXksXG4gIGdldFdlYWs6ICBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXQgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jylcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDIyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChtaXgoY29sb3IucmdiLCB1X2NvbG9yLnJnYiwgdV9jb2xvci5hKSwgY29sb3IuYSkgKiBjb2xvci5hO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9lbmdpbmUvZmlsdGVycy9zb3VyY2UvY29sb3Itb3ZlcmxheS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAyMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IuYSA+IDAuID8gY29sb3IucmdiIC8gY29sb3IuYSA6IHZlYzMoMCksIGNvbG9yLmEpO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9lbmdpbmUvZmlsdGVycy9zb3VyY2UvdW5wcmVtdWx0aXBseS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpICogdl9jb2xvcjtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vZW5naW5lL3NoYWRlcnMvc291cmNlL3RleHR1cmUuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG51bmlmb3JtIG1hdDMgdV9wcm9qTWF0cml4O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9wcm9qTWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHksIDAsIDEpO1xcbiAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XFxuICB2X2NvbG9yID0gdmVjNChhX2NvbG9yLnJnYiAqIGFfY29sb3IuYSwgYV9jb2xvci5hKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vZW5naW5lL3NoYWRlcnMvc291cmNlL3RleHR1cmUudmVydFxuLy8gbW9kdWxlIGlkID0gMjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcbiAqIEJhc2VkIG9uIGV2YW53J3MgZ2xmeC5qcyB0aWx0IHNoaWZ0IHNoYWRlcjpcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iL21hc3Rlci9zcmMvZmlsdGVycy9ibHVyL3RpbHRzaGlmdC5qc1xcbiAqIEBsaWNlbnNlXFxuICovXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfYmx1clJhZGl1cztcXG51bmlmb3JtIGZsb2F0IHVfZ3JhZGllbnRTaXplO1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplO1xcbnVuaWZvcm0gdmVjMiB1X3N0YXJ0O1xcbnVuaWZvcm0gdmVjMiB1X2VuZDtcXG51bmlmb3JtIHZlYzIgdV9kZWx0YTtcXG51bmlmb3JtIHZlYzIgdV90ZXhTaXplO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcblxcbmZsb2F0IHJhbmRvbSh2ZWMyIGNvKVxcbntcXG4gICAgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTg7XFxuICAgIGhpZ2hwIGZsb2F0IGIgPSA3OC4yMzM7XFxuICAgIGhpZ2hwIGZsb2F0IGMgPSA0Mzc1OC41NDUzO1xcbiAgICBoaWdocCBmbG9hdCBkdCA9IGRvdChjby54eSx2ZWMyKGEsYikpO1xcbiAgICBoaWdocCBmbG9hdCBzbiA9IG1vZChkdCwgMy4xNCk7XFxuICAgIHJldHVybiBmcmFjdChzaW4oc24pICogYyk7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG4gICAgZmxvYXQgdG90YWwgPSAwLjA7XFxuXFxuICAgIGZsb2F0IG9mZnNldCA9IHJhbmRvbShnbF9GcmFnQ29vcmQueHkgLyB1X3RleFNpemUueHkpO1xcblxcbiAgICB2ZWMyIG5vcm1hbCA9IG5vcm1hbGl6ZSh2ZWMyKHVfc3RhcnQueSAtIHVfZW5kLnksIHVfZW5kLnggLSB1X3N0YXJ0LngpKTtcXG4gICAgZmxvYXQgcmFkaXVzID0gc21vb3Roc3RlcCgwLjAsIDEuMCxcXG4gICAgICAoYWJzKFxcbiAgICAgICAgZG90KHZfdGV4Q29vcmQgKiB1X3RleFNpemUgLSB1X3N0YXJ0LCBub3JtYWwpXFxuICAgICAgKSAtIHVfc2l6ZSkgLyB1X2dyYWRpZW50U2l6ZVxcbiAgICApICogdV9ibHVyUmFkaXVzO1xcblxcbiAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspIHtcXG4gICAgICAgIGZsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyAzMC4wO1xcbiAgICAgICAgZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbiAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCArIHVfZGVsdGEgKiBwZXJjZW50ICogcmFkaXVzIC8gdV90ZXhTaXplKTtcXG5cXG4gICAgICAgIHNhbXBsZS5yZ2IgKj0gc2FtcGxlLmE7XFxuXFxuICAgICAgICBjb2xvciArPSBzYW1wbGUgKiB3ZWlnaHQ7XFxuICAgICAgICB0b3RhbCArPSB3ZWlnaHQ7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiAvPSBnbF9GcmFnQ29sb3IuYSArIDAuMDAwMDE7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vcmF3LWxvYWRlciEuL3NoYWRlcnMvZm9jdXMvbGluZWFyLWZvY3VzLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLypcXG4gKiBCYXNlZCBvbiBldmFudydzIGdsZnguanMgdGlsdCBzaGlmdCBzaGFkZXI6XFxuICogaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanNcXG4gKiBAbGljZW5zZVxcbiAqL1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBmbG9hdCB1X3JhZGl1cztcXG51bmlmb3JtIGZsb2F0IHVfYmx1clJhZGl1cztcXG51bmlmb3JtIGZsb2F0IHVfZ3JhZGllbnRSYWRpdXM7XFxudW5pZm9ybSB2ZWMyIHVfcG9zaXRpb247XFxudW5pZm9ybSB2ZWMyIHVfZGVsdGE7XFxudW5pZm9ybSB2ZWMyIHVfdGV4U2l6ZTtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG5cXG5mbG9hdCByYW5kb20odmVjMiBjbylcXG57XFxuICAgIGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4O1xcbiAgICBoaWdocCBmbG9hdCBiID0gNzguMjMzO1xcbiAgICBoaWdocCBmbG9hdCBjID0gNDM3NTguNTQ1MztcXG4gICAgaGlnaHAgZmxvYXQgZHQgPSBkb3QoY28ueHksdmVjMihhLGIpKTtcXG4gICAgaGlnaHAgZmxvYXQgc24gPSBtb2QoZHQsIDMuMTQpO1xcbiAgICByZXR1cm4gZnJhY3Qoc2luKHNuKSAqIGMpO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuICAgIGZsb2F0IHRvdGFsID0gMC4wO1xcblxcbiAgICBmbG9hdCBvZmZzZXQgPSByYW5kb20oZ2xfRnJhZ0Nvb3JkLnh5IC8gdV90ZXhTaXplLnh5KTtcXG4gICAgZmxvYXQgcmFkaXVzID0gc21vb3Roc3RlcChcXG4gICAgICAwLjAsIDEuMCxcXG4gICAgICAoYWJzKFxcbiAgICAgICAgZGlzdGFuY2Uodl90ZXhDb29yZCAqIHVfdGV4U2l6ZSwgdV9wb3NpdGlvbilcXG4gICAgICApIC0gdV9yYWRpdXMpIC8gKHVfZ3JhZGllbnRSYWRpdXMgKiAyLjApXFxuICAgICkgKiB1X2JsdXJSYWRpdXM7XFxuICAgIGZvciAoZmxvYXQgdCA9IC0zMC4wOyB0IDw9IDMwLjA7IHQrKykge1xcbiAgICAgICAgZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIDMwLjA7XFxuICAgICAgICBmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XFxuICAgICAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkICsgdV9kZWx0YSAqIHBlcmNlbnQgKiByYWRpdXMgLyB1X3RleFNpemUpO1xcblxcbiAgICAgICAgc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG5cXG4gICAgICAgIGNvbG9yICs9IHNhbXBsZSAqIHdlaWdodDtcXG4gICAgICAgIHRvdGFsICs9IHdlaWdodDtcXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHRvdGFsO1xcbiAgICBnbF9GcmFnQ29sb3IucmdiIC89IGdsX0ZyYWdDb2xvci5hICsgMC4wMDAwMTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9mb2N1cy9yYWRpYWwtZm9jdXMuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzO1xcbnVuaWZvcm0gZmxvYXQgdV9zYXR1cmF0aW9uO1xcbnVuaWZvcm0gZmxvYXQgdV9jb250cmFzdDtcXG51bmlmb3JtIGZsb2F0IHVfZ2FtbWE7XFxudW5pZm9ybSBmbG9hdCB1X2V4cG9zdXJlO1xcbnVuaWZvcm0gZmxvYXQgdV9zaGFkb3dzO1xcbnVuaWZvcm0gZmxvYXQgdV9oaWdobGlnaHRzO1xcblxcbmNvbnN0IHZlYzMgbHVtaW5hbmNlV2VpZ2h0aW5nID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcblxcbiAgdmVjNCBjb2xvciA9IHRleENvbG9yO1xcblxcbiAgLy8gQXBwbHkgZ2FtbWFcXG4gIGNvbG9yLnJnYiA9IHBvdyhjb2xvci5yZ2IsIHZlYzMoMS4wIC8gdV9nYW1tYSkpO1xcblxcbiAgLy8gQXBwbHkgc2hhZG93cyBhbmQgaGlnaGxpZ2h0c1xcbiAgZmxvYXQgbHVtaW5hbmNlID0gZG90KGNvbG9yLnJnYiwgbHVtaW5hbmNlV2VpZ2h0aW5nKTtcXG4gIGZsb2F0IHNoYWRvdyA9IGNsYW1wKChwb3cobHVtaW5hbmNlLCAxLjAvKHVfc2hhZG93cysxLjApKSArICgtMC43NikqcG93KGx1bWluYW5jZSwgMi4wLyh1X3NoYWRvd3MrMS4wKSkpIC0gbHVtaW5hbmNlLCAwLjAsIDEuMCk7XFxuICBmbG9hdCBoaWdobGlnaHQgPSBjbGFtcCgoMS4wIC0gKHBvdygxLjAtbHVtaW5hbmNlLCAxLjAvKDIuMC11X2hpZ2hsaWdodHMpKSArICgtMC44KSpwb3coMS4wLWx1bWluYW5jZSwgMi4wLygyLjAtdV9oaWdobGlnaHRzKSkpKSAtIGx1bWluYW5jZSwgLTEuMCwgMC4wKTtcXG4gIGNvbG9yLnJnYiA9IChsdW1pbmFuY2UgKyBzaGFkb3cgKyBoaWdobGlnaHQpICogKGNvbG9yLnJnYiAvIGx1bWluYW5jZSApO1xcblxcbiAgLy8gQXBwbHkgZXhwb3N1cmVcXG4gIGNvbG9yLnJnYiA9IGNvbG9yLnJnYiAqIHBvdygyLjAsIHVfZXhwb3N1cmUpO1xcblxcbiAgLy8gQXBwbHkgYnJpZ2h0bmVzc1xcbiAgY29sb3IucmdiID0gKGNvbG9yLnJnYiArIHVfYnJpZ2h0bmVzcyk7XFxuXFxuICAvLyBBcHBseSBzYXR1cmF0aW9uXFxuICB2ZWMzIGdyZXlTY2FsZUNvbG9yID0gdmVjMyhsdW1pbmFuY2UpO1xcbiAgY29sb3IucmdiID0gbWl4KGdyZXlTY2FsZUNvbG9yLCBjb2xvci5yZ2IsIHVfc2F0dXJhdGlvbik7XFxuXFxuICAvLyBBcHBseSBjb250cmFzdFxcbiAgY29sb3IucmdiID0gKGNvbG9yLnJnYiAtIDAuNSkgKiB1X2NvbnRyYXN0ICsgMC41O1xcblxcbiAgLy8gQXBwbHkgYWxwaGFcXG4gIGNvbG9yID0gdmVjNChjb2xvci5yZ2IgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvci5hKTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL2dlbmVyaWMvYWRqdXN0bWVudHMuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfZmlsdGVyZWRJbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfaW50ZW5zaXR5O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgY29sb3IwID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodV9maWx0ZXJlZEltYWdlLCB2X3RleENvb3JkKTtcXG4gIGdsX0ZyYWdDb2xvciA9IG1peChjb2xvcjAsIGNvbG9yMSwgdV9pbnRlbnNpdHkpO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL2dlbmVyaWMvYmxlbmQuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcbiAqIEJhc2VkIG9uIGV2YW53J3MgZ2xmeC5qcyB0aWx0IHNoaWZ0IHNoYWRlcjpcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iL21hc3Rlci9zcmMvZmlsdGVycy9ibHVyL3RpbHRzaGlmdC5qc1xcbiAqIEBsaWNlbnNlXFxuICovXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfYmx1clJhZGl1cztcXG51bmlmb3JtIHZlYzIgdV9kZWx0YTtcXG51bmlmb3JtIHZlYzIgdV90ZXhTaXplO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcblxcbmZsb2F0IHJhbmRvbSh2ZWMyIGNvKVxcbntcXG4gICAgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTg7XFxuICAgIGhpZ2hwIGZsb2F0IGIgPSA3OC4yMzM7XFxuICAgIGhpZ2hwIGZsb2F0IGMgPSA0Mzc1OC41NDUzO1xcbiAgICBoaWdocCBmbG9hdCBkdCA9IGRvdChjby54eSx2ZWMyKGEsYikpO1xcbiAgICBoaWdocCBmbG9hdCBzbiA9IG1vZChkdCwgMy4xNCk7XFxuICAgIHJldHVybiBmcmFjdChzaW4oc24pICogYyk7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG4gICAgZmxvYXQgdG90YWwgPSAwLjA7XFxuXFxuICAgIGZsb2F0IG9mZnNldCA9IHJhbmRvbShnbF9GcmFnQ29vcmQueHkgLyB1X3RleFNpemUueHkpO1xcblxcbiAgICBmbG9hdCByYWRpdXMgPSB1X2JsdXJSYWRpdXM7XFxuXFxuICAgIGZvciAoZmxvYXQgdCA9IC0zMC4wOyB0IDw9IDMwLjA7IHQrKykge1xcbiAgICAgICAgZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIDMwLjA7XFxuICAgICAgICBmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XFxuICAgICAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkICsgdV9kZWx0YSAqIHBlcmNlbnQgKiByYWRpdXMgLyB1X3RleFNpemUpO1xcblxcbiAgICAgICAgc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG5cXG4gICAgICAgIGNvbG9yICs9IHNhbXBsZSAqIHdlaWdodDtcXG4gICAgICAgIHRvdGFsICs9IHdlaWdodDtcXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHRvdGFsO1xcbiAgICBnbF9GcmFnQ29sb3IucmdiIC89IGdsX0ZyYWdDb2xvci5hICsgMC4wMDAwMTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9nZW5lcmljL2JsdXIuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgdV9jbGFyaXR5O1xcbnVuaWZvcm0gdmVjMiB1X3RleFNpemU7XFxuXFxuZmxvYXQgcmFuZG9tKHZlYzMgc2NhbGUsIGZsb2F0IHNlZWQpIHtcXG4gIHJldHVybiBmcmFjdChzaW4oZG90KGdsX0ZyYWdDb29yZC54eXogKyBzZWVkLCBzY2FsZSkpICogNDM3NTguNTQ1MyArIHNlZWQpO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IG9yaWdpbmFsID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcblxcbiAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gIGNvbG9yICs9ICB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCArIHZlYzIoLTEuMCwgMC4wKSAqIHVfdGV4U2l6ZSk7XFxuICBjb2xvciArPSAgdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQgKyB2ZWMyKDEuMCwgMC4wKSAqIHVfdGV4U2l6ZSk7XFxuXFxuICBjb2xvciArPSAgdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQgKyB2ZWMyKDAuMCwgMS4wKSAqIHVfdGV4U2l6ZSk7XFxuICBjb2xvciArPSAgdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkgKiB1X3RleFNpemUpO1xcbiAgY29sb3IgKz0gIHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkICsgdmVjMigxLjAsIDEuMCkgKiB1X3RleFNpemUpO1xcblxcbiAgY29sb3IgKz0gIHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkICsgdmVjMigwLjAsIC0xLjApICogdV90ZXhTaXplKTtcXG4gIGNvbG9yICs9ICB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCArIHZlYzIoLTEuMCwgLTEuMCkgKiB1X3RleFNpemUpO1xcbiAgY29sb3IgKz0gIHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkICsgdmVjMigxLjAsIC0xLjApICogdV90ZXhTaXplKTtcXG5cXG4gIC8vIGFwcGx5IHVuc2hhcnAgbWFza1xcbiAgdmVjNCBibHVycmVkID0gY29sb3IgLyA5LjA7XFxuICBjb2xvciA9IG1peChibHVycmVkLCBvcmlnaW5hbCwgMS4wICsgdV9jbGFyaXR5KTtcXG5cXG4gIC8vIGRlc2F0dXJhdGlvbiwgdG8gZW1waGVzaXplIHRoZSBlZmZlY3RcXG4gIHZlYzMgZ3JheVhmZXIgPSB2ZWMzKDAuMywgMC41OSwgMC4xMSk7XFxuICB2ZWMzIGdyYXkgPSB2ZWMzKGRvdChncmF5WGZlciwgY29sb3IueHl6KSk7XFxuICBmbG9hdCBkZXNhdHVyYXRpb24gPSBjbGFtcCh1X2NsYXJpdHkgKiAwLjEzLCAwLjAsIDEuMCk7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peChjb2xvci54eXosIGdyYXksIGRlc2F0dXJhdGlvbikgKiBjb2xvci5hLCBjb2xvci5hKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9nZW5lcmljL2NsYXJpdHkuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfZmlsdGVySW1hZ2U7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9tYXNrSW1hZ2U7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjNCBjb2xvcjAgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICB2ZWM0IGNvbG9yMSA9IHRleHR1cmUyRCh1X2ZpbHRlckltYWdlLCB2X3RleENvb3JkKTtcXG4gIHZlYzQgbWFzayA9IHRleHR1cmUyRCh1X21hc2tJbWFnZSwgdl90ZXhDb29yZCk7XFxuICBnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IwLCBjb2xvcjEsIG1hc2spO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL2dlbmVyaWMvbWFzay5mcmFnXG4vLyBtb2R1bGUgaWQgPSAyNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcInZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBmbG9hdCB1X2JyaWdodG5lc3M7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoKHRleENvbG9yLnJnYiArIHZlYzModV9icmlnaHRuZXNzKSAqIHRleENvbG9yLmEpLCB0ZXhDb2xvci5hKTs7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vcmF3LWxvYWRlciEuL3NoYWRlcnMvcHJpbWl0aXZlcy9icmlnaHRuZXNzLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIG1hdDQgdV9jb2xvcm1hdHJpeDtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcm1hdHJpeF92ZWM7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRleENvbG9yICogdV9jb2xvcm1hdHJpeCArIHVfY29sb3JtYXRyaXhfdmVjO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL3ByaW1pdGl2ZXMvY29sb3ItbWF0cml4LmZyYWdcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfY29udHJhc3Q7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoKCh0ZXhDb2xvci5yZ2IgLSB2ZWMzKDAuNSkpICogdV9jb250cmFzdCArIHZlYzMoMC41KSAqIHRleENvbG9yLmEpLCB0ZXhDb2xvci5hKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9wcmltaXRpdmVzL2NvbnRyYXN0LmZyYWdcbi8vIG1vZHVsZSBpZCA9IDI0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfZGVzYXR1cmF0aW9uO1xcblxcbmNvbnN0IHZlYzMgbHVtaW5hbmNlV2VpZ2h0aW5nID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgdmVjMyBncmF5WGZlciA9IHZlYzMoMC4zLCAwLjU5LCAwLjExKTtcXG4gIHZlYzMgZ3JheSA9IHZlYzMoZG90KGdyYXlYZmVyLCB0ZXhDb2xvci54eXopKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQobWl4KHRleENvbG9yLnh5eiwgZ3JheSwgdV9kZXNhdHVyYXRpb24pICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vcmF3LWxvYWRlciEuL3NoYWRlcnMvcHJpbWl0aXZlcy9kZXNhdHVyYXRpb24uZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gdmVjMyB1X2dhbW1hO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICB2ZWMzIHJnYiA9IHZlYzModGV4Q29sb3IuciwgdGV4Q29sb3IuZywgdGV4Q29sb3IuYik7XFxuICByZ2IgPSBwb3cocmdiLCB1X2dhbW1hKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQocmdiICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7O1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL3ByaW1pdGl2ZXMvZ2FtbWEuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuXFxuICB2ZWMyIHRleHR1cmVDb29yZCA9IHZfdGV4Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTtcXG4gIHRleHR1cmVDb29yZCAvPSAwLjc1O1xcblxcbiAgZmxvYXQgZCA9IDEuMCAtIGRvdCh0ZXh0dXJlQ29vcmQsIHRleHR1cmVDb29yZCk7XFxuICBkID0gY2xhbXAoZCwgMC4yLCAxLjApO1xcbiAgdmVjMyBuZXdDb2xvciA9IHRleENvbG9yLnJnYiAqIGQgKiB1X2NvbG9yLnJnYjtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMyhuZXdDb2xvcikgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvci5hKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9wcmltaXRpdmVzL2dsb3cuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICB0ZXhDb2xvci5iID0gdGV4Q29sb3IuZyAqIDAuMzM7XFxuICB0ZXhDb2xvci5yID0gdGV4Q29sb3IuciAqIDAuNjtcXG4gIHRleENvbG9yLmIgKz0gdGV4Q29sb3IuciAqIDAuMzM7XFxuICB0ZXhDb2xvci5nID0gdGV4Q29sb3IuZyAqIDAuNztcXG4gIGdsX0ZyYWdDb2xvciA9IHRleENvbG9yO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL3ByaW1pdGl2ZXMvZ29iYmxpbi5mcmFnXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcInZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudmVjMyBXID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgZmxvYXQgbHVtaW5hbmNlID0gZG90KHRleENvbG9yLnJnYiwgVyk7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMobHVtaW5hbmNlKSAqIHRleENvbG9yLmEsIHRleENvbG9yLmEpO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3VidW50dS9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL3ByaW1pdGl2ZXMvZ3JheXNjYWxlLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqXFxuICogQmFzZWQgb2ZmIG9mIEdQVUltYWdlJ3MgTG9va3VwRmlsdGVyOlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9CcmFkTGFyc29uL0dQVUltYWdlL2Jsb2IvbWFzdGVyL2ZyYW1ld29yay9Tb3VyY2UvR1BVSW1hZ2VMb29rdXBGaWx0ZXIubVxcbiAqL1xcblxcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9sb29rdXBUYWJsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgZmxvYXQgYmx1ZUNvbG9yID0gdGV4Q29sb3IuYiAqIDYzLjA7XFxuXFxuICB2ZWMyIHF1YWQxO1xcbiAgcXVhZDEueSA9IGZsb29yKGZsb29yKGJsdWVDb2xvcikgLyA4LjApO1xcbiAgcXVhZDEueCA9IGZsb29yKGJsdWVDb2xvcikgLSAocXVhZDEueSAqIDguMCk7XFxuXFxuICB2ZWMyIHF1YWQyO1xcbiAgcXVhZDIueSA9IGZsb29yKGNlaWwoYmx1ZUNvbG9yKSAvIDguMCk7XFxuICBxdWFkMi54ID0gY2VpbChibHVlQ29sb3IpIC0gKHF1YWQyLnkgKiA4LjApO1xcblxcbiAgdmVjMiB0ZXhDb29yZDE7XFxuICB0ZXhDb29yZDEueCA9IChxdWFkMS54ICogMC4xMjUpICsgMC41LzUxMi4wICsgKCgwLjEyNSAtIDEuMC81MTIuMCkgKiB0ZXhDb2xvci5yKTtcXG4gIHRleENvb3JkMS55ID0gKHF1YWQxLnkgKiAwLjEyNSkgKyAwLjUvNTEyLjAgKyAoKDAuMTI1IC0gMS4wLzUxMi4wKSAqIHRleENvbG9yLmcpO1xcblxcbiAgdmVjMiB0ZXhDb29yZDI7XFxuICB0ZXhDb29yZDIueCA9IChxdWFkMi54ICogMC4xMjUpICsgMC41LzUxMi4wICsgKCgwLjEyNSAtIDEuMC81MTIuMCkgKiB0ZXhDb2xvci5yKTtcXG4gIHRleENvb3JkMi55ID0gKHF1YWQyLnkgKiAwLjEyNSkgKyAwLjUvNTEyLjAgKyAoKDAuMTI1IC0gMS4wLzUxMi4wKSAqIHRleENvbG9yLmcpO1xcblxcbiAgdmVjNCBuZXdDb2xvcjEgPSB0ZXh0dXJlMkQodV9sb29rdXBUYWJsZSwgdGV4Q29vcmQxKTtcXG4gIHZlYzQgbmV3Q29sb3IyID0gdGV4dHVyZTJEKHVfbG9va3VwVGFibGUsIHRleENvb3JkMik7XFxuXFxuICB2ZWM0IG5ld0NvbG9yID0gbWl4KG5ld0NvbG9yMSwgbmV3Q29sb3IyLCBmcmFjdChibHVlQ29sb3IpKTtcXG4gIGdsX0ZyYWdDb2xvciA9IG1peCh0ZXhDb2xvciwgdmVjNChuZXdDb2xvci5yZ2IsIHRleENvbG9yLncpLCB0ZXhDb2xvci5hKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9wcmltaXRpdmVzL2xvb2t1cC10YWJsZS1pbWFnZS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcInZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9sb29rdXBUYWJsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgZmxvYXQgciA9IHRleHR1cmUyRCh1X2xvb2t1cFRhYmxlLCB2ZWMyKHRleENvbG9yLnIsIDAuMCkpLnI7XFxuICBmbG9hdCBnID0gdGV4dHVyZTJEKHVfbG9va3VwVGFibGUsIHZlYzIodGV4Q29sb3IuZywgMC4wKSkuZztcXG4gIGZsb2F0IGIgPSB0ZXh0dXJlMkQodV9sb29rdXBUYWJsZSwgdmVjMih0ZXhDb2xvci5iLCAwLjApKS5iO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKHIsIGcsIGIpICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vcmF3LWxvYWRlciEuL3NoYWRlcnMvcHJpbWl0aXZlcy9sb29rdXAtdGFibGUuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgdV9zYXR1cmF0aW9uO1xcblxcbmNvbnN0IHZlYzMgbHVtaW5hbmNlV2VpZ2h0aW5nID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgZmxvYXQgbHVtaW5hbmNlID0gZG90KHRleENvbG9yLnJnYiwgbHVtaW5hbmNlV2VpZ2h0aW5nKTtcXG5cXG4gIHZlYzMgZ3JleVNjYWxlQ29sb3IgPSB2ZWMzKGx1bWluYW5jZSk7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peChncmV5U2NhbGVDb2xvciwgdGV4Q29sb3IucmdiLCB1X3NhdHVyYXRpb24pICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vcmF3LWxvYWRlciEuL3NoYWRlcnMvcHJpbWl0aXZlcy9zYXR1cmF0aW9uLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIHZlYzMgdV9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgdmVjNCBvdmVybGF5VmVjNCA9IHZlYzQodV9jb2xvciwgdGV4Q29sb3IuYSk7XFxuICBnbF9GcmFnQ29sb3IgPSBtYXgob3ZlcmxheVZlYzQgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvcik7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vcmF3LWxvYWRlciEuL3NoYWRlcnMvcHJpbWl0aXZlcy9zb2Z0LWNvbG9yLW92ZXJsYXkuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICBmbG9hdCBncmF5ID0gdGV4Q29sb3IuciAqIDAuMyArIHRleENvbG9yLmcgKiAwLjMgKyB0ZXhDb2xvci5iICogMC4zO1xcbiAgZ3JheSAtPSAwLjI7XFxuICBncmF5ID0gY2xhbXAoZ3JheSwgMC4wLCAxLjApO1xcbiAgZ3JheSArPSAwLjE1O1xcbiAgZ3JheSAqPSAxLjQ7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoZ3JheSkgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvci5hKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS91YnVudHUvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9wcmltaXRpdmVzL3g0MDAuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0YXRzLmpzIC0gaHR0cDovL2dpdGh1Yi5jb20vbXJkb29iL3N0YXRzLmpzXG52YXIgU3RhdHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBoKGEpe2MuYXBwZW5kQ2hpbGQoYS5kb20pO3JldHVybiBhfWZ1bmN0aW9uIGsoYSl7Zm9yKHZhciBkPTA7ZDxjLmNoaWxkcmVuLmxlbmd0aDtkKyspYy5jaGlsZHJlbltkXS5zdHlsZS5kaXNwbGF5PWQ9PT1hP1wiYmxvY2tcIjpcIm5vbmVcIjtsPWF9dmFyIGw9MCxjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Yy5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO2N1cnNvcjpwb2ludGVyO29wYWNpdHk6MC45O3otaW5kZXg6MTAwMDBcIjtjLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKTtrKCsrbCVjLmNoaWxkcmVuLmxlbmd0aCl9LCExKTt2YXIgZz0ocGVyZm9ybWFuY2V8fERhdGUpLm5vdygpLGU9ZyxhPTAscj1oKG5ldyBTdGF0cy5QYW5lbChcIkZQU1wiLFwiIzBmZlwiLFwiIzAwMlwiKSksZj1oKG5ldyBTdGF0cy5QYW5lbChcIk1TXCIsXCIjMGYwXCIsXCIjMDIwXCIpKTtcbmlmKHNlbGYucGVyZm9ybWFuY2UmJnNlbGYucGVyZm9ybWFuY2UubWVtb3J5KXZhciB0PWgobmV3IFN0YXRzLlBhbmVsKFwiTUJcIixcIiNmMDhcIixcIiMyMDFcIikpO2soMCk7cmV0dXJue1JFVklTSU9OOjE2LGRvbTpjLGFkZFBhbmVsOmgsc2hvd1BhbmVsOmssYmVnaW46ZnVuY3Rpb24oKXtnPShwZXJmb3JtYW5jZXx8RGF0ZSkubm93KCl9LGVuZDpmdW5jdGlvbigpe2ErKzt2YXIgYz0ocGVyZm9ybWFuY2V8fERhdGUpLm5vdygpO2YudXBkYXRlKGMtZywyMDApO2lmKGM+ZSsxRTMmJihyLnVwZGF0ZSgxRTMqYS8oYy1lKSwxMDApLGU9YyxhPTAsdCkpe3ZhciBkPXBlcmZvcm1hbmNlLm1lbW9yeTt0LnVwZGF0ZShkLnVzZWRKU0hlYXBTaXplLzEwNDg1NzYsZC5qc0hlYXBTaXplTGltaXQvMTA0ODU3Nil9cmV0dXJuIGN9LHVwZGF0ZTpmdW5jdGlvbigpe2c9dGhpcy5lbmQoKX0sZG9tRWxlbWVudDpjLHNldE1vZGU6a319O1xuU3RhdHMuUGFuZWw9ZnVuY3Rpb24oaCxrLGwpe3ZhciBjPUluZmluaXR5LGc9MCxlPU1hdGgucm91bmQsYT1lKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKSxyPTgwKmEsZj00OCphLHQ9MyphLHU9MiphLGQ9MyphLG09MTUqYSxuPTc0KmEscD0zMCphLHE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtxLndpZHRoPXI7cS5oZWlnaHQ9ZjtxLnN0eWxlLmNzc1RleHQ9XCJ3aWR0aDo4MHB4O2hlaWdodDo0OHB4XCI7dmFyIGI9cS5nZXRDb250ZXh0KFwiMmRcIik7Yi5mb250PVwiYm9sZCBcIis5KmErXCJweCBIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZlwiO2IudGV4dEJhc2VsaW5lPVwidG9wXCI7Yi5maWxsU3R5bGU9bDtiLmZpbGxSZWN0KDAsMCxyLGYpO2IuZmlsbFN0eWxlPWs7Yi5maWxsVGV4dChoLHQsdSk7Yi5maWxsUmVjdChkLG0sbixwKTtiLmZpbGxTdHlsZT1sO2IuZ2xvYmFsQWxwaGE9Ljk7Yi5maWxsUmVjdChkLG0sbixwKTtyZXR1cm57ZG9tOnEsdXBkYXRlOmZ1bmN0aW9uKGYsXG52KXtjPU1hdGgubWluKGMsZik7Zz1NYXRoLm1heChnLGYpO2IuZmlsbFN0eWxlPWw7Yi5nbG9iYWxBbHBoYT0xO2IuZmlsbFJlY3QoMCwwLHIsbSk7Yi5maWxsU3R5bGU9aztiLmZpbGxUZXh0KGUoZikrXCIgXCIraCtcIiAoXCIrZShjKStcIi1cIitlKGcpK1wiKVwiLHQsdSk7Yi5kcmF3SW1hZ2UocSxkK2EsbSxuLWEscCxkLG0sbi1hLHApO2IuZmlsbFJlY3QoZCtuLWEsbSxhLHApO2IuZmlsbFN0eWxlPWw7Yi5nbG9iYWxBbHBoYT0uOTtiLmZpbGxSZWN0KGQrbi1hLG0sYSxlKCgxLWYvdikqcCkpfX19O1wib2JqZWN0XCI9PT10eXBlb2YgbW9kdWxlJiYobW9kdWxlLmV4cG9ydHM9U3RhdHMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUvdWJ1bnR1L3Blc2RrLWh0bWw1L34vc3RhdHMuanMvYnVpbGQvc3RhdHMubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqIEBsaWNlbnNlXG4gKi9cblxuaW1wb3J0IFBob3RvRWRpdG9yU0RLIGZyb20gJy4vc2RrJ1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIFNES1xuICogQG5hbWUgUGhvdG9FZGl0b3JTREsudmVyc2lvblxuICogQGludGVybmFsIEtlZXAgaW4gc3luYyB3aXRoIHBhY2thZ2UuanNvblxuICovXG5QaG90b0VkaXRvclNESy52ZXJzaW9uID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4vLyBOYW1lc3BhY2VzXG5pbXBvcnQgKiBhcyBNYXRoIGZyb20gJy4vbGliL21hdGgvJ1xuUGhvdG9FZGl0b3JTREsuTWF0aCA9IE1hdGhcblxuaW1wb3J0ICogYXMgT3BlcmF0aW9ucyBmcm9tICcuL29wZXJhdGlvbnMvJ1xuUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucyA9IE9wZXJhdGlvbnNcblxuaW1wb3J0ICogYXMgRmlsdGVycyBmcm9tICcuL29wZXJhdGlvbnMvZmlsdGVycy8nXG5QaG90b0VkaXRvclNESy5GaWx0ZXJzID0gRmlsdGVyc1xuXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvJ1xuUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlcyA9IEZpbHRlclByaW1pdGl2ZXNcblxuaW1wb3J0IEVuZ2luZSBmcm9tICcuL2VuZ2luZS8nXG5QaG90b0VkaXRvclNESy5FbmdpbmUgPSBFbmdpbmVcblxuLy8gQ2xhc3Nlc1xuaW1wb3J0IENvbG9yIGZyb20gJy4vbGliL2NvbG9yJ1xuUGhvdG9FZGl0b3JTREsuQ29sb3IgPSBDb2xvclxuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpbHRlcidcblBob3RvRWRpdG9yU0RLLkZpbHRlciA9IEZpbHRlclxuXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9ucy9vcGVyYXRpb24nXG5QaG90b0VkaXRvclNESy5PcGVyYXRpb24gPSBPcGVyYXRpb25cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2xpYi9ldmVudC1lbWl0dGVyJ1xuUGhvdG9FZGl0b3JTREsuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyXG5cbmltcG9ydCBVdGlscyBmcm9tICcuL2xpYi91dGlscydcblBob3RvRWRpdG9yU0RLLlV0aWxzID0gVXRpbHNcblxuaW1wb3J0IE9wZXJhdGlvbnNTdGFjayBmcm9tICcuL2xpYi9vcGVyYXRpb25zLXN0YWNrJ1xuUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uc1N0YWNrID0gT3BlcmF0aW9uc1N0YWNrXG5cbmltcG9ydCBFWElGIGZyb20gJy4vbGliL2V4aWYnXG5QaG90b0VkaXRvclNESy5FWElGID0gRVhJRlxuXG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuL3ZlbmRvci9wcm9taXNlJ1xuUGhvdG9FZGl0b3JTREsuUHJvbWlzZSA9IFByb21pc2VcblxuaW1wb3J0IENvbmZpZ3VyYWJsZSBmcm9tICcuL2xpYi9jb25maWd1cmFibGUnXG5QaG90b0VkaXRvclNESy5Db25maWd1cmFibGUgPSBDb25maWd1cmFibGVcblxuaW1wb3J0IExvZyBmcm9tICcuLi9zaGFyZWQvbG9nJ1xuUGhvdG9FZGl0b3JTREsuTG9nID0gTG9nXG5cbi8vIENvbnN0YW50c1xuaW1wb3J0IHsgUmVuZGVyVHlwZSwgSW1hZ2VGb3JtYXQsIE9wdGlvblR5cGUgfSBmcm9tICcuL2NvbnN0YW50cydcblBob3RvRWRpdG9yU0RLLlJlbmRlclR5cGUgPSBSZW5kZXJUeXBlXG5QaG90b0VkaXRvclNESy5JbWFnZUZvcm1hdCA9IEltYWdlRm9ybWF0XG5QaG90b0VkaXRvclNESy5PcHRpb25UeXBlID0gT3B0aW9uVHlwZVxuXG4vLyBMaWJzXG5pbXBvcnQgeyBkZWZhdWx0IGFzIEJhc2U2NCB9IGZyb20gJy4vbGliL2Jhc2U2NCdcblBob3RvRWRpdG9yU0RLLkJhc2U2NCA9IEJhc2U2NFxuXG5tb2R1bGUuZXhwb3J0cyA9IFBob3RvRWRpdG9yU0RLXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=